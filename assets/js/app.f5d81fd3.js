(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,s,o=e[0],l=e[1],c=e[2],u=0,p=[];u<o.length;u++)s=o[u],Object.prototype.hasOwnProperty.call(i,s)&&i[s]&&p.push(i[s][0]),i[s]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(d&&d(e);p.length;)p.shift()();return r.push.apply(r,c||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],a=!0,o=1;o<t.length;o++){var l=t[o];0!==i[l]&&(a=!1)}a&&(r.splice(e--,1),n=s(s.s=t[0]))}return n}var a={},i={8:0},r=[];function s(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=i[n]=[e,a]}));e.push(t[2]=a);var r,o=document.createElement("script");o.charset="utf-8",o.timeout=120,s.nc&&o.setAttribute("nonce",s.nc),o.src=function(n){return s.p+"assets/js/"+({9:"vendors~docsearch"}[n]||n)+"."+{1:"40ff521e",2:"7de9c511",3:"d2a5efbd",4:"55bd5ee9",5:"6c0b706d",6:"2981ea96",7:"587f0293",9:"e8eeddec",10:"557b319b",11:"864926e1",12:"c9665aab",13:"ffb05b43",14:"a0ed8bba",15:"236bb627",16:"7448e52f",17:"ca282e90",18:"a9536862",19:"bd880beb",20:"45c81e5e",21:"0adec914",22:"05a7f1fe",23:"16baff2b",24:"7405d421",25:"5bccc3c7",26:"151ec9eb",27:"58648605",28:"3a4794cf",29:"c40f4abb",30:"2b9f1b2b",31:"049b8197",32:"5a86085e",33:"47a46ca7",34:"19d07a0f",35:"c1c7fa47",36:"61b37a24",37:"d5ec228a",38:"46a68289",39:"1a7bc068",40:"115578fb",41:"c9b25e8e",42:"dc4e0b0d",43:"5bd9d18f",44:"fc338ced",45:"c484eb67",46:"85be572a",47:"0906d5a1",48:"10c84c7a",49:"8cb07faf",50:"0ef12596",51:"27ef43ad",52:"a4bd9e25",53:"e2a8b224",54:"c291ac17",55:"2a837e3f",56:"971095f5",57:"22b20ca5",58:"9fac042d",59:"111e1275",60:"c51b6449",61:"495b203f",62:"593ef1ed",63:"4c47993a",64:"1d6fce23",65:"c761bcfe",66:"9faff52a",67:"864c24bb",68:"9180d04f",69:"7d0ca116",70:"6dfd72df",71:"71c4b550",72:"13dd9cf4",73:"faef3318",74:"96466e69",75:"4c02fd89",76:"b5237a4a",77:"5984d23b",78:"8159793b",79:"d439efe7",80:"fd565d86",81:"5fc27270",82:"57e95b12",83:"093ecc1d",84:"401948f3",85:"43734563",86:"ef5782e0",87:"513bce3b",88:"4c4d1f90",89:"71465ed7",90:"add32a12",91:"d168e230",92:"4cfc79e1",93:"e6d62235",94:"6b58a698",95:"ff6ddc3c",96:"2c82e92f",97:"4950f751",98:"028ab902",99:"b526735d",100:"c1c90991",101:"813f7b2e",102:"d3e1d9ca",103:"c598e2f1",104:"da6b8d25",105:"04ae844e",106:"122506a8",107:"8534ba31",108:"ad8ec0f4",109:"1dcc1937",110:"6058df08",111:"ff90d9a9",112:"67a4511c",113:"3f73e1bd",114:"a8f3bfa7",115:"921439be",116:"73ddac82",117:"9daeb33c",118:"cef0fa1f",119:"fabf6bf0",120:"b0246e30",121:"5d52654f",122:"b20b16ea",123:"c6954c80",124:"952b796c",125:"67e9dd69",126:"cfc67310",127:"e041365d",128:"5b412815",129:"3a2eca61",130:"828cb06d",131:"a84cc9b3",132:"d82eea2c",133:"59b3b6f9",134:"b3454286",135:"d0e8f80d",136:"9a6ecb08",137:"3e782865",138:"051578ce",139:"893cf741",140:"54af2462",141:"c253cac6",142:"11e5c334",143:"c04fe670",144:"68019ec7",145:"bace04a0",146:"5e3b7700",147:"e0cf3efb",148:"9e643e58",149:"56d3480f",150:"396f1c71",151:"3540053c",152:"706a9cc7",153:"e48a1071",154:"25f45aa6",155:"31a557f0",156:"0a3e017a",157:"f52ed9ce",158:"3ed953ce",159:"a39164f4"}[n]+".js"}(n);var l=new Error;r=function(e){o.onerror=o.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),r=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+r+")",l.name="ChunkLoadError",l.type=a,l.request=r,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){r({type:"timeout",target:o})}),12e4);o.onerror=o.onload=r,document.head.appendChild(o)}return Promise.all(e)},s.m=n,s.c=a,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)s.d(t,a,function(e){return n[e]}.bind(null,a));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/notes/",s.oe=function(n){throw console.error(n),n};var o=window.webpackJsonp=window.webpackJsonp||[],l=o.push.bind(o);o.push=e,o=o.slice();for(var c=0;c<o.length;c++)e(o[c]);var d=l;r.push([129,0]),t()}([function(n,e,t){"use strict";var a=function(n){return n&&n.Math===Math&&n};n.exports=a("object"==typeof globalThis&&globalThis)||a("object"==typeof window&&window)||a("object"==typeof self&&self)||a("object"==typeof global&&global)||a("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var a="object"==typeof document&&document.all;n.exports=void 0===a&&void 0!==a?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var a=t(11),i=t(0),r=t(144),s=t(4),o=t(2),l=t(87),c=t(127),d=t(146),u=t(1),p=t(10),m=t(18),h=t(88).IteratorPrototype,g=t(6),b=t(24),f=m("toStringTag"),y=TypeError,v=i.Iterator,k=b||!o(v)||v.prototype!==h||!u((function(){v({})})),x=function(){if(r(this,h),l(this)===h)throw new y("Abstract class Iterator not directly constructable")},w=function(n,e){g?c(h,n,{configurable:!0,get:function(){return e},set:function(e){if(s(this),this===h)throw new y("You can't redefine this property");p(this,n)?this[n]=e:d(this,n,e)}}):h[n]=e};p(h,f)||w(f,"Iterator"),!k&&p(h,"constructor")&&h.constructor!==Object||w("constructor",x),x.prototype=h,a({global:!0,constructor:!0,forced:k},{Iterator:x})},function(n,e,t){"use strict";var a=t(9),i=String,r=TypeError;n.exports=function(n){if(a(n))return n;throw new r(i(n)+" is not an object")}},function(n,e,t){"use strict";var a=t(34),i=Function.prototype,r=i.call,s=a&&i.bind.bind(r,r);n.exports=a?s:function(n){return function(){return r.apply(n,arguments)}}},function(n,e,t){"use strict";var a=t(1);n.exports=!a((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var a=t(34),i=Function.prototype.call;n.exports=a?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){"use strict";var a=t(2),i=t(50),r=TypeError;n.exports=function(n){if(a(n))return n;throw new r(i(n)+" is not a function")}},function(n,e,t){"use strict";var a=t(2);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){"use strict";var a=t(5),i=t(32),r=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return r(i(n),e)}},function(n,e,t){"use strict";var a=t(0),i=t(70).f,r=t(25),s=t(46),o=t(52),l=t(84),c=t(143);n.exports=function(n,e){var t,d,u,p,m,h=n.target,g=n.global,b=n.stat;if(t=g?a:b?a[h]||o(h,{}):a[h]&&a[h].prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=i(t,d))&&m.value:t[d],!c(g?d:h+(b?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&r(p,"sham",!0),s(t,d,p,n)}}},function(n,e,t){"use strict";var a=t(7),i=t(4),r=t(39);n.exports=function(n,e,t){var s,o;i(n);try{if(!(s=r(n,"return"))){if("throw"===e)throw t;return t}s=a(s,n)}catch(n){o=!0,s=n}if("throw"===e)throw t;if(o)throw s;return i(s),t}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(98),i="object"==typeof self&&self&&self.Object===Object&&self,r=a||i||Function("return this")();n.exports=r},function(n,e,t){"use strict";function a(n,e,t,a,i,r,s,o){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),r&&(c._scopeId="data-v-"+r),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):i&&(l=o?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";var a=t(11),i=t(7),r=t(8),s=t(4),o=t(26),l=t(89),c=t(90),d=t(24),u=t(12),p=t(91),m=t(27),h=!d&&!p("filter",(function(){})),g=!d&&!h&&m("filter",TypeError),b=d||h||g,f=l((function(){for(var n,e,t=this.iterator,a=this.predicate,r=this.next;;){if(n=s(i(r,t)),this.done=!!n.done)return;if(e=n.value,c(t,a,[e,this.counter++],!0))return e}}));a({target:"Iterator",proto:!0,real:!0,forced:b},{filter:function(n){s(this);try{r(n)}catch(n){u(this,"throw",n)}return g?i(g,this,n):new f(o(this),{predicate:n})}})},function(n,e,t){"use strict";var a=t(11),i=t(7),r=t(47),s=t(8),o=t(4),l=t(26),c=t(12),d=t(27)("forEach",TypeError);a({target:"Iterator",proto:!0,real:!0,forced:d},{forEach:function(n){o(this);try{s(n)}catch(n){c(this,"throw",n)}if(d)return i(d,this,n);var e=l(this),t=0;r(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e,t){"use strict";var a=t(0),i=t(77),r=t(10),s=t(78),o=t(74),l=t(73),c=a.Symbol,d=i("wks"),u=l?c.for||c:c&&c.withoutSetter||s;n.exports=function(n){return r(d,n)||(d[n]=o&&r(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){"use strict";var a=t(6),i=t(79),r=t(81),s=t(4),o=t(71),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?r?function(n,e,t){if(s(n),e=o(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=o(e),s(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(196),i=t(199);n.exports=function(n,e){var t=i(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return r})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return b})),t.d(e,"k",(function(){return f})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return k}));t(31),t(3),t(16),t(17),t(22);const a=/#.*$/,i=/\.(md|html)$/,r=/\/$/,s=/^[a-z]+:/i;function o(n){return decodeURI(n).replace(a,"").replace(i,"")}function l(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",i=o(n);return r.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(i&&t!==i)return!1;return o(n.path)===o(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const r=n.replace(/^\//,"").split("/");for(let n=0;n<r.length;n++){const e=r[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const a=o(e);for(let e=0;e<n.length;e++)if(o(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:i,themeConfig:r}=t,s=a&&r.locales&&r.locales[a]||r;if("auto"===(n.frontmatter.sidebar||s.sidebar||r.sidebar))return g(n);const o=s.sidebar||r.sidebar;if(o){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,o);return"auto"===a?g(n):a?a.map(n=>function n(e,t,a,i=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const r=e.children||[];return 0===r.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:r.map(e=>n(e,t,a,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function g(n){const e=b(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function b(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return v(e)-v(n)}},function(n,e,t){"use strict";var a=t(11),i=t(7),r=t(8),s=t(4),o=t(26),l=t(89),c=t(90),d=t(12),u=t(91),p=t(27),m=t(24),h=!m&&!u("map",(function(){})),g=!m&&!h&&p("map",TypeError),b=m||h||g,f=l((function(){var n=this.iterator,e=s(i(this.next,n));if(!(this.done=!!e.done))return c(n,this.mapper,[e.value,this.counter++],!0)}));a({target:"Iterator",proto:!0,real:!0,forced:b},{map:function(n){s(this);try{r(n)}catch(n){d(this,"throw",n)}return g?i(g,this,n):new f(o(this),{mapper:n})}})},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var a=t(6),i=t(19),r=t(35);n.exports=a?function(n,e,t){return i.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){"use strict";var a=t(0);n.exports=function(n,e){var t=a.Iterator,i=t&&t.prototype,r=i&&i[n],s=!1;if(r)try{r.call({next:function(){return{done:!0}},return:function(){s=!0}},-1)}catch(n){n instanceof e||(s=!1)}if(!s)return r}},function(n,e,t){var a=t(30),i=t(181),r=t(182),s=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?i(n):r(n)}},function(n,e,t){"use strict";var a=t(5),i=a({}.toString),r=a("".slice);n.exports=function(n){return r(i(n),8,-1)}},function(n,e,t){var a=t(14).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(11),i=t(32),r=t(33),s=t(175),o=t(177);a({target:"Array",proto:!0,arity:1,forced:t(1)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=r(e),a=arguments.length;o(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return s(e,t),t}})},function(n,e,t){"use strict";var a=t(48),i=Object;n.exports=function(n){return i(a(n))}},function(n,e,t){"use strict";var a=t(141);n.exports=function(n){return a(n.length)}},function(n,e,t){"use strict";var a=t(1);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var a=t(67),i=t(48);n.exports=function(n){return a(i(n))}},function(n,e,t){"use strict";var a=t(0),i=t(2),r=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?r(a[n]):a[n]&&a[n][e]}},function(n,e,t){"use strict";var a=t(5);n.exports=a({}.isPrototypeOf)},function(n,e,t){"use strict";var a=t(8),i=t(49);n.exports=function(n,e){var t=n[e];return i(t)?void 0:a(t)}},function(n,e,t){var a=t(186),i=t(187),r=t(188),s=t(189),o=t(190);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var a=t(100);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(20)(Object,"create");n.exports=a},function(n,e,t){var a=t(208);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(63);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function r(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),d=a.speed,u=a.easing;return l.offsetWidth,s((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),o(c,function(n,e,t){var i;return(i="translate3d"===a.positionUsing?{transform:"translate3d("+r(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+r(n)+"%,0)"}:{"margin-left":r(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(o(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){o(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var i,s=e.querySelector(a.barSelector),l=n?"-100":r(t.status||0),d=document.querySelector(a.parent);return o(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(i=e.querySelector(a.spinnerSelector))&&p(i),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),o=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,i=n.length,r=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((a=n[i]+r)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,i,r=arguments;if(2==r.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&a(n,t,i);else a(n,r[1],r[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=u(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=i)},function(n,e,t){"use strict";var a=t(2),i=t(19),r=t(82),s=t(52);n.exports=function(n,e,t,o){o||(o={});var l=o.enumerable,c=void 0!==o.name?o.name:e;if(a(t)&&r(t,c,o),o.global)l?n[e]=t:s(e,t);else{try{o.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return n}},function(n,e,t){"use strict";var a=t(128),i=t(7),r=t(4),s=t(50),o=t(159),l=t(33),c=t(38),d=t(160),u=t(93),p=t(12),m=TypeError,h=function(n,e){this.stopped=n,this.result=e},g=h.prototype;n.exports=function(n,e,t){var b,f,y,v,k,x,w,_=t&&t.that,S=!(!t||!t.AS_ENTRIES),j=!(!t||!t.IS_RECORD),E=!(!t||!t.IS_ITERATOR),T=!(!t||!t.INTERRUPTED),C=a(e,_),q=function(n){return b&&p(b,"normal"),new h(!0,n)},I=function(n){return S?(r(n),T?C(n[0],n[1],q):C(n[0],n[1])):T?C(n,q):C(n)};if(j)b=n.iterator;else if(E)b=n;else{if(!(f=u(n)))throw new m(s(n)+" is not iterable");if(o(f)){for(y=0,v=l(n);v>y;y++)if((k=I(n[y]))&&c(g,k))return k;return new h(!1)}b=d(n,f)}for(x=j?n.next:b.next;!(w=i(x,b)).done;){try{k=I(w.value)}catch(n){p(b,"throw",n)}if("object"==typeof k&&k&&c(g,k))return k}return new h(!1)}},function(n,e,t){"use strict";var a=t(49),i=TypeError;n.exports=function(n){if(a(n))throw new i("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var a=String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var a=t(24),i=t(0),r=t(52),s=n.exports=i["__core-js_shared__"]||r("__core-js_shared__",{});(s.versions||(s.versions=[])).push({version:"3.45.1",mode:a?"pure":"global",copyright:"© 2014-2025 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var a=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){"use strict";var a=t(77),i=t(78),r=a("keys");n.exports=function(n){return r[n]||(r[n]=i(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(180),i=t(23),r=Object.prototype,s=r.hasOwnProperty,o=r.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return i(n)&&s.call(n,"callee")&&!o.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(20)(t(14),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(200),i=t(207),r=t(209),s=t(210),o=t(211);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(13),i=t(63),r=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(s.test(n)||!r.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(28),i=t(23);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var a=t(11),i=t(7),r=t(47),s=t(8),o=t(4),l=t(26),c=t(12),d=t(27)("some",TypeError);a({target:"Iterator",proto:!0,real:!0,forced:d},{some:function(n){o(this);try{s(n)}catch(n){c(this,"throw",n)}if(d)return i(d,this,n);var e=l(this),t=0;return r(e,(function(e,a){if(n(e,t++))return a()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,r=/^0o[0-7]+$/i,s=parseInt,o="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=o||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var o=i.test(n);return o||r.test(n)?s(n.slice(2),o?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,i,r,s,o,l,c=0,d=!1,b=!1,f=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=a,r=i;return a=i=void 0,c=e,s=n.apply(r,t)}function v(n){return c=n,o=setTimeout(x,e),d?y(n):s}function k(n){var t=n-l;return void 0===l||t>=e||t<0||b&&n-c>=r}function x(){var n=m();if(k(n))return w(n);o=setTimeout(x,function(n){var t=e-(n-l);return b?p(t,r-(n-c)):t}(n))}function w(n){return o=void 0,f&&a?y(n):(a=i=void 0,s)}function _(){var n=m(),t=k(n);if(a=arguments,i=this,l=n,t){if(void 0===o)return v(l);if(b)return o=setTimeout(x,e),y(l)}return void 0===o&&(o=setTimeout(x,e)),s}return e=g(e)||0,h(t)&&(d=!!t.leading,r=(b="maxWait"in t)?u(g(t.maxWait)||0,e):r,f="trailing"in t?!!t.trailing:f),_.cancel=function(){void 0!==o&&clearTimeout(o),c=0,a=l=i=o=void 0},_.flush=function(){return void 0===o?s:w(m())},_}},function(n,e,t){"use strict";var a=t(5),i=t(1),r=t(29),s=Object,o=a("".split);n.exports=i((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"===r(n)?o(n,""):s(n)}:s},function(n,e,t){"use strict";var a,i=t(4),r=t(147),s=t(55),o=t(54),l=t(149),c=t(80),d=t(53),u=d("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},g=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;g="undefined"!=typeof document?document.domain&&a?h(a):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(a);for(var t=s.length;t--;)delete g.prototype[s[t]];return g()};o[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=i(n),t=new p,p.prototype=null,t[u]=n):t=g(),void 0===e?t:r.f(t,e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var a=t(6),i=t(7),r=t(130),s=t(35),o=t(36),l=t(71),c=t(10),d=t(79),u=Object.getOwnPropertyDescriptor;e.f=a?u:function(n,e){if(n=o(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return s(!i(r.f,n,e),n[e])}},function(n,e,t){"use strict";var a=t(131),i=t(72);n.exports=function(n){var e=a(n,"string");return i(e)?e:e+""}},function(n,e,t){"use strict";var a=t(37),i=t(2),r=t(38),s=t(73),o=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&r(e.prototype,o(n))}},function(n,e,t){"use strict";var a=t(74);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var a=t(75),i=t(1),r=t(0).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol("symbol detection");return!r(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){"use strict";var a,i,r=t(0),s=t(76),o=r.process,l=r.Deno,c=o&&o.versions||l&&l.version,d=c&&c.v8;d&&(i=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!i&&s&&(!(a=s.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=s.match(/Chrome\/(\d+)/))&&(i=+a[1]),n.exports=i},function(n,e,t){"use strict";var a=t(0).navigator,i=a&&a.userAgent;n.exports=i?String(i):""},function(n,e,t){"use strict";var a=t(51);n.exports=function(n,e){return a[n]||(a[n]=e||{})}},function(n,e,t){"use strict";var a=t(5),i=0,r=Math.random(),s=a(1.1.toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++i+r,36)}},function(n,e,t){"use strict";var a=t(6),i=t(1),r=t(80);n.exports=!a&&!i((function(){return 7!==Object.defineProperty(r("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var a=t(0),i=t(9),r=a.document,s=i(r)&&i(r.createElement);n.exports=function(n){return s?r.createElement(n):{}}},function(n,e,t){"use strict";var a=t(6),i=t(1);n.exports=a&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var a=t(5),i=t(1),r=t(2),s=t(10),o=t(6),l=t(133).CONFIGURABLE,c=t(134),d=t(83),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,g=a("".slice),b=a("".replace),f=a([].join),y=o&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),v=String(String).split("String"),k=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+b(m(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||l&&n.name!==e)&&(o?h(n,"name",{value:e,configurable:!0}):n.name=e),y&&t&&s(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?o&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=u(n);return s(a,"source")||(a.source=f(v,"string"==typeof e?e:"")),n};Function.prototype.toString=k((function(){return r(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var a,i,r,s=t(135),o=t(0),l=t(9),c=t(25),d=t(10),u=t(51),p=t(53),m=t(54),h=o.TypeError,g=o.WeakMap;if(s||u.state){var b=u.state||(u.state=new g);b.get=b.get,b.has=b.has,b.set=b.set,a=function(n,e){if(b.has(n))throw new h("Object already initialized");return e.facade=n,b.set(n,e),e},i=function(n){return b.get(n)||{}},r=function(n){return b.has(n)}}else{var f=p("state");m[f]=!0,a=function(n,e){if(d(n,f))throw new h("Object already initialized");return e.facade=n,c(n,f,e),e},i=function(n){return d(n,f)?n[f]:{}},r=function(n){return d(n,f)}}n.exports={set:a,get:i,has:r,enforce:function(n){return r(n)?i(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var a=t(10),i=t(136),r=t(70),s=t(19);n.exports=function(n,e,t){for(var o=i(e),l=s.f,c=r.f,d=0;d<o.length;d++){var u=o[d];a(n,u)||t&&a(t,u)||l(n,u,c(e,u))}}},function(n,e,t){"use strict";var a=t(5),i=t(10),r=t(36),s=t(138).indexOf,o=t(54),l=a([].push);n.exports=function(n,e){var t,a=r(n),c=0,d=[];for(t in a)!i(o,t)&&i(a,t)&&l(d,t);for(;e.length>c;)i(a,t=e[c++])&&(~s(d,t)||l(d,t));return d}},function(n,e,t){"use strict";var a=t(140);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){"use strict";var a=t(10),i=t(2),r=t(32),s=t(53),o=t(145),l=s("IE_PROTO"),c=Object,d=c.prototype;n.exports=o?c.getPrototypeOf:function(n){var e=r(n);if(a(e,l))return e[l];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof c?d:null}},function(n,e,t){"use strict";var a,i,r,s=t(1),o=t(2),l=t(9),c=t(68),d=t(87),u=t(46),p=t(18),m=t(24),h=p("iterator"),g=!1;[].keys&&("next"in(r=[].keys())?(i=d(d(r)))!==Object.prototype&&(a=i):g=!0),!l(a)||s((function(){var n={};return a[h].call(n)!==n}))?a={}:m&&(a=c(a)),o(a[h])||u(a,h,(function(){return this})),n.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:g}},function(n,e,t){"use strict";var a=t(7),i=t(68),r=t(25),s=t(150),o=t(18),l=t(83),c=t(39),d=t(88).IteratorPrototype,u=t(151),p=t(12),m=t(152),h=o("toStringTag"),g=l.set,b=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return s(i(d),{next:function(){var t=e(this);if(n)return t.nextHandler();if(t.done)return u(void 0,!0);try{var a=t.nextHandler();return t.returnHandlerResult?a:u(a,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),i=t.iterator;if(t.done=!0,n){var r=c(i,"return");return r?a(r,i):u(void 0,!0)}if(t.inner)try{p(t.inner.iterator,"normal")}catch(n){return p(i,"throw",n)}if(t.openIters)try{m(t.openIters,"normal")}catch(n){return p(i,"throw",n)}return i&&p(i,"normal"),u(void 0,!0)}})},f=b(!0),y=b(!1);r(y,h,"Iterator Helper"),n.exports=function(n,e,t){var a=function(a,i){i?(i.iterator=a.iterator,i.next=a.next):i=a,i.type=e?"WrapForValidIterator":"IteratorHelper",i.returnHandlerResult=!!t,i.nextHandler=n,i.counter=0,i.done=!1,g(this,i)};return a.prototype=e?f:y,a}},function(n,e,t){"use strict";var a=t(4),i=t(12);n.exports=function(n,e,t,r){try{return r?e(a(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";n.exports=function(n,e){var t="function"==typeof Iterator&&Iterator.prototype[n];if(t)try{t.call({next:null},e).next()}catch(n){return!0}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var a=t(94),i=t(39),r=t(49),s=t(92),o=t(18)("iterator");n.exports=function(n){if(!r(n))return i(n,o)||i(n,"@@iterator")||s[a(n)]}},function(n,e,t){"use strict";var a=t(161),i=t(2),r=t(29),s=t(18)("toStringTag"),o=Object,l="Arguments"===r(function(){return arguments}());n.exports=a?r:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=o(n),s))?t:l?r(e):"Object"===(a=r(e))&&i(e.callee)?"Arguments":a}},function(n,e,t){"use strict";var a=t(34),i=Function.prototype,r=i.apply,s=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?s.bind(r):function(){return s.apply(r,arguments)})},function(n,e,t){"use strict";var a=t(165),i=t(9),r=t(48),s=t(166);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),s(a),i(t)?(e?n(t,a):t.__proto__=a,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,i=n.length;++t<a;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(40),i=t(191),r=t(192),s=t(193),o=t(194),l=t(195);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=r,c.prototype.get=s,c.prototype.has=o,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(28),i=t(58);n.exports=function(n){if(!i(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(212),i=t(23);n.exports=function n(e,t,r,s,o){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:a(e,t,r,s,n,o))}},function(n,e,t){var a=t(105),i=t(215),r=t(106);n.exports=function(n,e,t,s,o,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,b=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var f=n[h],y=e[h];if(s)var v=c?s(y,f,h,e,n,l):s(f,y,h,n,e,l);if(void 0!==v){if(v)continue;g=!1;break}if(b){if(!i(e,(function(n,e){if(!r(b,e)&&(f===n||o(f,n,t,s,l)))return b.push(e)}))){g=!1;break}}else if(f!==y&&!o(f,y,t,s,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var a=t(59),i=t(213),r=t(214);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=i,s.prototype.has=r,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(225),i=t(231),r=t(111);n.exports=function(n){return r(n)?a(n):i(n)}},function(n,e,t){(function(n){var a=t(14),i=t(227),r=e&&!e.nodeType&&e,s=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===r?a.Buffer:void 0,l=(o?o.isBuffer:void 0)||i;n.exports=l}).call(this,t(69)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(228),i=t(229),r=t(230),s=r&&r.isTypedArray,o=s?i(s):a;n.exports=o},function(n,e,t){var a=t(101),i=t(61);n.exports=function(n){return null!=n&&i(n.length)&&!a(n)}},function(n,e,t){var a=t(20)(t(14),"Set");n.exports=a},function(n,e,t){var a=t(58);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(116),i=t(44);n.exports=function(n,e){for(var t=0,r=(e=a(e,n)).length;null!=n&&t<r;)n=n[i(e[t++])];return t&&t==r?n:void 0}},function(n,e,t){var a=t(13),i=t(62),r=t(242),s=t(245);n.exports=function(n,e){return a(n)?n:i(n,e)?[n]:r(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(178),i=t(183),r=t(254),s=t(262),o=t(271),l=t(126),c=r((function(n){var e=l(n);return o(e)&&(e=void 0),s(a(n,1,o,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=a.exec(t);if(!i)return t;var r="",s=0,o=0;for(s=i.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}o!==s&&(r+=t.substring(o,s)),o=s+1,r+=e}return o!==s?r+t.substring(o,s):r}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(274),t(15)),r=Object(i.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=r.exports},function(n,e,t){"use strict";t.r(e);t(3),t(16),t(17),t(22);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(275),t(15)),r=Object(i.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=r.exports},function(n,e,t){"use strict";var a=t(94),i=String;n.exports=function(n){if("Symbol"===a(n))throw new TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var a=t(82),i=t(19);n.exports=function(n,e,t){return t.get&&a(t.get,e,{getter:!0}),t.set&&a(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){"use strict";var a=t(158),i=t(8),r=t(34),s=a(a.bind);n.exports=function(n,e){return i(n),void 0===e?n:r?s(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){n.exports=t(280)},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,r=i&&!a.call({1:2},1);e.f=r?function(n){var e=i(this,n);return!!e&&e.enumerable}:a},function(n,e,t){"use strict";var a=t(7),i=t(9),r=t(72),s=t(39),o=t(132),l=t(18),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!i(n)||r(n))return n;var t,l=s(n,d);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!i(t)||r(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),o(n,e)}},function(n,e,t){"use strict";var a=t(7),i=t(2),r=t(9),s=TypeError;n.exports=function(n,e){var t,o;if("string"===e&&i(t=n.toString)&&!r(o=a(t,n)))return o;if(i(t=n.valueOf)&&!r(o=a(t,n)))return o;if("string"!==e&&i(t=n.toString)&&!r(o=a(t,n)))return o;throw new s("Can't convert object to primitive value")}},function(n,e,t){"use strict";var a=t(6),i=t(10),r=Function.prototype,s=a&&Object.getOwnPropertyDescriptor,o=i(r,"name"),l=o&&"something"===function(){}.name,c=o&&(!a||a&&s(r,"name").configurable);n.exports={EXISTS:o,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var a=t(5),i=t(2),r=t(51),s=a(Function.toString);i(r.inspectSource)||(r.inspectSource=function(n){return s(n)}),n.exports=r.inspectSource},function(n,e,t){"use strict";var a=t(0),i=t(2),r=a.WeakMap;n.exports=i(r)&&/native code/.test(String(r))},function(n,e,t){"use strict";var a=t(37),i=t(5),r=t(137),s=t(142),o=t(4),l=i([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=r.f(o(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var a=t(85),i=t(55).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,i)}},function(n,e,t){"use strict";var a=t(36),i=t(139),r=t(33),s=function(n){return function(e,t,s){var o=a(e),l=r(o);if(0===l)return!n&&-1;var c,d=i(s,l);if(n&&t!=t){for(;l>d;)if((c=o[d++])!=c)return!0}else for(;l>d;d++)if((n||d in o)&&o[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){"use strict";var a=t(86),i=Math.max,r=Math.min;n.exports=function(n,e){var t=a(n);return t<0?i(t+e,0):r(t,e)}},function(n,e,t){"use strict";var a=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:a)(e)}},function(n,e,t){"use strict";var a=t(86),i=Math.min;n.exports=function(n){var e=a(n);return e>0?i(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var a=t(1),i=t(2),r=/#|\.prototype\./,s=function(n,e){var t=l[o(n)];return t===d||t!==c&&(i(e)?a(e):!!e)},o=s.normalize=function(n){return String(n).replace(r,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",d=s.POLYFILL="P";n.exports=s},function(n,e,t){"use strict";var a=t(38),i=TypeError;n.exports=function(n,e){if(a(e,n))return n;throw new i("Incorrect invocation")}},function(n,e,t){"use strict";var a=t(1);n.exports=!a((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var a=t(6),i=t(19),r=t(35);n.exports=function(n,e,t){a?i.f(n,e,r(0,t)):n[e]=t}},function(n,e,t){"use strict";var a=t(6),i=t(81),r=t(19),s=t(4),o=t(36),l=t(148);e.f=a&&!i?Object.defineProperties:function(n,e){s(n);for(var t,a=o(e),i=l(e),c=i.length,d=0;c>d;)r.f(n,t=i[d++],a[t]);return n}},function(n,e,t){"use strict";var a=t(85),i=t(55);n.exports=Object.keys||function(n){return a(n,i)}},function(n,e,t){"use strict";var a=t(37);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(46);n.exports=function(n,e,t){for(var i in e)a(n,i,e[i],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var a=t(12);n.exports=function(n,e,t){for(var i=n.length-1;i>=0;i--)if(void 0!==n[i])try{t=a(n[i].iterator,e,t)}catch(n){e="throw",t=n}if("throw"===e)throw t;return t}},function(n,e,t){"use strict";var a=t(11),i=t(154).left,r=t(155),s=t(75);a({target:"Array",proto:!0,forced:!t(156)&&s>79&&s<83||!r("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a=t(8),i=t(32),r=t(67),s=t(33),o=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,d){var u=i(e),p=r(u),m=s(u);if(a(t),0===m&&c<2)throw new o(l);var h=n?m-1:0,g=n?-1:1;if(c<2)for(;;){if(h in p){d=p[h],h+=g;break}if(h+=g,n?h<0:m<=h)throw new o(l)}for(;n?h>=0:m>h;h+=g)h in p&&(d=t(d,p[h],h,u));return d}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var a=t(1);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var a=t(157);n.exports="NODE"===a},function(n,e,t){"use strict";var a=t(0),i=t(76),r=t(29),s=function(n){return i.slice(0,n.length)===n};n.exports=s("Bun/")?"BUN":s("Cloudflare-Workers")?"CLOUDFLARE":s("Deno/")?"DENO":s("Node.js/")?"NODE":a.Bun&&"string"==typeof Bun.version?"BUN":a.Deno&&"object"==typeof Deno.version?"DENO":"process"===r(a.process)?"NODE":a.window&&a.document?"BROWSER":"REST"},function(n,e,t){"use strict";var a=t(29),i=t(5);n.exports=function(n){if("Function"===a(n))return i(n)}},function(n,e,t){"use strict";var a=t(18),i=t(92),r=a("iterator"),s=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||s[r]===n)}},function(n,e,t){"use strict";var a=t(7),i=t(8),r=t(4),s=t(50),o=t(93),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?o(n):e;if(i(t))return r(a(t,n));throw new l(s(n)+" is not iterable")}},function(n,e,t){"use strict";var a={};a[t(18)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){"use strict";var a=t(11),i=t(47),r=t(8),s=t(4),o=t(26),l=t(12),c=t(27),d=t(95),u=t(1),p=TypeError,m=u((function(){[].keys().reduce((function(){}),void 0)})),h=!m&&c("reduce",p);a({target:"Iterator",proto:!0,real:!0,forced:m||h},{reduce:function(n){s(this);try{r(n)}catch(n){l(this,"throw",n)}var e=arguments.length<2,t=e?void 0:arguments[1];if(h)return d(h,this,e?[n]:[n,t]);var a=o(this),c=0;if(i(a,(function(a){e?(e=!1,t=a):t=n(t,a,c),c++}),{IS_RECORD:!0}),e)throw new p("Reduce of empty iterator with no initial value");return t}})},function(n,e,t){"use strict";var a=t(11),i=t(0),r=t(95),s=t(164),o=i.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(o&&o[n]){var t={};t[n]=s("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return r(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return r(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return r(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return r(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return r(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return r(n,this,arguments)}})),c("URIError",(function(n){return function(e){return r(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return r(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return r(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return r(n,this,arguments)}}))},function(n,e,t){"use strict";var a=t(37),i=t(10),r=t(25),s=t(38),o=t(96),l=t(84),c=t(168),d=t(169),u=t(170),p=t(171),m=t(172),h=t(6),g=t(24);n.exports=function(n,e,t,b){var f=b?2:1,y=n.split("."),v=y[y.length-1],k=a.apply(null,y);if(k){var x=k.prototype;if(!g&&i(x,"cause")&&delete x.cause,!t)return k;var w=a("Error"),_=e((function(n,e){var t=u(b?e:n,void 0),a=b?new k(n):new k;return void 0!==t&&r(a,"message",t),m(a,_,a.stack,2),this&&s(x,this)&&d(a,this,_),arguments.length>f&&p(a,arguments[f]),a}));if(_.prototype=x,"Error"!==v?o?o(_,w):l(_,w,{name:!0}):h&&"stackTraceLimit"in k&&(c(_,k,"stackTraceLimit"),c(_,k,"prepareStackTrace")),l(_,k),!g)try{x.name!==v&&r(x,"name",v),x.constructor=_}catch(n){}return _}}},function(n,e,t){"use strict";var a=t(5),i=t(8);n.exports=function(n,e,t){try{return a(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var a=t(167),i=String,r=TypeError;n.exports=function(n){if(a(n))return n;throw new r("Can't set "+i(n)+" as a prototype")}},function(n,e,t){"use strict";var a=t(9);n.exports=function(n){return a(n)||null===n}},function(n,e,t){"use strict";var a=t(19).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var a=t(2),i=t(9),r=t(96);n.exports=function(n,e,t){var s,o;return r&&a(s=e.constructor)&&s!==t&&i(o=s.prototype)&&o!==t.prototype&&r(n,o),n}},function(n,e,t){"use strict";var a=t(125);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){"use strict";var a=t(9),i=t(25);n.exports=function(n,e){a(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){"use strict";var a=t(25),i=t(173),r=t(174),s=Error.captureStackTrace;n.exports=function(n,e,t,o){r&&(s?s(n,e):a(n,"stack",i(t,o)))}},function(n,e,t){"use strict";var a=t(5),i=Error,r=a("".replace),s=String(new i("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=r(n,o,"");return n}},function(n,e,t){"use strict";var a=t(1),i=t(35);n.exports=!a((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var a=t(6),i=t(176),r=TypeError,s=Object.getOwnPropertyDescriptor,o=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=o?function(n,e){if(i(n)&&!s(n,"length").writable)throw new r("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var a=t(29);n.exports=Array.isArray||function(n){return"Array"===a(n)}},function(n,e,t){"use strict";var a=TypeError;n.exports=function(n){if(n>9007199254740991)throw a("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(97),i=t(179);n.exports=function n(e,t,r,s,o){var l=-1,c=e.length;for(r||(r=i),o||(o=[]);++l<c;){var d=e[l];t>0&&r(d)?t>1?n(d,t-1,r,s,o):a(o,d):s||(o[o.length]=d)}return o}},function(n,e,t){var a=t(30),i=t(56),r=t(13),s=a?a.isConcatSpreadable:void 0;n.exports=function(n){return r(n)||i(n)||!!(s&&n&&n[s])}},function(n,e,t){var a=t(28),i=t(23);n.exports=function(n){return i(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(30),i=Object.prototype,r=i.hasOwnProperty,s=i.toString,o=a?a.toStringTag:void 0;n.exports=function(n){var e=r.call(n,o),t=n[o];try{n[o]=void 0;var a=!0}catch(n){}var i=s.call(n);return a&&(e?n[o]=t:delete n[o]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(184),i=t(240),r=t(64),s=t(13),o=t(251);n.exports=function(n){return"function"==typeof n?n:null==n?r:"object"==typeof n?s(n)?i(n[0],n[1]):a(n):o(n)}},function(n,e,t){var a=t(185),i=t(239),r=t(114);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?r(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(99),i=t(103);n.exports=function(n,e,t,r){var s=t.length,o=s,l=!r;if(null==n)return!o;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<o;){var d=(c=t[s])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new a;if(r)var h=r(u,p,d,n,e,m);if(!(void 0===h?i(p,u,3,r,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(41),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(41);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(41);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(41);n.exports=function(n,e){var t=this.__data__,i=a(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var a=t(40);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(40),i=t(57),r=t(59);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var s=t.__data__;if(!i||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new r(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(101),i=t(197),r=t(58),s=t(102),o=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!r(n)||i(n))&&(a(n)?p:o).test(s(n))}},function(n,e,t){var a,i=t(198),r=(a=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!r&&r in n}},function(n,e,t){var a=t(14)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(201),i=t(40),r=t(57);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(r||i),string:new a}}},function(n,e,t){var a=t(202),i=t(203),r=t(204),s=t(205),o=t(206);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var a=t(42);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var a=t(42);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(43);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(43);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(43);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(43);n.exports=function(n,e){var t=a(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var a=t(99),i=t(104),r=t(216),s=t(219),o=t(235),l=t(13),c=t(108),d=t(110),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var b=l(n),f=l(e),y=b?"[object Array]":o(n),v=f?"[object Array]":o(e),k=(y="[object Arguments]"==y?u:y)==u,x=(v="[object Arguments]"==v?u:v)==u,w=y==v;if(w&&c(n)){if(!c(e))return!1;b=!0,k=!1}if(w&&!k)return g||(g=new a),b||d(n)?i(n,e,t,m,h,g):r(n,e,y,t,m,h,g);if(!(1&t)){var _=k&&p.call(n,"__wrapped__"),S=x&&p.call(e,"__wrapped__");if(_||S){var j=_?n.value():n,E=S?e.value():e;return g||(g=new a),h(j,E,t,m,g)}}return!!w&&(g||(g=new a),s(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(30),i=t(217),r=t(100),s=t(104),o=t(218),l=t(60),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return r(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=o;case"[object Set]":var h=1&a;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;a|=2,p.set(n,e);var b=s(m(n),m(e),a,c,u,p);return p.delete(n),b;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(14).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(220),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,r,s,o){var l=1&t,c=a(n),d=c.length;if(d!=a(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:i.call(e,p)))return!1}var m=o.get(n),h=o.get(e);if(m&&h)return m==e&&h==n;var g=!0;o.set(n,e),o.set(e,n);for(var b=l;++u<d;){var f=n[p=c[u]],y=e[p];if(r)var v=l?r(y,f,p,e,n,o):r(f,y,p,n,e,o);if(!(void 0===v?f===y||s(f,y,t,r,o):v)){g=!1;break}b||(b="constructor"==p)}if(g&&!b){var k=n.constructor,x=e.constructor;k==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof x&&x instanceof x||(g=!1)}return o.delete(n),o.delete(e),g}},function(n,e,t){var a=t(221),i=t(222),r=t(107);n.exports=function(n){return a(n,r,i)}},function(n,e,t){var a=t(97),i=t(13);n.exports=function(n,e,t){var r=e(n);return i(n)?r:a(r,t(n))}},function(n,e,t){var a=t(223),i=t(224),r=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,o=s?function(n){return null==n?[]:(n=Object(n),a(s(n),(function(e){return r.call(n,e)})))}:i;n.exports=o},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=0,r=[];++t<a;){var s=n[t];e(s,t,n)&&(r[i++]=s)}return r}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(226),i=t(56),r=t(13),s=t(108),o=t(109),l=t(110),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=r(n),d=!t&&i(n),u=!t&&!d&&s(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?a(n.length,String):[],g=h.length;for(var b in n)!e&&!c.call(n,b)||m&&("length"==b||u&&("offset"==b||"parent"==b)||p&&("buffer"==b||"byteLength"==b||"byteOffset"==b)||o(b,g))||h.push(b);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(28),i=t(61),r=t(23),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return r(n)&&i(n.length)&&!!s[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(98),i=e&&!e.nodeType&&e,r=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=r&&r.exports===i&&a.process,o=function(){try{var n=r&&r.require&&r.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=o}).call(this,t(69)(n))},function(n,e,t){var a=t(232),i=t(233),r=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return i(n);var e=[];for(var t in Object(n))r.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(234)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(236),i=t(57),r=t(237),s=t(112),o=t(238),l=t(28),c=t(102),d=c(a),u=c(i),p=c(r),m=c(s),h=c(o),g=l;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||r&&"[object Promise]"!=g(r.resolve())||s&&"[object Set]"!=g(new s)||o&&"[object WeakMap]"!=g(new o))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var a=t(20)(t(14),"DataView");n.exports=a},function(n,e,t){var a=t(20)(t(14),"Promise");n.exports=a},function(n,e,t){var a=t(20)(t(14),"WeakMap");n.exports=a},function(n,e,t){var a=t(113),i=t(107);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var r=e[t],s=n[r];e[t]=[r,s,a(s)]}return e}},function(n,e,t){var a=t(103),i=t(241),r=t(248),s=t(62),o=t(113),l=t(114),c=t(44);n.exports=function(n,e){return s(n)&&o(e)?l(c(n),e):function(t){var s=i(t,n);return void 0===s&&s===e?r(t,n):a(e,s,3)}}},function(n,e,t){var a=t(115);n.exports=function(n,e,t){var i=null==n?void 0:a(n,e);return void 0===i?t:i}},function(n,e,t){var a=t(243),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,r=/\\(\\)?/g,s=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,a,i){e.push(a?i.replace(r,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var a=t(244);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(59);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,i=e?e.apply(this,a):a[0],r=t.cache;if(r.has(i))return r.get(i);var s=n.apply(this,a);return t.cache=r.set(i,s)||r,s};return t.cache=new(i.Cache||a),t}i.Cache=a,n.exports=i},function(n,e,t){var a=t(246);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(30),i=t(247),r=t(13),s=t(63),o=a?a.prototype:void 0,l=o?o.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(r(e))return i(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=Array(a);++t<a;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var a=t(249),i=t(250);n.exports=function(n,e){return null!=n&&i(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(116),i=t(56),r=t(13),s=t(109),o=t(61),l=t(44);n.exports=function(n,e,t){for(var c=-1,d=(e=a(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&o(d)&&s(p,d)&&(r(n)||i(n))}},function(n,e,t){var a=t(252),i=t(253),r=t(62),s=t(44);n.exports=function(n){return r(n)?a(s(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(115);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(64),i=t(255),r=t(257);n.exports=function(n,e){return r(i(n,e,a),n+"")}},function(n,e,t){var a=t(256),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var r=arguments,s=-1,o=i(r.length-e,0),l=Array(o);++s<o;)l[s]=r[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=r[s];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(258),i=t(261)(a);n.exports=i},function(n,e,t){var a=t(259),i=t(260),r=t(64),s=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:r;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(20),i=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var i=t(),r=16-(i-a);if(a=i,r>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(105),i=t(263),r=t(268),s=t(106),o=t(269),l=t(60);n.exports=function(n,e,t){var c=-1,d=i,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=r;else if(u>=200){var g=e?null:o(n);if(g)return l(g);p=!1,d=s,h=new a}else h=e?[]:m;n:for(;++c<u;){var b=n[c],f=e?e(b):b;if(b=t||0!==b?b:0,p&&f==f){for(var y=h.length;y--;)if(h[y]===f)continue n;e&&h.push(f),m.push(b)}else d(h,f,t)||(h!==m&&h.push(f),m.push(b))}return m}},function(n,e,t){var a=t(264);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(265),i=t(266),r=t(267);n.exports=function(n,e,t){return e==e?r(n,e,t):a(n,i,t)}},function(n,e){n.exports=function(n,e,t,a){for(var i=n.length,r=t+(a?1:-1);a?r--:++r<i;)if(e(n[r],r,n))return r;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,i=n.length;++a<i;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,i=null==n?0:n.length;++a<i;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(112),i=t(270),r=t(60),s=a&&1/r(new a([,-0]))[1]==1/0?function(n){return new a(n)}:i;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(111),i=t(23);n.exports=function(n){return i(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(117)},function(n,e,t){"use strict";t(118)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(119)},function(n,e,t){"use strict";t(120)},function(n,e,t){"use strict";t.r(e);t(3),t(16),t(22);var a=Object.freeze({}),i=Array.isArray;function r(n){return null==n}function s(n){return null!=n}function o(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function b(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,f,2):String(n)}function f(n,e){return e&&e.__v_isRef?e.value:e}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),a=n.split(","),i=0;i<a.length;i++)t[a[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var k=v("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var w=Object.prototype.hasOwnProperty;function _(n,e){return w.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,E=S((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),T=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,q=S((function(n){return n.replace(C,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function M(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&M(e,n[t]);return e}function L(n,e,t){}var D=function(n,e,t){return!1},R=function(n){return n};function B(n,e){if(n===e)return!0;var t=d(n),a=d(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var i=Array.isArray(n),r=Array.isArray(e);if(i&&r)return n.length===e.length&&n.every((function(n,t){return B(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||r)return!1;var s=Object.keys(n),o=Object.keys(e);return s.length===o.length&&s.every((function(t){return B(n[t],e[t])}))}catch(n){return!1}}function O(n,e){for(var t=0;t<n.length;t++)if(B(n[t],e))return t;return-1}function P(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function N(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],J=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],Q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:L,parsePlatformTagName:R,mustUseProp:D,async:!0,_lifecycleHooks:J},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function F(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(H.source,".$_\\d]"));var $="__proto__"in{},W="undefined"!=typeof window,K=W&&window.navigator.userAgent.toLowerCase(),Y=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Z=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var nn=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var en,tn=K&&K.match(/firefox\/(\d+)/),an={}.watch,rn=!1;if(W)try{var sn={};Object.defineProperty(sn,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,sn)}catch(n){}var on=function(){return void 0===en&&(en=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var dn,un="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);dn="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function mn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,a,i,r,s,o){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=i,this.ns=void 0,this.context=r,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function bn(n){return new hn(void 0,void 0,void 0,String(n))}function fn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var yn=0,vn=[],kn=function(){function n(){this._pending=!1,this.id=yn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();kn.target=null;var xn=[];function wn(n){xn.push(n),kn.target=n}function _n(){xn.pop(),kn.target=xn[xn.length-1]}var Sn=Array.prototype,jn=Object.create(Sn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Sn[n];V(jn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var i,r=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&s.observeArray(i),s.dep.notify(),r}))}));var En=Object.getOwnPropertyNames(jn),Tn={},Cn=!0;function qn(n){Cn=n}var In={notify:L,depend:L,addSub:L,removeSub:L},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?In:new kn,this.vmCount=0,V(n,"__ob__",this),i(n)){if(!t)if($)n.__proto__=jn;else for(var a=0,r=En.length;a<r;a++){V(n,o=En[a],jn[o])}e||this.observeArray(n)}else{var s=Object.keys(n);for(a=0;a<s.length;a++){var o;zn(n,o=s[a],Tn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Mn(n[e],!1,this.mock)},n}();function Mn(n,e,t){return n&&_(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!Cn||!t&&on()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Nn(n)||n instanceof hn?void 0:new An(n,e,t)}function zn(n,e,t,a,r,s,o){void 0===o&&(o=!1);var l=new kn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var d=c&&c.get,u=c&&c.set;d&&!u||t!==Tn&&2!==arguments.length||(t=n[e]);var p=r?t&&t.__ob__:Mn(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=d?d.call(n):t;return kn.target&&(l.depend(),p&&(p.dep.depend(),i(e)&&Rn(e))),Nn(e)&&!r?e.value:e},set:function(e){var a=d?d.call(n):t;if(N(a,e)){if(u)u.call(n,e);else{if(d)return;if(!r&&Nn(a)&&!Nn(e))return void(a.value=e);t=e}p=r?e&&e.__ob__:Mn(e,!1,s),l.notify()}}}),l}}function Ln(n,e,t){if(!Pn(n)){var a=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Mn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(zn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Dn(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Pn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function Rn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Rn(e)}function Bn(n){return On(n,!0),V(n,"__v_isShallow",!0),n}function On(n,e){if(!Pn(n)){Mn(n,e,on());0}}function Pn(n){return!(!n||!n.__v_isReadonly)}function Nn(n){return!(!n||!0!==n.__v_isRef)}function Un(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Nn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Nn(a)&&!Nn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Jn;var Qn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Jn,!n&&Jn&&(this.index=(Jn.scopes||(Jn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Jn;try{return Jn=this,n()}finally{Jn=e}}else 0},n.prototype.on=function(){Jn=this},n.prototype.off=function(){Jn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Fn=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Vn(n,e){function t(){var n=t.fns;if(!i(n))return Ce(n,null,arguments,e,"v-on handler");for(var a=n.slice(),r=0;r<a.length;r++)Ce(a[r],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,a,i,s){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=Fn(l),r(c)||(r(d)?(r(c.fns)&&(c=n[l]=Vn(c,s)),o(u.once)&&(c=n[l]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)r(n[l])&&a((u=Fn(l)).name,e[l],u.capture)}function $n(n,e,t){var a;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),x(a.fns,l)}r(i)?a=Vn([l]):s(i.fns)&&o(i.merged)?(a=i).fns.push(l):a=Vn([i,l]),a.merged=!0,n[e]=a}function Wn(n,e,t,a,i){if(s(e)){if(_(e,t))return n[t]=e[t],i||delete e[t],!0;if(_(e,a))return n[t]=e[a],i||delete e[a],!0}return!1}function Kn(n){return l(n)?[bn(n)]:i(n)?function n(e,t){var a,c,d,u,p=[];for(a=0;a<e.length;a++)r(c=e[a])||"boolean"==typeof c||(d=p.length-1,u=p[d],i(c)?c.length>0&&(Yn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Yn(u)&&(p[d]=bn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Yn(u)?p[d]=bn(u.text+c):""!==c&&p.push(bn(c)):Yn(c)&&Yn(u)?p[d]=bn(u.text+c.text):(o(e._isVList)&&s(c.tag)&&r(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),p.push(c)));return p}(n):void 0}function Yn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Xn(n,e){var t,a,r,o,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(r=Object.keys(n),l=new Array(r.length),t=0,a=r.length;t<a;t++)o=r[t],l[t]=e(n[o],o,t);return s(l)||(l=[]),l._isVList=!0,l}function Zn(n,e,t,a){var i,r=this.$scopedSlots[n];r?(t=t||{},a&&(t=M(M({},a),t)),i=r(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},i):i}function ne(n){return At(this.$options,"filters",n,!0)||R}function ee(n,e){return i(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,a,i){var r=Q.keyCodes[e]||t;return i&&a&&!Q.keyCodes[e]?ee(i,a):r?ee(r,n):a?q(a)!==e:void 0===n}function ae(n,e,t,a,r){if(t)if(d(t)){i(t)&&(t=z(t));var s=void 0,o=function(i){if("class"===i||"style"===i||k(i))s=n;else{var o=n.attrs&&n.attrs.type;s=a||Q.mustUseProp(e,o,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=E(i),c=q(i);l in s||c in s||(s[i]=t[i],r&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)o(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||se(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function re(n,e,t){return se(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function se(n,e,t){if(i(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&oe(n[a],"".concat(e,"_").concat(a),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?M({},n.on):{};for(var a in e){var i=t[a],r=e[a];t[a]=i?[].concat(i,r):r}}else;return n}function ce(n,e,t,a){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var s=n[r];i(s)?ce(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return a&&(e.$key=a),e}function de(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function ue(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=re,n._n=y,n._s=b,n._l=Xn,n._t=Zn,n._q=B,n._i=O,n._m=ie,n._f=ne,n._k=te,n._b=ae,n._v=bn,n._e=gn,n._u=ce,n._g=le,n._d=de,n._p=ue}function me(n,e){if(!n||!n.length)return{};for(var t={},a=0,i=n.length;a<i;a++){var r=n[a],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==e&&r.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(r);else{var o=s.slot,l=t[o]||(t[o]=[]);"template"===r.tag?l.push.apply(l,r.children||[]):l.push(r)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function be(n,e,t,i){var r,s=Object.keys(t).length>0,o=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(o&&i&&i!==a&&l===i.$key&&!s&&!i.$hasNormal)return i;for(var c in r={},e)e[c]&&"$"!==c[0]&&(r[c]=fe(n,t,c,e[c]))}else r={};for(var d in t)d in r||(r[d]=ye(t,d));return e&&Object.isExtensible(e)&&(e._normalized=r),V(r,"$stable",o),V(r,"$key",l),V(r,"$hasNormal",s),r}function fe(n,e,t,a){var r=function(){var e=pn;mn(n);var t=arguments.length?a.apply(null,arguments):a({}),r=(t=t&&"object"==typeof t&&!i(t)?[t]:Kn(t))&&t[0];return mn(e),t&&(!r||1===t.length&&r.isComment&&!ge(r))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:r,enumerable:!0,configurable:!0}),r}function ye(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),ke(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ke(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Un(n,e,t)}))}}}function ke(n,e,t,a,i){var r=!1;for(var s in e)s in n?e[s]!==t[s]&&(r=!0):(r=!0,xe(n,s,a,i));for(var s in n)s in e||(r=!0,delete n[s]);return r}function xe(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var _e=null;function Se(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function je(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||ge(t)))return t}}function Ee(n,e,t,a,u,p){return(i(t)||l(t))&&(u=a,a=t,t=void 0),o(p)&&(u=2),function(n,e,t,a,l){if(s(t)&&s(t.__ob__))return gn();s(t)&&s(t.is)&&(e=t.is);if(!e)return gn();0;i(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Kn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||Q.getTagNamespace(e),u=Q.isReservedTag(e)?new hn(Q.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!s(m=At(n.$options,"components",e))?new hn(e,t,a,void 0,void 0,n):xt(m,t,n,a,e)}else u=xt(e,t,n,a);return i(u)?u:s(u)?(s(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(s(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];s(c.tag)&&(r(c.ns)||o(a)&&"svg"!==c.tag)&&n(c,t,a)}}(u,p),s(t)&&function(n){d(n.style)&&Qe(n.style);d(n.class)&&Qe(n.class)}(t),u):gn()}(n,e,t,a,u)}function Te(n,e,t){wn();try{if(e)for(var a=e;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var r=0;r<i.length;r++)try{if(!1===i[r].call(a,n,e,t))return}catch(n){qe(n,a,"errorCaptured hook")}}qe(n,e,t)}finally{_n()}}function Ce(n,e,t,a,i){var r;try{(r=t?n.apply(e,t):n.call(e))&&!r._isVue&&g(r)&&!r._handled&&(r.catch((function(n){return Te(n,a,i+" (Promise/async)")})),r._handled=!0)}catch(n){Te(n,a,i)}return r}function qe(n,e,t){if(Q.errorHandler)try{return Q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ie(e,null,"config.errorHandler")}Ie(n,e,t)}function Ie(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var Ae,Me=!1,ze=[],Le=!1;function De(){Le=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Re=Promise.resolve();Ae=function(){Re.then(De),nn&&setTimeout(L)},Me=!0}else if(Y||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(De)}:function(){setTimeout(De,0)};else{var Be=1,Oe=new MutationObserver(De),Pe=document.createTextNode(String(Be));Oe.observe(Pe,{characterData:!0}),Ae=function(){Be=(Be+1)%2,Pe.data=String(Be)},Me=!0}function Ne(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){Te(n,e,"nextTick")}else t&&t(e)})),Le||(Le=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ue(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var a=n.$options;a[e]=Tt(a[e],t)}(t,n,e)}}Ue("beforeMount"),Ue("mounted"),Ue("beforeUpdate"),Ue("updated"),Ue("beforeDestroy"),Ue("destroyed"),Ue("activated"),Ue("deactivated"),Ue("serverPrefetch"),Ue("renderTracked"),Ue("renderTriggered"),Ue("errorCaptured");var Je=new dn;function Qe(n){return function n(e,t){var a,r,s=i(e);if(!s&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(a=e.length;a--;)n(e[a],t);else if(Nn(e))n(e.value,t);else for(r=Object.keys(e),a=r.length;a--;)n(e[r[a]],t)}(n,Je),Je.clear(),n}var He,Fe=0,Ve=function(){function n(n,e,t,a,i){var r,s;r=this,void 0===(s=Jn&&!Jn._vm?Jn:n?n._scope:void 0)&&(s=Jn),s&&s.active&&s.effects.push(r),(this.vm=n)&&i&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Fe,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new dn,this.newDepIds=new dn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Te(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Qe(n),_n(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ce(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){He.$on(n,e)}function $e(n,e){He.$off(n,e)}function We(n,e){var t=He;return function a(){var i=e.apply(null,arguments);null!==i&&t.$off(n,a)}}function Ke(n,e,t){He=n,Gn(e,t||{},Ge,$e,We,n),He=void 0}var Ye=null;function Xe(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,a){void 0===a&&(a=!0),wn();var i=pn,r=Jn;a&&mn(n);var s=n.$options[e],o="".concat(e," hook");if(s)for(var l=0,c=s.length;l<c;l++)Ce(s[l],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&(mn(i),r&&r.on()),_n()}var tt=[],at=[],it={},rt=!1,st=!1,ot=0;var lt=0,ct=Date.now;if(W&&!Y){var dt=window.performance;dt&&"function"==typeof dt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return dt.now()})}var ut=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(lt=ct(),st=!0,tt.sort(ut),ot=0;ot<tt.length;ot++)(n=tt[ot]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=at.slice(),a=tt.slice();ot=tt.length=at.length=0,it={},rt=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&et(a,"updated")}}(a),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),ln&&Q.devtools&&ln.emit("flush")}function mt(n){var e=n.id;if(null==it[e]&&(n!==kn.target||!n.noRecurse)){if(it[e]=!0,st){for(var t=tt.length-1;t>ot&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);rt||(rt=!0,Ne(pt))}}function ht(n,e){if(n){for(var t=Object.create(null),a=un?Reflect.ownKeys(n):Object.keys(n),i=0;i<a.length;i++){var r=a[i];if("__ob__"!==r){var s=n[r].from;if(s in e._provided)t[r]=e._provided[s];else if("default"in n[r]){var o=n[r].default;t[r]=c(o)?o.call(e):o}else 0}}return t}}function gt(n,e,t,r,s){var l,c=this,d=s.options;_(r,"_uid")?(l=Object.create(r))._original=r:(l=r,r=r._original);var u=o(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=ht(d.inject,r),this.slots=function(){return c.$slots||be(r,n.scopedSlots,c.$slots=me(t,r)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(r,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=be(r,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,a){var s=Ee(l,n,e,t,a,p);return s&&!i(s)&&(s.fnScopeId=d._scopeId,s.fnContext=r),s}:this._c=function(n,e,t,a){return Ee(l,n,e,t,a,p)}}function bt(n,e,t,a,i){var r=fn(n);return r.fnContext=t,r.fnOptions=a,e.slot&&((r.data||(r.data={})).slot=e.slot),r}function ft(n,e){for(var t in e)n[E(t)]=e[t]}function yt(n){return n.name||n.__name||n._componentTag}pe(gt.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;s(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,r){var s=i.data.scopedSlots,o=n.$scopedSlots,l=!!(s&&!s.$stable||o!==a&&!o.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(r||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=r;var u=i.data.attrs||a;n._attrsProxy&&ke(n._attrsProxy,u,d.data&&d.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ke(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){qn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var b=h[g],f=n.$options.props;m[b]=Mt(b,f,e,n)}qn(!0),n.$options.propsData=e}c&&(n.$slots=me(r,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,et(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,at.push(e)):nt(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);et(e,"deactivated")}}(e,!0):e.$destroy())}},kt=Object.keys(vt);function xt(n,e,t,l,c){if(!r(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(r(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=_e;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),o(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var a=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(a,t)}));var u=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=P((function(t){n.resolved=Se(t,e),i?a.length=0:u(!0)})),m=P((function(e){s(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(g(h)?r(n.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),s(h.error)&&(n.errorComp=Se(h.error,e)),s(h.loading)&&(n.loadingComp=Se(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,r(n.resolved)&&r(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),s(h.timeout)&&(c=setTimeout((function(){c=null,r(n.resolved)&&m(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,a,i){var r=gn();return r.asyncFactory=n,r.asyncMeta={data:e,context:t,children:a,tag:i},r}(p,e,t,l,c);e=e||{},Vt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),o=r[a],l=e.model.callback;s(o)?(i(o)?-1===o.indexOf(l):o!==l)&&(r[a]=[l].concat(o)):r[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!r(a)){var i={},o=n.attrs,l=n.props;if(s(o)||s(l))for(var c in a){var d=q(c);Wn(i,l,c,d,!0)||Wn(i,o,c,d,!1)}return i}}(e,n);if(o(n.options.functional))return function(n,e,t,r,o){var l=n.options,c={},d=l.props;if(s(d))for(var u in d)c[u]=Mt(u,d,e||a);else s(t.attrs)&&ft(c,t.attrs),s(t.props)&&ft(c,t.props);var p=new gt(t,c,o,r,n),m=l.render.call(null,p._c,p);if(m instanceof hn)return bt(m,t,p.parent,l,p);if(i(m)){for(var h=Kn(m)||[],g=new Array(h.length),b=0;b<h.length;b++)g[b]=bt(h[b],t,p.parent,l,p);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var b=e.slot;e={},b&&(e.slot=b)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<kt.length;t++){var a=kt[t],i=e[a],r=vt[a];i===r||i&&i._merged||(e[a]=i?wt(r,i):r)}}(e);var f=yt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(f?"-".concat(f):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function wt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var _t=L,St=Q.optionMergeStrategies;function jt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,i,r,s=un?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(a=s[o])&&(i=n[a],r=e[a],t&&_(n,a)?i!==r&&p(i)&&p(r)&&jt(i,r):Ln(n,a,r));return n}function Et(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return a?jt(a,i):i}:e?n?function(){return jt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Tt(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ct(n,e,t,a){var i=Object.create(n||null);return e?M(i,e):i}St.data=function(n,e,t){return t?Et(n,e,t):e&&"function"!=typeof e?n:Et(n,e)},J.forEach((function(n){St[n]=Tt})),U.forEach((function(n){St[n+"s"]=Ct})),St.watch=function(n,e,t,a){if(n===an&&(n=void 0),e===an&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var s in M(r,n),e){var o=r[s],l=e[s];o&&!i(o)&&(o=[o]),r[s]=o?o.concat(l):i(l)?l:[l]}return r},St.props=St.methods=St.inject=St.computed=function(n,e,t,a){if(!n)return e;var i=Object.create(null);return M(i,n),e&&M(i,e),i},St.provide=function(n,e){return n?function(){var t=Object.create(null);return jt(t,c(n)?n.call(this):n),e&&jt(t,c(e)?e.call(this):e,!1),t}:e};var qt=function(n,e){return void 0===e?n:e};function It(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,r,s={};if(i(t))for(a=t.length;a--;)"string"==typeof(r=t[a])&&(s[E(r)]={type:null});else if(p(t))for(var o in t)r=t[o],s[E(o)]=p(r)?r:{type:r};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(i(t))for(var r=0;r<t.length;r++)a[t[r]]={from:t[r]};else if(p(t))for(var s in t){var o=t[s];a[s]=p(o)?M({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=It(n,e.extends,t)),e.mixins))for(var a=0,r=e.mixins.length;a<r;a++)n=It(n,e.mixins[a],t);var s,o={};for(s in n)l(s);for(s in e)_(n,s)||l(s);function l(a){var i=St[a]||qt;o[a]=i(n[a],e[a],t,a)}return o}function At(n,e,t,a){if("string"==typeof t){var i=n[e];if(_(i,t))return i[t];var r=E(t);if(_(i,r))return i[r];var s=T(r);return _(i,s)?i[s]:i[t]||i[r]||i[s]}}function Mt(n,e,t,a){var i=e[n],r=!_(t,n),s=t[n],o=Rt(Boolean,i.type);if(o>-1)if(r&&!_(i,"default"))s=!1;else if(""===s||s===q(n)){var l=Rt(String,i.type);(l<0||o<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!_(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Lt(e.type)?a.call(n):a}(a,i,n);var d=Cn;qn(!0),Mn(s),qn(d)}return s}var zt=/^\s*function (\w+)/;function Lt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function Dt(n,e){return Lt(n)===Lt(e)}function Rt(n,e){if(!i(e))return Dt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Dt(e[t],n))return t;return-1}var Bt={enumerable:!0,configurable:!0,get:L,set:L};function Ot(n,e,t){Bt.get=function(){return this[e][t]},Bt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Bt)}function Pt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Bn({}),i=n.$options._propKeys=[];n.$parent&&qn(!1);var r=function(r){i.push(r);var s=Mt(r,e,t,n);zn(a,r,s,void 0,!0),r in n||Ot(n,"_props",r)};for(var s in e)r(s);qn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ve(n);mn(n),wn();var i=Ce(t,null,[n._props||Bn({}),a],n,"setup");if(_n(),mn(),c(i))e.render=i;else if(d(i))if(n._setupState=i,i.__sfc){var r=n._setupProxy={};for(var s in i)"__sfc"!==s&&Un(r,i,s)}else for(var s in i)F(s)||Un(n,i,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Te(n,e,"data()"),{}}finally{_n()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var r=t[i];0,a&&_(a,r)||F(r)||Ot(n,"_data",r)}var s=Mn(e);s&&s.vmCount++}(n);else{var t=Mn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var i in e){var r=e[i],s=c(r)?r:r.get;0,a||(t[i]=new Ve(n,s||L,L,Nt)),i in n||Ut(n,i,r)}}(n,e.computed),e.watch&&e.watch!==an&&function(n,e){for(var t in e){var a=e[t];if(i(a))for(var r=0;r<a.length;r++)Ht(n,t,a[r]);else Ht(n,t,a)}}(n,e.watch)}var Nt={lazy:!0};function Ut(n,e,t){var a=!on();c(t)?(Bt.get=a?Jt(e):Qt(t),Bt.set=L):(Bt.get=t.get?a&&!1!==t.cache?Jt(e):Qt(t.get):L,Bt.set=t.set||L),Object.defineProperty(n,e,Bt)}function Jt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),kn.target&&e.depend(),e.value}}function Qt(n){return function(){return n.call(this,this)}}function Ht(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Ft=0;function Vt(n){var e=n.options;if(n.super){var t=Vt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var i in t)t[i]!==a[i]&&(e||(e={}),e[i]=t[i]);return e}(n);a&&M(n.extendOptions,a),(e=n.options=It(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function $t(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,i=n._Ctor||(n._Ctor={});if(i[a])return i[a];var r=yt(n)||yt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=It(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)Ot(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ut(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,U.forEach((function(n){s[n]=t[n]})),r&&(s.options.components[r]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=M({},s.options),i[a]=s,s}}function Wt(n){return n&&(yt(n.Ctor.options)||n.tag)}function Kt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Yt(n,e){var t=n.cache,a=n.keys,i=n._vnode,r=n.$vnode;for(var s in t){var o=t[s];if(o){var l=o.name;l&&!e(l)&&Xt(t,s,a,i)}}r.componentOptions.children=void 0}function Xt(n,e,t,a){var i=n[e];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ft++,e._isVue=!0,e.__v_skip=!0,e._scope=new Qn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var i=a.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=It(Vt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=me(e._renderChildren,i),n.$scopedSlots=t?be(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,i){return Ee(n,e,t,a,i,!1)},n.$createElement=function(e,t,a,i){return Ee(n,e,t,a,i,!0)};var r=t&&t.data;zn(n,"$attrs",r&&r.attrs||a,null,!0),zn(n,"$listeners",e._parentListeners||a,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(qn(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),qn(!0))}(e),Pt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var a=Hn(n),i=un?Reflect.ownKeys(t):Object.keys(t),r=0;r<i.length;r++){var s=i[r];Object.defineProperty(a,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Gt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Ln,n.prototype.$delete=Dn,n.prototype.$watch=function(n,e,t){if(p(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var a=new Ve(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(a.expression,'"');wn(),Ce(e,this,[a.value],this,i),_n()}return function(){a.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(i(n))for(var r=0,s=n.length;r<s;r++)a.$on(n[r],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var a=0,r=n.length;a<r;a++)t.$off(n[a],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((s=o[l])===e||s.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var a=A(arguments,1),i='event handler for "'.concat(n,'"'),r=0,s=t.length;r<s;r++)Ce(t[r],e,a,e,i)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,i=t._vnode,r=Xe(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),r(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return Ne(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,a=e._parentVnode;a&&n._isMounted&&(n.$scopedSlots=be(n.$parent,a.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&we(n._slotsProxy,n.$scopedSlots)),n.$vnode=a;var r,s=pn,o=_e;try{mn(n),_e=n,r=t.call(n._renderProxy,n.$createElement)}catch(e){Te(e,n,"render"),r=n._vnode}finally{_e=o,mn(s)}return i(r)&&1===r.length&&(r=r[0]),r instanceof hn||(r=gn()),r.parent=a,r}}(Gt);var Zt=[String,RegExp,Array],na={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var i=t.tag,r=t.componentInstance,s=t.componentOptions;n[a]={name:Wt(s),tag:i,componentInstance:r},e.push(a),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=je(n),t=e&&e.componentOptions;if(t){var a=Wt(t),i=this.include,r=this.exclude;if(i&&(!a||!Kt(i,a))||r&&a&&Kt(r,a))return e;var s=this.cache,o=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,x(o,l),o.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return Q}};Object.defineProperty(n,"config",e),n.util={warn:_t,extend:M,mergeOptions:It,defineReactive:zn},n.set=Ln,n.delete=Dn,n.nextTick=Ne,n.observable=function(n){return Mn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,M(n.options.components,na),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=It(this.options,n),this}}(n),$t(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:on}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:gt}),Gt.version="2.7.16";var ea=v("style,class"),ta=v("input,textarea,option,select,progress"),aa=v("contenteditable,draggable,spellcheck"),ia=v("events,caret,typing,plaintext-only"),ra=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),sa="http://www.w3.org/1999/xlink",oa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},la=function(n){return oa(n)?n.slice(6,n.length):""},ca=function(n){return null==n||!1===n};function da(n){for(var e=n.data,t=n,a=n;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=ua(a.data,e));for(;s(t=t.parent);)t&&t.data&&(e=ua(e,t.data));return function(n,e){if(s(n)||s(e))return pa(n,ma(e));return""}(e.staticClass,e.class)}function ua(n,e){return{staticClass:pa(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function pa(n,e){return n?e?n+" "+e:n:e||""}function ma(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,i=n.length;a<i;a++)s(e=ma(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ha={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ga=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ba=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fa=function(n){return ga(n)||ba(n)};var ya=Object.create(null);var va=v("text,number,password,search,email,tel,url");var ka=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ha[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xa={create:function(n,e){wa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wa(n,!0),wa(e))},destroy:function(n){wa(n,!0)}};function wa(n,e){var t=n.data.ref;if(s(t)){var a=n.context,r=n.componentInstance||n.elm,o=e?null:r,l=e?void 0:r;if(c(t))Ce(t,a,[o],a,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Nn(t),m=a.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?i(h)&&x(h,r):i(h)?h.includes(r)||h.push(r):u?(m[t]=[r],_a(a,t,m[t])):t.value=[r]}else if(u){if(e&&m[t]!==r)return;m[t]=l,_a(a,t,o)}else if(p){if(e&&t.value!==r)return;t.value=o}else 0}}}function _a(n,e,t){var a=n._setupState;a&&_(a,e)&&(Nn(a[e])?a[e].value=t:a[e]=t)}var Sa=new hn("",{},[]),ja=["create","activate","update","remove","destroy"];function Ea(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=s(t=n.data)&&s(t=t.attrs)&&t.type,i=s(t=e.data)&&s(t=t.attrs)&&t.type;return a===i||va(a)&&va(i)}(n,e)||o(n.isAsyncPlaceholder)&&r(e.asyncFactory.error))}function Ta(n,e,t){var a,i,r={};for(a=e;a<=t;++a)s(i=n[a].key)&&(r[i]=a);return r}var Ca={create:qa,update:qa,destroy:function(n){qa(n,Sa)}};function qa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,i,r=n===Sa,s=e===Sa,o=Aa(n.data.directives,n.context),l=Aa(e.data.directives,e.context),c=[],d=[];for(t in l)a=o[t],i=l[t],a?(i.oldValue=a.value,i.oldArg=a.arg,za(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(za(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)za(c[t],"inserted",e,n)};r?$n(e,"insert",u):u()}d.length&&$n(e,"postpatch",(function(){for(var t=0;t<d.length;t++)za(d[t],"componentUpdated",e,n)}));if(!r)for(t in o)l[t]||za(o[t],"unbind",n,n,s)}(n,e)}var Ia=Object.create(null);function Aa(n,e){var t,a,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Ia),i[Ma(a)]=a,e._setupState&&e._setupState.__sfc){var r=a.def||At(e,"_setupState","v-"+a.name);a.def="function"==typeof r?{bind:r,update:r}:r}a.def=a.def||At(e.$options,"directives",a.name)}return i}function Ma(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function za(n,e,t,a,i){var r=n.def&&n.def[e];if(r)try{r(t.elm,n,t,a,i)}catch(a){Te(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var La=[xa,Ca];function Da(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||r(n.data.attrs)&&r(e.data.attrs))){var a,i,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(a in(s(d.__ob__)||o(d._v_attr_proxy))&&(d=e.data.attrs=M({},d)),d)i=d[a],c[a]!==i&&Ra(l,a,i,e.data.pre);for(a in(Y||Z)&&d.value!==c.value&&Ra(l,"value",d.value),c)r(d[a])&&(oa(a)?l.removeAttributeNS(sa,la(a)):aa(a)||l.removeAttribute(a))}}function Ra(n,e,t,a){a||n.tagName.indexOf("-")>-1?Ba(n,e,t):ra(e)?ca(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):aa(e)?n.setAttribute(e,function(n,e){return ca(e)||"false"===e?"false":"contenteditable"===n&&ia(e)?e:"true"}(e,t)):oa(e)?ca(t)?n.removeAttributeNS(sa,la(e)):n.setAttributeNS(sa,e,t):Ba(n,e,t)}function Ba(n,e,t){if(ca(t))n.removeAttribute(e);else{if(Y&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Oa={create:Da,update:Da};function Pa(n,e){var t=e.elm,a=e.data,i=n.data;if(!(r(a.staticClass)&&r(a.class)&&(r(i)||r(i.staticClass)&&r(i.class)))){var o=da(e),l=t._transitionClasses;s(l)&&(o=pa(o,ma(l))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var Na,Ua={create:Pa,update:Pa};function Ja(n,e,t){var a=Na;return function i(){var r=e.apply(null,arguments);null!==r&&Fa(n,i,t,a)}}var Qa=Me&&!(tn&&Number(tn[1])<=53);function Ha(n,e,t,a){if(Qa){var i=lt,r=e;e=r._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return r.apply(this,arguments)}}Na.addEventListener(n,e,rn?{capture:t,passive:a}:t)}function Fa(n,e,t,a){(a||Na).removeEventListener(n,e._wrapper||e,t)}function Va(n,e){if(!r(n.data.on)||!r(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Na=e.elm||n.elm,function(n){if(s(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,a,Ha,Fa,Ja,e.context),Na=void 0}}var Ga,$a={create:Va,update:Va,destroy:function(n){return Va(n,Sa)}};function Wa(n,e){if(!r(n.data.domProps)||!r(e.data.domProps)){var t,a,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||o(c._v_attr_proxy))&&(c=e.data.domProps=M({},c)),l)t in c||(i[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=a;var d=r(a)?"":String(a);Ka(i,d)&&(i.value=d)}else if("innerHTML"===t&&ba(i.tagName)&&r(i.innerHTML)){(Ga=Ga||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=Ga.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(a!==l[t])try{i[t]=a}catch(n){}}}}function Ka(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(s(a)){if(a.number)return y(t)!==y(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ya={create:Wa,update:Wa},Xa=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Za(n){var e=ni(n.style);return n.staticStyle?M(n.staticStyle,e):e}function ni(n){return Array.isArray(n)?z(n):"string"==typeof n?Xa(n):n}var ei,ti=/^--/,ai=/\s*!important$/,ii=function(n,e,t){if(ti.test(e))n.style.setProperty(e,t);else if(ai.test(t))n.style.setProperty(q(e),t.replace(ai,""),"important");else{var a=si(e);if(Array.isArray(t))for(var i=0,r=t.length;i<r;i++)n.style[a]=t[i];else n.style[a]=t}},ri=["Webkit","Moz","ms"],si=S((function(n){if(ei=ei||document.createElement("div").style,"filter"!==(n=E(n))&&n in ei)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ri.length;t++){var a=ri[t]+e;if(a in ei)return a}}));function oi(n,e){var t=e.data,a=n.data;if(!(r(t.staticStyle)&&r(t.style)&&r(a.staticStyle)&&r(a.style))){var i,o,l=e.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},u=c||d,p=ni(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?M({},p):p;var m=function(n,e){var t,a={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Za(i.data))&&M(a,t);(t=Za(n.data))&&M(a,t);for(var r=n;r=r.parent;)r.data&&(t=Za(r.data))&&M(a,t);return a}(e,!0);for(o in u)r(m[o])&&ii(l,o,"");for(o in m)i=m[o],ii(l,o,null==i?"":i)}}var li={create:oi,update:oi},ci=/\s+/;function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ui(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pi(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&M(e,mi(n.name||"v")),M(e,n),e}return"string"==typeof n?mi(n):void 0}}var mi=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hi=W&&!X,gi="transition",bi="transitionend",fi="animation",yi="animationend";hi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(gi="WebkitTransition",bi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fi="WebkitAnimation",yi="webkitAnimationEnd"));var vi=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ki(n){vi((function(){vi(n)}))}function xi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),di(n,e))}function wi(n,e){n._transitionClasses&&x(n._transitionClasses,e),ui(n,e)}function _i(n,e,t){var a=ji(n,e),i=a.type,r=a.timeout,s=a.propCount;if(!i)return t();var o="transition"===i?bi:yi,l=0,c=function(){n.removeEventListener(o,d),t()},d=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),r+1),n.addEventListener(o,d)}var Si=/\b(transform|all)(,|$)/;function ji(n,e){var t,a=window.getComputedStyle(n),i=(a[gi+"Delay"]||"").split(", "),r=(a[gi+"Duration"]||"").split(", "),s=Ei(i,r),o=(a[fi+"Delay"]||"").split(", "),l=(a[fi+"Duration"]||"").split(", "),c=Ei(o,l),d=0,u=0;return"transition"===e?s>0&&(t="transition",d=s,u=r.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?r.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&Si.test(a[gi+"Property"])}}function Ei(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ti(e)+Ti(n[t])})))}function Ti(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ci(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=pi(n.data.transition);if(!r(a)&&!s(t._enterCb)&&1===t.nodeType){for(var i=a.css,o=a.type,l=a.enterClass,u=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,g=a.appearActiveClass,b=a.beforeEnter,f=a.enter,v=a.afterEnter,k=a.enterCancelled,x=a.beforeAppear,w=a.appear,_=a.afterAppear,S=a.appearCancelled,j=a.duration,E=Ye,T=Ye.$vnode;T&&T.parent;)E=T.context,T=T.parent;var C=!E._isMounted||!n.isRootInsert;if(!C||w||""===w){var q=C&&m?m:l,I=C&&g?g:p,A=C&&h?h:u,M=C&&x||b,z=C&&c(w)?w:f,L=C&&_||v,D=C&&S||k,R=y(d(j)?j.enter:j);0;var B=!1!==i&&!X,O=Ai(z),N=t._enterCb=P((function(){B&&(wi(t,A),wi(t,I)),N.cancelled?(B&&wi(t,q),D&&D(t)):L&&L(t),t._enterCb=null}));n.data.show||$n(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,N)})),M&&M(t),B&&(xi(t,q),xi(t,I),ki((function(){wi(t,q),N.cancelled||(xi(t,A),O||(Ii(R)?setTimeout(N,R):_i(t,o,N)))}))),n.data.show&&(e&&e(),z&&z(t,N)),B||O||N()}}}function qi(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=pi(n.data.transition);if(r(a)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var i=a.css,o=a.type,l=a.leaveClass,c=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,g=a.leaveCancelled,b=a.delayLeave,f=a.duration,v=!1!==i&&!X,k=Ai(m),x=y(d(f)?f.leave:f);0;var w=t._leaveCb=P((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(wi(t,c),wi(t,u)),w.cancelled?(v&&wi(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));b?b(_):_()}function _(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),v&&(xi(t,l),xi(t,u),ki((function(){wi(t,l),w.cancelled||(xi(t,c),k||(Ii(x)?setTimeout(w,x):_i(t,o,w)))}))),m&&m(t,w),v||k||w())}}function Ii(n){return"number"==typeof n&&!isNaN(n)}function Ai(n){if(r(n))return!1;var e=n.fns;return s(e)?Ai(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Mi(n,e){!0!==e.data.show&&Ci(e)}var zi=function(n){var e,t,a={},c=n.modules,d=n.nodeOps;for(e=0;e<ja.length;++e)for(a[ja[e]]=[],t=0;t<c.length;++t)s(c[t][ja[e]])&&a[ja[e]].push(c[t][ja[e]]);function u(n){var e=d.parentNode(n);s(e)&&d.removeChild(e,n)}function p(n,e,t,i,r,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=fn(n)),n.isRootInsert=!r,!function(n,e,t,i){var r=n.data;if(s(r)){var l=s(n.componentInstance)&&r.keepAlive;if(s(r=r.hook)&&s(r=r.init)&&r(n,!1),s(n.componentInstance))return m(n,e),h(t,n.elm,i),o(l)&&function(n,e,t,i){var r,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(r=o.data)&&s(r=r.transition)){for(r=0;r<a.activate.length;++r)a.activate[r](Sa,o);e.push(o);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,p=n.children,b=n.tag;s(b)?(n.elm=n.ns?d.createElementNS(n.ns,b):d.createElement(b,n),y(n),g(n,p,e),s(u)&&f(n,e),h(t,n.elm,i)):o(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,i)):(n.elm=d.createTextNode(n.text),h(t,n.elm,i))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,b(n)?(f(n,e),y(n)):(wa(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function g(n,e,t){if(i(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function b(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function f(n,t){for(var i=0;i<a.create.length;++i)a.create[i](Sa,n);s(e=n.data.hook)&&(s(e.create)&&e.create(Sa,n),s(e.insert)&&t.push(n))}function y(n){var e;if(s(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;s(e=Ye)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function k(n,e,t,a,i,r){for(;a<=i;++a)p(t[a],r,n,e,!1,t,a)}function x(n){var e,t,i=n.data;if(s(i))for(s(e=i.hook)&&s(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];s(a)&&(s(a.tag)?(_(a),x(a)):u(a.elm))}}function _(n,e){if(s(e)||s(n.data)){var t,i=a.remove.length+1;for(s(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,i),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&_(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else u(n.elm)}function S(n,e,t,a){for(var i=t;i<a;i++){var r=e[i];if(s(r)&&Ea(n,r))return i}}function j(n,e,t,i,l,c){if(n!==e){s(e.elm)&&s(i)&&(e=i[l]=fn(e));var u=e.elm=n.elm;if(o(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;s(h)&&s(m=h.hook)&&s(m=m.prepatch)&&m(n,e);var g=n.children,f=e.children;if(s(h)&&b(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);s(m=h.hook)&&s(m=m.update)&&m(n,e)}r(e.text)?s(g)&&s(f)?g!==f&&function(n,e,t,a,i){var o,l,c,u=0,m=0,h=e.length-1,g=e[0],b=e[h],f=t.length-1,y=t[0],v=t[f],x=!i;for(0;u<=h&&m<=f;)r(g)?g=e[++u]:r(b)?b=e[--h]:Ea(g,y)?(j(g,y,a,t,m),g=e[++u],y=t[++m]):Ea(b,v)?(j(b,v,a,t,f),b=e[--h],v=t[--f]):Ea(g,v)?(j(g,v,a,t,f),x&&d.insertBefore(n,g.elm,d.nextSibling(b.elm)),g=e[++u],v=t[--f]):Ea(b,y)?(j(b,y,a,t,m),x&&d.insertBefore(n,b.elm,g.elm),b=e[--h],y=t[++m]):(r(o)&&(o=Ta(e,u,h)),r(l=s(y.key)?o[y.key]:S(y,e,u,h))?p(y,a,n,g.elm,!1,t,m):Ea(c=e[l],y)?(j(c,y,a,t,m),e[l]=void 0,x&&d.insertBefore(n,c.elm,g.elm)):p(y,a,n,g.elm,!1,t,m),y=t[++m]);u>h?k(n,r(t[f+1])?null:t[f+1].elm,t,m,f,a):m>f&&w(e,u,h)}(u,g,f,t,c):s(f)?(s(n.text)&&d.setTextContent(u,""),k(u,null,f,0,f.length-1,t)):s(g)?w(g,0,g.length-1):s(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),s(h)&&s(m=h.hook)&&s(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(o(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var T=v("attrs,class,staticClass,staticStyle,key");function C(n,e,t,a){var i,r=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,o(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(i=l.hook)&&s(i=i.init)&&i(e,!0),s(i=e.componentInstance)))return m(e,t),!0;if(s(r)){if(s(c))if(n.hasChildNodes())if(s(i=l)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!C(u,c[p],t,a)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else g(e,c,t);if(s(l)){var h=!1;for(var b in l)if(!T(b)){h=!0,f(e,t);break}!h&&l.class&&Qe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!r(e)){var l,c=!1,u=[];if(r(n))c=!0,p(e,u);else{var m=s(n.nodeType);if(!m&&Ea(n,e))j(n,e,u,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&C(n,e,u))return E(e,u,!0),n;l=n,n=new hn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=d.parentNode(h);if(p(e,u,h._leaveCb?null:g,d.nextSibling(h)),s(e.parent))for(var f=e.parent,y=b(e);f;){for(var v=0;v<a.destroy.length;++v)a.destroy[v](f);if(f.elm=e.elm,y){for(var k=0;k<a.create.length;++k)a.create[k](Sa,f);var _=f.data.hook.insert;if(_.merged)for(var S=_.fns.slice(1),T=0;T<S.length;T++)S[T]()}else wa(f);f=f.parent}s(g)?w([n],0,0):s(n.tag)&&x(n)}}return E(e,u,c),e.elm}s(n)&&x(n)}}({nodeOps:ka,modules:[Oa,Ua,$a,Ya,li,W?{create:Mi,activate:Mi,remove:function(n,e){!0!==n.data.show?qi(n,e):e()}}:{}].concat(La)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ui(n,"input")}));var Li={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?$n(t,"postpatch",(function(){Li.componentUpdated(n,e,t)})):Di(n,e,t.context),n._vOptions=[].map.call(n.options,Oi)):("textarea"===t.tag||va(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Pi),n.addEventListener("compositionend",Ni),n.addEventListener("change",Ni),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Di(n,e,t.context);var a=n._vOptions,i=n._vOptions=[].map.call(n.options,Oi);if(i.some((function(n,e){return!B(n,a[e])})))(n.multiple?e.value.some((function(n){return Bi(n,i)})):e.value!==e.oldValue&&Bi(e.value,i))&&Ui(n,"change")}}};function Di(n,e,t){Ri(n,e,t),(Y||Z)&&setTimeout((function(){Ri(n,e,t)}),0)}function Ri(n,e,t){var a=e.value,i=n.multiple;if(!i||Array.isArray(a)){for(var r,s,o=0,l=n.options.length;o<l;o++)if(s=n.options[o],i)r=O(a,Oi(s))>-1,s.selected!==r&&(s.selected=r);else if(B(Oi(s),a))return void(n.selectedIndex!==o&&(n.selectedIndex=o));i||(n.selectedIndex=-1)}}function Bi(n,e){return e.every((function(e){return!B(e,n)}))}function Oi(n){return"_value"in n?n._value:n.value}function Pi(n){n.target.composing=!0}function Ni(n){n.target.composing&&(n.target.composing=!1,Ui(n.target,"input"))}function Ui(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ji(n){return!n.componentInstance||n.data&&n.data.transition?n:Ji(n.componentInstance._vnode)}var Qi={model:Li,show:{bind:function(n,e,t){var a=e.value,i=(t=Ji(t)).data&&t.data.transition,r=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&i?(t.data.show=!0,Ci(t,(function(){n.style.display=r}))):n.style.display=a?r:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ji(t)).data&&t.data.transition?(t.data.show=!0,a?Ci(t,(function(){n.style.display=n.__vOriginalDisplay})):qi(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,i){i||(n.style.display=n.__vOriginalDisplay)}}},Hi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Fi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Fi(je(e.children)):n}function Vi(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var i=t._parentListeners;for(var a in i)e[E(a)]=i[a];return e}function Gi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var $i=function(n){return n.tag||ge(n)},Wi=function(n){return"show"===n.name},Ki={name:"transition",props:Hi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter($i)).length){0;var a=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var r=Fi(i);if(!r)return i;if(this._leaving)return Gi(n,i);var s="__transition-".concat(this._uid,"-");r.key=null==r.key?r.isComment?s+"comment":s+r.tag:l(r.key)?0===String(r.key).indexOf(s)?r.key:s+r.key:r.key;var o=(r.data||(r.data={})).transition=Vi(this),c=this._vnode,d=Fi(c);if(r.data.directives&&r.data.directives.some(Wi)&&(r.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(r,d)&&!ge(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=M({},o);if("out-in"===a)return this._leaving=!0,$n(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Gi(n,i);if("in-out"===a){if(ge(r))return c;var p,m=function(){p()};$n(o,"afterEnter",m),$n(o,"enterCancelled",m),$n(u,"delayLeave",(function(n){p=n}))}}return i}}},Yi=M({tag:String,moveClass:String},Hi);function Xi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Zi(n){n.data.newPos=n.elm.getBoundingClientRect()}function nr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,i=e.top-t.top;if(a||i){n.data.moved=!0;var r=n.elm.style;r.transform=r.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),r.transitionDuration="0s"}}delete Yi.mode;var er={Transition:Ki,TransitionGroup:{props:Yi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var i=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],r=this.children=[],s=Vi(this),o=0;o<i.length;o++){if((d=i[o]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))r.push(d),t[d.key]=d,(d.data||(d.data={})).transition=s;else;}if(a){var l=[],c=[];for(o=0;o<a.length;o++){var d;(d=a[o]).data.transition=s,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,r)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xi),n.forEach(Zi),n.forEach(nr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;xi(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(bi,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(bi,n),t._moveCb=null,wi(t,e))})}})))},methods:{hasMove:function(n,e){if(!hi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ui(t,n)})),di(t,e),t.style.display="none",this.$el.appendChild(t);var a=ji(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function tr(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&ta(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=fa,Gt.config.isReservedAttr=ea,Gt.config.getTagNamespace=function(n){return ba(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!W)return!0;if(fa(n))return!1;if(n=n.toLowerCase(),null!=ya[n])return ya[n];var e=document.createElement(n);return n.indexOf("-")>-1?ya[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ya[n]=/HTMLUnknownElement/.test(e.toString())},M(Gt.options.directives,Qi),M(Gt.options.components,er),Gt.prototype.__patch__=W?zi:L,Gt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Ve(n,a,L,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var r=0;r<i.length;r++)i[r].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){Q.devtools&&ln&&ln.emit("init",Gt)}),0);var ar=/[!'()*]/g,ir=function(n){return"%"+n.charCodeAt(0).toString(16)},rr=/%2C/g,sr=function(n){return encodeURIComponent(n).replace(ar,ir).replace(rr,",")};function or(n){try{return decodeURIComponent(n)}catch(n){0}return n}var lr=function(n){return null==n||"object"==typeof n?n:String(n)};function cr(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=or(t.shift()),i=t.length>0?or(t.join("=")):null;void 0===e[a]?e[a]=i:Array.isArray(e[a])?e[a].push(i):e[a]=[e[a],i]})),e):e}function dr(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return sr(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(sr(e)):a.push(sr(e)+"="+sr(n)))})),a.join("&")}return sr(e)+"="+sr(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ur=/\/?$/;function pr(n,e,t,a){var i=a&&a.options.stringifyQuery,r=e.query||{};try{r=mr(r)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:r,params:e.params||{},fullPath:br(e,i),matched:n?gr(n):[]};return t&&(s.redirectedFrom=br(t,i)),Object.freeze(s)}function mr(n){if(Array.isArray(n))return n.map(mr);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=mr(n[t]);return e}return n}var hr=pr(null,{path:"/"});function gr(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function br(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||dr)(a)+i}function fr(n,e,t){return e===hr?n===e:!!e&&(n.path&&e.path?n.path.replace(ur,"")===e.path.replace(ur,"")&&(t||n.hash===e.hash&&yr(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&yr(n.query,e.query)&&yr(n.params,e.params))))}function yr(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,i){var r=n[t];if(a[i]!==t)return!1;var s=e[t];return null==r||null==s?r===s:"object"==typeof r&&"object"==typeof s?yr(r,s):String(r)===String(s)}))}function vr(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var i=t.instances[a],r=t.enteredCbs[a];if(i&&r){delete t.enteredCbs[a];for(var s=0;s<r.length;s++)i._isBeingDestroyed||r[s](i)}}}}var kr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,r=e.data;r.routerView=!0;for(var s=i.$createElement,o=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&d++,p.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(r.routerViewDepth=d,u){var m=c[o],h=m&&m.component;return h?(m.configProps&&xr(h,r,m.route,m.configProps),s(h,r,a)):s()}var g=l.matched[d],b=g&&g.components[o];if(!g||!b)return c[o]=null,s();c[o]={component:b},r.registerRouteInstance=function(n,e){var t=g.instances[o];(e&&t!==n||!e&&t===n)&&(g.instances[o]=e)},(r.hook||(r.hook={})).prepatch=function(n,e){g.instances[o]=e.componentInstance},r.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[o]&&(g.instances[o]=n.componentInstance),vr(l)};var f=g.props&&g.props[o];return f&&(tr(c[o],{route:l,configProps:f}),xr(b,r,l,f)),s(b,r,a)}};function xr(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=tr({},i);var r=e.attrs=e.attrs||{};for(var s in i)n.props&&s in n.props||(r[s]=i[s],delete i[s])}}function wr(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var r=n.replace(/^\//,"").split("/"),s=0;s<r.length;s++){var o=r[s];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function _r(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Sr=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},jr=Pr,Er=Ar,Tr=function(n,e){return zr(Ar(n,e),e)},Cr=zr,qr=Or,Ir=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ar(n,e){for(var t,a=[],i=0,r=0,s="",o=e&&e.delimiter||"/";null!=(t=Ir.exec(n));){var l=t[0],c=t[1],d=t.index;if(s+=n.slice(r,d),r=d+l.length,c)s+=c[1];else{var u=n[r],p=t[2],m=t[3],h=t[4],g=t[5],b=t[6],f=t[7];s&&(a.push(s),s="");var y=null!=p&&null!=u&&u!==p,v="+"===b||"*"===b,k="?"===b||"*"===b,x=t[2]||o,w=h||g;a.push({name:m||i++,prefix:p||"",delimiter:x,optional:k,repeat:v,partial:y,asterisk:!!f,pattern:w?Dr(w):f?".*":"[^"+Lr(x)+"]+?"})}}return r<n.length&&(s+=n.substr(r)),s&&a.push(s),a}function Mr(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function zr(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Br(e)));return function(e,a){for(var i="",r=e||{},s=(a||{}).pretty?Mr:encodeURIComponent,o=0;o<n.length;o++){var l=n[o];if("string"!=typeof l){var c,d=r[l.name];if(null==d){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Sr(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=s(d[u]),!t[o].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(d),!t[o].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function Lr(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Dr(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Rr(n,e){return n.keys=e,n}function Br(n){return n&&n.sensitive?"":"i"}function Or(n,e,t){Sr(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,i=!1!==t.end,r="",s=0;s<n.length;s++){var o=n[s];if("string"==typeof o)r+=Lr(o);else{var l=Lr(o.prefix),c="(?:"+o.pattern+")";e.push(o),o.repeat&&(c+="(?:"+l+c+")*"),r+=c=o.optional?o.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Lr(t.delimiter||"/"),u=r.slice(-d.length)===d;return a||(r=(u?r.slice(0,-d.length):r)+"(?:"+d+"(?=$))?"),r+=i?"$":a&&u?"":"(?="+d+"|$)",Rr(new RegExp("^"+r,Br(t)),e)}function Pr(n,e,t){return Sr(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Rr(n,e)}(n,e):Sr(n)?function(n,e,t){for(var a=[],i=0;i<n.length;i++)a.push(Pr(n[i],e,t).source);return Rr(new RegExp("(?:"+a.join("|")+")",Br(t)),e)}(n,e,t):function(n,e,t){return Or(Ar(n,t),e,t)}(n,e,t)}jr.parse=Er,jr.compile=Tr,jr.tokensToFunction=Cr,jr.tokensToRegExp=qr;var Nr=Object.create(null);function Ur(n,e,t){e=e||{};try{var a=Nr[n]||(Nr[n]=jr.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Jr(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var r=(i=tr({},n)).params;return r&&"object"==typeof r&&(i.params=tr({},r)),i}if(!i.path&&i.params&&e){(i=tr({},i))._normalized=!0;var s=tr(tr({},e.params),i.params);if(e.name)i.name=e.name,i.params=s;else if(e.matched.length){var o=e.matched[e.matched.length-1].path;i.path=Ur(o,s,e.path)}else 0;return i}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",d=l.path?wr(l.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var a,i=t||cr;try{a=i(n||"")}catch(n){a={}}for(var r in e){var s=e[r];a[r]=Array.isArray(s)?s.map(lr):lr(s)}return a}(l.query,i.query,a&&a.options.parseQuery),p=i.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Qr,Hr=function(){},Fr={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),r=i.location,s=i.route,o=i.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=s.redirectedFrom?pr(null,Jr(s.redirectedFrom),null,t):s;l[h]=fr(a,g,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ur,"/").indexOf(e.path.replace(ur,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,g);var b=l[h]?this.ariaCurrentValue:null,f=function(n){Vr(n)&&(e.replace?t.replace(r,Hr):t.push(r,Hr))},y={click:Vr};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=f})):y[this.event]=f;var v={class:l},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:s,navigate:f,isActive:l[m],isExactActive:l[h]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)v.on=y,v.attrs={href:o,"aria-current":b};else{var x=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=tr({},x.data);for(var _ in w.on=w.on||{},w.on){var S=w.on[_];_ in y&&(w.on[_]=Array.isArray(S)?S:[S])}for(var j in y)j in w.on?w.on[j].push(y[j]):w.on[j]=f;var E=x.data.attrs=tr({},x.data.attrs);E.href=o,E["aria-current"]=b}else v.on=y}return n(this.tag,v,this.$slots.default)}};function Vr(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Gr="undefined"!=typeof window;function $r(n,e,t,a,i){var r=e||[],s=t||Object.create(null),o=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,i,r,s){var o=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return _r(e.path+"/"+n)}(o,r,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:d,regex:Wr(d,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:r,matchAs:s,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var r=s?_r(s+"/"+i.path):void 0;n(e,t,a,i,u,r)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:i.children};n(e,t,a,h,r,u.path||"/")}l&&(a[l]||(a[l]=u))}(r,s,o,n,i)}));for(var l=0,c=r.length;l<c;l++)"*"===r[l]&&(r.push(r.splice(l,1)[0]),c--,l--);return{pathList:r,pathMap:s,nameMap:o}}function Wr(n,e){return jr(n,[],e)}function Kr(n,e){var t=$r(n),a=t.pathList,i=t.pathMap,r=t.nameMap;function s(n,t,s){var o=Jr(n,t,!1,e),c=o.name;if(c){var d=r[c];if(!d)return l(null,o);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof o.params&&(o.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in o.params)&&u.indexOf(p)>-1&&(o.params[p]=t.params[p]);return o.path=Ur(d.path,o.params),l(d,o,s)}if(o.path){o.params={};for(var m=0;m<a.length;m++){var h=a[m],g=i[h];if(Yr(g.regex,o.path,o.params))return l(g,o,s)}}return l(null,o)}function o(n,t){var a=n.redirect,i="function"==typeof a?a(pr(n,t,null,e)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var o=i,c=o.name,d=o.path,u=t.query,p=t.hash,m=t.params;if(u=o.hasOwnProperty("query")?o.query:u,p=o.hasOwnProperty("hash")?o.hash:p,m=o.hasOwnProperty("params")?o.params:m,c){r[c];return s({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return wr(n,e.parent?e.parent.path:"/",!0)}(d,n);return s({_normalized:!0,path:Ur(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?o(n,a||t):n&&n.matchAs?function(n,e,t){var a=s({_normalized:!0,path:Ur(t,e.params)});if(a){var i=a.matched,r=i[i.length-1];return e.params=a.params,l(r,e)}return l(null,e)}(0,t,n.matchAs):pr(n,t,a,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?r[n]:void 0;$r([e||n],a,i,r,t),t&&t.alias.length&&$r(t.alias.map((function(n){return{path:n,children:[e]}})),a,i,r,t)},getRoutes:function(){return a.map((function(n){return i[n]}))},addRoutes:function(n){$r(n,a,i,r)}}}function Yr(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var i=1,r=a.length;i<r;++i){var s=n.keys[i-1];s&&(t[s.name||"pathMatch"]="string"==typeof a[i]?or(a[i]):a[i])}return!0}var Xr=Gr&&window.performance&&window.performance.now?window.performance:Date;function Zr(){return Xr.now().toFixed(3)}var ns=Zr();function es(){return ns}function ts(n){return ns=n}var as=Object.create(null);function is(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=tr({},window.history.state);return t.key=es(),window.history.replaceState(t,"",e),window.addEventListener("popstate",os),function(){window.removeEventListener("popstate",os)}}function rs(n,e,t,a){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var r=function(){var n=es();if(n)return as[n]}(),s=i.call(n,e,t,a?r:null);s&&("function"==typeof s.then?s.then((function(n){ps(n,r)})).catch((function(n){0})):ps(s,r))}))}}function ss(){var n=es();n&&(as[n]={x:window.pageXOffset,y:window.pageYOffset})}function os(n){ss(),n.state&&n.state.key&&ts(n.state.key)}function ls(n){return ds(n.x)||ds(n.y)}function cs(n){return{x:ds(n.x)?n.x:window.pageXOffset,y:ds(n.y)?n.y:window.pageYOffset}}function ds(n){return"number"==typeof n}var us=/^#\d/;function ps(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var i=us.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var r=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(i,r={x:ds((t=r).x)?t.x:0,y:ds(t.y)?t.y:0})}else ls(n)&&(e=cs(n))}else a&&ls(n)&&(e=cs(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ms,hs=Gr&&((-1===(ms=window.navigator.userAgent).indexOf("Android 2.")&&-1===ms.indexOf("Android 4.0")||-1===ms.indexOf("Mobile Safari")||-1!==ms.indexOf("Chrome")||-1!==ms.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function gs(n,e){ss();var t=window.history;try{if(e){var a=tr({},t.state);a.key=es(),t.replaceState(a,"",n)}else t.pushState({key:ts(Zr())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function bs(n){gs(n,!0)}var fs={redirected:2,aborted:4,cancelled:8,duplicated:16};function ys(n,e){return ks(n,e,fs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xs.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function vs(n,e){return ks(n,e,fs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ks(n,e,t,a){var i=new Error(a);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var xs=["params","query","hash"];function ws(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function _s(n,e){return ws(n)&&n._isRouter&&(null==e||n.type===e)}function Ss(n,e,t){var a=function(i){i>=n.length?t():n[i]?e(n[i],(function(){a(i+1)})):a(i+1)};a(0)}function js(n){return function(e,t,a){var i=!1,r=0,s=null;Es(n,(function(n,e,t,o){if("function"==typeof n&&void 0===n.cid){i=!0,r++;var l,c=qs((function(e){var i;((i=e).__esModule||Cs&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Qr.extend(e),t.components[o]=e,--r<=0&&a()})),d=qs((function(n){var e="Failed to resolve async component "+o+": "+n;s||(s=ws(n)?n:new Error(e),a(s))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),i||a()}}function Es(n,e){return Ts(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ts(n){return Array.prototype.concat.apply([],n)}var Cs="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function qs(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Is=function(n,e){this.router=n,this.base=function(n){if(!n)if(Gr){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=hr,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function As(n,e,t,a){var i=Es(n,(function(n,a,i,r){var s=function(n,e){"function"!=typeof n&&(n=Qr.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,a,i,r)})):t(s,a,i,r)}));return Ts(a?i.reverse():i)}function Ms(n,e){if(e)return function(){return n.apply(e,arguments)}}Is.prototype.listen=function(n){this.cb=n},Is.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Is.prototype.onError=function(n){this.errorCbs.push(n)},Is.prototype.transitionTo=function(n,e,t){var a,i=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var r=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),e&&e(a),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(a,r)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!i.ready&&(_s(n,fs.redirected)&&r===hr||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},Is.prototype.confirmTransition=function(n,e,t){var a=this,i=this.current;this.pending=n;var r,s,o=function(n){!_s(n)&&ws(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(fr(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&rs(this.router,i,n,!1),o(((s=ks(r=i,n,fs.duplicated,'Avoided redundant navigation to current location: "'+r.fullPath+'".')).name="NavigationDuplicated",s));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return As(n,"beforeRouteLeave",Ms,!0)}(p),this.router.beforeHooks,function(n){return As(n,"beforeRouteUpdate",Ms)}(u),m.map((function(n){return n.beforeEnter})),js(m)),g=function(e,t){if(a.pending!==n)return o(vs(i,n));try{e(n,i,(function(e){!1===e?(a.ensureURL(!0),o(function(n,e){return ks(n,e,fs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):ws(e)?(a.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(ys(i,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){o(n)}};Ss(h,g,(function(){Ss(function(n){return As(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,i,r){return n(a,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),r(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),g,(function(){if(a.pending!==n)return o(vs(i,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){vr(n)}))}))}))},Is.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Is.prototype.setupListeners=function(){},Is.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=hr,this.pending=null};var zs=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ls(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=hs&&t;a&&this.listeners.push(is());var i=function(){var t=n.current,i=Ls(n.base);n.current===hr&&i===n._startLocation||n.transitionTo(i,(function(n){a&&rs(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){gs(_r(a.base+n.fullPath)),rs(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){bs(_r(a.base+n.fullPath)),rs(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ls(this.base)!==this.current.fullPath){var e=_r(this.base+this.current.fullPath);n?gs(e):bs(e)}},e.prototype.getCurrentLocation=function(){return Ls(this.base)},e}(Is);function Ls(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(_r(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ds=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Ls(n);if(!/^\/#/.test(e))return window.location.replace(_r(n+"/#"+e)),!0}(this.base)||Rs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=hs&&e;t&&this.listeners.push(is());var a=function(){var e=n.current;Rs()&&n.transitionTo(Bs(),(function(a){t&&rs(n.router,a,e,!0),hs||Ns(a.fullPath)}))},i=hs?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Ps(n.fullPath),rs(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Ns(n.fullPath),rs(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Bs()!==e&&(n?Ps(e):Ns(e))},e.prototype.getCurrentLocation=function(){return Bs()},e}(Is);function Rs(){var n=Bs();return"/"===n.charAt(0)||(Ns("/"+n),!1)}function Bs(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Os(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ps(n){hs?gs(Os(n)):window.location.hash=n}function Ns(n){hs?bs(Os(n)):window.location.replace(Os(n))}var Us=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){_s(n,fs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Is),Js=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Kr(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!hs&&!1!==n.fallback,this.fallback&&(e="hash"),Gr||(e="abstract"),this.mode=e,e){case"history":this.history=new zs(this,n.base);break;case"hash":this.history=new Ds(this,n.base,this.fallback);break;case"abstract":this.history=new Us(this,n.base);break;default:0}},Qs={currentRoute:{configurable:!0}};Js.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Qs.currentRoute.get=function(){return this.history&&this.history.current},Js.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof zs||t instanceof Ds){var a=function(n){t.setupListeners(),function(n){var a=t.current,i=e.options.scrollBehavior;hs&&i&&"fullPath"in n&&rs(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Js.prototype.beforeEach=function(n){return Fs(this.beforeHooks,n)},Js.prototype.beforeResolve=function(n){return Fs(this.resolveHooks,n)},Js.prototype.afterEach=function(n){return Fs(this.afterHooks,n)},Js.prototype.onReady=function(n,e){this.history.onReady(n,e)},Js.prototype.onError=function(n){this.history.onError(n)},Js.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Js.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Js.prototype.go=function(n){this.history.go(n)},Js.prototype.back=function(){this.go(-1)},Js.prototype.forward=function(){this.go(1)},Js.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Js.prototype.resolve=function(n,e,t){var a=Jr(n,e=e||this.history.current,t,this),i=this.match(a,e),r=i.redirectedFrom||i.fullPath;return{location:a,route:i,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?_r(n+"/"+a):a}(this.history.base,r,this.mode),normalizedTo:a,resolved:i}},Js.prototype.getRoutes=function(){return this.matcher.getRoutes()},Js.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==hr&&this.history.transitionTo(this.history.getCurrentLocation())},Js.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==hr&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Js.prototype,Qs);var Hs=Js;function Fs(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Js.install=function n(e){if(!n.installed||Qr!==e){n.installed=!0,Qr=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",kr),e.component("RouterLink",Fr);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Js.version="3.6.5",Js.isNavigationFailure=_s,Js.NavigationFailureType=fs,Js.START_LOCATION=hr,Gr&&window.Vue&&window.Vue.use(Js);t(153),t(17),t(162);t(163),t(31);var Vs={"components/AlgoliaSearchBox":()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,394)),"components/ArchivesPage":()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,361)),"components/ArticleInfo":()=>Promise.all([t.e(0),t.e(20)]).then(t.bind(null,362)),"components/BloggerBar":()=>Promise.all([t.e(0),t.e(21)]).then(t.bind(null,363)),"components/BodyBgImg":()=>Promise.all([t.e(0),t.e(22)]).then(t.bind(null,364)),"components/Buttons":()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,365)),"components/Catalogue":()=>Promise.all([t.e(0),t.e(23)]).then(t.bind(null,366)),"components/CategoriesBar":()=>Promise.all([t.e(0),t.e(24)]).then(t.bind(null,327)),"components/CategoriesPage":()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,367)),"components/DropdownLink":()=>Promise.all([t.e(0),t.e(15)]).then(t.bind(null,305)),"components/DropdownTransition":()=>Promise.all([t.e(0),t.e(25)]).then(t.bind(null,283)),"components/Footer":()=>Promise.all([t.e(0),t.e(26)]).then(t.bind(null,368)),"components/Home":()=>Promise.all([t.e(0),t.e(2),t.e(36)]).then(t.bind(null,390)),"components/MainLayout":()=>Promise.all([t.e(0),t.e(27)]).then(t.bind(null,297)),"components/NavLink":()=>t.e(37).then(t.bind(null,282)),"components/NavLinks":()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,329)),"components/Navbar":()=>Promise.all([t.e(0),t.e(1)]).then(t.bind(null,389)),"components/Page":()=>Promise.all([t.e(0),t.e(3),t.e(34)]).then(t.bind(null,391)),"components/PageEdit":()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,369)),"components/PageNav":()=>Promise.all([t.e(0),t.e(16)]).then(t.bind(null,370)),"components/Pagination":()=>Promise.all([t.e(0),t.e(28)]).then(t.bind(null,296)),"components/PostList":()=>Promise.all([t.e(0),t.e(29)]).then(t.bind(null,295)),"components/RightMenu":()=>Promise.all([t.e(0),t.e(30)]).then(t.bind(null,371)),"components/Sidebar":()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,372)),"components/SidebarButton":()=>Promise.all([t.e(0),t.e(31)]).then(t.bind(null,374)),"components/SidebarGroup":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,330)),"components/SidebarLink":()=>Promise.all([t.e(0),t.e(32)]).then(t.bind(null,306)),"components/SidebarLinks":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,303)),"components/TagsBar":()=>Promise.all([t.e(0),t.e(33)]).then(t.bind(null,328)),"components/TagsPage":()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,373)),"components/UpdateArticle":()=>Promise.all([t.e(0),t.e(35)]).then(t.bind(null,333)),"global-components/Badge":()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,397)),"global-components/CodeBlock":()=>Promise.resolve().then(t.bind(null,123)),"global-components/CodeGroup":()=>Promise.resolve().then(t.bind(null,124)),"layouts/404":()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,395)),"layouts/Layout":()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(3),t.e(4)]).then(t.bind(null,396)),NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,395)),Layout:()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(3),t.e(4)]).then(t.bind(null,396))},Gs={"v-551fbd5b":()=>t.e(40).then(t.bind(null,398)),"v-e7e40508":()=>t.e(38).then(t.bind(null,399)),"v-48424b17":()=>t.e(42).then(t.bind(null,400)),"v-a8a3be30":()=>t.e(41).then(t.bind(null,401)),"v-61ff5e21":()=>t.e(43).then(t.bind(null,402)),"v-17fd5c60":()=>t.e(44).then(t.bind(null,403)),"v-4a7ed15c":()=>t.e(46).then(t.bind(null,404)),"v-560c45dc":()=>t.e(47).then(t.bind(null,405)),"v-9c3ab8f0":()=>t.e(39).then(t.bind(null,406)),"v-1156e8e2":()=>t.e(45).then(t.bind(null,407)),"v-4f888be4":()=>t.e(49).then(t.bind(null,408)),"v-33e78c7a":()=>t.e(48).then(t.bind(null,409)),"v-76db6908":()=>t.e(50).then(t.bind(null,410)),"v-08095c97":()=>t.e(52).then(t.bind(null,411)),"v-1c2c99c8":()=>t.e(53).then(t.bind(null,412)),"v-990ee8ec":()=>t.e(54).then(t.bind(null,413)),"v-576d295a":()=>t.e(51).then(t.bind(null,414)),"v-1fb534ce":()=>t.e(56).then(t.bind(null,415)),"v-6d754144":()=>t.e(57).then(t.bind(null,416)),"v-0bc483d1":()=>t.e(55).then(t.bind(null,417)),"v-26212a8a":()=>t.e(58).then(t.bind(null,418)),"v-0d0a72db":()=>t.e(59).then(t.bind(null,419)),"v-458cddd9":()=>t.e(60).then(t.bind(null,420)),"v-79afdc49":()=>t.e(61).then(t.bind(null,421)),"v-2831c459":()=>t.e(62).then(t.bind(null,422)),"v-053d84f2":()=>t.e(63).then(t.bind(null,423)),"v-b2628b0c":()=>t.e(64).then(t.bind(null,424)),"v-ba15898e":()=>t.e(66).then(t.bind(null,425)),"v-797fe2d2":()=>t.e(65).then(t.bind(null,426)),"v-0210a959":()=>t.e(67).then(t.bind(null,427)),"v-2d5f5839":()=>t.e(68).then(t.bind(null,428)),"v-417db3ae":()=>t.e(70).then(t.bind(null,429)),"v-43d92dd9":()=>t.e(69).then(t.bind(null,430)),"v-28e9210c":()=>t.e(71).then(t.bind(null,431)),"v-5dded6fa":()=>t.e(72).then(t.bind(null,432)),"v-90469700":()=>t.e(73).then(t.bind(null,433)),"v-6079c7fa":()=>t.e(74).then(t.bind(null,434)),"v-4bb79bd0":()=>t.e(76).then(t.bind(null,435)),"v-e2d344f2":()=>t.e(77).then(t.bind(null,436)),"v-5e22edfe":()=>t.e(78).then(t.bind(null,437)),"v-b785b0fe":()=>t.e(75).then(t.bind(null,438)),"v-e9d086fe":()=>t.e(80).then(t.bind(null,439)),"v-fa5b3454":()=>t.e(81).then(t.bind(null,440)),"v-049ddce1":()=>t.e(79).then(t.bind(null,441)),"v-38a9c856":()=>t.e(82).then(t.bind(null,442)),"v-6989e0ac":()=>t.e(83).then(t.bind(null,443)),"v-e50b8c2e":()=>t.e(85).then(t.bind(null,444)),"v-2a221380":()=>t.e(84).then(t.bind(null,445)),"v-7e2b9df0":()=>t.e(87).then(t.bind(null,446)),"v-4fa6c7e5":()=>t.e(88).then(t.bind(null,447)),"v-0734792a":()=>t.e(89).then(t.bind(null,448)),"v-5909a860":()=>t.e(90).then(t.bind(null,449)),"v-bcb1749a":()=>t.e(86).then(t.bind(null,450)),"v-101289a5":()=>t.e(91).then(t.bind(null,451)),"v-38a63570":()=>t.e(93).then(t.bind(null,452)),"v-5a6a2f10":()=>t.e(92).then(t.bind(null,453)),"v-2a0bf03b":()=>t.e(94).then(t.bind(null,454)),"v-0deb7e9f":()=>t.e(95).then(t.bind(null,455)),"v-615e5fce":()=>t.e(96).then(t.bind(null,456)),"v-4c80214c":()=>t.e(97).then(t.bind(null,457)),"v-2fc63d9e":()=>t.e(99).then(t.bind(null,458)),"v-cfeb30e6":()=>t.e(98).then(t.bind(null,459)),"v-7a1e2428":()=>t.e(100).then(t.bind(null,460)),"v-6971b032":()=>t.e(101).then(t.bind(null,461)),"v-597ac620":()=>t.e(102).then(t.bind(null,462)),"v-7f6d5ac0":()=>t.e(103).then(t.bind(null,463)),"v-56b0312c":()=>t.e(104).then(t.bind(null,464)),"v-78e814f8":()=>t.e(105).then(t.bind(null,465)),"v-b013a97e":()=>t.e(106).then(t.bind(null,466)),"v-23662401":()=>t.e(107).then(t.bind(null,467)),"v-d48a660e":()=>t.e(108).then(t.bind(null,468)),"v-792e46c1":()=>t.e(110).then(t.bind(null,469)),"v-7a59e988":()=>t.e(112).then(t.bind(null,470)),"v-37e966eb":()=>t.e(109).then(t.bind(null,471)),"v-66cd1cb0":()=>t.e(113).then(t.bind(null,472)),"v-ece34b10":()=>t.e(114).then(t.bind(null,473)),"v-740e8b5b":()=>t.e(111).then(t.bind(null,474)),"v-30cb5d4c":()=>t.e(116).then(t.bind(null,475)),"v-6a747794":()=>t.e(115).then(t.bind(null,476)),"v-4fac6ad4":()=>t.e(117).then(t.bind(null,477)),"v-220a90d1":()=>t.e(118).then(t.bind(null,478)),"v-fb43fc32":()=>t.e(119).then(t.bind(null,479)),"v-1be5385e":()=>t.e(120).then(t.bind(null,480)),"v-ea04530c":()=>t.e(122).then(t.bind(null,481)),"v-32fb0c7e":()=>t.e(123).then(t.bind(null,482)),"v-1bb853fa":()=>t.e(124).then(t.bind(null,483)),"v-4eea68e0":()=>t.e(121).then(t.bind(null,484)),"v-aa511c30":()=>t.e(125).then(t.bind(null,485)),"v-ec96f538":()=>t.e(126).then(t.bind(null,486)),"v-c629ccf6":()=>t.e(127).then(t.bind(null,487)),"v-2c3587d8":()=>t.e(128).then(t.bind(null,488)),"v-44326a4c":()=>t.e(129).then(t.bind(null,489)),"v-4e08f385":()=>t.e(130).then(t.bind(null,490)),"v-7eff31ac":()=>t.e(131).then(t.bind(null,491)),"v-b7c7369a":()=>t.e(132).then(t.bind(null,492)),"v-636ce848":()=>t.e(133).then(t.bind(null,493)),"v-36da3e34":()=>t.e(135).then(t.bind(null,494)),"v-6461f3c1":()=>t.e(137).then(t.bind(null,495)),"v-87e4ba86":()=>t.e(136).then(t.bind(null,496)),"v-76ebdf26":()=>t.e(138).then(t.bind(null,497)),"v-586d11fa":()=>t.e(134).then(t.bind(null,498)),"v-2fed92e6":()=>t.e(139).then(t.bind(null,499)),"v-c7c7b8ea":()=>t.e(140).then(t.bind(null,500)),"v-635d5f8d":()=>t.e(143).then(t.bind(null,501)),"v-36ee805b":()=>t.e(141).then(t.bind(null,502)),"v-2967a998":()=>t.e(142).then(t.bind(null,503)),"v-360040da":()=>t.e(144).then(t.bind(null,504)),"v-21390089":()=>t.e(145).then(t.bind(null,505)),"v-5233b41b":()=>t.e(146).then(t.bind(null,506)),"v-e25da80e":()=>t.e(148).then(t.bind(null,507)),"v-6f12cff7":()=>t.e(147).then(t.bind(null,508)),"v-8e9c4c14":()=>t.e(149).then(t.bind(null,509)),"v-54f3eee1":()=>t.e(150).then(t.bind(null,510)),"v-0436aabe":()=>t.e(151).then(t.bind(null,511)),"v-5944f74c":()=>t.e(153).then(t.bind(null,512)),"v-7a41b909":()=>t.e(154).then(t.bind(null,513)),"v-23d64f0e":()=>t.e(155).then(t.bind(null,514)),"v-bbc08472":()=>t.e(152).then(t.bind(null,515)),"v-536574fe":()=>t.e(158).then(t.bind(null,516)),"v-fc806cac":()=>t.e(156).then(t.bind(null,517)),"v-3a8672e0":()=>t.e(157).then(t.bind(null,518)),"v-bf924ecc":()=>t.e(159).then(t.bind(null,519))};function $s(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ws=/-(\w)/g,Ks=$s(n=>n.replace(Ws,(n,e)=>e?e.toUpperCase():"")),Ys=/\B([A-Z])/g,Xs=$s(n=>n.replace(Ys,"-$1").toLowerCase()),Zs=$s(n=>n.charAt(0).toUpperCase()+n.slice(1));function no(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Zs(Ks(e))):n(Zs(e))||n(Xs(e))}const eo=Object.assign({},Vs,Gs),to=n=>eo[n],ao=n=>Gs[n],io=n=>Vs[n],ro=n=>Gt.component(n);function so(n){return no(ao,n)}function oo(n){return no(io,n)}function lo(n){return no(to,n)}function co(n){return no(ro,n)}function uo(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!co(n)&&lo(n)){const e=await lo(n)();Gt.component(n,e.default)}}))}function po(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var mo=t(121),ho=t.n(mo),go=t(122),bo=t.n(go),fo={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${bo()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vo(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ko(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ho()([{name:"description",content:this.$description}],n,this.siteMeta,xo)},updateCanonicalLink(){yo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ko(null,this.currentMetaTags),yo()}};function yo(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vo(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ko(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xo(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(65);var wo=t(66),_o={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(wo)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const r=e[n],s=e[n+1],o=0===n&&0===t||t>=r.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(o&&l!==decodeURIComponent(r.hash)){const t=r;if(i===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},So=t(45),jo=t.n(So),Eo={mounted(){jo.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||jo.a.start(),t()}),this.$router.afterEach(()=>{jo.a.done(),this.isSidebarOpen=!1})}};t(272),t(273);class To{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Co={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new To).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&a.firstChild?a.insertBefore(i,a.firstChild):a.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var qo={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Io={},Ao=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Mo=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:qo[n]},zo=function n(e,t,a){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,r=e.children;i.appendChild(n(t,a,r))})),i},Lo=function(n,e,t){var a,i=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==i.length||t?i:i[0]},Do=function(n,e){var t,a,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<template>([\s\S]+)<\/template>/),s=n.match(/<script>([\s\S]+)<\/script>/),o={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};o.htmlTpl=Ao(o.html),o.jsTpl=(t=o.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),o.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,r=[eval][0](i);return r.template=e,r}(o.js,o.html);var l=Mo("vue");return o.jsLib.unshift(l),o},Ro=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),r=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:r&&r[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return s.htmlTpl=s.html,s.jsTpl=s.js,s.script=(t=s.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),s},Bo=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Oo(){var n=Lo(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Lo(n,"vuepress-plugin-demo-block__code"),t=Lo(n,"vuepress-plugin-demo-block__display"),a=Lo(n,"vuepress-plugin-demo-block__footer"),i=Lo(t,"vuepress-plugin-demo-block__app"),r=decodeURIComponent(n.dataset.code),s=decodeURIComponent(n.dataset.config),o=decodeURIComponent(n.dataset.type);s=s?JSON.parse(s):{};var l=e.querySelector("div").clientHeight,c="react"===o?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(a))(),r={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Bo(n),htmlTpl:Ao("")},s=Mo("react"),o=Mo("reactDOM");return r.jsLib.unshift(s,o),r}(r,s):"vanilla"===o?Ro(r,s):Do(r,s),d=zo("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Po.bind(null,d,l,e,a)),Mo("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,i=n.jsLib,r=n.cssLib,s=i.concat(r).concat(Mo("cssLib")).concat(Mo("jsLib")).join(",");return zo("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:s}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Mo("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,i=n.jsLib,r=n.cssLib,s=JSON.stringify({css:e,html:t,js:a,js_external:i.concat(Mo("jsLib")).join(";"),css_external:r.concat(Mo("cssLib")).join(";"),layout:Mo("codepenLayout"),js_pre_processor:Mo("codepenJsProcessor"),editors:Mo("codepenEditors")});return zo("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:s}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==s.horizontal?s.horizontal:Mo("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Io[n]){var e=zo("style",{innerHTML:n});document.body.appendChild(e),Io[n]=!0}}(c.css),"react"===o)ReactDOM.render(React.createElement(c.js),i);else if("vue"===o){var p=(new(Vue.extend(c.script))).$mount();i.appendChild(p.$el)}else"vanilla"===o&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Oo()}),300)}function Po(n,e,t,a){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var No={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Oo()},updated:function(){Oo()}},Uo="auto",Jo="zoom-in",Qo="zoom-out",Ho="grab",Fo="move";function Vo(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};a?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Go(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function $o(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Wo(n,e,t){!function(n){var e=Ko,t=Yo;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var a=n.style,i={};for(var r in e)t&&(i[r]=a[r]||""),a[r]=e[r];return i}var Ko="transition",Yo="transform",Xo="transform",Zo="transitionend";var nl=function(){},el={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:nl,onClose:nl,onGrab:nl,onMove:nl,onRelease:nl,onBeforeOpen:nl,onBeforeClose:nl,onBeforeGrab:nl,onBeforeRelease:nl,onImageLoading:nl,onImageLoaded:nl},tl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),il(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,r=this.options.scrollThreshold;(Math.abs(i)>=r||Math.abs(a)>=r)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(al(n)&&!il(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){al(n)&&!il(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function al(n){return 0===n.button}function il(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Wo(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Vo(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Wo(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},sl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ol=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),ll=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},cl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=$o(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ho:Qo,transition:Xo+"\n        "+a+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Wo(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Wo(this.el,{transform:"none"})},grab:function(n,e,t){var a=dl(),i=a.x-n,r=a.y-e;Wo(this.el,{cursor:Fo,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=dl(),i=a.x-n,r=a.y-e;Wo(this.el,{transition:Xo,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Wo(this.el,this.styleClose)},restoreOpenStyle:function(){Wo(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=dl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,i=a.customSize,r=a.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":sl(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var s=this.rect.width/2,o=this.rect.height/2,l=dl(),c={x:l.x-s,y:l.y-o},d=c.x/s,u=c.y/o,p=r+Math.min(d,u);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(i)*m/(100*this.rect.width),b=parseFloat(i)*h/(100*this.rect.height);if(p>g||p>b)return{x:g,y:b}}return{x:p,y:p}}};function dl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function ul(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Vo(n,a,e[a],t)}))}var pl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(cl),this.overlay=Object.create(rl),this.handler=Object.create(tl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ll({},el,e),this.overlay.init(this),this.handler.init(this)}return ol(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Jo,Vo(n,"click",this.handler.click),this.options.preloadImage&&Go($o(n)));return this}},{key:"config",value:function(n){return n?(ll(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(a),Go(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Vo(document,"scroll",this.handler.scroll),Vo(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Vo(window,"resize",this.handler.resizeWindow);var r=function n(){Vo(a,Zo,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&ul(document,e.handler,!0),t(a)};return Vo(a,Zo,r),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Uo,this.overlay.fadeOut(),this.target.zoomOut(),Vo(document,"scroll",this.handler.scroll,!1),Vo(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Vo(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Vo(t,Zo,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&ul(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Vo(t,Zo,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var r=function n(){Vo(i,Zo,n,!1),a(i)};return Vo(i,Zo,r),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Fo,this.target.move(n,e,t);var i=this.target.el,r=function n(){Vo(i,Zo,n,!1),a(i)};return Vo(i,Zo,r),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Uo,this.target.restoreOpenStyle();var a=function a(){Vo(t,Zo,a,!1),n.lock=!1,n.released=!0,e(t)};return Vo(t,Zo,a),this}}}]),n}();const ml=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),hl=Number("500");class gl{constructor(){this.instance=new pl(ml)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=hl){setTimeout(()=>this.update(n),e)}}var bl=[fo,_o,Eo,Co,No,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new gl,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return po("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},yl=t(15),vl=Object(yl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(vl,"mixins",bl);const kl=[{name:"v-551fbd5b",path:"/spider/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-551fbd5b").then(t)}},{path:"/spider/index.html",redirect:"/spider/"},{path:"/00.目录页/20.爬虫.html",redirect:"/spider/"},{name:"v-e7e40508",path:"/java/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-e7e40508").then(t)}},{path:"/java/index.html",redirect:"/java/"},{path:"/00.目录页/01.java.html",redirect:"/java/"},{name:"v-48424b17",path:"/java/se/initial-java/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-48424b17").then(t)}},{path:"/java/se/initial-java/index.html",redirect:"/java/se/initial-java/"},{path:"/01.Java/02.java-基础/01.初识java.html",redirect:"/java/se/initial-java/"},{name:"v-a8a3be30",path:"/ai/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-a8a3be30").then(t)}},{path:"/ai/index.html",redirect:"/ai/"},{path:"/00.目录页/30.AI.html",redirect:"/ai/"},{name:"v-61ff5e21",path:"/java/se/basic-grammar/annotation/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-61ff5e21").then(t)}},{path:"/java/se/basic-grammar/annotation/index.html",redirect:"/java/se/basic-grammar/annotation/"},{path:"/01.Java/02.java-基础/02.基础语法/01.注释.html",redirect:"/java/se/basic-grammar/annotation/"},{name:"v-17fd5c60",path:"/java/se/basic-grammar/identifier/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-17fd5c60").then(t)}},{path:"/java/se/basic-grammar/identifier/index.html",redirect:"/java/se/basic-grammar/identifier/"},{path:"/01.Java/02.java-基础/02.基础语法/02.标识符.html",redirect:"/java/se/basic-grammar/identifier/"},{name:"v-4a7ed15c",path:"/java/se/basic-grammar/type-conversion/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4a7ed15c").then(t)}},{path:"/java/se/basic-grammar/type-conversion/index.html",redirect:"/java/se/basic-grammar/type-conversion/"},{path:"/01.Java/02.java-基础/02.基础语法/04.类型转换.html",redirect:"/java/se/basic-grammar/type-conversion/"},{name:"v-560c45dc",path:"/java/se/basic-grammar/variate-constant/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-560c45dc").then(t)}},{path:"/java/se/basic-grammar/variate-constant/index.html",redirect:"/java/se/basic-grammar/variate-constant/"},{path:"/01.Java/02.java-基础/02.基础语法/05.变量和常量.html",redirect:"/java/se/basic-grammar/variate-constant/"},{name:"v-9c3ab8f0",path:"/about/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-9c3ab8f0").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/00.目录页/10.关于.html",redirect:"/about/"},{name:"v-1156e8e2",path:"/java/se/basic-grammar/data-type/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-1156e8e2").then(t)}},{path:"/java/se/basic-grammar/data-type/index.html",redirect:"/java/se/basic-grammar/data-type/"},{path:"/01.Java/02.java-基础/02.基础语法/03.数据类型.html",redirect:"/java/se/basic-grammar/data-type/"},{name:"v-4f888be4",path:"/java/se/basic-grammar/packet/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4f888be4").then(t)}},{path:"/java/se/basic-grammar/packet/index.html",redirect:"/java/se/basic-grammar/packet/"},{path:"/01.Java/02.java-基础/02.基础语法/07.包机制.html",redirect:"/java/se/basic-grammar/packet/"},{name:"v-33e78c7a",path:"/java/se/basic-grammar/operator/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-33e78c7a").then(t)}},{path:"/java/se/basic-grammar/operator/index.html",redirect:"/java/se/basic-grammar/operator/"},{path:"/01.Java/02.java-基础/02.基础语法/06.运算符.html",redirect:"/java/se/basic-grammar/operator/"},{name:"v-76db6908",path:"/java/se/basic-grammar/javadoc/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-76db6908").then(t)}},{path:"/java/se/basic-grammar/javadoc/index.html",redirect:"/java/se/basic-grammar/javadoc/"},{path:"/01.Java/02.java-基础/02.基础语法/08.JavaDoc.html",redirect:"/java/se/basic-grammar/javadoc/"},{name:"v-08095c97",path:"/java/se/process-control/sequential-structure/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-08095c97").then(t)}},{path:"/java/se/process-control/sequential-structure/index.html",redirect:"/java/se/process-control/sequential-structure/"},{path:"/01.Java/02.java-基础/03.流程控制/02.顺序结构.html",redirect:"/java/se/process-control/sequential-structure/"},{name:"v-1c2c99c8",path:"/java/se/process-control/case-structure/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-1c2c99c8").then(t)}},{path:"/java/se/process-control/case-structure/index.html",redirect:"/java/se/process-control/case-structure/"},{path:"/01.Java/02.java-基础/03.流程控制/03.选择结构.html",redirect:"/java/se/process-control/case-structure/"},{name:"v-990ee8ec",path:"/java/se/process-control/loop-structure/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-990ee8ec").then(t)}},{path:"/java/se/process-control/loop-structure/index.html",redirect:"/java/se/process-control/loop-structure/"},{path:"/01.Java/02.java-基础/03.流程控制/04.循环结构.html",redirect:"/java/se/process-control/loop-structure/"},{name:"v-576d295a",path:"/java/se/process-control/scanner/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-576d295a").then(t)}},{path:"/java/se/process-control/scanner/index.html",redirect:"/java/se/process-control/scanner/"},{path:"/01.Java/02.java-基础/03.流程控制/01.用户交互Scanner.html",redirect:"/java/se/process-control/scanner/"},{name:"v-1fb534ce",path:"/java/se/method/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-1fb534ce").then(t)}},{path:"/java/se/method/index.html",redirect:"/java/se/method/"},{path:"/01.Java/02.java-基础/04.方法.html",redirect:"/java/se/method/"},{name:"v-6d754144",path:"/java/se/array/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6d754144").then(t)}},{path:"/java/se/array/index.html",redirect:"/java/se/array/"},{path:"/01.Java/02.java-基础/05.数组.html",redirect:"/java/se/array/"},{name:"v-0bc483d1",path:"/java/se/process-control/break-continue/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-0bc483d1").then(t)}},{path:"/java/se/process-control/break-continue/index.html",redirect:"/java/se/process-control/break-continue/"},{path:"/01.Java/02.java-基础/03.流程控制/05.break和continue.html",redirect:"/java/se/process-control/break-continue/"},{name:"v-26212a8a",path:"/java/se/exception/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-26212a8a").then(t)}},{path:"/java/se/exception/index.html",redirect:"/java/se/exception/"},{path:"/01.Java/02.java-基础/07.异常机制.html",redirect:"/java/se/exception/"},{name:"v-0d0a72db",path:"/java/se/object/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-0d0a72db").then(t)}},{path:"/java/se/object/index.html",redirect:"/java/se/object/"},{path:"/01.Java/03.java-面向对象/06.面向对象.html",redirect:"/java/se/object/"},{name:"v-458cddd9",path:"/java/se/commonly-used-class/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-458cddd9").then(t)}},{path:"/java/se/commonly-used-class/index.html",redirect:"/java/se/commonly-used-class/"},{path:"/01.Java/04.Java-常用类/08.常用类.html",redirect:"/java/se/commonly-used-class/"},{name:"v-79afdc49",path:"/java/se/collection/synopsis/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-79afdc49").then(t)}},{path:"/java/se/collection/synopsis/index.html",redirect:"/java/se/collection/synopsis/"},{path:"/01.Java/05.Java-集合框架/01.集合概序.html",redirect:"/java/se/collection/synopsis/"},{name:"v-2831c459",path:"/java/se/collection/ArrayList/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2831c459").then(t)}},{path:"/java/se/collection/ArrayList/index.html",redirect:"/java/se/collection/ArrayList/"},{path:"/01.Java/05.Java-集合框架/02.ArrayList.html",redirect:"/java/se/collection/ArrayList/"},{name:"v-053d84f2",path:"/java/se/collection/LinkedList/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-053d84f2").then(t)}},{path:"/java/se/collection/LinkedList/index.html",redirect:"/java/se/collection/LinkedList/"},{path:"/01.Java/05.Java-集合框架/03.LinkedList.html",redirect:"/java/se/collection/LinkedList/"},{name:"v-b2628b0c",path:"/java/se/collection/Vevtor-Stack/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-b2628b0c").then(t)}},{path:"/java/se/collection/Vevtor-Stack/index.html",redirect:"/java/se/collection/Vevtor-Stack/"},{path:"/01.Java/05.Java-集合框架/04.Vevtor和Stack.html",redirect:"/java/se/collection/Vevtor-Stack/"},{name:"v-ba15898e",path:"/java/se/collection/HashMap/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-ba15898e").then(t)}},{path:"/java/se/collection/HashMap/index.html",redirect:"/java/se/collection/HashMap/"},{path:"/01.Java/05.Java-集合框架/06.HashMap.html",redirect:"/java/se/collection/HashMap/"},{name:"v-797fe2d2",path:"/java/se/collection/List-summary/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-797fe2d2").then(t)}},{path:"/java/se/collection/List-summary/index.html",redirect:"/java/se/collection/List-summary/"},{path:"/01.Java/05.Java-集合框架/05.List总结.html",redirect:"/java/se/collection/List-summary/"},{name:"v-0210a959",path:"/java/se/collection/set/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-0210a959").then(t)}},{path:"/java/se/collection/set/index.html",redirect:"/java/se/collection/set/"},{path:"/01.Java/05.Java-集合框架/07.Set.html",redirect:"/java/se/collection/set/"},{name:"v-2d5f5839",path:"/java/se/collection/HashSet/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2d5f5839").then(t)}},{path:"/java/se/collection/HashSet/index.html",redirect:"/java/se/collection/HashSet/"},{path:"/01.Java/05.Java-集合框架/08.HashSet.html",redirect:"/java/se/collection/HashSet/"},{name:"v-417db3ae",path:"/java/se/collection/iterator/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-417db3ae").then(t)}},{path:"/java/se/collection/iterator/index.html",redirect:"/java/se/collection/iterator/"},{path:"/01.Java/05.Java-集合框架/10.迭代器.html",redirect:"/java/se/collection/iterator/"},{name:"v-43d92dd9",path:"/java/se/collection/TreeSet/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-43d92dd9").then(t)}},{path:"/java/se/collection/TreeSet/index.html",redirect:"/java/se/collection/TreeSet/"},{path:"/01.Java/05.Java-集合框架/09.TreeSet.html",redirect:"/java/se/collection/TreeSet/"},{name:"v-28e9210c",path:"/java/se/collection/generic-paradigm/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-28e9210c").then(t)}},{path:"/java/se/collection/generic-paradigm/index.html",redirect:"/java/se/collection/generic-paradigm/"},{path:"/01.Java/05.Java-集合框架/11.泛型.html",redirect:"/java/se/collection/generic-paradigm/"},{name:"v-5dded6fa",path:"/java/se/collection/collections/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-5dded6fa").then(t)}},{path:"/java/se/collection/collections/index.html",redirect:"/java/se/collection/collections/"},{path:"/01.Java/05.Java-集合框架/12.Collections工具类.html",redirect:"/java/se/collection/collections/"},{name:"v-90469700",path:"/java/se/thread/1/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-90469700").then(t)}},{path:"/java/se/thread/1/index.html",redirect:"/java/se/thread/1/"},{path:"/01.Java/07.Java-多线程/02.JUC学习笔记.html",redirect:"/java/se/thread/1/"},{name:"v-6079c7fa",path:"/java/se/thread/2/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6079c7fa").then(t)}},{path:"/java/se/thread/2/index.html",redirect:"/java/se/thread/2/"},{path:"/01.Java/07.Java-多线程/05.JUC学习笔记.html",redirect:"/java/se/thread/2/"},{name:"v-4bb79bd0",path:"/pages/5916e7/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4bb79bd0").then(t)}},{path:"/pages/5916e7/index.html",redirect:"/pages/5916e7/"},{path:"/01.Java/20.JavaWeb/01.基本概念.html",redirect:"/pages/5916e7/"},{name:"v-e2d344f2",path:"/pages/1ccdff/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-e2d344f2").then(t)}},{path:"/pages/1ccdff/index.html",redirect:"/pages/1ccdff/"},{path:"/01.Java/20.JavaWeb/02.Tomcat.html",redirect:"/pages/1ccdff/"},{name:"v-5e22edfe",path:"/pages/7187be/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-5e22edfe").then(t)}},{path:"/pages/7187be/index.html",redirect:"/pages/7187be/"},{path:"/01.Java/20.JavaWeb/03.Http.html",redirect:"/pages/7187be/"},{name:"v-b785b0fe",path:"/javaweb/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-b785b0fe").then(t)}},{path:"/javaweb/index.html",redirect:"/javaweb/"},{path:"/01.Java/20.JavaWeb/00.javaweb.html",redirect:"/javaweb/"},{name:"v-e9d086fe",path:"/pages/e986b8/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-e9d086fe").then(t)}},{path:"/pages/e986b8/index.html",redirect:"/pages/e986b8/"},{path:"/01.Java/20.JavaWeb/05.servlet.html",redirect:"/pages/e986b8/"},{name:"v-fa5b3454",path:"/pages/d20044/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-fa5b3454").then(t)}},{path:"/pages/d20044/index.html",redirect:"/pages/d20044/"},{path:"/01.Java/20.JavaWeb/06.cookie和session.html",redirect:"/pages/d20044/"},{name:"v-049ddce1",path:"/pages/cb259f/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-049ddce1").then(t)}},{path:"/pages/cb259f/index.html",redirect:"/pages/cb259f/"},{path:"/01.Java/20.JavaWeb/04.Maven.html",redirect:"/pages/cb259f/"},{name:"v-38a9c856",path:"/pages/e8021e/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-38a9c856").then(t)}},{path:"/pages/e8021e/index.html",redirect:"/pages/e8021e/"},{path:"/01.Java/20.JavaWeb/20.总览.html",redirect:"/pages/e8021e/"},{name:"v-6989e0ac",path:"/mysql/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6989e0ac").then(t)}},{path:"/mysql/index.html",redirect:"/mysql/"},{path:"/03.数据库/05.MySQL/02.MySQL.html",redirect:"/mysql/"},{name:"v-e50b8c2e",path:"/mysql/index/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-e50b8c2e").then(t)}},{path:"/mysql/index/index.html",redirect:"/mysql/index/"},{path:"/03.数据库/05.MySQL/06.MySQL - 索引.html",redirect:"/mysql/index/"},{name:"v-2a221380",path:"/mysql/logic/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2a221380").then(t)}},{path:"/mysql/logic/index.html",redirect:"/mysql/logic/"},{path:"/03.数据库/05.MySQL/04.MySQL - 逻辑架构.html",redirect:"/mysql/logic/"},{name:"v-7e2b9df0",path:"/mysql/index-use/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-7e2b9df0").then(t)}},{path:"/mysql/index-use/index.html",redirect:"/mysql/index-use/"},{path:"/03.数据库/05.MySQL/12.MySQL - 索引的使用.html",redirect:"/mysql/index-use/"},{name:"v-4fa6c7e5",path:"/mysql/sql-optimize/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4fa6c7e5").then(t)}},{path:"/mysql/sql-optimize/index.html",redirect:"/mysql/sql-optimize/"},{path:"/03.数据库/05.MySQL/14.MySQL - SQL优化.html",redirect:"/mysql/sql-optimize/"},{name:"v-0734792a",path:"/mysql/cache-query/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-0734792a").then(t)}},{path:"/mysql/cache-query/index.html",redirect:"/mysql/cache-query/"},{path:"/03.数据库/05.MySQL/16.MySQL - 缓存查询.html",redirect:"/mysql/cache-query/"},{name:"v-5909a860",path:"/mysql/memory-management/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-5909a860").then(t)}},{path:"/mysql/memory-management/index.html",redirect:"/mysql/memory-management/"},{path:"/03.数据库/05.MySQL/18.MySQL - 内存管理.html",redirect:"/mysql/memory-management/"},{name:"v-bcb1749a",path:"/mysql/optimize-sql-check/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-bcb1749a").then(t)}},{path:"/mysql/optimize-sql-check/index.html",redirect:"/mysql/optimize-sql-check/"},{path:"/03.数据库/05.MySQL/10.MySQL - 优化SQL检测步骤.html",redirect:"/mysql/optimize-sql-check/"},{name:"v-101289a5",path:"/mysql/concurrent-parameter/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-101289a5").then(t)}},{path:"/mysql/concurrent-parameter/index.html",redirect:"/mysql/concurrent-parameter/"},{path:"/03.数据库/05.MySQL/20.MySQL - 并发参数.html",redirect:"/mysql/concurrent-parameter/"},{name:"v-38a63570",path:"/mysql/common-use-sql-skill/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-38a63570").then(t)}},{path:"/mysql/common-use-sql-skill/index.html",redirect:"/mysql/common-use-sql-skill/"},{path:"/03.数据库/05.MySQL/24.MySQL - 常用sql技巧.html",redirect:"/mysql/common-use-sql-skill/"},{name:"v-5a6a2f10",path:"/mysql/lock-question/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-5a6a2f10").then(t)}},{path:"/mysql/lock-question/index.html",redirect:"/mysql/lock-question/"},{path:"/03.数据库/05.MySQL/22.MySQL - 锁问题.html",redirect:"/mysql/lock-question/"},{name:"v-2a0bf03b",path:"/mysql/common-tools/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2a0bf03b").then(t)}},{path:"/mysql/common-tools/index.html",redirect:"/mysql/common-tools/"},{path:"/03.数据库/05.MySQL/26.MySQL - 常用工具.html",redirect:"/mysql/common-tools/"},{name:"v-0deb7e9f",path:"/mysql/log/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-0deb7e9f").then(t)}},{path:"/mysql/log/index.html",redirect:"/mysql/log/"},{path:"/03.数据库/05.MySQL/28.MySQL - 日志.html",redirect:"/mysql/log/"},{name:"v-615e5fce",path:"/mysql/copy/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-615e5fce").then(t)}},{path:"/mysql/copy/index.html",redirect:"/mysql/copy/"},{path:"/03.数据库/05.MySQL/30.MySQL - 主从复制.html",redirect:"/mysql/copy/"},{name:"v-4c80214c",path:"/redis/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4c80214c").then(t)}},{path:"/redis/index.html",redirect:"/redis/"},{path:"/03.数据库/10.Redis/00.Redis知识体系.html",redirect:"/redis/"},{name:"v-2fc63d9e",path:"/pages/6ea36e/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2fc63d9e").then(t)}},{path:"/pages/6ea36e/index.html",redirect:"/pages/6ea36e/"},{path:"/03.数据库/10.Redis/02.五大数据类型.html",redirect:"/pages/6ea36e/"},{name:"v-cfeb30e6",path:"/pages/28aa50/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-cfeb30e6").then(t)}},{path:"/pages/28aa50/index.html",redirect:"/pages/28aa50/"},{path:"/03.数据库/10.Redis/01.Redis - 入门.html",redirect:"/pages/28aa50/"},{name:"v-7a1e2428",path:"/pages/5898ab/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-7a1e2428").then(t)}},{path:"/pages/5898ab/index.html",redirect:"/pages/5898ab/"},{path:"/03.数据库/10.Redis/03.三种特殊数据类型.html",redirect:"/pages/5898ab/"},{name:"v-6971b032",path:"/pages/41f31b/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6971b032").then(t)}},{path:"/pages/41f31b/index.html",redirect:"/pages/41f31b/"},{path:"/03.数据库/10.Redis/04.Redis事务.html",redirect:"/pages/41f31b/"},{name:"v-597ac620",path:"/pages/216cfe/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-597ac620").then(t)}},{path:"/pages/216cfe/index.html",redirect:"/pages/216cfe/"},{path:"/03.数据库/10.Redis/05.Redis - Java.html",redirect:"/pages/216cfe/"},{name:"v-7f6d5ac0",path:"/pages/feab74/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-7f6d5ac0").then(t)}},{path:"/pages/feab74/index.html",redirect:"/pages/feab74/"},{path:"/03.数据库/10.Redis/10.Redis学习笔记-总览.html",redirect:"/pages/feab74/"},{name:"v-56b0312c",path:"/es/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-56b0312c").then(t)}},{path:"/es/index.html",redirect:"/es/"},{path:"/03.数据库/15.ElasticSearch/01.ElasticSearch.html",redirect:"/es/"},{name:"v-78e814f8",path:"/es/introduce/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-78e814f8").then(t)}},{path:"/es/introduce/index.html",redirect:"/es/introduce/"},{path:"/03.数据库/15.ElasticSearch/02.ES - 基础概念.html",redirect:"/es/introduce/"},{name:"v-b013a97e",path:"/es/install/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-b013a97e").then(t)}},{path:"/es/install/index.html",redirect:"/es/install/"},{path:"/03.数据库/15.ElasticSearch/04.ES - 安装.html",redirect:"/es/install/"},{name:"v-23662401",path:"/es/index-doc/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-23662401").then(t)}},{path:"/es/index-doc/index.html",redirect:"/es/index-doc/"},{path:"/03.数据库/15.ElasticSearch/06.ES - 索引和文档的基本操作.html",redirect:"/es/index-doc/"},{name:"v-d48a660e",path:"/es/query/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-d48a660e").then(t)}},{path:"/es/query/index.html",redirect:"/es/query/"},{path:"/03.数据库/15.ElasticSearch/08.ES - 高级查询操作.html",redirect:"/es/query/"},{name:"v-792e46c1",path:"/pages/87178e/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-792e46c1").then(t)}},{path:"/pages/87178e/index.html",redirect:"/pages/87178e/"},{path:"/03.数据库/15.ElasticSearch/12.ES - 分词.html",redirect:"/pages/87178e/"},{name:"v-7a59e988",path:"/pages/34c4ae/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-7a59e988").then(t)}},{path:"/pages/34c4ae/index.html",redirect:"/pages/34c4ae/"},{path:"/03.数据库/20.MongoDB/05.Mongo - 基础概念.html",redirect:"/pages/34c4ae/"},{name:"v-37e966eb",path:"/pages/8b85ee/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-37e966eb").then(t)}},{path:"/pages/8b85ee/index.html",redirect:"/pages/8b85ee/"},{path:"/03.数据库/15.ElasticSearch/10.ES - 索引管理.html",redirect:"/pages/8b85ee/"},{name:"v-66cd1cb0",path:"/pages/f04bc7/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-66cd1cb0").then(t)}},{path:"/pages/f04bc7/index.html",redirect:"/pages/f04bc7/"},{path:"/03.数据库/20.MongoDB/10.Mongo - 安装和CRUD.html",redirect:"/pages/f04bc7/"},{name:"v-ece34b10",path:"/mybatis/study-note/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-ece34b10").then(t)}},{path:"/mybatis/study-note/index.html",redirect:"/mybatis/study-note/"},{path:"/04.框架/01.mybatis/01.学习笔记.html",redirect:"/mybatis/study-note/"},{name:"v-740e8b5b",path:"/mongodb/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-740e8b5b").then(t)}},{path:"/mongodb/index.html",redirect:"/mongodb/"},{path:"/03.数据库/20.MongoDB/00.Mongo - 目录页.html",redirect:"/mongodb/"},{name:"v-30cb5d4c",path:"/spring/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-30cb5d4c").then(t)}},{path:"/spring/index.html",redirect:"/spring/"},{path:"/04.框架/03.Spring/01.spring - 目录页.html",redirect:"/spring/"},{name:"v-6a747794",path:"/mybatis-plus/study-note/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6a747794").then(t)}},{path:"/mybatis-plus/study-note/index.html",redirect:"/mybatis-plus/study-note/"},{path:"/04.框架/02.mybatis-plus/01.学习笔记.html",redirect:"/mybatis-plus/study-note/"},{name:"v-4fac6ad4",path:"/rabbitmq/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4fac6ad4").then(t)}},{path:"/rabbitmq/index.html",redirect:"/rabbitmq/"},{path:"/04.框架/20.RabbitMQ/01.RabbitMQ知识体系 .html",redirect:"/rabbitmq/"},{name:"v-220a90d1",path:"/pages/e38dcb/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-220a90d1").then(t)}},{path:"/pages/e38dcb/index.html",redirect:"/pages/e38dcb/"},{path:"/04.框架/20.RabbitMQ/02.中间件介绍.html",redirect:"/pages/e38dcb/"},{name:"v-fb43fc32",path:"/pages/2c91a1/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-fb43fc32").then(t)}},{path:"/pages/2c91a1/index.html",redirect:"/pages/2c91a1/"},{path:"/04.框架/20.RabbitMQ/04.消息队列介绍.html",redirect:"/pages/2c91a1/"},{name:"v-1be5385e",path:"/pages/f015b1/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-1be5385e").then(t)}},{path:"/pages/f015b1/index.html",redirect:"/pages/f015b1/"},{path:"/04.框架/20.RabbitMQ/06.RabbitMQ - 安装.html",redirect:"/pages/f015b1/"},{name:"v-ea04530c",path:"/pages/ef9b33/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-ea04530c").then(t)}},{path:"/pages/ef9b33/index.html",redirect:"/pages/ef9b33/"},{path:"/04.框架/20.RabbitMQ/10.RabbitMQ - 发布确认.html",redirect:"/pages/ef9b33/"},{name:"v-32fb0c7e",path:"/pages/c9c254/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-32fb0c7e").then(t)}},{path:"/pages/c9c254/index.html",redirect:"/pages/c9c254/"},{path:"/04.框架/20.RabbitMQ/12.RabbitMQ - 交换机.html",redirect:"/pages/c9c254/"},{name:"v-1bb853fa",path:"/pages/1477b8/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-1bb853fa").then(t)}},{path:"/pages/1477b8/index.html",redirect:"/pages/1477b8/"},{path:"/04.框架/20.RabbitMQ/14.RabbitMQ - 死信队列.html",redirect:"/pages/1477b8/"},{name:"v-4eea68e0",path:"/pages/95ce73/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4eea68e0").then(t)}},{path:"/pages/95ce73/index.html",redirect:"/pages/95ce73/"},{path:"/04.框架/20.RabbitMQ/08.RabbitMQ - 简单案例.html",redirect:"/pages/95ce73/"},{name:"v-aa511c30",path:"/pages/0a0086/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-aa511c30").then(t)}},{path:"/pages/0a0086/index.html",redirect:"/pages/0a0086/"},{path:"/04.框架/20.RabbitMQ/16.RabbitMQ - 延迟队列.html",redirect:"/pages/0a0086/"},{name:"v-ec96f538",path:"/pages/c94906/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-ec96f538").then(t)}},{path:"/pages/c94906/index.html",redirect:"/pages/c94906/"},{path:"/04.框架/20.RabbitMQ/18.RabbitMQ - 发布确认高级.html",redirect:"/pages/c94906/"},{name:"v-c629ccf6",path:"/pages/ee71b9/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-c629ccf6").then(t)}},{path:"/pages/ee71b9/index.html",redirect:"/pages/ee71b9/"},{path:"/04.框架/20.RabbitMQ/20.RabbitMQ - 幂等性、优先级、惰性.html",redirect:"/pages/ee71b9/"},{name:"v-2c3587d8",path:"/git/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2c3587d8").then(t)}},{path:"/git/index.html",redirect:"/git/"},{path:"/05.工具部署/01.Git/00.Git.html",redirect:"/git/"},{name:"v-44326a4c",path:"/pages/7d2d32/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-44326a4c").then(t)}},{path:"/pages/7d2d32/index.html",redirect:"/pages/7d2d32/"},{path:"/05.工具部署/01.Git/01.Git简单提交.html",redirect:"/pages/7d2d32/"},{name:"v-4e08f385",path:"/pages/5747a6/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-4e08f385").then(t)}},{path:"/pages/5747a6/index.html",redirect:"/pages/5747a6/"},{path:"/05.工具部署/01.Git/02.SSH免密登录.html",redirect:"/pages/5747a6/"},{name:"v-7eff31ac",path:"/pages/fe0004/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-7eff31ac").then(t)}},{path:"/pages/fe0004/index.html",redirect:"/pages/fe0004/"},{path:"/05.工具部署/01.Git/04.Git - Commit常用表情.html",redirect:"/pages/fe0004/"},{name:"v-b7c7369a",path:"/pages/81663b/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-b7c7369a").then(t)}},{path:"/pages/81663b/index.html",redirect:"/pages/81663b/"},{path:"/05.工具部署/01.Git/05.Git删除提交记录.html",redirect:"/pages/81663b/"},{name:"v-636ce848",path:"/pages/0fc313/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-636ce848").then(t)}},{path:"/pages/0fc313/index.html",redirect:"/pages/0fc313/"},{path:"/05.工具部署/01.Git/06.DS_Store.html",redirect:"/pages/0fc313/"},{name:"v-36da3e34",path:"/docker/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-36da3e34").then(t)}},{path:"/docker/index.html",redirect:"/docker/"},{path:"/05.工具部署/10.Docker/01.Docker.html",redirect:"/docker/"},{name:"v-6461f3c1",path:"/pages/fc0548/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6461f3c1").then(t)}},{path:"/pages/fc0548/index.html",redirect:"/pages/fc0548/"},{path:"/05.工具部署/10.Docker/04.Docker - 安装.html",redirect:"/pages/fc0548/"},{name:"v-87e4ba86",path:"/pages/09f2eb/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-87e4ba86").then(t)}},{path:"/pages/09f2eb/index.html",redirect:"/pages/09f2eb/"},{path:"/05.工具部署/10.Docker/02.Docker - 概述.html",redirect:"/pages/09f2eb/"},{name:"v-76ebdf26",path:"/pages/a25911/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-76ebdf26").then(t)}},{path:"/pages/a25911/index.html",redirect:"/pages/a25911/"},{path:"/05.工具部署/10.Docker/06.Docker - 常用命令.html",redirect:"/pages/a25911/"},{name:"v-586d11fa",path:"/pages/90bb76/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-586d11fa").then(t)}},{path:"/pages/90bb76/index.html",redirect:"/pages/90bb76/"},{path:"/05.工具部署/01.Git/11.GitHub提速.html",redirect:"/pages/90bb76/"},{name:"v-2fed92e6",path:"/pages/4e8ad2/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2fed92e6").then(t)}},{path:"/pages/4e8ad2/index.html",redirect:"/pages/4e8ad2/"},{path:"/05.工具部署/10.Docker/08.Docker - 可视化.html",redirect:"/pages/4e8ad2/"},{name:"v-c7c7b8ea",path:"/pages/982fe2/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-c7c7b8ea").then(t)}},{path:"/pages/982fe2/index.html",redirect:"/pages/982fe2/"},{path:"/05.工具部署/10.Docker/10.Docker - 镜像和仓库.html",redirect:"/pages/982fe2/"},{name:"v-635d5f8d",path:"/pages/3b9d4b/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-635d5f8d").then(t)}},{path:"/pages/3b9d4b/index.html",redirect:"/pages/3b9d4b/"},{path:"/05.工具部署/10.Docker/16.Docker - 网络.html",redirect:"/pages/3b9d4b/"},{name:"v-36ee805b",path:"/pages/d7cc4c/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-36ee805b").then(t)}},{path:"/pages/d7cc4c/index.html",redirect:"/pages/d7cc4c/"},{path:"/05.工具部署/10.Docker/12.Docker - 数据卷.html",redirect:"/pages/d7cc4c/"},{name:"v-2967a998",path:"/pages/786a41/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-2967a998").then(t)}},{path:"/pages/786a41/index.html",redirect:"/pages/786a41/"},{path:"/05.工具部署/10.Docker/14.Docker - DockerFile.html",redirect:"/pages/786a41/"},{name:"v-360040da",path:"/pages/a38e01/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-360040da").then(t)}},{path:"/pages/a38e01/index.html",redirect:"/pages/a38e01/"},{path:"/05.工具部署/10.Docker/18.Docker - Compose.html",redirect:"/pages/a38e01/"},{name:"v-21390089",path:"/jenkins/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-21390089").then(t)}},{path:"/jenkins/index.html",redirect:"/jenkins/"},{path:"/05.工具部署/30.Jenkins/01.Jenkins - 目录页.html",redirect:"/jenkins/"},{name:"v-5233b41b",path:"/pages/3dedc8/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-5233b41b").then(t)}},{path:"/pages/3dedc8/index.html",redirect:"/pages/3dedc8/"},{path:"/05.工具部署/30.Jenkins/02.Jenkins - 介绍.html",redirect:"/pages/3dedc8/"},{name:"v-e25da80e",path:"/pages/038c37/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-e25da80e").then(t)}},{path:"/pages/038c37/index.html",redirect:"/pages/038c37/"},{path:"/10.关于/01.关于 - 我/01.关于 - 我.html",redirect:"/pages/038c37/"},{name:"v-6f12cff7",path:"/pages/ec9790/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-6f12cff7").then(t)}},{path:"/pages/ec9790/index.html",redirect:"/pages/ec9790/"},{path:"/05.工具部署/30.Jenkins/04.从零开始用Jenkins自动构建部署SpringBoot项目.html",redirect:"/pages/ec9790/"},{name:"v-8e9c4c14",path:"/pages/c6c456/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-8e9c4c14").then(t)}},{path:"/pages/c6c456/index.html",redirect:"/pages/c6c456/"},{path:"/10.关于/02.关于 - 本站/02.文档 -  快速上手.html",redirect:"/pages/c6c456/"},{name:"v-54f3eee1",path:"/pages/2a3030/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-54f3eee1").then(t)}},{path:"/pages/2a3030/index.html",redirect:"/pages/2a3030/"},{path:"/10.关于/02.关于 - 本站/03.文档 - md文件写作.html",redirect:"/pages/2a3030/"},{name:"v-0436aabe",path:"/pages/39f283/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-0436aabe").then(t)}},{path:"/pages/39f283/index.html",redirect:"/pages/39f283/"},{path:"/10.关于/02.关于 - 本站/05.文档 - 部署.html",redirect:"/pages/39f283/"},{name:"v-5944f74c",path:"/pages/8bac8d/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-5944f74c").then(t)}},{path:"/pages/8bac8d/index.html",redirect:"/pages/8bac8d/"},{path:"/10.关于/02.关于 - 本站/12.标题 - 锚点比较.html",redirect:"/pages/8bac8d/"},{name:"v-7a41b909",path:"/pages/007827/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-7a41b909").then(t)}},{path:"/pages/007827/index.html",redirect:"/pages/007827/"},{path:"/20.爬虫/02.某度翻译.html",redirect:"/pages/007827/"},{name:"v-23d64f0e",path:"/pages/7de988/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-23d64f0e").then(t)}},{path:"/pages/7de988/index.html",redirect:"/pages/7de988/"},{path:"/20.爬虫/04.文档密码破解.html",redirect:"/pages/7de988/"},{name:"v-bbc08472",path:"/pages/2bde62/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-bbc08472").then(t)}},{path:"/pages/2bde62/index.html",redirect:"/pages/2bde62/"},{path:"/10.关于/02.关于 - 本站/11.标题 - 目录生成.html",redirect:"/pages/2bde62/"},{name:"v-536574fe",path:"/archives/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-536574fe").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-fc806cac",path:"/pages/86599a/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-fc806cac").then(t)}},{path:"/pages/86599a/index.html",redirect:"/pages/86599a/"},{path:"/30.AI/01.AI 解读项目.html",redirect:"/pages/86599a/"},{name:"v-3a8672e0",path:"/pages/ec7818/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-3a8672e0").then(t)}},{path:"/pages/ec7818/index.html",redirect:"/pages/ec7818/"},{path:"/30.AI/05.Claude Code教程.html",redirect:"/pages/ec7818/"},{name:"v-bf924ecc",path:"/",component:vl,beforeEnter:(n,e,t)=>{uo("Layout","v-bf924ecc").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:vl}],xl={title:"OddFar's Notes",description:"我们在黑暗中并肩前行，走在各自的朝圣路上!",base:"/notes/",headTags:[["link",{rel:"icon",href:"/notes/img/favicon.ico"}],["meta",{name:"keywords",content:"oddfar,zhiyuan"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"爬虫",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"20.爬虫",imgUrl:"/img/web.png",description:"爬虫专栏，关于爬虫、逆向等"}},title:"爬虫",permalink:"/spider",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2022-07-08T18:26:57.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/20.%E7%88%AC%E8%99%AB.html",relativePath:"00.目录页/20.爬虫.md",key:"v-551fbd5b",path:"/spider/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757171752e3},{title:"java",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.Java",imgUrl:"/img/web.png",description:"java目录页，最下面有java学习路线"}},title:"java",date:"2021年4月14日14:39:06",permalink:"/java",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.java.html",relativePath:"00.目录页/01.java.md",key:"v-e7e40508",path:"/java/",headers:[{level:3,title:"为何不用博客",slug:"为何不用博客",normalizedTitle:"为何不用博客",charIndex:210}],headersStr:"为何不用博客",content:" * 尚硅谷的java学习路线：https://www.bilibili.com/read/cv5216534\n\n * 狂神的java视频地址：https://www.bilibili.com/read/cv5702420\n\n> 关于知识体系如何搭建：\n\nGitHub：https://github.com/oddfar/notes\n\nGitee： https://gitee.com/oddfar/notes\n\n\n# 为何不用博客\n\n本人博客：https://oddfar.com\n\n搭建博客需要服务器+域名，在阿里云购买学生机即可\n\n写博客个人推荐使用typecho，好看的主题有handsome（收费88）、joe（免费）\n\n最开始我是用的博客做笔记，虽然有很多功能，后来博客页面美化的越来越“花里胡哨”，不适合进行大文章的阅读，以及不能更快更好的查看知识，后来发现了vuepress，特别适合做文档或知识体系，于是就选择了它。",normalizedContent:" * 尚硅谷的java学习路线：https://www.bilibili.com/read/cv5216534\n\n * 狂神的java视频地址：https://www.bilibili.com/read/cv5702420\n\n> 关于知识体系如何搭建：\n\ngithub：https://github.com/oddfar/notes\n\ngitee： https://gitee.com/oddfar/notes\n\n\n# 为何不用博客\n\n本人博客：https://oddfar.com\n\n搭建博客需要服务器+域名，在阿里云购买学生机即可\n\n写博客个人推荐使用typecho，好看的主题有handsome（收费88）、joe（免费）\n\n最开始我是用的博客做笔记，虽然有很多功能，后来博客页面美化的越来越“花里胡哨”，不适合进行大文章的阅读，以及不能更快更好的查看知识，后来发现了vuepress，特别适合做文档或知识体系，于是就选择了它。",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"初识java",frontmatter:{title:"初识java",date:"2021-04-15T22:39:56.000Z",permalink:"/java/se/initial-java/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/01.%E5%88%9D%E8%AF%86java.html",relativePath:"01.Java/02.java-基础/01.初识java.md",key:"v-48424b17",path:"/java/se/initial-java/",headers:[{level:2,title:"Java : 一个帝国的诞生",slug:"java-一个帝国的诞生",normalizedTitle:"java : 一个帝国的诞生",charIndex:13},{level:3,title:"1、C语言帝国的统治",slug:"_1、c语言帝国的统治",normalizedTitle:"1、c语言帝国的统治",charIndex:32},{level:3,title:"2、反抗",slug:"_2、反抗",normalizedTitle:"2、反抗",charIndex:747},{level:3,title:"3、一鸣惊人",slug:"_3、一鸣惊人",normalizedTitle:"3、一鸣惊人",charIndex:1198},{level:3,title:"4、开拓疆土",slug:"_4、开拓疆土",normalizedTitle:"4、开拓疆土",charIndex:1785},{level:3,title:"5、帝国的诞生",slug:"_5、帝国的诞生",normalizedTitle:"5、帝国的诞生",charIndex:2668},{level:2,title:"Java的特性和优势",slug:"java的特性和优势",normalizedTitle:"java的特性和优势",charIndex:3824},{level:3,title:"八大特性",slug:"八大特性",normalizedTitle:"八大特性",charIndex:3839},{level:3,title:"核心优势",slug:"核心优势",normalizedTitle:"核心优势",charIndex:3864},{level:2,title:"Java三大版本",slug:"java三大版本",normalizedTitle:"java三大版本",charIndex:5185},{level:2,title:"JDK 和 JRE",slug:"jdk-和-jre",normalizedTitle:"jdk 和 jre",charIndex:5852},{level:2,title:"初识JVM",slug:"初识jvm",normalizedTitle:"初识jvm",charIndex:6300},{level:2,title:"JAVA程序运行机制",slug:"java程序运行机制",normalizedTitle:"java程序运行机制",charIndex:6931},{level:3,title:"编译型语言",slug:"编译型语言",normalizedTitle:"编译型语言",charIndex:6964},{level:3,title:"解释型语言",slug:"解释型语言",normalizedTitle:"解释型语言",charIndex:6973},{level:3,title:"二者的区别",slug:"二者的区别",normalizedTitle:"二者的区别",charIndex:7161},{level:3,title:"Java的运行机制",slug:"java的运行机制",normalizedTitle:"java的运行机制",charIndex:6945},{level:2,title:"Hello World",slug:"hello-world",normalizedTitle:"hello world",charIndex:7670}],headersStr:"Java : 一个帝国的诞生 1、C语言帝国的统治 2、反抗 3、一鸣惊人 4、开拓疆土 5、帝国的诞生 Java的特性和优势 八大特性 核心优势 Java三大版本 JDK 和 JRE 初识JVM JAVA程序运行机制 编译型语言 解释型语言 二者的区别 Java的运行机制 Hello World",content:'# 初始java\n\n\n# Java : 一个帝国的诞生\n\n\n# 1、C语言帝国的统治\n\n现在是公元1995年， C语言帝国已经统治了我们20多年， 实在是太久了。\n\n1972年， 随着C语言的诞生和Unix的问世， 帝国迅速建立统治， 从北美到欧洲， 从欧洲到亚洲， 无数程序员臣服在他的脚下。\n\n帝国给我们提供了极好的福利：贴近硬件， 运行极快， 效率极高。\n\n使用这些福利， 程序员们用C 开发了很多系统级软件，操作系统， 编译器， 数据库，网络系统.....\n\n但是帝国也给我们安上了两个沉重的枷锁： 指针和内存管理\n\n虽然指针无比强大， 能直接操作内存， 但是帝国却没有给我们工具去做越界的检查， 导致很多新手程序员轻易犯错。\n\n至于内存管理， 帝国更完全是放任的态度： 你自己分配的空间， 自己去释放 ！\n\n更要命的是这些问题在编译期发现不了， 在运行时才会突然暴露， 常常让我们手忙脚乱， 昏天黑地去调试。\n\n我们的大量时间和宝贵的精力都被浪费在小心翼翼的处理指针和内存分配上。\n\n每个程序员都被这两个东西搞的焦头烂额！\n\n帝国宣称的可移植性骗了我们，他宣称我们在一个机器上写的程序， 只要在另外一个机器上编译就可以了， 实际上不是这样。 他要求我们尽量用标准的C函数库。其次，如果遇到了一些针对特定平台的调用， 需要对每个平台都得写一份 ！ 有一点点小错误，都会导致编译失败。\n\n1982年，帝国又推出了一门新的语言C++, 添加了面向对象的功能，兼容C, 有静态类型检查， 性能也很好。\n\n但是这门新的语言实在是太复杂了， 复杂到比我聪明的多的人都没有办法完全掌握这门语言，它的很多特性复杂的让人吃惊。\n\nC++在图形领域和游戏上取得了一些成功， 但是我一直学不好它。\n\n\n# 2、反抗\n\n我决定反抗这个庞大的帝国， 我偷偷的带领着一帮志同道合的兄弟离开了，我们要新建一块清新自由的领地。\n\n为了吸引更多的程序员加入我们， 我们要建立一个新的语言，这个语言应该有这样的特性：\n\n语法有点像C ， 这样大家容易接受\n\n没有C语言那样的指针\n\n再也不要考虑内存管理了， 实在受不了了\n\n真正的可移植性， 编写一次， 到处运行\n\n面向对象\n\n类型安全\n\n还有，我们要提供一套高质量的类库， 随语言发行。\n\n我想把这个语言命名为C++-- , 即C++减减， 因为我想在C++的基础上改进，把它简化。\n\n后来发现不行， 设计理念差别太大。\n\n干脆重启炉灶。\n\n我看到门口的一棵橡树， 就把这个语言叫做Oak。\n\n但是后来发布的时候， 发现Oak已经被别人用了， 我们讨论很久， 最终决定把这门新的语言叫做 Java。\n\n为了实现跨平台， 我们在操作系统和应用程序之间增加了一个抽象层： Java 虚拟机\n\n用Java写的程序都跑在虚拟机上， 除非个别情况， 都不用看到操作系统。\n\n\n# 3、一鸣惊人\n\n为了吸引更多的人加入我们的新领地， 我们决定搞一个演示， 向大家展示Java 的能力。\n\n出世未久的Java其实还远不完善。 搞点什么好呢？\n\n我们把眼光盯上了刚刚兴起的互联网， 1995年的网页简单而粗糙， 缺乏互动性。 于是我们在浏览器上弄了个小插件， 把java 运行环境放了上去。\n\n然后在上面开发了一个图形界面的程序(Applet)， 让它看起来美轮美奂， 震撼人心。\n\n每一个看到他的程序员都会发出“Wow”的惊叹 ！为之倾倒。\n\nJava 活了！\n\n通过Applet , 无数的程序员看到了Java这门语言，了解了这门语言特性以后， 很多无法忍受C帝国暴政的程序员， 很快加入了我们， 我们的领地开始迅速扩大。\n\n连C语言帝国里的一些商业巨头也纷纷来和我们合作， 其中就包括Oracle , 微软这样的巨头 ， 微软的头领Bill Gates还说 ：这是迄今为止设计的最好的语言！\n\n但是Bill Gates非常的不地道， 买了我们的Java 许可以后，虽然在自家的浏览器上也支持Applet, 但是他们却偷偷的试图修改Java , 想把Java绑死在自家的操作系统上赚钱， Java会变的不可移植。\n\n这是我们难于忍受的， 我们和微软发起了一场旷日持久的游击战争， 逼着微软退出了Java领域， 开发了自己的.NET , 这是后话。\n\n\n# 4、开拓疆土\n\n从1995年到1997年，我们依靠 Java 不断的攻城略地， 开拓疆土，我们王国的子民不断增加， 达到了几十万之众， 已经是一个不可忽视的力量了。\n\n但是大家发现， Java除了Applet, 以及一些小程序之外， 似乎干不了别的事情。\n\nC帝国的人还不断的嘲笑我们慢， 像个玩具。\n\n到了1998年， 经过密谋， 我们Java 王国决定派出三只军队向外扩展：\n\nJava 2 标准版(J2SE)： 去占领桌面\n\nJava 2 移动版(J2ME)： 去占领手机\n\nJava 2 企业版(J2EE)： 去占领服务器\n\n其中的两只大军很快败下阵来。\n\nJ2SE 的首领发现， 开发桌面应用的程序员根本接受不了Java， 虽然我们有做的很优雅的Swing 可以开发界面， 但是开发出的界面非常难看， 和原生的桌面差距很大。 尤其是为了运行程序还得安装一个虚拟机， 大家都受不了。\n\nJ2ME也是， 一直不受待见， 当然更重要的原因是乔布斯还没有重新发明手机， 移动互联网还没有启动。\n\n失之东隅，收之桑榆， J2EE赶上了好时候， 互联网大发展， 大家忽然发现， Java简直是为写服务器端程序所发明的！\n\n强大， 健壮， 安全， 简单， 跨平台 ！\n\n在J2EE规范的指导下， 特别适合团队开发复杂的大型项目。\n\n我们授权BEA公司第一个使用J2EE许可证， 推出了Weblogic, 凭借其集群功能， 第一次展示了复杂应用的可扩展性和高可用性。\n\n这个后来被称为中间件的东西把程序员从事务管理，安全管理，权限管理等方面解放出来， 让他们专注于业务开发。 这立刻捕获了大量程序员的心。\n\n很快Java 王国的子民就达到数百万之众。\n\n榜样的力量是无穷的， 很快其他商业巨头也纷纷入场， 尤其是IBM，在Java 上疯狂投入，不仅开发了自己的应用服务器 Websphere, 还推出了Eclipse这个极具魅力的开源开发平台。\n\n当然IBM利用java 获得了非常可观的效益， 软件+硬件+服务 三驾马车滚滚向前， 把IBM推向了一个新的高峰。\n\n\n# 5、帝国的诞生\n\n大家也没有想到，除了商业巨头以外， 程序员们也会对Java王国 这么热爱， 他们基于Java 开发了巨多的平台，系统，工具，例如：\n\n构建工具: Ant，Maven, Jekins\n\n应用服务器： Tomcat，Jetty, Jboss, Websphere, weblogic\n\nWeb开发： Struts,Spring,Hibernate, myBatis\n\n开发工具： Eclipse, Netbean,intellij idea, Jbuilder\n\n。。。。等等等等。。。。\n\n并且绝大部分都是开源的 ！\n\n微软眼睁睁的看着服务器端的市场被Java 王国占据， 岂能善罢甘休？ 他们赶紧推出.NET来对抗， 但我们已经不在乎了， 因为他的系统是封闭的，所有的软件都是自家的：\n\n开发工具是Visual Studio, 应用服务器是IIS, 数据库是SQL Server，只要你用.NET，基本上就会绑定微软。\n\n另外他们的系统只能运行在Windows服务器上， 这个服务器在高端市场的占有率实在是太低了。\n\n2005年底， 一个新的王国突然崛起， 他们号称开发效率比java 快5-10倍， 由此吸引了大批程序员前往加盟。\n\n这个新的王国叫做Ruby on Rails, 它结合了PHP体系的优点（快速开发）和Java体系的优点（程序规整）， 特别适合快速的开发简单的Web网站。\n\n虽然发展很快， 但没有对Java 王国产生实质性的威胁， 使用Ruby on Rails搭建大型商业系统的还很少。\n\n除了Ruby on Rails ，还有PHP， Python ， 都适合快速开发不太复杂的Web系统。 但是关键的，复杂的商业系统开发还是Java 王国的统治之下。 所以我们和他们相安无事。\n\n2006年， 一只叫Hadoop的军队让Java王国入侵了大数据领域， 由于使用Java 语言， 绝大多数程序员在理解了Map/Reduce , 分布式文件系统在Hadoop中的实现以后， 很快就能编写处理处理海量数据的程序， Java 王国的领地得到了极大的扩展。\n\n2008年， 一个名叫Android 的系统横空出世， 并且随着移动互联网的爆发迅速普及， 运行在Android之上的正是Java ！\n\nJava 王国在Google的支持下， 以一种意想不到的方式占领了手机端， 完成了当年J2ME 壮志未酬的事业 ！\n\n到今年为止， 全世界估计有1000万程序员加入了Java王国，它领土之广泛， 实力之强大， 是其他语言无法比拟的。\n\nJava 占据了大部分的服务器端开发，尤其是关键的复杂的系统， 绝大多数的手机端， 以及大部分的大数据领域。\n\n一个伟大的帝国诞生了。\n\n\n# Java的特性和优势\n\n\n# 八大特性\n\n1、跨平台/可移植性\n\n这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。\n\n2、安全性\n\nJava适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。\n\n3、面向对象\n\n面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！\n\nJava则是完全的面向对象语言。\n\n4、简单性\n\nJava就是C++语法的简化版，我们也可以将Java称之为“C++-”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。\n\n同时，由于语法基于C语言，因此学习起来完全不费力。\n\n5、高性能\n\nJava最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。\n\n比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，\n\n某些代码甚至接待C++的效率。因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。\n\n6、分布式\n\nJava是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，\n\n使程序能够通过网络调用方法。\n\n7、多线程\n\n多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。\n\n8、健壮性\n\nJava是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。\n\n如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。\n\n\n# 核心优势\n\n\n\n跨平台是Java语言的核心优势，赶上最初互联网的发展，并随着互联网的发展而发展，建立了强大的生态体系，目前已经覆盖IT各行业的“第一大语言”，是计算机界的“英语”。\n\n虽然，目前也有很多跨平台的语言，但是已经失去先机，无法和Java强大的生态体系抗衡。Java仍将在未来几十年成为编程语言的主流语言。\n\nJAVA虚拟机是JAVA实现跨平台的核心。事实上，基于JAVA虚拟机(JVM)的编程语言还有很多种：\n\n\n\n基于JAVA生态建立的产品将会越来越多；基于JAVA虚拟机的编程语言也将会越来越多；生态系统的强大，是JAVA能长盛不衰的根本。\n\n\n# Java三大版本\n\nJAVA最大的特点：\n\nJava的主要优势在于其做出的WORA：即一次编写（Write Once）、随处运行（Run Anywhere）。简单来讲，这意味着开发团队能够利用Java编写一款应用程序，并将其编译为可执行形式，而后将其运行 在任何支持Java的平台之上。这显然能够极大提高编程工作的实际效率，这种优势来源于Java Virtual Machine(JAVA虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在 实际的计算机上仿真模拟各种计算机功能来实现的。JAVA语言的一个非常重要的特点就是与平台的无关 性，而使用Java虚拟机是实现这一特点的关键。\n\nJAVA三大版本：\n\n 1. JAVA SE：它是JAVA的标准版，是整个JAVA的基础和核心，这是我们主要学习的一个部分，也是 JAVAEE和JAVAME技术的基础，主要用于开发桌面应用程序。学会后可以做一些简单的桌面应用 如：扫雷，连连看等。\n 2. JAVA ME：它是JAVA的微缩版，主要应用于嵌入式开发，比如手机程序的开发。目前来说就业范围不是很广，在一些城市可能相对的不好找工作。\n 3. JAVA EE：也叫JAVA的企业版，它提供了企业级应用开发的完整解决方案，比如开发网站，还有企业的一些应用系统，是JAVA技术应用最广泛的领域。主要还是偏向于WEB的开发，而JAVA EE的基础就是JAVA SE，所以我们在学习JAVA SE的时候，基础一定要打好，因为这是最基本的，也是最核 心的。\n\n\n# JDK 和 JRE\n\nJDK\n\nJava 2 SDK (Development Kit)包含：JRE的超集，包含编译器和调试器等用于程序开发的文件\n\nJRE\n\nJava Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序和Applet所必须文件\n\nJava运行环境的三项主要功能：\n\n * 加载代码：由class loader 完成；\n * 校验代码：由bytecode verifier 完成；\n * 执行代码：由 runtime interpreter完成。\n\n区别和联系：\n\nsdk（也就是jdk）是jre的超集，是在jre的基础上增加了编译器及其他一些开发工具。\n\njre就是java运行时环境，包括了jvm和其它一些java核心api,任何一台电脑，只有安装了jre才可以行 java程序.\n\n如果只是要运行JAVA程序，之需要JRE就可以。 JRE通常非常小，也包含了JVM.\n\n如果要开发JAVA程序，就需要安装JDK。\n\n\n# 初识JVM\n\nJVM（JAVA Virtual Machine）\n\nJVM是一种规范，可以使用软件来实现，也可以使用硬件来实现，就是一个虚拟的用于执byte-codes 字节码的计算机。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。\n\nJVM负责将java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。JAVA提供了另一种 解释运行的方法JIT（just in time），可以一次解释完，再运行特定平台上的机器码，高级的JIT可以只能 分析热点代码，并将这些代码转成本地机器码，并将结果缓存起来，下次直接从内存中调用，这样就大 大提高了执行JAVA代码的效率。这样就实现了跨平台、可移植的功能。\n\n 1. JVM是指在一台计算机上由软件或硬件模拟的计算机；它类似一个小巧而高效的CPU。\n\n 2. byte-code代码是与平台无关的是虚拟机的机器指令。\n\n 3. java字节代码运行的两种方式:\n    \n    * interpreter(解释)\n      \n      运行期解释字节码并执行\n    \n    * Just-in-time(即时编译)\n      \n      由代码生成器将字节代码转换成本机的机器代码,然后可以以较高速度执行。\n\nJAVA的跨平台实现的核心是不同平台使用不同的虚拟机\n\n不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。\n\n\n# JAVA程序运行机制\n\n说到Java的运行机制，不得不提一下什么是编译型语言，什么是解释型语言。\n\n\n# 编译型语言\n\n编译型语言是先将源代码编译成机器语言（机器可以读懂的语言），再由机器运行机器码，这样执行程序的效率比较高。像C和C++就是典型的编译型语言。\n\n\n# 解释型语言\n\n其实解释型语言是相对编译型语言存在的，解释型语言是在运行的时候才进行编译，每次运行都需要编译，这样效率比较低。像JavaScript，Python就是典型的解释型语言\n\n\n# 二者的区别\n\n简单的举个例子：同样一本英文书，找人翻译成中文版的书然后拿给你看就是编译，找一个翻译员在你旁边给你解读书的含义就是解释。两者各有利弊，编译型语言执行效率高，翻译一次可以多次运行。解释性语言执行效率低，每次运行都需要重新翻译。但是解释型的跨平台性相对要好，比如解释给一个懂中文和解释给一个懂日文的人就叫做兼容性。\n\n\n# Java的运行机制\n\nJava属于两者都有，既有编译过程，又是解释型语言\n\nJava语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介 于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解 释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以 执行起来比“纯解释型”程序要快许多。\n\n总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。\n\n第一步：编译\n\n利用编译器（javac）将源程序编译成字节码à 字节码文件名：源文件名.class\n\n第二部：运行\n\n利用虚拟机（解释器，java）解释执行class字节码文件。\n\n\n\n\n# Hello World\n\n需要先配置好开发环境\n\n参考链接：https://www.runoob.com/java/java-environment-setup.html\n\n测试代码一定要写HelloWorld！代表你向这个世界的呐喊，仪式感很重要，就像你生活 中和家人，朋友，妻子在节日中或者纪念日一定要做一些事情，这就是仪式感。\n\n 1. 新建文件 Hello.java\n\n 2. 编写我们的HelloWorld程序！\n    \n    public class Hello{\n        public static void main(String[] args){\n            System.out.println("Hello,World!");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 保存文件，cmd打开命令行，利用javac编译！\n    \n    javac Hello.java\n    # 如果没有报错，查看文件夹下是否有新的一个文件\n    # Hello.class\n    # 如果没有出现，恭喜！说明你遇到了你在学Java当中的第一个Bug\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. java 执行！\n    \n    java Hello\n    # 成功输出Hello，World！\n    \n    \n    1\n    2\n    \n\n如果出现错误，检查字母大小写是否有错误，或者是否标点符号错误，文件名错误等等，一定要确保成功输出\n\n编写 Java 程序时，应注意以下几点：\n\n * 大小写敏感\n   \n   Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。\n\n * 类名\n   \n   对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。\n\n * 方法名\n   \n   所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字 母大写。\n\n * 源文件名\n   \n   源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。\n\n * 主方法入口\n   \n   所有的 Java 程序由 public static void main(String []args) 方法开始执行。',normalizedContent:'# 初始java\n\n\n# java : 一个帝国的诞生\n\n\n# 1、c语言帝国的统治\n\n现在是公元1995年， c语言帝国已经统治了我们20多年， 实在是太久了。\n\n1972年， 随着c语言的诞生和unix的问世， 帝国迅速建立统治， 从北美到欧洲， 从欧洲到亚洲， 无数程序员臣服在他的脚下。\n\n帝国给我们提供了极好的福利：贴近硬件， 运行极快， 效率极高。\n\n使用这些福利， 程序员们用c 开发了很多系统级软件，操作系统， 编译器， 数据库，网络系统.....\n\n但是帝国也给我们安上了两个沉重的枷锁： 指针和内存管理\n\n虽然指针无比强大， 能直接操作内存， 但是帝国却没有给我们工具去做越界的检查， 导致很多新手程序员轻易犯错。\n\n至于内存管理， 帝国更完全是放任的态度： 你自己分配的空间， 自己去释放 ！\n\n更要命的是这些问题在编译期发现不了， 在运行时才会突然暴露， 常常让我们手忙脚乱， 昏天黑地去调试。\n\n我们的大量时间和宝贵的精力都被浪费在小心翼翼的处理指针和内存分配上。\n\n每个程序员都被这两个东西搞的焦头烂额！\n\n帝国宣称的可移植性骗了我们，他宣称我们在一个机器上写的程序， 只要在另外一个机器上编译就可以了， 实际上不是这样。 他要求我们尽量用标准的c函数库。其次，如果遇到了一些针对特定平台的调用， 需要对每个平台都得写一份 ！ 有一点点小错误，都会导致编译失败。\n\n1982年，帝国又推出了一门新的语言c++, 添加了面向对象的功能，兼容c, 有静态类型检查， 性能也很好。\n\n但是这门新的语言实在是太复杂了， 复杂到比我聪明的多的人都没有办法完全掌握这门语言，它的很多特性复杂的让人吃惊。\n\nc++在图形领域和游戏上取得了一些成功， 但是我一直学不好它。\n\n\n# 2、反抗\n\n我决定反抗这个庞大的帝国， 我偷偷的带领着一帮志同道合的兄弟离开了，我们要新建一块清新自由的领地。\n\n为了吸引更多的程序员加入我们， 我们要建立一个新的语言，这个语言应该有这样的特性：\n\n语法有点像c ， 这样大家容易接受\n\n没有c语言那样的指针\n\n再也不要考虑内存管理了， 实在受不了了\n\n真正的可移植性， 编写一次， 到处运行\n\n面向对象\n\n类型安全\n\n还有，我们要提供一套高质量的类库， 随语言发行。\n\n我想把这个语言命名为c++-- , 即c++减减， 因为我想在c++的基础上改进，把它简化。\n\n后来发现不行， 设计理念差别太大。\n\n干脆重启炉灶。\n\n我看到门口的一棵橡树， 就把这个语言叫做oak。\n\n但是后来发布的时候， 发现oak已经被别人用了， 我们讨论很久， 最终决定把这门新的语言叫做 java。\n\n为了实现跨平台， 我们在操作系统和应用程序之间增加了一个抽象层： java 虚拟机\n\n用java写的程序都跑在虚拟机上， 除非个别情况， 都不用看到操作系统。\n\n\n# 3、一鸣惊人\n\n为了吸引更多的人加入我们的新领地， 我们决定搞一个演示， 向大家展示java 的能力。\n\n出世未久的java其实还远不完善。 搞点什么好呢？\n\n我们把眼光盯上了刚刚兴起的互联网， 1995年的网页简单而粗糙， 缺乏互动性。 于是我们在浏览器上弄了个小插件， 把java 运行环境放了上去。\n\n然后在上面开发了一个图形界面的程序(applet)， 让它看起来美轮美奂， 震撼人心。\n\n每一个看到他的程序员都会发出“wow”的惊叹 ！为之倾倒。\n\njava 活了！\n\n通过applet , 无数的程序员看到了java这门语言，了解了这门语言特性以后， 很多无法忍受c帝国暴政的程序员， 很快加入了我们， 我们的领地开始迅速扩大。\n\n连c语言帝国里的一些商业巨头也纷纷来和我们合作， 其中就包括oracle , 微软这样的巨头 ， 微软的头领bill gates还说 ：这是迄今为止设计的最好的语言！\n\n但是bill gates非常的不地道， 买了我们的java 许可以后，虽然在自家的浏览器上也支持applet, 但是他们却偷偷的试图修改java , 想把java绑死在自家的操作系统上赚钱， java会变的不可移植。\n\n这是我们难于忍受的， 我们和微软发起了一场旷日持久的游击战争， 逼着微软退出了java领域， 开发了自己的.net , 这是后话。\n\n\n# 4、开拓疆土\n\n从1995年到1997年，我们依靠 java 不断的攻城略地， 开拓疆土，我们王国的子民不断增加， 达到了几十万之众， 已经是一个不可忽视的力量了。\n\n但是大家发现， java除了applet, 以及一些小程序之外， 似乎干不了别的事情。\n\nc帝国的人还不断的嘲笑我们慢， 像个玩具。\n\n到了1998年， 经过密谋， 我们java 王国决定派出三只军队向外扩展：\n\njava 2 标准版(j2se)： 去占领桌面\n\njava 2 移动版(j2me)： 去占领手机\n\njava 2 企业版(j2ee)： 去占领服务器\n\n其中的两只大军很快败下阵来。\n\nj2se 的首领发现， 开发桌面应用的程序员根本接受不了java， 虽然我们有做的很优雅的swing 可以开发界面， 但是开发出的界面非常难看， 和原生的桌面差距很大。 尤其是为了运行程序还得安装一个虚拟机， 大家都受不了。\n\nj2me也是， 一直不受待见， 当然更重要的原因是乔布斯还没有重新发明手机， 移动互联网还没有启动。\n\n失之东隅，收之桑榆， j2ee赶上了好时候， 互联网大发展， 大家忽然发现， java简直是为写服务器端程序所发明的！\n\n强大， 健壮， 安全， 简单， 跨平台 ！\n\n在j2ee规范的指导下， 特别适合团队开发复杂的大型项目。\n\n我们授权bea公司第一个使用j2ee许可证， 推出了weblogic, 凭借其集群功能， 第一次展示了复杂应用的可扩展性和高可用性。\n\n这个后来被称为中间件的东西把程序员从事务管理，安全管理，权限管理等方面解放出来， 让他们专注于业务开发。 这立刻捕获了大量程序员的心。\n\n很快java 王国的子民就达到数百万之众。\n\n榜样的力量是无穷的， 很快其他商业巨头也纷纷入场， 尤其是ibm，在java 上疯狂投入，不仅开发了自己的应用服务器 websphere, 还推出了eclipse这个极具魅力的开源开发平台。\n\n当然ibm利用java 获得了非常可观的效益， 软件+硬件+服务 三驾马车滚滚向前， 把ibm推向了一个新的高峰。\n\n\n# 5、帝国的诞生\n\n大家也没有想到，除了商业巨头以外， 程序员们也会对java王国 这么热爱， 他们基于java 开发了巨多的平台，系统，工具，例如：\n\n构建工具: ant，maven, jekins\n\n应用服务器： tomcat，jetty, jboss, websphere, weblogic\n\nweb开发： struts,spring,hibernate, mybatis\n\n开发工具： eclipse, netbean,intellij idea, jbuilder\n\n。。。。等等等等。。。。\n\n并且绝大部分都是开源的 ！\n\n微软眼睁睁的看着服务器端的市场被java 王国占据， 岂能善罢甘休？ 他们赶紧推出.net来对抗， 但我们已经不在乎了， 因为他的系统是封闭的，所有的软件都是自家的：\n\n开发工具是visual studio, 应用服务器是iis, 数据库是sql server，只要你用.net，基本上就会绑定微软。\n\n另外他们的系统只能运行在windows服务器上， 这个服务器在高端市场的占有率实在是太低了。\n\n2005年底， 一个新的王国突然崛起， 他们号称开发效率比java 快5-10倍， 由此吸引了大批程序员前往加盟。\n\n这个新的王国叫做ruby on rails, 它结合了php体系的优点（快速开发）和java体系的优点（程序规整）， 特别适合快速的开发简单的web网站。\n\n虽然发展很快， 但没有对java 王国产生实质性的威胁， 使用ruby on rails搭建大型商业系统的还很少。\n\n除了ruby on rails ，还有php， python ， 都适合快速开发不太复杂的web系统。 但是关键的，复杂的商业系统开发还是java 王国的统治之下。 所以我们和他们相安无事。\n\n2006年， 一只叫hadoop的军队让java王国入侵了大数据领域， 由于使用java 语言， 绝大多数程序员在理解了map/reduce , 分布式文件系统在hadoop中的实现以后， 很快就能编写处理处理海量数据的程序， java 王国的领地得到了极大的扩展。\n\n2008年， 一个名叫android 的系统横空出世， 并且随着移动互联网的爆发迅速普及， 运行在android之上的正是java ！\n\njava 王国在google的支持下， 以一种意想不到的方式占领了手机端， 完成了当年j2me 壮志未酬的事业 ！\n\n到今年为止， 全世界估计有1000万程序员加入了java王国，它领土之广泛， 实力之强大， 是其他语言无法比拟的。\n\njava 占据了大部分的服务器端开发，尤其是关键的复杂的系统， 绝大多数的手机端， 以及大部分的大数据领域。\n\n一个伟大的帝国诞生了。\n\n\n# java的特性和优势\n\n\n# 八大特性\n\n1、跨平台/可移植性\n\n这是java的核心优势。java在设计时就很注重移植和跨平台性。比如：java的int永远都是32位。不像c++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。\n\n2、安全性\n\njava适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使java可以很容易构建防病毒，防篡改的系统。\n\n3、面向对象\n\n面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于c++为了照顾大量c语言使用者而兼容了c，使得自身仅仅成为了带类的c语言，多少影响了其面向对象的彻底性！\n\njava则是完全的面向对象语言。\n\n4、简单性\n\njava就是c++语法的简化版，我们也可以将java称之为“c++-”。跟我念“c加加减”，指的就是将c++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。\n\n同时，由于语法基于c语言，因此学习起来完全不费力。\n\n5、高性能\n\njava最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。\n\n比如，通过jit(just in time)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使java程序的执行效率大大提高，\n\n某些代码甚至接待c++的效率。因此，java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多c++应用转到java开发，很多c++程序员转型为java程序员。\n\n6、分布式\n\njava是为internet的分布式环境设计的，因为它能够处理tcp/ip协议。事实上，通过url访问一个网络资源和访问本地文件是一样简单的。java还支持远程方法调用(rmi,remote method invocation)，\n\n使程序能够通过网络调用方法。\n\n7、多线程\n\n多线程的使用可以带来更好的交互响应和实时行为。 java多线程的简单性是java成为主流服务器端开发语言的主要原因之一。\n\n8、健壮性\n\njava是一种健壮的语言，吸收了c/c++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。java程序不可能造成计算机崩溃。即使java程序也可能有错误。\n\n如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。\n\n\n# 核心优势\n\n\n\n跨平台是java语言的核心优势，赶上最初互联网的发展，并随着互联网的发展而发展，建立了强大的生态体系，目前已经覆盖it各行业的“第一大语言”，是计算机界的“英语”。\n\n虽然，目前也有很多跨平台的语言，但是已经失去先机，无法和java强大的生态体系抗衡。java仍将在未来几十年成为编程语言的主流语言。\n\njava虚拟机是java实现跨平台的核心。事实上，基于java虚拟机(jvm)的编程语言还有很多种：\n\n\n\n基于java生态建立的产品将会越来越多；基于java虚拟机的编程语言也将会越来越多；生态系统的强大，是java能长盛不衰的根本。\n\n\n# java三大版本\n\njava最大的特点：\n\njava的主要优势在于其做出的wora：即一次编写（write once）、随处运行（run anywhere）。简单来讲，这意味着开发团队能够利用java编写一款应用程序，并将其编译为可执行形式，而后将其运行 在任何支持java的平台之上。这显然能够极大提高编程工作的实际效率，这种优势来源于java virtual machine(java虚拟机的缩写)，jvm是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在 实际的计算机上仿真模拟各种计算机功能来实现的。java语言的一个非常重要的特点就是与平台的无关 性，而使用java虚拟机是实现这一特点的关键。\n\njava三大版本：\n\n 1. java se：它是java的标准版，是整个java的基础和核心，这是我们主要学习的一个部分，也是 javaee和javame技术的基础，主要用于开发桌面应用程序。学会后可以做一些简单的桌面应用 如：扫雷，连连看等。\n 2. java me：它是java的微缩版，主要应用于嵌入式开发，比如手机程序的开发。目前来说就业范围不是很广，在一些城市可能相对的不好找工作。\n 3. java ee：也叫java的企业版，它提供了企业级应用开发的完整解决方案，比如开发网站，还有企业的一些应用系统，是java技术应用最广泛的领域。主要还是偏向于web的开发，而java ee的基础就是java se，所以我们在学习java se的时候，基础一定要打好，因为这是最基本的，也是最核 心的。\n\n\n# jdk 和 jre\n\njdk\n\njava 2 sdk (development kit)包含：jre的超集，包含编译器和调试器等用于程序开发的文件\n\njre\n\njava runtime environment (jre) 包含：java虚拟机、库函数、运行java应用程序和applet所必须文件\n\njava运行环境的三项主要功能：\n\n * 加载代码：由class loader 完成；\n * 校验代码：由bytecode verifier 完成；\n * 执行代码：由 runtime interpreter完成。\n\n区别和联系：\n\nsdk（也就是jdk）是jre的超集，是在jre的基础上增加了编译器及其他一些开发工具。\n\njre就是java运行时环境，包括了jvm和其它一些java核心api,任何一台电脑，只有安装了jre才可以行 java程序.\n\n如果只是要运行java程序，之需要jre就可以。 jre通常非常小，也包含了jvm.\n\n如果要开发java程序，就需要安装jdk。\n\n\n# 初识jvm\n\njvm（java virtual machine）\n\njvm是一种规范，可以使用软件来实现，也可以使用硬件来实现，就是一个虚拟的用于执byte-codes 字节码的计算机。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。\n\njvm负责将java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。java提供了另一种 解释运行的方法jit（just in time），可以一次解释完，再运行特定平台上的机器码，高级的jit可以只能 分析热点代码，并将这些代码转成本地机器码，并将结果缓存起来，下次直接从内存中调用，这样就大 大提高了执行java代码的效率。这样就实现了跨平台、可移植的功能。\n\n 1. jvm是指在一台计算机上由软件或硬件模拟的计算机；它类似一个小巧而高效的cpu。\n\n 2. byte-code代码是与平台无关的是虚拟机的机器指令。\n\n 3. java字节代码运行的两种方式:\n    \n    * interpreter(解释)\n      \n      运行期解释字节码并执行\n    \n    * just-in-time(即时编译)\n      \n      由代码生成器将字节代码转换成本机的机器代码,然后可以以较高速度执行。\n\njava的跨平台实现的核心是不同平台使用不同的虚拟机\n\n不同的操作系统有不同的虚拟机。java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。\n\n\n# java程序运行机制\n\n说到java的运行机制，不得不提一下什么是编译型语言，什么是解释型语言。\n\n\n# 编译型语言\n\n编译型语言是先将源代码编译成机器语言（机器可以读懂的语言），再由机器运行机器码，这样执行程序的效率比较高。像c和c++就是典型的编译型语言。\n\n\n# 解释型语言\n\n其实解释型语言是相对编译型语言存在的，解释型语言是在运行的时候才进行编译，每次运行都需要编译，这样效率比较低。像javascript，python就是典型的解释型语言\n\n\n# 二者的区别\n\n简单的举个例子：同样一本英文书，找人翻译成中文版的书然后拿给你看就是编译，找一个翻译员在你旁边给你解读书的含义就是解释。两者各有利弊，编译型语言执行效率高，翻译一次可以多次运行。解释性语言执行效率低，每次运行都需要重新翻译。但是解释型的跨平台性相对要好，比如解释给一个懂中文和解释给一个懂日文的人就叫做兼容性。\n\n\n# java的运行机制\n\njava属于两者都有，既有编译过程，又是解释型语言\n\njava语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介 于机器码和java源代码之间的中介代码，运行的时候则由jvm（java的虚拟机平台，可视为解释器）解 释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以 执行起来比“纯解释型”程序要快许多。\n\n总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。\n\n第一步：编译\n\n利用编译器（javac）将源程序编译成字节码a 字节码文件名：源文件名.class\n\n第二部：运行\n\n利用虚拟机（解释器，java）解释执行class字节码文件。\n\n\n\n\n# hello world\n\n需要先配置好开发环境\n\n参考链接：https://www.runoob.com/java/java-environment-setup.html\n\n测试代码一定要写helloworld！代表你向这个世界的呐喊，仪式感很重要，就像你生活 中和家人，朋友，妻子在节日中或者纪念日一定要做一些事情，这就是仪式感。\n\n 1. 新建文件 hello.java\n\n 2. 编写我们的helloworld程序！\n    \n    public class hello{\n        public static void main(string[] args){\n            system.out.println("hello,world!");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 保存文件，cmd打开命令行，利用javac编译！\n    \n    javac hello.java\n    # 如果没有报错，查看文件夹下是否有新的一个文件\n    # hello.class\n    # 如果没有出现，恭喜！说明你遇到了你在学java当中的第一个bug\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. java 执行！\n    \n    java hello\n    # 成功输出hello，world！\n    \n    \n    1\n    2\n    \n\n如果出现错误，检查字母大小写是否有错误，或者是否标点符号错误，文件名错误等等，一定要确保成功输出\n\n编写 java 程序时，应注意以下几点：\n\n * 大小写敏感\n   \n   java 是大小写敏感的，这就意味着标识符 hello 与 hello 是不同的。\n\n * 类名\n   \n   对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 myfirstjavaclass 。\n\n * 方法名\n   \n   所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字 母大写。\n\n * 源文件名\n   \n   源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。\n\n * 主方法入口\n   \n   所有的 java 程序由 public static void main(string []args) 方法开始执行。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"AI专栏",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"30.AI",imgUrl:"/img/web.png",description:"关于AI的一些知识"}},title:"AI专栏",permalink:"/ai",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2025-09-06T23:07:31.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/30.AI.html",relativePath:"00.目录页/30.AI.md",key:"v-a8a3be30",path:"/ai/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757171752e3},{title:"注释",frontmatter:{title:"注释",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/annotation",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01.%E6%B3%A8%E9%87%8A.html",relativePath:"01.Java/02.java-基础/02.基础语法/01.注释.md",key:"v-61ff5e21",path:"/java/se/basic-grammar/annotation/",headers:[{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:18}],headersStr:"注释",content:'# JavaSE-基础语法\n\n\n# 注释\n\n平时我们编写代码，在代码量比较少的时候，我们还可以看懂自己写的，但是当项目结构一旦复杂起来，我们就需要用到一个注释了，注释就类似于我们上学时候写的笔记，我们看着笔记就知道自己写的 什么东西了！在程序中也是如此。我们来看一下Java中的注释怎么写，看以下代码：\n\n/*\n* @Description HelloWorld类\n* @Author Diamond 狂神\n**/\npublic class HelloWorld {\n    /*\n    这是我们Java程序的主入口，\n    main方法也是程序的主线程。\n    */\n    public static void main(String[] args) {\n        //输出HelloWorld！\n        System.out.println("Hello,World!");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n注释并不会被执行，是给我们写代码的人看的，书写注释是一个非常好的习惯。\n\nJava中的注释有三种：\n\n单行注释：只能注释当前行，以//开始，直到行结束\n\n//输出HelloWorld！\n\n\n1\n\n\n多行注释：注释一段文字，以/*开始， */结束！\n\n/*\n    这是我们Java程序的主入口，\n    main方法也是程序的主线程。\n*/\n\n\n1\n2\n3\n4\n\n\n文档注释：用于生产API文档，配合JavaDoc。\n\n/*\n* @Description HelloWorld类\n* @Author Diamond 狂神\n**/\n\n\n1\n2\n3\n4\n',normalizedContent:'# javase-基础语法\n\n\n# 注释\n\n平时我们编写代码，在代码量比较少的时候，我们还可以看懂自己写的，但是当项目结构一旦复杂起来，我们就需要用到一个注释了，注释就类似于我们上学时候写的笔记，我们看着笔记就知道自己写的 什么东西了！在程序中也是如此。我们来看一下java中的注释怎么写，看以下代码：\n\n/*\n* @description helloworld类\n* @author diamond 狂神\n**/\npublic class helloworld {\n    /*\n    这是我们java程序的主入口，\n    main方法也是程序的主线程。\n    */\n    public static void main(string[] args) {\n        //输出helloworld！\n        system.out.println("hello,world!");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n注释并不会被执行，是给我们写代码的人看的，书写注释是一个非常好的习惯。\n\njava中的注释有三种：\n\n单行注释：只能注释当前行，以//开始，直到行结束\n\n//输出helloworld！\n\n\n1\n\n\n多行注释：注释一段文字，以/*开始， */结束！\n\n/*\n    这是我们java程序的主入口，\n    main方法也是程序的主线程。\n*/\n\n\n1\n2\n3\n4\n\n\n文档注释：用于生产api文档，配合javadoc。\n\n/*\n* @description helloworld类\n* @author diamond 狂神\n**/\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"标识符",frontmatter:{title:"标识符",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/identifier/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02.%E6%A0%87%E8%AF%86%E7%AC%A6.html",relativePath:"01.Java/02.java-基础/02.基础语法/02.标识符.md",key:"v-17fd5c60",path:"/java/se/basic-grammar/identifier/",headers:[{level:2,title:"标识符",slug:"标识符",normalizedTitle:"标识符",charIndex:2}],headersStr:"标识符",content:"# 标识符\n\n每个人从出生开始就有一个名字，咋们生活中的所有事物也都有名字，这名字是谁规定呢？回答是：造物主，谁生产出来的谁规定名字，在我们的程序中也不例外。\n\n我们作为造物主，需要给所有的东西给上一个名字，比如我们的HelloWorld程序：\n\nHelloWorld是类名，也是我们的文件名。它前面的 public class是关键字，不过是搞Java那群人已经定 义好的有特殊作用的，下面的每一个代码都有自己的意思和名字对吧，就是用来作区分！和我们的名字 一样，拿来被叫或者称呼的，程序一切都源自于生活，一定要把学程序和生活中的一切联系起来，你会发现这一切都是息息相关的。\n\n\n\n我们来看看有哪些是Java自己定义好的关键字呢？\n\n\n\n我们自己起名字有哪些要求呢？\n\n表示类名的标识符用大写字母开始。\n\n> 如：Man, GoodMan\n\n表示方法和变量的标识符用小写字母开始，后面的描述性词以大写开始。\n\n> 如：eat(),eatFood()\n\n具体可参考《阿里巴巴Java开发手册》\n\n关于 Java 标识符，有以下几点需要注意：\n\n * 所有的标识符都应该以字母（A-Z 或者 a-z）美元符（$）或者下划线（_）开始\n * 首字符之后可以是字母（A-Z 或者 a-z）美元符（$）下划线（_）或数字的任何字符组合\n * 不能使用关键字作为变量名或方法名。\n * 标识符是大小写敏感的\n * 合法标识符举例：age、$salary、_value、__1_value\n * 非法标识符举例：123abc、-salary、#abc\n\nJAVA不采用通常语言使用的ASCII字符集，而是采用unicode这样的标准的国际字符集。因此，这里的 字母的含义：可以表示英文、汉字等等。\n\n可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low",normalizedContent:"# 标识符\n\n每个人从出生开始就有一个名字，咋们生活中的所有事物也都有名字，这名字是谁规定呢？回答是：造物主，谁生产出来的谁规定名字，在我们的程序中也不例外。\n\n我们作为造物主，需要给所有的东西给上一个名字，比如我们的helloworld程序：\n\nhelloworld是类名，也是我们的文件名。它前面的 public class是关键字，不过是搞java那群人已经定 义好的有特殊作用的，下面的每一个代码都有自己的意思和名字对吧，就是用来作区分！和我们的名字 一样，拿来被叫或者称呼的，程序一切都源自于生活，一定要把学程序和生活中的一切联系起来，你会发现这一切都是息息相关的。\n\n\n\n我们来看看有哪些是java自己定义好的关键字呢？\n\n\n\n我们自己起名字有哪些要求呢？\n\n表示类名的标识符用大写字母开始。\n\n> 如：man, goodman\n\n表示方法和变量的标识符用小写字母开始，后面的描述性词以大写开始。\n\n> 如：eat(),eatfood()\n\n具体可参考《阿里巴巴java开发手册》\n\n关于 java 标识符，有以下几点需要注意：\n\n * 所有的标识符都应该以字母（a-z 或者 a-z）美元符（$）或者下划线（_）开始\n * 首字符之后可以是字母（a-z 或者 a-z）美元符（$）下划线（_）或数字的任何字符组合\n * 不能使用关键字作为变量名或方法名。\n * 标识符是大小写敏感的\n * 合法标识符举例：age、$salary、_value、__1_value\n * 非法标识符举例：123abc、-salary、#abc\n\njava不采用通常语言使用的ascii字符集，而是采用unicode这样的标准的国际字符集。因此，这里的 字母的含义：可以表示英文、汉字等等。\n\n可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很low",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"类型转换",frontmatter:{title:"类型转换",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/type-conversion/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",relativePath:"01.Java/02.java-基础/02.基础语法/04.类型转换.md",key:"v-4a7ed15c",path:"/java/se/basic-grammar/type-conversion/",headers:[{level:2,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:2},{level:3,title:"1、自动类型转换",slug:"_1、自动类型转换",normalizedTitle:"1、自动类型转换",charIndex:586},{level:3,title:"2、强制类型转换",slug:"_2、强制类型转换",normalizedTitle:"2、强制类型转换",charIndex:1091},{level:3,title:"3、常见错误和问题",slug:"_3、常见错误和问题",normalizedTitle:"3、常见错误和问题",charIndex:1662},{level:3,title:"4、JDK7扩展",slug:"_4、jdk7扩展",normalizedTitle:"4、jdk7扩展",charIndex:2546},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"类型转换 1、自动类型转换 2、强制类型转换 3、常见错误和问题 4、JDK7扩展 ",content:"# 类型转换\n\n由于Java是强类型语言，所以要进行有些运算的时候的，需要用到类型转换。\n\n整型、实型（常量）、字符型数据可以混合运算。\n\n运算中，不同类型的数据先转化为同一类型，然后进行运算。\n\n转换从低级到高级（根据容量来看）。\n\n> 低 ------------------------------------\x3e 高\n> \n> byte,short,char—> int —> long—> float —> double\n\n数据类型转换必须满足如下规则：\n\n * 不能对boolean类型进行类型转换。\n\n * 不能把对象类型转换成不相关类的对象。\n\n * 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n\n * 转换过程中可能导致溢出或损失精度，例如：\n   \n   int i = 128;\n   byte b = (byte)i;\n   \n   \n   1\n   2\n   \n   \n   因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n   \n   推荐文章：细谈为什么单字节的整数范围是[-128 ~ 127]\n\n浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n\n> (int)23.7 == 23; (int)-45.89f == -45\n\n\n# 1、自动类型转换\n\n自动类型转换：容量小的数据类型可以自动转换为容量大的数据类型。\n\n例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为 32，可以自动转换为64位的double类型。\n\npublic static void main(String[] args) {\n    char c1 = 'a';//定义一个char类型\n    int i1 = c1;//char自动类型转换为int\n    System.out.println(\"char自动类型转换为int后的值等于\" + i1);\n    char c2 = 'A';//定义一个char类型\n    int i2 = c2 + 1;//char 类型和 int 类型计算\n    System.out.println(\"char类型和int计算后的值等于\" + i2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97，所以i1=97。 A 对应值为 65，所以 i2=65+1=66。\n\n\n# 2、强制类型转换\n\n强制类型转换，又被称为造型，用于显式的转换一个数值的类型。\n\n在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。\n\n强制类型转换的语法格式：(type)var ，运算符 “()” 中的 type 表示将值var想要转换成的目标数据类型。 条件是转换的数据类型必须是兼容的。\n\npublic static void main(String[] args) {\n    double x = 3.14;\n    int nx = (int) x; //值为3\n    char c = 'a';\n    int d = c + 1;\n    System.out.println(d); //98\n    System.out.println((char) d); //b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当将一种类型强制转换成另一种类型，而又超出了目标类型的表示范围，就会被截断成为一个完全不同 的值，溢出。\n\npublic static void main(String[] args) {\n    int x = 300;\n    byte bx = (byte)x; //值为44\n    System.out.println(bx);\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3、常见错误和问题\n\n * 操作比较大的数时，要留意是否溢出，尤其是整数操作时；\n   \n   public static void main(String[] args) {\n       int money = 1000000000; //10亿\n       int years = 20;\n       int total = money * years; //返回的是负数\n       long total1 = money * years; //返回的仍然是负数。默认是int，因此结果会转成int值，再转成long。但是已经发生了数据丢失\n       long total2 = money * ((long) years); //先将一个因子变成long，整个表达式发生提升。全部用long来计算。\n       System.out.println(total); //-1474836480\n       System.out.println(total1); //-1474836480\n       System.out.println(total2); //20000000000\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * L和l 的问题：\n   \n   * 不要命名名字为l的变量\n   \n   * long类型使用大写L不要用小写。\n     \n     public static void main(String[] args) {\n         int l = 2;\n         long a = 23451l;\n         System.out.println(l + 1); //3\n         System.out.println(a); //23451\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\n\n# 4、JDK7扩展\n\nJDK7新特性: 二进制整数\n\n由于我们在开发中也经常使用二进制整数，因此JDK7为我们直接提供了二进制整数的类型。\n\n我们只要以：0b开头即可。\n\nint a = 0b0101;\n\n\n1\n\n\nJDK7新特性：下划线分隔符\n\n在实际开发和学习中，如果遇到特别长的数字，读懂它令人头疼！JDK7为我们提供了下划线分隔符，可 以按照自己的习惯进行分割。\n\nint b = 1_2234_5678;\n\n\n1\n\n\n我们很容易就知道这是1亿2234万5678啦！ 非常符合国人的习惯！\n\npublic static void main(String[] args) {\n    int a = 0b0101;\n    int b = 1_2345_7893;\n    System.out.println(a); //5\n    System.out.println(b); //123457893\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n#",normalizedContent:"# 类型转换\n\n由于java是强类型语言，所以要进行有些运算的时候的，需要用到类型转换。\n\n整型、实型（常量）、字符型数据可以混合运算。\n\n运算中，不同类型的数据先转化为同一类型，然后进行运算。\n\n转换从低级到高级（根据容量来看）。\n\n> 低 ------------------------------------\x3e 高\n> \n> byte,short,char—> int —> long—> float —> double\n\n数据类型转换必须满足如下规则：\n\n * 不能对boolean类型进行类型转换。\n\n * 不能把对象类型转换成不相关类的对象。\n\n * 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n\n * 转换过程中可能导致溢出或损失精度，例如：\n   \n   int i = 128;\n   byte b = (byte)i;\n   \n   \n   1\n   2\n   \n   \n   因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n   \n   推荐文章：细谈为什么单字节的整数范围是[-128 ~ 127]\n\n浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n\n> (int)23.7 == 23; (int)-45.89f == -45\n\n\n# 1、自动类型转换\n\n自动类型转换：容量小的数据类型可以自动转换为容量大的数据类型。\n\n例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为 32，可以自动转换为64位的double类型。\n\npublic static void main(string[] args) {\n    char c1 = 'a';//定义一个char类型\n    int i1 = c1;//char自动类型转换为int\n    system.out.println(\"char自动类型转换为int后的值等于\" + i1);\n    char c2 = 'a';//定义一个char类型\n    int i2 = c2 + 1;//char 类型和 int 类型计算\n    system.out.println(\"char类型和int计算后的值等于\" + i2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n解析：c1 的值为字符 a ,查 ascii 码表可知对应的 int 类型值为 97，所以i1=97。 a 对应值为 65，所以 i2=65+1=66。\n\n\n# 2、强制类型转换\n\n强制类型转换，又被称为造型，用于显式的转换一个数值的类型。\n\n在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。\n\n强制类型转换的语法格式：(type)var ，运算符 “()” 中的 type 表示将值var想要转换成的目标数据类型。 条件是转换的数据类型必须是兼容的。\n\npublic static void main(string[] args) {\n    double x = 3.14;\n    int nx = (int) x; //值为3\n    char c = 'a';\n    int d = c + 1;\n    system.out.println(d); //98\n    system.out.println((char) d); //b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当将一种类型强制转换成另一种类型，而又超出了目标类型的表示范围，就会被截断成为一个完全不同 的值，溢出。\n\npublic static void main(string[] args) {\n    int x = 300;\n    byte bx = (byte)x; //值为44\n    system.out.println(bx);\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3、常见错误和问题\n\n * 操作比较大的数时，要留意是否溢出，尤其是整数操作时；\n   \n   public static void main(string[] args) {\n       int money = 1000000000; //10亿\n       int years = 20;\n       int total = money * years; //返回的是负数\n       long total1 = money * years; //返回的仍然是负数。默认是int，因此结果会转成int值，再转成long。但是已经发生了数据丢失\n       long total2 = money * ((long) years); //先将一个因子变成long，整个表达式发生提升。全部用long来计算。\n       system.out.println(total); //-1474836480\n       system.out.println(total1); //-1474836480\n       system.out.println(total2); //20000000000\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * l和l 的问题：\n   \n   * 不要命名名字为l的变量\n   \n   * long类型使用大写l不要用小写。\n     \n     public static void main(string[] args) {\n         int l = 2;\n         long a = 23451l;\n         system.out.println(l + 1); //3\n         system.out.println(a); //23451\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\n\n# 4、jdk7扩展\n\njdk7新特性: 二进制整数\n\n由于我们在开发中也经常使用二进制整数，因此jdk7为我们直接提供了二进制整数的类型。\n\n我们只要以：0b开头即可。\n\nint a = 0b0101;\n\n\n1\n\n\njdk7新特性：下划线分隔符\n\n在实际开发和学习中，如果遇到特别长的数字，读懂它令人头疼！jdk7为我们提供了下划线分隔符，可 以按照自己的习惯进行分割。\n\nint b = 1_2234_5678;\n\n\n1\n\n\n我们很容易就知道这是1亿2234万5678啦！ 非常符合国人的习惯！\n\npublic static void main(string[] args) {\n    int a = 0b0101;\n    int b = 1_2345_7893;\n    system.out.println(a); //5\n    system.out.println(b); //123457893\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"变量和常量",frontmatter:{title:"变量和常量",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/variate-constant/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05.%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F.html",relativePath:"01.Java/02.java-基础/02.基础语法/05.变量和常量.md",key:"v-560c45dc",path:"/java/se/basic-grammar/variate-constant/",headers:[{level:2,title:"变量，常量",slug:"变量-常量",normalizedTitle:"变量，常量",charIndex:2},{level:3,title:"1、变量（variable）",slug:"_1、变量-variable",normalizedTitle:"1、变量（variable）",charIndex:12},{level:3,title:"2、变量作用域",slug:"_2、变量作用域",normalizedTitle:"2、变量作用域",charIndex:783},{level:4,title:"局部变量",slug:"局部变量",normalizedTitle:"局部变量",charIndex:922},{level:4,title:"实例变量",slug:"实例变量",normalizedTitle:"实例变量",charIndex:865},{level:4,title:"静态变量",slug:"静态变量",normalizedTitle:"静态变量",charIndex:815},{level:3,title:"3、常量",slug:"_3、常量",normalizedTitle:"3、常量",charIndex:2405},{level:3,title:"4、变量的命名规范",slug:"_4、变量的命名规范",normalizedTitle:"4、变量的命名规范",charIndex:2700}],headersStr:"变量，常量 1、变量（variable） 2、变量作用域 局部变量 实例变量 静态变量 3、常量 4、变量的命名规范",content:'# 变量，常量\n\n\n# 1、变量（variable）\n\n变量是什么：就是可以变化的量！\n\n我们通过变量来操纵存储空间中的数据，变量就是指代这个存储空间！空间位置是确定的，但是里面放 置什么值不确定！ 打个比方：\n\n这就好像我们家里有一个大衣柜，里面有十分多的小格子，我们给格子上贴上标签，放衣服，放鞋子， 放手表等等，此时我们知道了哪里该放什么，但是，我们并不知道里面到底放的是什么牌子的鞋子，是 衣服还是裤子。那个标签就相当于我们的变量，我们给他起了个名字，但是里面要放什么需要我们自己 去放。\n\nJava是一种强类型语言，每个变量都必须声明其类型。\n\nJava变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。\n\n变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元，声明格式为：\n\n> 数据类型 变量名 = 值；\n> \n> 可以使用逗号隔开来声明多个同类型变量。\n\n注意事项：\n\n * 每个变量都有类型，类型可以是基本类型，也可以是引用类型。\n * 变量名必须是合法的标识符。\n * 变量声明是一条完整的语句，因此每一个声明都必须以分号结束\n\n【演示】\n\nint a, b, c; // 声明三个int型整数：a、 b、c\nint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值\nbyte z = 22; // 声明并初始化 z\nString s = "runoob"; // 声明并初始化字符串 s\ndouble pi = 3.14159; // 声明了双精度浮点型变量 pi\nchar x = \'x\'; // 声明变量 x 的值是字符 \'x\'。\n\n\n1\n2\n3\n4\n5\n6\n\n\n【编码规范】\n\n虽然可以在一行声明多个变量，但是不提倡这个风格，逐一声明每一个变量可以提高程序可读性。\n\n\n# 2、变量作用域\n\n变量根据作用域可划分为三种：\n\n * 类变量（静态变量： static variable）：独立于方法之外的变量，用 static 修饰。\n * 实例变量（成员变量：member variable）：独立于方法之外的变量，不过没有 static 修饰。\n * 局部变量（lacal variable）：类的方法中的变量。\n\npublic class Variable{\n    static int allClicks = 0; // 类变量\n    String str = "hello world"; // 实例变量\n    \n    public void method(){\n        int i =0; // 局部变量\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 局部变量\n\n方法或语句块内部定义的变量。生命周期是从声明位置开始到 ”}” 为止\n\n在使用前必须先声明和初始化(赋初值)。\n\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\npublic static void main(String[] args) {\n    int i;\n    int j = i + 5; // 编译出错，变量i还未被初始化\n    System.out.println(j);\n}\n\n\n1\n2\n3\n4\n5\n\n\n修改为：\n\npublic static void main(String[] args) {\n    int i=10;\n    int j = i+5 ;\n    System.out.println(j);\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 实例变量\n\n方法外部、类的内部定义的变量。\n\n从属于对象，生命周期伴随对象始终。\n\n如果不自行初始化，他会自动初始化成该类型的默认初始值\n\n（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）\n\npublic class Test {\n    // 这个实例变量对子类可见\n    public String name;\n    // 私有变量，仅在该类可见\n    private double salary;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 静态变量\n\n使用static定义。\n\n从属于类，生命周期伴随类始终，从类加载到卸载。\n\n(注：讲完内存分析后我们再深入！先放一放这个概念！)\n\n> 不同的类之间需要对同一个变量进行操作，比如一个水池，同时打开入水口和出水口，进水和出水这两个动作会同时影响到池中的水量，此时池中的水量就可以认为是一个共享的变量。该变量就是静态变量\n> \n> 静态简单的说是 被类的所有对象共享，比如有一个类，有学校，姓名，年龄三个参数，调用就需要给这三个赋上值，假如这些人都是一个学校的，每次调用都需要赋值就太重复，加上静态的话，一个赋值了，每次调用则都是那个值\n\n如果不自行初始化，他会自动初始化成该类型的默认初始值\n\n（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）\n\npublic class Employee {\n    //salary是静态的私有变量\n    private static double salary;\n    // DEPARTMENT是一个常量\n    public static final String DEPARTMENT = "开发人员";\n    public static void main(String[] args){\n        salary = 10000;\n        System.out.println(DEPARTMENT+"平均工资:"+salary);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3、常量\n\n常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值。\n\n所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。\n\nfinal 常量名=值;\nfinal double PI=3.14;\nfinal String LOVE="hello";\n\n\n1\n2\n3\n\n\n常量名一般使用大写字符。\n\n程序中使用常量可以提高代码的可维护性。例如，在项目开发时，我们需要指定用户的性别，此时可以 定义一个常量 SEX，赋值为 "男"，在需要指定用户性别的地方直接调用此常量即可，避免了由于用户的 不规范赋值导致程序出错的情况。\n\n\n# 4、变量的命名规范\n\n 1. 所有变量、方法、类名：见名知意\n 2. 类成员变量：首字母小写和驼峰原则 : monthSalary\n 3. 局部变量：首字母小写和驼峰原则\n 4. 常量：大写字母和下划线：MAX_VALUE\n 5. 类名：首字母大写和驼峰原则: Man, GoodMan\n 6. 方法名：首字母小写和驼峰原则: run(), runRun()\n\n具体可参考《阿里巴巴Java开发手册》',normalizedContent:'# 变量，常量\n\n\n# 1、变量（variable）\n\n变量是什么：就是可以变化的量！\n\n我们通过变量来操纵存储空间中的数据，变量就是指代这个存储空间！空间位置是确定的，但是里面放 置什么值不确定！ 打个比方：\n\n这就好像我们家里有一个大衣柜，里面有十分多的小格子，我们给格子上贴上标签，放衣服，放鞋子， 放手表等等，此时我们知道了哪里该放什么，但是，我们并不知道里面到底放的是什么牌子的鞋子，是 衣服还是裤子。那个标签就相当于我们的变量，我们给他起了个名字，但是里面要放什么需要我们自己 去放。\n\njava是一种强类型语言，每个变量都必须声明其类型。\n\njava变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。\n\n变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元，声明格式为：\n\n> 数据类型 变量名 = 值；\n> \n> 可以使用逗号隔开来声明多个同类型变量。\n\n注意事项：\n\n * 每个变量都有类型，类型可以是基本类型，也可以是引用类型。\n * 变量名必须是合法的标识符。\n * 变量声明是一条完整的语句，因此每一个声明都必须以分号结束\n\n【演示】\n\nint a, b, c; // 声明三个int型整数：a、 b、c\nint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值\nbyte z = 22; // 声明并初始化 z\nstring s = "runoob"; // 声明并初始化字符串 s\ndouble pi = 3.14159; // 声明了双精度浮点型变量 pi\nchar x = \'x\'; // 声明变量 x 的值是字符 \'x\'。\n\n\n1\n2\n3\n4\n5\n6\n\n\n【编码规范】\n\n虽然可以在一行声明多个变量，但是不提倡这个风格，逐一声明每一个变量可以提高程序可读性。\n\n\n# 2、变量作用域\n\n变量根据作用域可划分为三种：\n\n * 类变量（静态变量： static variable）：独立于方法之外的变量，用 static 修饰。\n * 实例变量（成员变量：member variable）：独立于方法之外的变量，不过没有 static 修饰。\n * 局部变量（lacal variable）：类的方法中的变量。\n\npublic class variable{\n    static int allclicks = 0; // 类变量\n    string str = "hello world"; // 实例变量\n    \n    public void method(){\n        int i =0; // 局部变量\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 局部变量\n\n方法或语句块内部定义的变量。生命周期是从声明位置开始到 ”}” 为止\n\n在使用前必须先声明和初始化(赋初值)。\n\n局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\npublic static void main(string[] args) {\n    int i;\n    int j = i + 5; // 编译出错，变量i还未被初始化\n    system.out.println(j);\n}\n\n\n1\n2\n3\n4\n5\n\n\n修改为：\n\npublic static void main(string[] args) {\n    int i=10;\n    int j = i+5 ;\n    system.out.println(j);\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 实例变量\n\n方法外部、类的内部定义的变量。\n\n从属于对象，生命周期伴随对象始终。\n\n如果不自行初始化，他会自动初始化成该类型的默认初始值\n\n（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）\n\npublic class test {\n    // 这个实例变量对子类可见\n    public string name;\n    // 私有变量，仅在该类可见\n    private double salary;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 静态变量\n\n使用static定义。\n\n从属于类，生命周期伴随类始终，从类加载到卸载。\n\n(注：讲完内存分析后我们再深入！先放一放这个概念！)\n\n> 不同的类之间需要对同一个变量进行操作，比如一个水池，同时打开入水口和出水口，进水和出水这两个动作会同时影响到池中的水量，此时池中的水量就可以认为是一个共享的变量。该变量就是静态变量\n> \n> 静态简单的说是 被类的所有对象共享，比如有一个类，有学校，姓名，年龄三个参数，调用就需要给这三个赋上值，假如这些人都是一个学校的，每次调用都需要赋值就太重复，加上静态的话，一个赋值了，每次调用则都是那个值\n\n如果不自行初始化，他会自动初始化成该类型的默认初始值\n\n（数值型变量初始化成0或0.0，字符型变量的初始化值是16位的0，布尔型默认是false）\n\npublic class employee {\n    //salary是静态的私有变量\n    private static double salary;\n    // department是一个常量\n    public static final string department = "开发人员";\n    public static void main(string[] args){\n        salary = 10000;\n        system.out.println(department+"平均工资:"+salary);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3、常量\n\n常量(constant)：初始化(initialize)后不能再改变值！不会变动的值。\n\n所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。\n\nfinal 常量名=值;\nfinal double pi=3.14;\nfinal string love="hello";\n\n\n1\n2\n3\n\n\n常量名一般使用大写字符。\n\n程序中使用常量可以提高代码的可维护性。例如，在项目开发时，我们需要指定用户的性别，此时可以 定义一个常量 sex，赋值为 "男"，在需要指定用户性别的地方直接调用此常量即可，避免了由于用户的 不规范赋值导致程序出错的情况。\n\n\n# 4、变量的命名规范\n\n 1. 所有变量、方法、类名：见名知意\n 2. 类成员变量：首字母小写和驼峰原则 : monthsalary\n 3. 局部变量：首字母小写和驼峰原则\n 4. 常量：大写字母和下划线：max_value\n 5. 类名：首字母大写和驼峰原则: man, goodman\n 6. 方法名：首字母小写和驼峰原则: run(), runrun()\n\n具体可参考《阿里巴巴java开发手册》',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"关于",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"10.关于",imgUrl:"/img/web.png",description:"关于"}},title:"关于",permalink:"/about",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-05-16T22:59:58.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/10.%E5%85%B3%E4%BA%8E.html",relativePath:"00.目录页/10.关于.md",key:"v-9c3ab8f0",path:"/about/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"数据类型",frontmatter:{title:"数据类型",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/data-type/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"01.Java/02.java-基础/02.基础语法/03.数据类型.md",key:"v-1156e8e2",path:"/java/se/basic-grammar/data-type/",headers:[{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:2},{level:3,title:"1、强弱类型语言",slug:"_1、强弱类型语言",normalizedTitle:"1、强弱类型语言",charIndex:99},{level:3,title:"2、数据类型",slug:"_2、数据类型",normalizedTitle:"2、数据类型",charIndex:560},{level:3,title:"3、整型拓展",slug:"_3、整型拓展",normalizedTitle:"3、整型拓展",charIndex:4332},{level:3,title:"4、浮点型拓展",slug:"_4、浮点型拓展",normalizedTitle:"4、浮点型拓展",charIndex:4622},{level:3,title:"5、字符型拓展",slug:"_5、字符型拓展",normalizedTitle:"5、字符型拓展",charIndex:5438},{level:3,title:"6、布尔型拓展",slug:"_6、布尔型拓展",normalizedTitle:"6、布尔型拓展",charIndex:6392}],headersStr:"数据类型 1、强弱类型语言 2、数据类型 3、整型拓展 4、浮点型拓展 5、字符型拓展 6、布尔型拓展",content:'# 数据类型\n\nJava是一种强类型语言，每个变量都必须声明其类型。\n\n扩展：各种字符集和编码详解(https://www.cnblogs.com/cmt/p/14553189.html)\n\n\n# 1、强弱类型语言\n\n * 强类型语言\n   \n   强类型语言是一种强制类型定义的语言，一旦某一个变量被定义类型，如果不经过强制转换，则它永远就是该数据类型了，强类型语言包括Java、.net 、Python、C++等语言。\n   \n   举个例子：定义了一个整数，如果不进行强制的类型转换，则不可以将该整数转化为字符串。\n\n * 弱类型语言\n   \n   弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换。弱类型语言包括vb 、PHP、javascript等语言。\n   \n   在VB Script中，可以将字符串‘12’和整数3进行连接得到字符串‘123’，也可以把它看成整数123，而不需 要显示转换。是不是十分的随便，我们Java就不是这样的。\n\n * 区别\n   \n   无论是强类型语言还是弱类型语言，判别的根本是是否会隐性的进行语言类型转变。强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。\n\n\n# 2、数据类型\n\nJava的数据类型分为两大类：基本类型（primitive type）和引用类型 （reference type）\n\n\n\n【注：引用数据类型的大小统一为4个字节，记录的是其引用对象的地址！】\n\n\n\n如果你看到这一堆头疼的话，没关系，不用记，JDK中类型对应的包装类都帮忙写好了，我们需要时候可 以直接看到！可以把以下代码拷贝进行查看结果：\n\npublic static void main(String[] args) {\n    // byte\n    System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE);\n    System.out.println("包装类：java.lang.Byte");\n    System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE);\n    System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE);\n    System.out.println();\n    // short\n    System.out.println("基本类型：short 二进制位数：" + Short.SIZE);\n    System.out.println("包装类：java.lang.Short");\n    System.out.println("最小值：Short.MIN_VALUE=" + Short.MIN_VALUE);\n    System.out.println("最大值：Short.MAX_VALUE=" + Short.MAX_VALUE);\n    System.out.println();\n    // int\n    System.out.println("基本类型：int 二进制位数：" + Integer.SIZE);\n    System.out.println("包装类：java.lang.Integer");\n    System.out.println("最小值：Integer.MIN_VALUE=" + Integer.MIN_VALUE);\n    System.out.println("最大值：Integer.MAX_VALUE=" + Integer.MAX_VALUE);\n    System.out.println();\n    // long\n    System.out.println("基本类型：long 二进制位数：" + Long.SIZE);\n    System.out.println("包装类：java.lang.Long");\n    System.out.println("最小值：Long.MIN_VALUE=" + Long.MIN_VALUE);\n    System.out.println("最大值：Long.MAX_VALUE=" + Long.MAX_VALUE);\n    System.out.println();\n    // float\n    System.out.println("基本类型：float 二进制位数：" + Float.SIZE);\n    System.out.println("包装类：java.lang.Float");\n    System.out.println("最小值：Float.MIN_VALUE=" + Float.MIN_VALUE);\n    System.out.println("最大值：Float.MAX_VALUE=" + Float.MAX_VALUE);\n    System.out.println();\n    // double\n    System.out.println("基本类型：double 二进制位数：" + Double.SIZE);\n    System.out.println("包装类：java.lang.Double");\n    System.out.println("最小值：Double.MIN_VALUE=" + Double.MIN_VALUE);\n    System.out.println("最大值：Double.MAX_VALUE=" + Double.MAX_VALUE);\n    System.out.println();\n    // char\n    System.out.println("基本类型：char 二进制位数：" + Character.SIZE);\n    System.out.println("包装类：java.lang.Character");\n    // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台\n    System.out.println("最小值：Character.MIN_VALUE="+ (int) Character.MIN_VALUE);\n    // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台\n    System.out.println("最大值：Character.MAX_VALUE="+ (int) Character.MAX_VALUE);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n字节相关知识：\n\n> 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。\n> \n> 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示。\n> \n> 1B（byte,字节）= 8bit（位）\n> \n> 字符：是指计算机中使用的字母、数字、字和符号\n\nASCIIS码：\n\n内容              占用大小\n1个英文字符（不分大小写）   1个字节\n1个中文汉字          2个字节\n1个ASCII码        1个字节\n\nUTF-8编码：\n\n内容         占用大小\n1个英文字符     1个字节\n英文标点       1个字节\n1个中文（含繁体   3个字节\n中文标点       3个字节\n\nUnicode编码：\n\n内容         占用大小\n1个英文字符     2个字节\n英文标点       2个字节\n1个中文（含繁体   2个字节\n中文标点       2个字节\n\n1bit表示1位 1Byte表示一个字节\n\n1B=8b 1024B=1KB 1024KB=1M 1024M=1G\n\n----------------------------------------\n\n那有人会问：电脑的32位和64位的区别是什么呢？\n\n * 32位操作系统只可以使用32位的cpu，而64位的CPU既可以安装32位操作系统也可以安装64位操作 系统。\n\n * 寻址能力简单点说就是支持的内存大小能力，64位系统最多可以支达128 GB的内存，而32位系统最 多只可以支持4G内存。\n\n * 32位操作系统只可以安装使用32位架构设计的软件，而64位的CPU既可以安装使用32位软件也可以 安装使用64位软件。\n\n * 现在的电脑都是64位了！\n\n回到正题，我们了解了这些知识后，我们自己定义一些变量来看！\n\npublic static void main(String[] args) {\n    //整型\n    int i1=100;\n    //长整型\n    long i2=998877665544332211L;\n    //短整型\n    short i3=235;\n    //浮点型\n    double d1=3.5; //双精度\n    double d2=3;\n    float f1=(float)3.5; //单精度\n    float f2=3.5f; //单精度\n    //布尔类型 boolean true真/false假\n    boolean isPass=true;\n    boolean isOk=false;\n    boolean isBig=5>8;\n    if(isPass){\n    System.out.println("通过了");\n    }else{\n    System.out.println("未通过");\n    }\n    //单字符\n    char f=\'女\';\n    char m=\'男\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nJava语言的整型常数默认为int型，浮点数默认是Double\n\n\n# 3、整型拓展\n\n在我们计算机中存在很多进制问题，十进制，八进制，十六进制等等的问题，他们怎么表示呢？\n\n * 十进制整数，如：99, -500, 0。\n\n * 八进制整数，要求以 0 开头，如：015。\n\n * 十六进制数，要求 0x 或 0X 开头，如：0x15 。\n\n演示：\n\n//整型\nint i= 10;\nint i2= 010;\nint i3= 0x10;\nSystem.out.println(i); //10\nSystem.out.println(i2); //8\nSystem.out.println(i3); //16\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4、浮点型拓展\n\n【金融面试问：银行金融业务用什么类型表示？】\n\n浮点类型float, double的数据不适合在不容许舍入误差的金融计算领域。\n\n如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。\n\npublic static void main(String[] args) {\n    float f = 0.1f;\n    double d = 1.0/10;\n    System.out.println(f==d); //false\n    \n    float d1 = 2131231231f;\n    float d2 = d1+1;\n    if(d1==d2){\n        System.out.println("d1==d2");\n    }else{\n        System.out.println("d1!=d2");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n最后运行结果：\n\n> false d1==d2\n\n主要理由：\n\n由于字长有限，浮点数能够精确表示的数是有限的，因而也是离散的。浮点数一般都存在舍入误差，很 多数字无法精确表示，其结果只能是接近，但不等于；二进制浮点数不能精确的表示0.1,0.01,0.001这样10的负次幂。并不是所有的小数都能可以精确的用二进制浮点数表示。\n\n大数值：Java.math下面的两个有用的类：BigInteger和BigDecimal，这两个类可以处理任意长度的数 值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。\n\n浮点数使用总结：\n\n 1. 默认是double\n 2. 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需 要使用BigDecimal类。\n 3. 避免比较中使用浮点数\n\n\n# 5、字符型拓展\n\n单引号用来表示字符常量。例如‘A’是一个字符，它与“A”是不同的，“A”表示一个字符串。\n\nchar 类型用来表示在Unicode编码表中的字符。\n\nUnicode编码被设计用来处理各种语言的所有文字，它占2个字节，可允许有65536个字符；\n\n科普：2字节=16位，2的16次方=65536，我们用的Excel原来就只有这么多行，并不是无限的\n\n【代码演示：字符转int看结果】\n\npublic static void main(String[] args) {\n    char c1 = \'a\';\n    char c2 = \'中\';\n    System.out.println(c1);\n    System.out.println((int) c1); //97\n    System.out.println(c2);\n    System.out.println((int) c2); //20013\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nUnicode具有从0到65535之间的编码，他们通常用从’u0000’到’uFFFF’之间的十六进制值来表示（前缀为 u表示Unicode）\n\nchar c3 = \'\\u0061\';\nSystem.out.println(c3); //a\n\n\n1\n2\n\n\nJava 语言中还允许使用转义字符 ‘’ 来将其后的字符转变为其它的含义，有如下常用转义字符：\n\n\n\n【以后我们学的String类，其实是字符序列(char sequence)。在这里给大家一个思考题】\n\n//代码1\nString sa=new String("Hello world");\nString sb=new String("Hello world");\nSystem.out.println(sa==sb); // false\n//代码2\nString sc="Hello world";\nString sd="Hello world";\nSystem.out.println(sc==sd); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n大家可以先思考下为什么，之后我们学到对象的时候，会给大家进行内存级别的分析，那时候你会恍然 大悟！\n\n\n# 6、布尔型拓展\n\nboolean类型（一位，不是一个字节），就是0|1\n\nboolean类型有两个值，true和false,不可以 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。\n\nboolean 类型用来判断逻辑条件，一般用于程序流程控制。\n\nboolean flag = false;\nif(flag){\n    // true分支\n}else{\n    // false分支\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【编码规范：很多新手程序员喜欢这样写】\n\nif (is == true && un == false ) {...}\n\n\n1\n\n\n只有新手才那么写。对于一个熟练的人来说，应该用如下方式来表示：\n\nif ( is && !un ) {....}\n\n\n1\n\n\n前面加个 ! 表示否定\n\n这点都不难理解吧。所以要习惯去掉所有的==fasle 和 ==true。Less is More！！ 代码要精简易读！',normalizedContent:'# 数据类型\n\njava是一种强类型语言，每个变量都必须声明其类型。\n\n扩展：各种字符集和编码详解(https://www.cnblogs.com/cmt/p/14553189.html)\n\n\n# 1、强弱类型语言\n\n * 强类型语言\n   \n   强类型语言是一种强制类型定义的语言，一旦某一个变量被定义类型，如果不经过强制转换，则它永远就是该数据类型了，强类型语言包括java、.net 、python、c++等语言。\n   \n   举个例子：定义了一个整数，如果不进行强制的类型转换，则不可以将该整数转化为字符串。\n\n * 弱类型语言\n   \n   弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换。弱类型语言包括vb 、php、javascript等语言。\n   \n   在vb script中，可以将字符串‘12’和整数3进行连接得到字符串‘123’，也可以把它看成整数123，而不需 要显示转换。是不是十分的随便，我们java就不是这样的。\n\n * 区别\n   \n   无论是强类型语言还是弱类型语言，判别的根本是是否会隐性的进行语言类型转变。强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。\n\n\n# 2、数据类型\n\njava的数据类型分为两大类：基本类型（primitive type）和引用类型 （reference type）\n\n\n\n【注：引用数据类型的大小统一为4个字节，记录的是其引用对象的地址！】\n\n\n\n如果你看到这一堆头疼的话，没关系，不用记，jdk中类型对应的包装类都帮忙写好了，我们需要时候可 以直接看到！可以把以下代码拷贝进行查看结果：\n\npublic static void main(string[] args) {\n    // byte\n    system.out.println("基本类型：byte 二进制位数：" + byte.size);\n    system.out.println("包装类：java.lang.byte");\n    system.out.println("最小值：byte.min_value=" + byte.min_value);\n    system.out.println("最大值：byte.max_value=" + byte.max_value);\n    system.out.println();\n    // short\n    system.out.println("基本类型：short 二进制位数：" + short.size);\n    system.out.println("包装类：java.lang.short");\n    system.out.println("最小值：short.min_value=" + short.min_value);\n    system.out.println("最大值：short.max_value=" + short.max_value);\n    system.out.println();\n    // int\n    system.out.println("基本类型：int 二进制位数：" + integer.size);\n    system.out.println("包装类：java.lang.integer");\n    system.out.println("最小值：integer.min_value=" + integer.min_value);\n    system.out.println("最大值：integer.max_value=" + integer.max_value);\n    system.out.println();\n    // long\n    system.out.println("基本类型：long 二进制位数：" + long.size);\n    system.out.println("包装类：java.lang.long");\n    system.out.println("最小值：long.min_value=" + long.min_value);\n    system.out.println("最大值：long.max_value=" + long.max_value);\n    system.out.println();\n    // float\n    system.out.println("基本类型：float 二进制位数：" + float.size);\n    system.out.println("包装类：java.lang.float");\n    system.out.println("最小值：float.min_value=" + float.min_value);\n    system.out.println("最大值：float.max_value=" + float.max_value);\n    system.out.println();\n    // double\n    system.out.println("基本类型：double 二进制位数：" + double.size);\n    system.out.println("包装类：java.lang.double");\n    system.out.println("最小值：double.min_value=" + double.min_value);\n    system.out.println("最大值：double.max_value=" + double.max_value);\n    system.out.println();\n    // char\n    system.out.println("基本类型：char 二进制位数：" + character.size);\n    system.out.println("包装类：java.lang.character");\n    // 以数值形式而不是字符形式将character.min_value输出到控制台\n    system.out.println("最小值：character.min_value="+ (int) character.min_value);\n    // 以数值形式而不是字符形式将character.max_value输出到控制台\n    system.out.println("最大值：character.max_value="+ (int) character.max_value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n字节相关知识：\n\n> 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。\n> \n> 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 b 来表示。\n> \n> 1b（byte,字节）= 8bit（位）\n> \n> 字符：是指计算机中使用的字母、数字、字和符号\n\nasciis码：\n\n内容              占用大小\n1个英文字符（不分大小写）   1个字节\n1个中文汉字          2个字节\n1个ascii码        1个字节\n\nutf-8编码：\n\n内容         占用大小\n1个英文字符     1个字节\n英文标点       1个字节\n1个中文（含繁体   3个字节\n中文标点       3个字节\n\nunicode编码：\n\n内容         占用大小\n1个英文字符     2个字节\n英文标点       2个字节\n1个中文（含繁体   2个字节\n中文标点       2个字节\n\n1bit表示1位 1byte表示一个字节\n\n1b=8b 1024b=1kb 1024kb=1m 1024m=1g\n\n----------------------------------------\n\n那有人会问：电脑的32位和64位的区别是什么呢？\n\n * 32位操作系统只可以使用32位的cpu，而64位的cpu既可以安装32位操作系统也可以安装64位操作 系统。\n\n * 寻址能力简单点说就是支持的内存大小能力，64位系统最多可以支达128 gb的内存，而32位系统最 多只可以支持4g内存。\n\n * 32位操作系统只可以安装使用32位架构设计的软件，而64位的cpu既可以安装使用32位软件也可以 安装使用64位软件。\n\n * 现在的电脑都是64位了！\n\n回到正题，我们了解了这些知识后，我们自己定义一些变量来看！\n\npublic static void main(string[] args) {\n    //整型\n    int i1=100;\n    //长整型\n    long i2=998877665544332211l;\n    //短整型\n    short i3=235;\n    //浮点型\n    double d1=3.5; //双精度\n    double d2=3;\n    float f1=(float)3.5; //单精度\n    float f2=3.5f; //单精度\n    //布尔类型 boolean true真/false假\n    boolean ispass=true;\n    boolean isok=false;\n    boolean isbig=5>8;\n    if(ispass){\n    system.out.println("通过了");\n    }else{\n    system.out.println("未通过");\n    }\n    //单字符\n    char f=\'女\';\n    char m=\'男\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\njava语言的整型常数默认为int型，浮点数默认是double\n\n\n# 3、整型拓展\n\n在我们计算机中存在很多进制问题，十进制，八进制，十六进制等等的问题，他们怎么表示呢？\n\n * 十进制整数，如：99, -500, 0。\n\n * 八进制整数，要求以 0 开头，如：015。\n\n * 十六进制数，要求 0x 或 0x 开头，如：0x15 。\n\n演示：\n\n//整型\nint i= 10;\nint i2= 010;\nint i3= 0x10;\nsystem.out.println(i); //10\nsystem.out.println(i2); //8\nsystem.out.println(i3); //16\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4、浮点型拓展\n\n【金融面试问：银行金融业务用什么类型表示？】\n\n浮点类型float, double的数据不适合在不容许舍入误差的金融计算领域。\n\n如果需要进行不产生舍入误差的精确数字计算，需要使用bigdecimal类。\n\npublic static void main(string[] args) {\n    float f = 0.1f;\n    double d = 1.0/10;\n    system.out.println(f==d); //false\n    \n    float d1 = 2131231231f;\n    float d2 = d1+1;\n    if(d1==d2){\n        system.out.println("d1==d2");\n    }else{\n        system.out.println("d1!=d2");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n最后运行结果：\n\n> false d1==d2\n\n主要理由：\n\n由于字长有限，浮点数能够精确表示的数是有限的，因而也是离散的。浮点数一般都存在舍入误差，很 多数字无法精确表示，其结果只能是接近，但不等于；二进制浮点数不能精确的表示0.1,0.01,0.001这样10的负次幂。并不是所有的小数都能可以精确的用二进制浮点数表示。\n\n大数值：java.math下面的两个有用的类：biginteger和bigdecimal，这两个类可以处理任意长度的数 值。biginteger实现了任意精度的整数运算。bigdecimal实现了任意精度的浮点运算。\n\n浮点数使用总结：\n\n 1. 默认是double\n 2. 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需 要使用bigdecimal类。\n 3. 避免比较中使用浮点数\n\n\n# 5、字符型拓展\n\n单引号用来表示字符常量。例如‘a’是一个字符，它与“a”是不同的，“a”表示一个字符串。\n\nchar 类型用来表示在unicode编码表中的字符。\n\nunicode编码被设计用来处理各种语言的所有文字，它占2个字节，可允许有65536个字符；\n\n科普：2字节=16位，2的16次方=65536，我们用的excel原来就只有这么多行，并不是无限的\n\n【代码演示：字符转int看结果】\n\npublic static void main(string[] args) {\n    char c1 = \'a\';\n    char c2 = \'中\';\n    system.out.println(c1);\n    system.out.println((int) c1); //97\n    system.out.println(c2);\n    system.out.println((int) c2); //20013\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nunicode具有从0到65535之间的编码，他们通常用从’u0000’到’uffff’之间的十六进制值来表示（前缀为 u表示unicode）\n\nchar c3 = \'\\u0061\';\nsystem.out.println(c3); //a\n\n\n1\n2\n\n\njava 语言中还允许使用转义字符 ‘’ 来将其后的字符转变为其它的含义，有如下常用转义字符：\n\n\n\n【以后我们学的string类，其实是字符序列(char sequence)。在这里给大家一个思考题】\n\n//代码1\nstring sa=new string("hello world");\nstring sb=new string("hello world");\nsystem.out.println(sa==sb); // false\n//代码2\nstring sc="hello world";\nstring sd="hello world";\nsystem.out.println(sc==sd); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n大家可以先思考下为什么，之后我们学到对象的时候，会给大家进行内存级别的分析，那时候你会恍然 大悟！\n\n\n# 6、布尔型拓展\n\nboolean类型（一位，不是一个字节），就是0|1\n\nboolean类型有两个值，true和false,不可以 0 或非 0 的整数替代 true 和 false ，这点和c语言不同。\n\nboolean 类型用来判断逻辑条件，一般用于程序流程控制。\n\nboolean flag = false;\nif(flag){\n    // true分支\n}else{\n    // false分支\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【编码规范：很多新手程序员喜欢这样写】\n\nif (is == true && un == false ) {...}\n\n\n1\n\n\n只有新手才那么写。对于一个熟练的人来说，应该用如下方式来表示：\n\nif ( is && !un ) {....}\n\n\n1\n\n\n前面加个 ! 表示否定\n\n这点都不难理解吧。所以要习惯去掉所有的==fasle 和 ==true。less is more！！ 代码要精简易读！',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"包机制",frontmatter:{title:"包机制",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/packet/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07.%E5%8C%85%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java/02.java-基础/02.基础语法/07.包机制.md",key:"v-4f888be4",path:"/java/se/basic-grammar/packet/",headers:[{level:2,title:"1、问题发现",slug:"_1、问题发现",normalizedTitle:"1、问题发现",charIndex:10},{level:2,title:"2、包的作用",slug:"_2、包的作用",normalizedTitle:"2、包的作用",charIndex:419},{level:2,title:"3、创建包",slug:"_3、创建包",normalizedTitle:"3、创建包",charIndex:1278},{level:2,title:"4、import 关键字",slug:"_4、import-关键字",normalizedTitle:"4、import 关键字",charIndex:1613}],headersStr:"1、问题发现 2、包的作用 3、创建包 4、import 关键字",content:'# 包机制\n\n\n# 1、问题发现\n\n存在这样一个问题：当定义了多个类的时候，可能会发生类名的重复问题。\n\n解决方式：在java中采用包机制处理开发者定义的类名冲突问题。\n\n就好比我们平时的用电脑，一个文件夹下不能存在同名的文件，我们要是有这样的需求，但是又不想换 名字，我们就可以考虑使用新建一个文件夹来存放！在我们的Java中也是这样的。\n\n我们在idea中创建包，输入代码后，第一行idea默认会有：package 包名路径，例如\n\n\n\n\n\n就要求此份java文件必须保存在这样一个目录下，这样Java解释器才能找到它。 在IDEA中能正确运行， 你可以去Windows下的工程中查看，HelloWorld这个文件必是在这样的目录结构下的。\n\n3-6行是文档注释，便于把java文件打包成文档自动生成文件信息，以后会遇到，在阿里巴巴开发手册中，要求添加@author的注释信息 ，可以下载个阿里巴巴开发手册插件配置在ide里\n\n\n# 2、包的作用\n\n为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。\n\n包的作用：\n\n1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n\n2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n\n3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\nJava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n\n包语句的语法格式为：\n\npackage pkg1[．pkg2[．pkg3…]];\n\n\n1\n\n\n例如,一个Something.java 文件它的内容:\n\npackage net.java.util;\npublic class Something{\n...\n}\n\n\n1\n2\n3\n4\n\n\n那么它的路径应该是 net/java/util/Something.java 这样保存的。\n\npackage(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。\n\n一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问 保护和命名空间管理的功能。\n\n以下是一些 Java 中的包：\n\n * java.lang-打包基础的类\n * java.io-包含输入输出功能的函数\n\n开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和 注释等是相关的。\n\n由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这 种机制，更容易实现访问控制，并且让定位相关类更加简单。\n\n\n# 3、创建包\n\n创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。\n\n包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。\n\n如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包 （unnamed package）中。\n\n一般利用公司域名倒置作为报名；\n\n例子：\n\nwww.baidu.com 包名：com.baidu.www\n\nbbs.baidu.com 包名：com.baidu.bbs\n\n我们平时也可以按照自己的公司域名去写，比如：com.kuangstudy.utils\n\n\n# 4、import 关键字\n\n为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 "import" 语句可完成此功能。\n\n在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：\n\nimport package1[.package2…].(classname|*);\n\n\n1\n\n\n如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。\n\n要是要用到其他包下的类，就必须要先导包！\n\n如果两个类重名，需要导入对应的包，否则就需要写出完整地址：\n\ncom.kuang.dao.Hello hello = new com.kuang.dao.Hello()\n\n\n1\n\n\n用 import 关键字引入，使用通配符 "*" , 导入io包下的所有类！\n\nimport java.io.*;\n\n\n1\n\n\n【不建议这样使用，因为会全局扫描，影响速度！】\n\n使用 import 关键字引入指定类:\n\nimport com.kuang.Hello;\n\n\n1\n\n\n【注意】类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。\n\n【编码规范：推荐参考阿里巴巴开发手册编程规范】',normalizedContent:'# 包机制\n\n\n# 1、问题发现\n\n存在这样一个问题：当定义了多个类的时候，可能会发生类名的重复问题。\n\n解决方式：在java中采用包机制处理开发者定义的类名冲突问题。\n\n就好比我们平时的用电脑，一个文件夹下不能存在同名的文件，我们要是有这样的需求，但是又不想换 名字，我们就可以考虑使用新建一个文件夹来存放！在我们的java中也是这样的。\n\n我们在idea中创建包，输入代码后，第一行idea默认会有：package 包名路径，例如\n\n\n\n\n\n就要求此份java文件必须保存在这样一个目录下，这样java解释器才能找到它。 在idea中能正确运行， 你可以去windows下的工程中查看，helloworld这个文件必是在这样的目录结构下的。\n\n3-6行是文档注释，便于把java文件打包成文档自动生成文件信息，以后会遇到，在阿里巴巴开发手册中，要求添加@author的注释信息 ，可以下载个阿里巴巴开发手册插件配置在ide里\n\n\n# 2、包的作用\n\n为了更好地组织类，java 提供了包机制，用于区别类名的命名空间。\n\n包的作用：\n\n1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n\n2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n\n3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\njava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n\n包语句的语法格式为：\n\npackage pkg1[．pkg2[．pkg3…]];\n\n\n1\n\n\n例如,一个something.java 文件它的内容:\n\npackage net.java.util;\npublic class something{\n...\n}\n\n\n1\n2\n3\n4\n\n\n那么它的路径应该是 net/java/util/something.java 这样保存的。\n\npackage(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。\n\n一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问 保护和命名空间管理的功能。\n\n以下是一些 java 中的包：\n\n * java.lang-打包基础的类\n * java.io-包含输入输出功能的函数\n\n开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和 注释等是相关的。\n\n由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这 种机制，更容易实现访问控制，并且让定位相关类更加简单。\n\n\n# 3、创建包\n\n创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。\n\n包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。\n\n如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包 （unnamed package）中。\n\n一般利用公司域名倒置作为报名；\n\n例子：\n\nwww.baidu.com 包名：com.baidu.www\n\nbbs.baidu.com 包名：com.baidu.bbs\n\n我们平时也可以按照自己的公司域名去写，比如：com.kuangstudy.utils\n\n\n# 4、import 关键字\n\n为了能够使用某一个包的成员，我们需要在 java 程序中明确导入该包。使用 "import" 语句可完成此功能。\n\n在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：\n\nimport package1[.package2…].(classname|*);\n\n\n1\n\n\n如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。\n\n要是要用到其他包下的类，就必须要先导包！\n\n如果两个类重名，需要导入对应的包，否则就需要写出完整地址：\n\ncom.kuang.dao.hello hello = new com.kuang.dao.hello()\n\n\n1\n\n\n用 import 关键字引入，使用通配符 "*" , 导入io包下的所有类！\n\nimport java.io.*;\n\n\n1\n\n\n【不建议这样使用，因为会全局扫描，影响速度！】\n\n使用 import 关键字引入指定类:\n\nimport com.kuang.hello;\n\n\n1\n\n\n【注意】类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。\n\n【编码规范：推荐参考阿里巴巴开发手册编程规范】',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"运算符",frontmatter:{title:"运算符",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/operator/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06.%E8%BF%90%E7%AE%97%E7%AC%A6.html",relativePath:"01.Java/02.java-基础/02.基础语法/06.运算符.md",key:"v-33e78c7a",path:"/java/se/basic-grammar/operator/",headers:[{level:2,title:"运算符",slug:"运算符",normalizedTitle:"运算符",charIndex:2},{level:3,title:"1、二元运算符",slug:"_1、二元运算符",normalizedTitle:"1、二元运算符",charIndex:201},{level:3,title:"2、取模运算",slug:"_2、取模运算",normalizedTitle:"2、取模运算",charIndex:1264},{level:3,title:"3、一元运算符",slug:"_3、一元运算符",normalizedTitle:"3、一元运算符",charIndex:1607},{level:3,title:"4、逻辑运算符",slug:"_4、逻辑运算符",normalizedTitle:"4、逻辑运算符",charIndex:2026},{level:3,title:"5、位运算符",slug:"_5、位运算符",normalizedTitle:"5、位运算符",charIndex:2781},{level:3,title:"6、扩展运算符",slug:"_6、扩展运算符",normalizedTitle:"6、扩展运算符",charIndex:3515},{level:3,title:"7、字符串连接符",slug:"_7、字符串连接符",normalizedTitle:"7、字符串连接符",charIndex:3686},{level:3,title:"8、三目条件运算符",slug:"_8、三目条件运算符",normalizedTitle:"8、三目条件运算符",charIndex:3883},{level:3,title:"9、运算符优先级",slug:"_9、运算符优先级",normalizedTitle:"9、运算符优先级",charIndex:4225},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"运算符 1、二元运算符 2、取模运算 3、一元运算符 4、逻辑运算符 5、位运算符 6、扩展运算符 7、字符串连接符 8、三目条件运算符 9、运算符优先级 ",content:'# 运算符\n\n运算符operator\n\nJava 语言支持如下运算符：\n\n * 算术运算符 +，-，*，/，%，++，--\n * 赋值运算符 =\n * 关系运算符 >，<，>=，<=，==，!= instanceof\n * 逻辑运算符 &&，||，!\n * 位运算符 &，|，^，~ ， >>，<<，>>> (了解！！！)\n * 条件运算符 ？：\n * 扩展赋值运算符 +=，-=，*=，/=\n\n\n# 1、二元运算符\n\n两个操作数，来看看我们小时候的数学运算；\n\npublic static void main(String[] args) {\n    int a = 10;\n    int b = 20;\n    int c = 25;\n    int d = 25;\n    System.out.println("a + b = " + (a + b) );\n    System.out.println("a - b = " + (a - b) );\n    System.out.println("a * b = " + (a * b) );\n    System.out.println("b / a = " + (b / a) );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n整数运算\n\n如果两个操作数有一个为Long, 则结果也为long\n\n没有long时，结果为int。即使操作数全为shot,byte，结果也是int.\n\npublic static void main(String[] args) {\n    long a = 1231321311231231L;\n    int b = 1213;\n    short c = 10;\n    byte d = 8;\n\n    System.out.println(a + b + c + d); //Long类型\n    System.out.println(b + c + d);//Int类型\n    System.out.println(c + d);//Int类型\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n浮点运算\n\n如果两个操作数有一个为double, 则结果为double\n\n只有两个操作数都是float, 则结果才为float\n\npublic static void main(String[] args) {\n    float a = 3.14565F;\n    double b = 3.194546464;\n    float c = 1.3123123F;\n    System.out.println(a+b); //double类型\n    System.out.println(b+c); //double类型\n    System.out.println(a+c); //float类型\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n关系运算符\n\n返回布尔值！\n\n\n\n可参考 菜鸟教程\n\n\n# 2、取模运算\n\n就是我们小学的取余；\n\n> 5%3 余 2\n\n其操作数可以为浮点数,一般使用整数。如：5.9%3.9=2.000000004\n\n要点：\n\n负数%负数＝负数；\n\n负数%正数＝负数；\n\n正数%负数＝正数；\n\npublic static void main(String[] args) {\n    System.out.println(9 % 4); //1\n    System.out.println(-9 % -4); //-1\n    System.out.println(-10 % 4); //-2\n    System.out.println(9 % -4); //1\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【注：一般都是正整数运算，进行结果的判断！】\n\n\n# 3、一元运算符\n\n自增（++）自减（--）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算， 而自增自减运算符是一个操作数，分为前缀和后缀两种。\n\npublic static void main(String[] args) {\n    int a = 3;\n    int b = a++; //执行完后,b=3。先给b赋值，再自增。\n    int c = ++a; //执行完后,c=5。先自增,再给b赋值\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意：java中的乘幂处理\n\npublic static void main(String[] args) {\n    int a = 3^2; //java中不能这么处理， ^是异或符号。\n    double b = Math.pow(3, 2);\n}\n\n\n1\n2\n3\n4\n\n\nMath类提供了很多科学和工程计算需要的方法和常数。特殊的运算都需要运用到方法!\n\n\n# 4、逻辑运算符\n\n逻辑与：&&和& 逻辑或：||和| 逻辑非：！\n\n\n\n【演示】\n\npublic static void main(String[] args) {\n    boolean a = true;\n    boolean b = false;\n    System.out.println("a && b = " + (a&&b));\n    System.out.println("a || b = " + (a||b) );\n    System.out.println("!(a && b) = " + !(a && b));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n逻辑与 和 逻辑或 采用短路的方式。从左到右计算，如果确定值则不会再计算下去。在两个操作数都为 true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断 第二个操作了。\n\n逻辑与只要有一个为false, 则直接返回false.\n\n逻辑或只要有一个为true, 则直接返回true;\n\npublic static void main(String[] args){\n    int a = 5;//定义一个变量；\n    boolean b = (a<4)&&(a++<10);\n    System.out.println("使用短路逻辑运算符的结果为"+b);\n    System.out.println("a的结果为"+a);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n解析： 该程序使用到了短路逻辑运算符(&&)，首先判断 a<4 的结果为 false，则 b 的结果必定是 false， 所以不再执行第二个操作 a++<10 的判断，所以 a 的值为 5。\n\n\n# 5、位运算符\n\nJava定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型 (byte)等类型。位运算符作用在所有的位上，并且按位运算。\n\n假设a = 60，b = 13;它们的二进制格式表示将如下：\n\nA = 0011 1100\nB = 0000 1101\n-----------------\nA&B = 0000 1100\nA | B = 0011 1101\nA ^ B = 0011 0001\n~A= 1100 0011\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n右移一位相当于除2取商。\n\n左移一位相当于乘2。\n\n【常见面试题：int a=2*8怎样运算效率最快？】\n\npublic static void main(String[] args) {\n    System.out.println(2 << 3);\n}\n\n\n1\n2\n3\n\n\n用移位运算 int a=2<<3; a就是2乘以8 最后结果是16 这是最省内存 最有效率的方法\n\n这个方法确实高效率的。我来解释一下： 2的二进制是10 在32位存储器里面是0000 0000 0000 0010 左移三位后变成 0000 0000 0001 0000 也就是16\n\n解释一下，在系统中运算是以二进制的形式进行的。相比来说俩个二进制数相乘运算比移位运算慢一 些。\n\n位操作是程序设计中对位模式按位或二进制数的一元和二元操作。 在许多古老的微处理器上， 位运算比加减运算略快， 通常位运算比乘除法运算要快很多。 在现代架构中， 情况并非如此：位运算的运算速度 通常与加法运算相同(仍然快于乘法运算). 详细的需要了解计算机的组成原理！\n\n\n# 6、扩展运算符\n\n\n\npublic static void main(String[] args) {\n    int a=10;\n    int b=20;\n    \n    a+=b; // a = a + b\n    \n    System.out.println(a+":"+b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7、字符串连接符\n\n“+” 运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串 然后再进行连接。\n\n//字符串\nString s1="Hello 中文!";\nString s2=1+""; //转换成String\n//int\nint c = 12;\nSystem.out.println("c=" + c);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 8、三目条件运算符\n\n三目条件运算符，语法格式：\n\n> x ? y : z\n\n其中x为boolean类型表达式，先计算x的值，若为true，则整个三目运算的结果为表达式y的值，否则整个运算结果为表达式z的值。\n\n【演示】\n\npublic static void main(String[] args) {\n    int score = 80;\n    String type = score < 60 ? "不及格" : "及格";\n    System.out.println("type= " + type);\n}\n\n\n1\n2\n3\n4\n5\n\n\n三元运算符在真实开发中十分的常见，大家可以多练习使用，之后我们会讲解分支语句，可以利用三元运算符做到更加精简代码！便于理解！\n\n\n# 9、运算符优先级\n\n我们小学都学过：先加减，后乘除，所以优先级我们并不陌生。\n\n当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。\n\n下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。\n\n类别     操作符                                       关联性\n后缀     () [] . (点操作符)                            左到右\n一元     expr++ expr--                             从左到右\n一元     ++expr --expr + - ～ ！                     从右到左\n乘性     * /％                                      左到右\n加性     + -                                       左到右\n移位     >> >>> <<                                 左到右\n关系     > >= < <=                                 左到右\n相等     == !=                                     左到右\n按位与    ＆                                         左到右\n按位异或   ^                                         左到右\n按位或    |                                         左到右\n逻辑与    &&                                        左到右\n逻辑或    | |                                       左到右\n条件     ？：                                        从右到左\n赋值     = + = - = * = / =％= >> = << =＆= ^ = | =   从右到左\n逗号     ，                                         左到右\n\n大家不需要去刻意的记住，表达式里面优先使用小括号来组织！！方便理解和使用，不建议写非常冗余 的代码运算！\n\npublic static void main(String[] args) {\n    boolean flag = 1<4*5&&122>3||\'q\'+3<5;\n    System.out.println(flag);\n}\n\n\n1\n2\n3\n4\n\n\n\n#',normalizedContent:'# 运算符\n\n运算符operator\n\njava 语言支持如下运算符：\n\n * 算术运算符 +，-，*，/，%，++，--\n * 赋值运算符 =\n * 关系运算符 >，<，>=，<=，==，!= instanceof\n * 逻辑运算符 &&，||，!\n * 位运算符 &，|，^，~ ， >>，<<，>>> (了解！！！)\n * 条件运算符 ？：\n * 扩展赋值运算符 +=，-=，*=，/=\n\n\n# 1、二元运算符\n\n两个操作数，来看看我们小时候的数学运算；\n\npublic static void main(string[] args) {\n    int a = 10;\n    int b = 20;\n    int c = 25;\n    int d = 25;\n    system.out.println("a + b = " + (a + b) );\n    system.out.println("a - b = " + (a - b) );\n    system.out.println("a * b = " + (a * b) );\n    system.out.println("b / a = " + (b / a) );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n整数运算\n\n如果两个操作数有一个为long, 则结果也为long\n\n没有long时，结果为int。即使操作数全为shot,byte，结果也是int.\n\npublic static void main(string[] args) {\n    long a = 1231321311231231l;\n    int b = 1213;\n    short c = 10;\n    byte d = 8;\n\n    system.out.println(a + b + c + d); //long类型\n    system.out.println(b + c + d);//int类型\n    system.out.println(c + d);//int类型\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n浮点运算\n\n如果两个操作数有一个为double, 则结果为double\n\n只有两个操作数都是float, 则结果才为float\n\npublic static void main(string[] args) {\n    float a = 3.14565f;\n    double b = 3.194546464;\n    float c = 1.3123123f;\n    system.out.println(a+b); //double类型\n    system.out.println(b+c); //double类型\n    system.out.println(a+c); //float类型\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n关系运算符\n\n返回布尔值！\n\n\n\n可参考 菜鸟教程\n\n\n# 2、取模运算\n\n就是我们小学的取余；\n\n> 5%3 余 2\n\n其操作数可以为浮点数,一般使用整数。如：5.9%3.9=2.000000004\n\n要点：\n\n负数%负数＝负数；\n\n负数%正数＝负数；\n\n正数%负数＝正数；\n\npublic static void main(string[] args) {\n    system.out.println(9 % 4); //1\n    system.out.println(-9 % -4); //-1\n    system.out.println(-10 % 4); //-2\n    system.out.println(9 % -4); //1\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【注：一般都是正整数运算，进行结果的判断！】\n\n\n# 3、一元运算符\n\n自增（++）自减（--）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算， 而自增自减运算符是一个操作数，分为前缀和后缀两种。\n\npublic static void main(string[] args) {\n    int a = 3;\n    int b = a++; //执行完后,b=3。先给b赋值，再自增。\n    int c = ++a; //执行完后,c=5。先自增,再给b赋值\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意：java中的乘幂处理\n\npublic static void main(string[] args) {\n    int a = 3^2; //java中不能这么处理， ^是异或符号。\n    double b = math.pow(3, 2);\n}\n\n\n1\n2\n3\n4\n\n\nmath类提供了很多科学和工程计算需要的方法和常数。特殊的运算都需要运用到方法!\n\n\n# 4、逻辑运算符\n\n逻辑与：&&和& 逻辑或：||和| 逻辑非：！\n\n\n\n【演示】\n\npublic static void main(string[] args) {\n    boolean a = true;\n    boolean b = false;\n    system.out.println("a && b = " + (a&&b));\n    system.out.println("a || b = " + (a||b) );\n    system.out.println("!(a && b) = " + !(a && b));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n逻辑与 和 逻辑或 采用短路的方式。从左到右计算，如果确定值则不会再计算下去。在两个操作数都为 true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断 第二个操作了。\n\n逻辑与只要有一个为false, 则直接返回false.\n\n逻辑或只要有一个为true, 则直接返回true;\n\npublic static void main(string[] args){\n    int a = 5;//定义一个变量；\n    boolean b = (a<4)&&(a++<10);\n    system.out.println("使用短路逻辑运算符的结果为"+b);\n    system.out.println("a的结果为"+a);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n解析： 该程序使用到了短路逻辑运算符(&&)，首先判断 a<4 的结果为 false，则 b 的结果必定是 false， 所以不再执行第二个操作 a++<10 的判断，所以 a 的值为 5。\n\n\n# 5、位运算符\n\njava定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型 (byte)等类型。位运算符作用在所有的位上，并且按位运算。\n\n假设a = 60，b = 13;它们的二进制格式表示将如下：\n\na = 0011 1100\nb = 0000 1101\n-----------------\na&b = 0000 1100\na | b = 0011 1101\na ^ b = 0011 0001\n~a= 1100 0011\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n右移一位相当于除2取商。\n\n左移一位相当于乘2。\n\n【常见面试题：int a=2*8怎样运算效率最快？】\n\npublic static void main(string[] args) {\n    system.out.println(2 << 3);\n}\n\n\n1\n2\n3\n\n\n用移位运算 int a=2<<3; a就是2乘以8 最后结果是16 这是最省内存 最有效率的方法\n\n这个方法确实高效率的。我来解释一下： 2的二进制是10 在32位存储器里面是0000 0000 0000 0010 左移三位后变成 0000 0000 0001 0000 也就是16\n\n解释一下，在系统中运算是以二进制的形式进行的。相比来说俩个二进制数相乘运算比移位运算慢一 些。\n\n位操作是程序设计中对位模式按位或二进制数的一元和二元操作。 在许多古老的微处理器上， 位运算比加减运算略快， 通常位运算比乘除法运算要快很多。 在现代架构中， 情况并非如此：位运算的运算速度 通常与加法运算相同(仍然快于乘法运算). 详细的需要了解计算机的组成原理！\n\n\n# 6、扩展运算符\n\n\n\npublic static void main(string[] args) {\n    int a=10;\n    int b=20;\n    \n    a+=b; // a = a + b\n    \n    system.out.println(a+":"+b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7、字符串连接符\n\n“+” 运算符两侧的操作数中只要有一个是字符串(string)类型，系统会自动将另一个操作数转换为字符串 然后再进行连接。\n\n//字符串\nstring s1="hello 中文!";\nstring s2=1+""; //转换成string\n//int\nint c = 12;\nsystem.out.println("c=" + c);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 8、三目条件运算符\n\n三目条件运算符，语法格式：\n\n> x ? y : z\n\n其中x为boolean类型表达式，先计算x的值，若为true，则整个三目运算的结果为表达式y的值，否则整个运算结果为表达式z的值。\n\n【演示】\n\npublic static void main(string[] args) {\n    int score = 80;\n    string type = score < 60 ? "不及格" : "及格";\n    system.out.println("type= " + type);\n}\n\n\n1\n2\n3\n4\n5\n\n\n三元运算符在真实开发中十分的常见，大家可以多练习使用，之后我们会讲解分支语句，可以利用三元运算符做到更加精简代码！便于理解！\n\n\n# 9、运算符优先级\n\n我们小学都学过：先加减，后乘除，所以优先级我们并不陌生。\n\n当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。\n\n下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。\n\n类别     操作符                                       关联性\n后缀     () [] . (点操作符)                            左到右\n一元     expr++ expr--                             从左到右\n一元     ++expr --expr + - ～ ！                     从右到左\n乘性     * /％                                      左到右\n加性     + -                                       左到右\n移位     >> >>> <<                                 左到右\n关系     > >= < <=                                 左到右\n相等     == !=                                     左到右\n按位与    ＆                                         左到右\n按位异或   ^                                         左到右\n按位或    |                                         左到右\n逻辑与    &&                                        左到右\n逻辑或    | |                                       左到右\n条件     ？：                                        从右到左\n赋值     = + = - = * = / =％= >> = << =＆= ^ = | =   从右到左\n逗号     ，                                         左到右\n\n大家不需要去刻意的记住，表达式里面优先使用小括号来组织！！方便理解和使用，不建议写非常冗余 的代码运算！\n\npublic static void main(string[] args) {\n    boolean flag = 1<4*5&&122>3||\'q\'+3<5;\n    system.out.println(flag);\n}\n\n\n1\n2\n3\n4\n\n\n\n#',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaDoc",frontmatter:{title:"JavaDoc",date:"2021-04-15T22:28:45.000Z",permalink:"/java/se/basic-grammar/javadoc/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/02.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08.JavaDoc.html",relativePath:"01.Java/02.java-基础/02.基础语法/08.JavaDoc.md",key:"v-76db6908",path:"/java/se/basic-grammar/javadoc/",headers:[{level:2,title:"JavaDoc",slug:"javadoc",normalizedTitle:"javadoc",charIndex:2},{level:3,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:14},{level:3,title:"2、命令行生成Doc",slug:"_2、命令行生成doc",normalizedTitle:"2、命令行生成doc",charIndex:811}],headersStr:"JavaDoc 1、简介 2、命令行生成Doc",content:"# JavaDoc\n\n\n# 1、简介\n\nJavaDoc是一种将注释生成HTML文档的技术，生成的HTML文档类似于Java的API，易读且清晰明了。 在简略介绍JavaDoc写法之后，再看一下在Intellij Idea 中如何将代码中的注释生成HTML文档。\n\njavadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配 套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过 Javadoc就可以同时形成程序的开发文档了。javadoc命令是用来生成自己API文档的，使用方式：使用 命令行在目标文件所在目录输入javadoc +文件名.java。\n\n先看一段样例代码：\n\n/**\n * 这是一个Javadoc测试程序\n *\n * @author Kuangshen\n * @version 1.0\n * @since 1.5\n */\npublic class HelloWorld {\n    public String name;\n\n    /**\n     * @param name 姓名\n     * @return 返回name姓名\n     * @throws Exception 无异常抛出\n     */\n    public String function(String name) throws Exception {\n        return name;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n解释一下： 以 /* 开始，以 / 结束。 @author 作者名 @version 版本号 @since 指明需要最早使用的jdk版本 @param 参数名 @return 返回值情况 @throws 异常抛出情况\n\n\n# 2、命令行生成Doc\n\n打开cmd\n\n切换到文件当前目录 cd /d E:\\java\\study\\package\\test\n\n输入指令： javadoc HelloWorld.java\n\n一般会加上-encoding UTF-8 -charset UTF-8 解决GBK乱码问题，在中间添加编码设置\n\njavadoc -encoding UTF-8 -charset UTF-8 HelloWorld.java\n\n\n1\n\n\n\n\n之后会多出一堆文件，打开index.html查看",normalizedContent:"# javadoc\n\n\n# 1、简介\n\njavadoc是一种将注释生成html文档的技术，生成的html文档类似于java的api，易读且清晰明了。 在简略介绍javadoc写法之后，再看一下在intellij idea 中如何将代码中的注释生成html文档。\n\njavadoc是sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配 套的api帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过 javadoc就可以同时形成程序的开发文档了。javadoc命令是用来生成自己api文档的，使用方式：使用 命令行在目标文件所在目录输入javadoc +文件名.java。\n\n先看一段样例代码：\n\n/**\n * 这是一个javadoc测试程序\n *\n * @author kuangshen\n * @version 1.0\n * @since 1.5\n */\npublic class helloworld {\n    public string name;\n\n    /**\n     * @param name 姓名\n     * @return 返回name姓名\n     * @throws exception 无异常抛出\n     */\n    public string function(string name) throws exception {\n        return name;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n解释一下： 以 /* 开始，以 / 结束。 @author 作者名 @version 版本号 @since 指明需要最早使用的jdk版本 @param 参数名 @return 返回值情况 @throws 异常抛出情况\n\n\n# 2、命令行生成doc\n\n打开cmd\n\n切换到文件当前目录 cd /d e:\\java\\study\\package\\test\n\n输入指令： javadoc helloworld.java\n\n一般会加上-encoding utf-8 -charset utf-8 解决gbk乱码问题，在中间添加编码设置\n\njavadoc -encoding utf-8 -charset utf-8 helloworld.java\n\n\n1\n\n\n\n\n之后会多出一堆文件，打开index.html查看",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"顺序结构",frontmatter:{title:"顺序结构",date:"2021-04-16T14:11:20.000Z",permalink:"/java/se/process-control/sequential-structure/",categories:["java","java-se","流程控制"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/02.%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84.html",relativePath:"01.Java/02.java-基础/03.流程控制/02.顺序结构.md",key:"v-08095c97",path:"/java/se/process-control/sequential-structure/",headers:[{level:2,title:"顺序结构",slug:"顺序结构",normalizedTitle:"顺序结构",charIndex:18}],headersStr:"顺序结构",content:'# JavaSE-流程控制\n\n\n# 顺序结构\n\nJAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。\n\n顺序结构是最简单的算法结构。\n\n\n\n语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的， 它是任何一个算法都离不开的一种基本算法结构。\n\n顺序结构在程序流程图中的体现就是用流程线将程序框自上而地连接起来，按顺序执行算法步骤。\n\npublic static void main(String[] args) {\n    System.out.println("Hello1");\n    System.out.println("Hello2");\n    System.out.println("Hello3");\n    System.out.println("Hello4");\n    System.out.println("Hello5");\n}\n//按照自上而下的顺序执行！依次输出。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'# javase-流程控制\n\n\n# 顺序结构\n\njava的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。\n\n顺序结构是最简单的算法结构。\n\n\n\n语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的， 它是任何一个算法都离不开的一种基本算法结构。\n\n顺序结构在程序流程图中的体现就是用流程线将程序框自上而地连接起来，按顺序执行算法步骤。\n\npublic static void main(string[] args) {\n    system.out.println("hello1");\n    system.out.println("hello2");\n    system.out.println("hello3");\n    system.out.println("hello4");\n    system.out.println("hello5");\n}\n//按照自上而下的顺序执行！依次输出。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"选择结构",frontmatter:{title:"选择结构",date:"2021-04-15T22:45:56.000Z",permalink:"/java/se/process-control/case-structure/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/03.%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84.html",relativePath:"01.Java/02.java-基础/03.流程控制/03.选择结构.md",key:"v-1c2c99c8",path:"/java/se/process-control/case-structure/",headers:[{level:2,title:"选择结构",slug:"选择结构",normalizedTitle:"选择结构",charIndex:18},{level:3,title:"1、if单选择结构",slug:"_1、if单选择结构",normalizedTitle:"1、if单选择结构",charIndex:27},{level:3,title:"2、if双选择结构",slug:"_2、if双选择结构",normalizedTitle:"2、if双选择结构",charIndex:627},{level:3,title:"3、if多选择结构",slug:"_3、if多选择结构",normalizedTitle:"3、if多选择结构",charIndex:1236},{level:3,title:"4、嵌套的if结构",slug:"_4、嵌套的if结构",normalizedTitle:"4、嵌套的if结构",charIndex:2657},{level:3,title:"5、switch多选择结构",slug:"_5、switch多选择结构",normalizedTitle:"5、switch多选择结构",charIndex:3207}],headersStr:"选择结构 1、if单选择结构 2、if双选择结构 3、if多选择结构 4、嵌套的if结构 5、switch多选择结构",content:'# JavaSE-流程控制\n\n\n# 选择结构\n\n\n# 1、if单选择结构\n\n我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用if语句来表 示：\n\n\n\nif(布尔表达式){\n    //如果布尔表达式为true将执行的语句\n}\n\n\n1\n2\n3\n\n\n意义：if语句对条件表达式进行一次测试，若测试为真，则执行下面的语句，否则跳过该语句。\n\n【演示】比如我们来接收一个用户输入，判断输入的是否为Hello字符串：\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    //接收用户输入\n    System.out.print("请输入内容：");\n    String s = scanner.nextLine();\n    \n    if (s.equals("Hello")){\n        System.out.println("输入的是："+s);\n    }\n    \n    System.out.println("End");\n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nequals方法是用来进行字符串的比较的，之后会详解，这里大家只需要知道他是用来比较字符串是否 一致的即可！和==是有区别的。\n\n\n# 2、if双选择结构\n\n那现在有个需求，公司要收购一个软件，成功了，给人支付100万元，失败了，自己找人开发。这样的 需求用一个if就搞不定了，我们需要有两个判断，需要一个双选择结构，所以就有了if-else结构。\n\n\n\nif(布尔表达式){\n    //如果布尔表达式的值为true\n    }else{\n    //如果布尔表达式的值为false\n}\n\n\n1\n2\n3\n4\n5\n\n\n意义：当条件表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分。\n\n【演示】我们来写一个示例：考试分数大于60就是及格，小于60分就不及格。\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    \n    System.out.print("请输入成绩：");\n    int score = scanner.nextInt();\n    \n    if (score>60){\n        System.out.println("及格");\n    }else {\n        System.out.println("不及格");\n    }\n    \n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3、if多选择结构\n\n我们发现上面的示例不符合实际情况，真实的情况还可能存在ABCD，存在区间多级判断。比如90-100 就是A，80-90 就是B.....，在生活中我们很多时候的选择也不仅仅只有两个，所以我们需要一个多选 择结构来处理这类问题！\n\n\n\nif(布尔表达式 1){\n    //如果布尔表达式 1的值为true执行代码\n}else if(布尔表达式 2){\n    //如果布尔表达式 2的值为true执行代码\n}else if(布尔表达式 3){\n    //如果布尔表达式 3的值为true执行代码\n}else {\n    //如果以上布尔表达式都不为true执行代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nif 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。\n\n使用 if，else if，else 语句的时候，需要注意下面几点：\n\n * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。\n * if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。\n * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n【演示】我们来改造一下上面的成绩案例，学校根据分数区间分为ABCD四个等级！\n\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    \n    System.out.print("请输入成绩：");\n    int score = scanner.nextInt();\n    \n    if (score==100){\n        System.out.println("恭喜满分");\n    }else if (score<100 && score >=90){\n        System.out.println("A级");\n    }else if (score<90 && score >=80){\n        System.out.println("B级");\n    }else if (score<80 && score >=70){\n        System.out.println("C级");\n    }else if (score<70 && score >=60){\n        System.out.println("D级");\n    }else if (score<60 && score >=0){\n        System.out.println("不及格！");\n    }else {\n        System.out.println("成绩输入不合法！");\n    }\n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n我们平时写程序一定要严谨，不然之后修补Bug是一件十分头疼的事情，要在编写代码的时候就把所有的问题都思考清除，再去一个个解决，这才是一个优秀的程序员应该做的事情，多思考，少犯错！\n\n\n# 4、嵌套的if结构\n\n使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语 句。你可以像 if 语句一样嵌套 else if...else。\n\nif(布尔表达式 1){\n    ////如果布尔表达式 1的值为true执行代码\n    if(布尔表达式 2){\n        ////如果布尔表达式 2的值为true执行代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n有时候我们在解决某些问题的时候，需要缩小查找范围，需要有层级条件判断，提高效率。比如：我们需要寻找一个数，在1-100之间，我们不知道这个数是多少的情况下，我们最笨的方式就是一个个去对比，看他到底是多少，这会花掉你大量的时间，如果可以利用if嵌套比较，我们可以节省大量的成本，如果你有这个思想，你已经很优秀了，因为很多大量的工程师就在寻找能够快速提高，查找和搜索效率的方式。为此提出了一系列的概念，我们生活在大数据时代，我们需要不断的去思考如何提高效率，或许哪一天，你们想出一个算法，能够将分析数据效率提高，或许你就可以在历史的长河中留下一些痕迹了，当然这是后话。\n\n【记住一点就好，所有的流程控制语句都可以互相嵌套，互不影响！】\n\n\n# 5、switch多选择结构\n\n多选择结构还有一个实现方式就是switch case 语句。\n\nswitch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch(expression){\n    case value :\n        //语句\n        break; //可选\n    case value :\n        //语句\n        break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n        //语句\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nswitch case 语句有如下规则：\n\n * switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。\n * switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n * case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n * 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n * switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\nswitch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。\n\npublic static void main(String[] args) {\n    char grade = \'C\';\n    switch (grade) {\n        case \'A\':\n            System.out.println("优秀");\n            break;\n        case \'B\':\n            System.out.println("秀");\n            break;\n        case \'C\':\n            System.out.println("良好");\n            break;\n        case \'D\':\n            System.out.println("及格");\n            break;\n        case \'F\':\n            System.out.println("你需要再努力努力");\n            break;\n        default:\n            System.out.println("未知等级");\n    }\n    System.out.println("你的等级是 " + grade);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输 出。如果后续的 case 语句块有 break 语句则会跳出判断。\n\npublic static void main(String[] args) {\n    int i = 1;\n    switch (i) {\n        case 0:\n            System.out.println("0");\n        case 1:\n            System.out.println("1");\n        case 2:\n            System.out.println("2");\n        case 3:\n            System.out.println("3");\n            break;\n        default:\n            System.out.println("default");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n输出：1，2，3。\n\n【JDK7增加了字符串表达式】\n\ncase 后边的可以是字符串的表达形式\n\npublic static void main(String[] args) {\n    String name = "你好";\n\n    switch (name) {\n        //JDK7的新特性，表达式结果可以是字符串！！！\n        case "你好":\n            System.out.println("你好");\n            break;\n        case "我好":\n            System.out.println("我好");\n            break;\n        default:\n            System.out.println("啥都不好");\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'# javase-流程控制\n\n\n# 选择结构\n\n\n# 1、if单选择结构\n\n我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用if语句来表 示：\n\n\n\nif(布尔表达式){\n    //如果布尔表达式为true将执行的语句\n}\n\n\n1\n2\n3\n\n\n意义：if语句对条件表达式进行一次测试，若测试为真，则执行下面的语句，否则跳过该语句。\n\n【演示】比如我们来接收一个用户输入，判断输入的是否为hello字符串：\n\npublic static void main(string[] args) {\n    scanner scanner = new scanner(system.in);\n    //接收用户输入\n    system.out.print("请输入内容：");\n    string s = scanner.nextline();\n    \n    if (s.equals("hello")){\n        system.out.println("输入的是："+s);\n    }\n    \n    system.out.println("end");\n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nequals方法是用来进行字符串的比较的，之后会详解，这里大家只需要知道他是用来比较字符串是否 一致的即可！和==是有区别的。\n\n\n# 2、if双选择结构\n\n那现在有个需求，公司要收购一个软件，成功了，给人支付100万元，失败了，自己找人开发。这样的 需求用一个if就搞不定了，我们需要有两个判断，需要一个双选择结构，所以就有了if-else结构。\n\n\n\nif(布尔表达式){\n    //如果布尔表达式的值为true\n    }else{\n    //如果布尔表达式的值为false\n}\n\n\n1\n2\n3\n4\n5\n\n\n意义：当条件表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分。\n\n【演示】我们来写一个示例：考试分数大于60就是及格，小于60分就不及格。\n\npublic static void main(string[] args) {\n    scanner scanner = new scanner(system.in);\n    \n    system.out.print("请输入成绩：");\n    int score = scanner.nextint();\n    \n    if (score>60){\n        system.out.println("及格");\n    }else {\n        system.out.println("不及格");\n    }\n    \n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3、if多选择结构\n\n我们发现上面的示例不符合实际情况，真实的情况还可能存在abcd，存在区间多级判断。比如90-100 就是a，80-90 就是b.....，在生活中我们很多时候的选择也不仅仅只有两个，所以我们需要一个多选 择结构来处理这类问题！\n\n\n\nif(布尔表达式 1){\n    //如果布尔表达式 1的值为true执行代码\n}else if(布尔表达式 2){\n    //如果布尔表达式 2的值为true执行代码\n}else if(布尔表达式 3){\n    //如果布尔表达式 3的值为true执行代码\n}else {\n    //如果以上布尔表达式都不为true执行代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nif 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。\n\n使用 if，else if，else 语句的时候，需要注意下面几点：\n\n * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。\n * if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。\n * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n【演示】我们来改造一下上面的成绩案例，学校根据分数区间分为abcd四个等级！\n\npublic static void main(string[] args) {\n    scanner scanner = new scanner(system.in);\n    \n    system.out.print("请输入成绩：");\n    int score = scanner.nextint();\n    \n    if (score==100){\n        system.out.println("恭喜满分");\n    }else if (score<100 && score >=90){\n        system.out.println("a级");\n    }else if (score<90 && score >=80){\n        system.out.println("b级");\n    }else if (score<80 && score >=70){\n        system.out.println("c级");\n    }else if (score<70 && score >=60){\n        system.out.println("d级");\n    }else if (score<60 && score >=0){\n        system.out.println("不及格！");\n    }else {\n        system.out.println("成绩输入不合法！");\n    }\n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n我们平时写程序一定要严谨，不然之后修补bug是一件十分头疼的事情，要在编写代码的时候就把所有的问题都思考清除，再去一个个解决，这才是一个优秀的程序员应该做的事情，多思考，少犯错！\n\n\n# 4、嵌套的if结构\n\n使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语 句。你可以像 if 语句一样嵌套 else if...else。\n\nif(布尔表达式 1){\n    ////如果布尔表达式 1的值为true执行代码\n    if(布尔表达式 2){\n        ////如果布尔表达式 2的值为true执行代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n有时候我们在解决某些问题的时候，需要缩小查找范围，需要有层级条件判断，提高效率。比如：我们需要寻找一个数，在1-100之间，我们不知道这个数是多少的情况下，我们最笨的方式就是一个个去对比，看他到底是多少，这会花掉你大量的时间，如果可以利用if嵌套比较，我们可以节省大量的成本，如果你有这个思想，你已经很优秀了，因为很多大量的工程师就在寻找能够快速提高，查找和搜索效率的方式。为此提出了一系列的概念，我们生活在大数据时代，我们需要不断的去思考如何提高效率，或许哪一天，你们想出一个算法，能够将分析数据效率提高，或许你就可以在历史的长河中留下一些痕迹了，当然这是后话。\n\n【记住一点就好，所有的流程控制语句都可以互相嵌套，互不影响！】\n\n\n# 5、switch多选择结构\n\n多选择结构还有一个实现方式就是switch case 语句。\n\nswitch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch(expression){\n    case value :\n        //语句\n        break; //可选\n    case value :\n        //语句\n        break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n        //语句\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nswitch case 语句有如下规则：\n\n * switch 语句中的变量类型可以是： byte、short、int 或者 char。从 java se 7 开始，switch 支持字符串 string 类型了，同时 case 标签必须为字符串常量或字面量。\n * switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n * case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n * 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n * switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\nswitch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。\n\npublic static void main(string[] args) {\n    char grade = \'c\';\n    switch (grade) {\n        case \'a\':\n            system.out.println("优秀");\n            break;\n        case \'b\':\n            system.out.println("秀");\n            break;\n        case \'c\':\n            system.out.println("良好");\n            break;\n        case \'d\':\n            system.out.println("及格");\n            break;\n        case \'f\':\n            system.out.println("你需要再努力努力");\n            break;\n        default:\n            system.out.println("未知等级");\n    }\n    system.out.println("你的等级是 " + grade);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输 出。如果后续的 case 语句块有 break 语句则会跳出判断。\n\npublic static void main(string[] args) {\n    int i = 1;\n    switch (i) {\n        case 0:\n            system.out.println("0");\n        case 1:\n            system.out.println("1");\n        case 2:\n            system.out.println("2");\n        case 3:\n            system.out.println("3");\n            break;\n        default:\n            system.out.println("default");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n输出：1，2，3。\n\n【jdk7增加了字符串表达式】\n\ncase 后边的可以是字符串的表达形式\n\npublic static void main(string[] args) {\n    string name = "你好";\n\n    switch (name) {\n        //jdk7的新特性，表达式结果可以是字符串！！！\n        case "你好":\n            system.out.println("你好");\n            break;\n        case "我好":\n            system.out.println("我好");\n            break;\n        default:\n            system.out.println("啥都不好");\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"循环结构",frontmatter:{title:"循环结构",date:"2021-04-15T22:45:56.000Z",permalink:"/java/se/process-control/loop-structure",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/04.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.html",relativePath:"01.Java/02.java-基础/03.流程控制/04.循环结构.md",key:"v-990ee8ec",path:"/java/se/process-control/loop-structure/",headers:[{level:2,title:"循环结构",slug:"循环结构",normalizedTitle:"循环结构",charIndex:18},{level:3,title:"1、while 循环",slug:"_1、while-循环",normalizedTitle:"1、while 循环",charIndex:272},{level:3,title:"2、do…while 循环",slug:"_2、do-while-循环",normalizedTitle:"2、do…while 循环",charIndex:1618},{level:3,title:"3、For循环",slug:"_3、for循环",normalizedTitle:"3、for循环",charIndex:2454},{level:3,title:"4、练习",slug:"_4、练习",normalizedTitle:"4、练习",charIndex:3285},{level:3,title:"5、增强for循环",slug:"_5、增强for循环",normalizedTitle:"5、增强for循环",charIndex:5180}],headersStr:"循环结构 1、while 循环 2、do…while 循环 3、For循环 4、练习 5、增强for循环",content:'# JavaSE-流程控制\n\n\n# 循环结构\n\n上面选择结构中，我们始终无法让程序一直跑着，我们每次运行就停止了。我们需要规定一个程序运行多少次，运行多久，等等。所以按照我们编程是为了解决人的问题的思想，我们是不是得需要有一个结构来搞定这个事情！于是循环结构自然的诞生了！\n\n顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。\n\nJava中有三种主要的循环结构：\n\n * while 循环\n * do…while 循环\n * for 循环\n\n在Java5中引入了一种主要用于数组的增强型for循环。\n\n\n# 1、while 循环\n\nwhile是最基本的循环，它的结构为：\n\nwhile( 布尔表达式 ) {\n    //循环内容\n}\n\n\n1\n2\n3\n\n\n\n\n【图解】在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一 次额外的循环，都会在开始前重新计算一次判断是否为真。直到条件不成立，则循环结束。\n\n我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。\n\n方式有：循环内部控制，外部设立标志位！等\n\npublic static void main(String[] args) {\n    int i = 0;\n    //i小于100就会一直循环\n    while (i<100){\n        i++;\n        System.out.println(i);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n少部分情况需要循环一直执行，比如服务器的请求响应监听等。\n\npublic static void main(String[] args) {\n    while (true){\n        //等待客户端连接\n        //定时检查\n        //......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影 响程序性能或者造成程序卡死奔溃！\n\n【案例：计算1+2+3+…+100=?】\n\npublic static void main(String[] args) {\n    int i = 0;\n    int sum = 0;\n    while (i <= 100) {\n        sum = sum+i;\n        i++;\n    }\n    System.out.println("Sum= " + sum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n【高斯的故事】\n\n德国大数学家高斯（Gauss）：高斯是一对普通夫妇的儿子。他的母亲是一个贫穷石匠的女儿，虽然十分聪明，但却没有接受过教育，近似于文盲。在她成为高斯父亲的第二个妻子之前，她从事女佣工作。他的父亲曾做过园丁，工头，商人的助手和一个小保险公司的评估师。当高斯三岁时便能够纠正他父亲的借债账目的事情， 已经成为一个轶事流传至今。他曾说，他在麦仙翁堆上学会计算。能够在头脑中进行复杂的计算，是上帝赐予他一生的天赋。\n\n高斯用很短的时间计算出了小学老师布置的任务：对自然数从1到100的求和.他所使用的方法是：对50 对构造成和101的数列求和（1＋100,2＋99,3＋98……）,同时得到结果：5050.这一年,高斯9岁.\n\n这个故事我们在高中数学中的“等差数列求和”听过，当时我们用的公式求解。\n\n\n\n编程难的不是语言，是算法。数学能让你写的程序运算次数更少，效率更高。\n\n如果求1+2+3.....+100万呢，虽然100万次的运算加法，对于计算机不算什么，但我们为了效率可以用数学公式进行求解。\n\n有能力的同学可以看下编程程序比赛，考验算法能力的，例如：“传智杯”，“蓝桥杯”\n\n\n# 2、do…while 循环\n\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少 执行一次。\n\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n\ndo {\n    //代码语句\n}while(布尔表达式);\n\n\n1\n2\n3\n\n\n\n\n注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n我们用do...while改造一下上面的案例！\n\npublic static void main(String[] args) {\n    int i = 0;\n    int sum = 0;\n    do {\n        sum = sum+i;\n        i++;\n    }while (i <= 100);\n    System.out.println("Sum= " + sum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n执行结果当然是一样的！\n\nWhile和do-While的区别：\n\nwhile先判断后执行。dowhile是先执行后判断！\n\nDo...while总是保证循环体会被至少执行一次！这是他们的主要差别。\n\npublic static void main(String[] args) {\n    int a = 0;\n    while(a<0){\n        System.out.println(a);\n        a++;\n    }\n    System.out.println("-----");\n    do{\n        System.out.println(a);\n        a++;\n    } while (a<0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3、For循环\n\n虽然所有循环结构都可以用 while 或者 do...while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。\n\nfor循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。\n\nfor循环执行的次数是在执行前就确定的。语法格式如下：\n\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n\n\n1\n2\n3\n\n\n\n\n关于 for 循环有以下几点说明：\n\n * 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n * 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。\n * 执行一次循环后，更新循环控制变量(迭代因子控制循环变量的增减。\n * 再次检测布尔表达式。循环执行上面的过程。\n\n【演示：while和for输出】\n\npublic static void main(String[] args) {\n    int a = 1; //初始化\n    \n    while(a<=100){ //条件判断\n        System.out.println(a); //循环体\n        a+=2; //迭代\n    }\n    System.out.println("while循环结束！");\n    \n    for(int i = 1;i<=100;i++){ //初始化//条件判断 //迭代\n        System.out.println(i); //循环体\n    }\n    System.out.println("while循环结束！");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们发现，for循环在知道循环次数的情况下，简化了代码，提高了可读性。我们平时用到的最多的也是 我们的for循环！\n\n\n# 4、练习\n\n【练习1：计算0到100之间的奇数和偶数的和】\n\npublic static void main(String[] args) {\n    int oddSum = 0; //用来保存奇数的和\n    int evenSum = 0; //用来存放偶数的和\n    for (int i = 0; i <= 100; i++) {\n        if (i % 2 != 0) {\n            oddSum += i;\n        } else {\n            evenSum += i;\n        }\n    }\n    System.out.println("奇数的和：" + oddSum);\n    System.out.println("偶数的和：" + evenSum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【练习2：用while或for循环输出1-1000之间能被5整除的数，并且每行输出3个】\n\npublic static void main(String[] args) {\n    for (int j = 1; j <= 1000; j++) {\n        if (j % 5 == 0) {\n            System.out.print(j + "\\t");\n        }\n        if (j % (5 * 3) == 0) {\n            System.out.println();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【练习3：打印九九乘法表】\n\n1*1=1\n1*2=2 2*2=4\n1*3=3 2*3=6 3*3=9\n1*4=4 2*4=8 3*4=12 4*4=16\n1*5=5 2*5=10 3*5=15 4*5=20 5*5=25\n1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36\n1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49\n1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64\n1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当然，成功的路不止一条，但是我们要追求最完美的一条，如果你做不到，不妨试试笨办法，依旧可以 完成任务！比如一行行输出，也是可以搞定的。一定要多分析！\n\n我们使用嵌套for循环就可以很轻松解决这个问题了！\n\n第一步：我们先打印第一列，这个大家应该都会\n\nfor (int i = 1; i <= 9; i++) {\n\tSystem.out.println(1 + "*" + i + "=" + (1 * i));\n}\n\n\n1\n2\n3\n\n\n第二步：我们把固定的1再用一个循环包起来\n\nfor (int i = 1; i <= 9 ; i++) {\n    for (int j = 1; j <= 9; j++) {\n        System.out.println(i + "*" + j + "=" + (i * j));\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三步：去掉重复项，j<=i\n\nfor (int i = 1; i <= 9 ; i++) {\n    for (int j = 1; j <= i; j++) {\n        System.out.println(j + "*" + i + "=" + (i * j));\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第四步：调整样式\n\nfor (int i = 1; i <= 9 ; i++) {\n    for (int j = 1; j <= i; j++) {\n        System.out.print(j + "*" + i + "=" + (i * j)+ "\\t");\n    }\n    System.out.println();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过本练习，大家要体会如何分析问题、如何切入问题！在我们以后写代码的过程中，一定要学会将一 个大问题分解成若干小问题，然后，由易到难，各个击破！这也是我们以后开发项目时的基本思维过程。希望大家好好体会！\n\n\n# 5、增强for循环\n\nJava5 引入了一种主要用于数组或集合的增强型 for 循环。\n\nJava 增强 for 循环语法格式如下:\n\nfor(声明语句 : 表达式)\n{\n    //代码句子\n}\n\n\n1\n2\n3\n4\n\n\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句 块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n\n【演示：增强for循环遍历输出数组元素】\n\npublic static void main(String[] args) {\n    \n    int [] numbers = {10, 20, 30, 40, 50};\n    for(int x : numbers ){\n        System.out.print( x );\n        System.out.print(",");\n    }\n    System.out.print("\\n");\n    \n    String [] names ={"James", "Larry", "Tom", "Lacy"};\n    for( String name : names ) {\n        System.out.print( name );\n        System.out.print(",");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们现在搞不懂这个没关系，就是拉出来和大家见一面，下章就讲解数组了！',normalizedContent:'# javase-流程控制\n\n\n# 循环结构\n\n上面选择结构中，我们始终无法让程序一直跑着，我们每次运行就停止了。我们需要规定一个程序运行多少次，运行多久，等等。所以按照我们编程是为了解决人的问题的思想，我们是不是得需要有一个结构来搞定这个事情！于是循环结构自然的诞生了！\n\n顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。\n\njava中有三种主要的循环结构：\n\n * while 循环\n * do…while 循环\n * for 循环\n\n在java5中引入了一种主要用于数组的增强型for循环。\n\n\n# 1、while 循环\n\nwhile是最基本的循环，它的结构为：\n\nwhile( 布尔表达式 ) {\n    //循环内容\n}\n\n\n1\n2\n3\n\n\n\n\n【图解】在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一 次额外的循环，都会在开始前重新计算一次判断是否为真。直到条件不成立，则循环结束。\n\n我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。\n\n方式有：循环内部控制，外部设立标志位！等\n\npublic static void main(string[] args) {\n    int i = 0;\n    //i小于100就会一直循环\n    while (i<100){\n        i++;\n        system.out.println(i);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n少部分情况需要循环一直执行，比如服务器的请求响应监听等。\n\npublic static void main(string[] args) {\n    while (true){\n        //等待客户端连接\n        //定时检查\n        //......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影 响程序性能或者造成程序卡死奔溃！\n\n【案例：计算1+2+3+…+100=?】\n\npublic static void main(string[] args) {\n    int i = 0;\n    int sum = 0;\n    while (i <= 100) {\n        sum = sum+i;\n        i++;\n    }\n    system.out.println("sum= " + sum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n【高斯的故事】\n\n德国大数学家高斯（gauss）：高斯是一对普通夫妇的儿子。他的母亲是一个贫穷石匠的女儿，虽然十分聪明，但却没有接受过教育，近似于文盲。在她成为高斯父亲的第二个妻子之前，她从事女佣工作。他的父亲曾做过园丁，工头，商人的助手和一个小保险公司的评估师。当高斯三岁时便能够纠正他父亲的借债账目的事情， 已经成为一个轶事流传至今。他曾说，他在麦仙翁堆上学会计算。能够在头脑中进行复杂的计算，是上帝赐予他一生的天赋。\n\n高斯用很短的时间计算出了小学老师布置的任务：对自然数从1到100的求和.他所使用的方法是：对50 对构造成和101的数列求和（1＋100,2＋99,3＋98……）,同时得到结果：5050.这一年,高斯9岁.\n\n这个故事我们在高中数学中的“等差数列求和”听过，当时我们用的公式求解。\n\n\n\n编程难的不是语言，是算法。数学能让你写的程序运算次数更少，效率更高。\n\n如果求1+2+3.....+100万呢，虽然100万次的运算加法，对于计算机不算什么，但我们为了效率可以用数学公式进行求解。\n\n有能力的同学可以看下编程程序比赛，考验算法能力的，例如：“传智杯”，“蓝桥杯”\n\n\n# 2、do…while 循环\n\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少 执行一次。\n\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n\ndo {\n    //代码语句\n}while(布尔表达式);\n\n\n1\n2\n3\n\n\n\n\n注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n我们用do...while改造一下上面的案例！\n\npublic static void main(string[] args) {\n    int i = 0;\n    int sum = 0;\n    do {\n        sum = sum+i;\n        i++;\n    }while (i <= 100);\n    system.out.println("sum= " + sum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n执行结果当然是一样的！\n\nwhile和do-while的区别：\n\nwhile先判断后执行。dowhile是先执行后判断！\n\ndo...while总是保证循环体会被至少执行一次！这是他们的主要差别。\n\npublic static void main(string[] args) {\n    int a = 0;\n    while(a<0){\n        system.out.println(a);\n        a++;\n    }\n    system.out.println("-----");\n    do{\n        system.out.println(a);\n        a++;\n    } while (a<0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3、for循环\n\n虽然所有循环结构都可以用 while 或者 do...while表示，但 java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。\n\nfor循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。\n\nfor循环执行的次数是在执行前就确定的。语法格式如下：\n\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n\n\n1\n2\n3\n\n\n\n\n关于 for 循环有以下几点说明：\n\n * 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n * 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。\n * 执行一次循环后，更新循环控制变量(迭代因子控制循环变量的增减。\n * 再次检测布尔表达式。循环执行上面的过程。\n\n【演示：while和for输出】\n\npublic static void main(string[] args) {\n    int a = 1; //初始化\n    \n    while(a<=100){ //条件判断\n        system.out.println(a); //循环体\n        a+=2; //迭代\n    }\n    system.out.println("while循环结束！");\n    \n    for(int i = 1;i<=100;i++){ //初始化//条件判断 //迭代\n        system.out.println(i); //循环体\n    }\n    system.out.println("while循环结束！");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们发现，for循环在知道循环次数的情况下，简化了代码，提高了可读性。我们平时用到的最多的也是 我们的for循环！\n\n\n# 4、练习\n\n【练习1：计算0到100之间的奇数和偶数的和】\n\npublic static void main(string[] args) {\n    int oddsum = 0; //用来保存奇数的和\n    int evensum = 0; //用来存放偶数的和\n    for (int i = 0; i <= 100; i++) {\n        if (i % 2 != 0) {\n            oddsum += i;\n        } else {\n            evensum += i;\n        }\n    }\n    system.out.println("奇数的和：" + oddsum);\n    system.out.println("偶数的和：" + evensum);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【练习2：用while或for循环输出1-1000之间能被5整除的数，并且每行输出3个】\n\npublic static void main(string[] args) {\n    for (int j = 1; j <= 1000; j++) {\n        if (j % 5 == 0) {\n            system.out.print(j + "\\t");\n        }\n        if (j % (5 * 3) == 0) {\n            system.out.println();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【练习3：打印九九乘法表】\n\n1*1=1\n1*2=2 2*2=4\n1*3=3 2*3=6 3*3=9\n1*4=4 2*4=8 3*4=12 4*4=16\n1*5=5 2*5=10 3*5=15 4*5=20 5*5=25\n1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36\n1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49\n1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64\n1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当然，成功的路不止一条，但是我们要追求最完美的一条，如果你做不到，不妨试试笨办法，依旧可以 完成任务！比如一行行输出，也是可以搞定的。一定要多分析！\n\n我们使用嵌套for循环就可以很轻松解决这个问题了！\n\n第一步：我们先打印第一列，这个大家应该都会\n\nfor (int i = 1; i <= 9; i++) {\n\tsystem.out.println(1 + "*" + i + "=" + (1 * i));\n}\n\n\n1\n2\n3\n\n\n第二步：我们把固定的1再用一个循环包起来\n\nfor (int i = 1; i <= 9 ; i++) {\n    for (int j = 1; j <= 9; j++) {\n        system.out.println(i + "*" + j + "=" + (i * j));\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三步：去掉重复项，j<=i\n\nfor (int i = 1; i <= 9 ; i++) {\n    for (int j = 1; j <= i; j++) {\n        system.out.println(j + "*" + i + "=" + (i * j));\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第四步：调整样式\n\nfor (int i = 1; i <= 9 ; i++) {\n    for (int j = 1; j <= i; j++) {\n        system.out.print(j + "*" + i + "=" + (i * j)+ "\\t");\n    }\n    system.out.println();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过本练习，大家要体会如何分析问题、如何切入问题！在我们以后写代码的过程中，一定要学会将一 个大问题分解成若干小问题，然后，由易到难，各个击破！这也是我们以后开发项目时的基本思维过程。希望大家好好体会！\n\n\n# 5、增强for循环\n\njava5 引入了一种主要用于数组或集合的增强型 for 循环。\n\njava 增强 for 循环语法格式如下:\n\nfor(声明语句 : 表达式)\n{\n    //代码句子\n}\n\n\n1\n2\n3\n4\n\n\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句 块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n\n【演示：增强for循环遍历输出数组元素】\n\npublic static void main(string[] args) {\n    \n    int [] numbers = {10, 20, 30, 40, 50};\n    for(int x : numbers ){\n        system.out.print( x );\n        system.out.print(",");\n    }\n    system.out.print("\\n");\n    \n    string [] names ={"james", "larry", "tom", "lacy"};\n    for( string name : names ) {\n        system.out.print( name );\n        system.out.print(",");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们现在搞不懂这个没关系，就是拉出来和大家见一面，下章就讲解数组了！',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Scanner",frontmatter:{title:"Scanner",date:"2021-04-15T22:45:56.000Z",permalink:"/java/se/process-control/scanner/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/01.%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92Scanner.html",relativePath:"01.Java/02.java-基础/03.流程控制/01.用户交互Scanner.md",key:"v-576d295a",path:"/java/se/process-control/scanner/",headers:[{level:2,title:"用户交互Scanner",slug:"用户交互scanner",normalizedTitle:"用户交互scanner",charIndex:18},{level:3,title:"1、Scanner对象",slug:"_1、scanner对象",normalizedTitle:"1、scanner对象",charIndex:34},{level:3,title:"2、next & nextLine",slug:"_2、next-nextline",normalizedTitle:"2、next &amp; nextline",charIndex:null},{level:3,title:"3、其他方法",slug:"_3、其他方法",normalizedTitle:"3、其他方法",charIndex:1498}],headersStr:"用户交互Scanner 1、Scanner对象 2、next & nextLine 3、其他方法",content:'# JavaSE-流程控制\n\n\n# 用户交互Scanner\n\n\n# 1、Scanner对象\n\n之前我们学的基本语法中我们并没有实现程序和人的交互，但是Java给我们提供了这样一个工具类，我 们可以获取用户的输入。java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。\n\n下面是创建 Scanner 对象的基本语法：\n\nScanner s = new Scanner(System.in);\n\n\n1\n\n\n接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext() 与 hasNextLine() 判断是否还有输入的数据。\n\n\n# 2、next & nextLine\n\npublic static void main(String[] args) {\n    //创建一个扫描器对象，用于接收键盘数据\n    Scanner scanner = new Scanner(System.in);\n    //next方式接收字符串\n    System.out.println("Next方式接收:");\n    //判断用户还有没有输入字符\n    if (scanner.hasNext()) {\n        String str = scanner.next();\n        System.out.println("输入内容：" + str);\n    }\n    //凡是属于IO流的类如果不关闭会一直占用资源.要养成好习惯用完就关掉.就好像你接水完了要关水龙头一样.很多下载软件或者视频软件如果你不彻底关, 都会自己上传下载从而占用资源, 你就会觉得卡, 这一个道理.\n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n测试数据：Hello World！\n\n结果：只输出了Hello。\n\n接下来我们使用另一个方法来接收数据：nextLine()\n\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    // 从键盘接收数据\n    // nextLine方式接收字符串\n    System.out.println("nextLine方式接收：");\n    // 判断是否还有输入\n    if (scan.hasNextLine()) {\n        String str2 = scan.nextLine();\n        System.out.println("输入内容：" + str2);\n    }\n    scan.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试数据：Hello World！\n\n结果：输出了Hello World！\n\n两者区别：\n\nnext():\n\n * 一定要读取到有效字符后才可以结束输入。\n * 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n * 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n * next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n * 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n * 可以获得空白。\n\n\n# 3、其他方法\n\n如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：\n\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    // 从键盘接收数据\n    int i = 0;\n    float f = 0.0f;\n    System.out.print("输入整数：");\n    if (scan.hasNextInt()) {\n        // 判断输入的是否是整数\n        i = scan.nextInt();\n        // 接收整数\n        System.out.println("整数数据：" + i);\n    } else {\n        // 输入错误的信息\n        System.out.println("输入的不是整数！");\n    }\n    System.out.print("输入小数：");\n    if (scan.hasNextFloat()) {\n        // 判断输入的是否是小数\n        f = scan.nextFloat();\n        // 接收小数\n        System.out.println("小数数据：" + f);\n    } else {\n        // 输入错误的信息\n        System.out.println("输入的不是小数！");\n    }\n    scan.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n具体Scanner类都有什么方法，可查看其中的源码，ctrl+鼠标左键 点中idea中的Scanner\n\n以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入，并输出执行结果：\n\npublic static void main(String[] args) {\n    //扫描器接收键盘数据\n    Scanner scan = new Scanner(System.in);\n    double sum = 0; //和\n    int m = 0; //输入了多少个数字\n    //通过循环判断是否还有输入，并在里面对每一次进行求和和统计\n    while (scan.hasNextDouble()) {\n        double x = scan.nextDouble();\n        m = m + 1;\n        sum = sum + x;\n    }\n    System.out.println(m + "个数的和为" + sum);\n    System.out.println(m + "个数的平均值是" + (sum / m));\n    scan.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n可能很多小伙伴到这里就看不懂写的什么东西了！这里我们使用了我们一会要学的流程控制语句，我们 接下来就去学习这些语句的具体作用！\n\nJava中的流程控制语句可以这样分类：顺序结构，选择结构，循环结构！这三种结构就足够解决所有的 问题了！',normalizedContent:'# javase-流程控制\n\n\n# 用户交互scanner\n\n\n# 1、scanner对象\n\n之前我们学的基本语法中我们并没有实现程序和人的交互，但是java给我们提供了这样一个工具类，我 们可以获取用户的输入。java.util.scanner 是 java5 的新特征，我们可以通过 scanner 类来获取用户的输入。\n\n下面是创建 scanner 对象的基本语法：\n\nscanner s = new scanner(system.in);\n\n\n1\n\n\n接下来我们演示一个最简单的数据输入，并通过 scanner 类的 next() 与 nextline() 方法获取输入的字符串，在读取前我们一般需要 使用 hasnext() 与 hasnextline() 判断是否还有输入的数据。\n\n\n# 2、next & nextline\n\npublic static void main(string[] args) {\n    //创建一个扫描器对象，用于接收键盘数据\n    scanner scanner = new scanner(system.in);\n    //next方式接收字符串\n    system.out.println("next方式接收:");\n    //判断用户还有没有输入字符\n    if (scanner.hasnext()) {\n        string str = scanner.next();\n        system.out.println("输入内容：" + str);\n    }\n    //凡是属于io流的类如果不关闭会一直占用资源.要养成好习惯用完就关掉.就好像你接水完了要关水龙头一样.很多下载软件或者视频软件如果你不彻底关, 都会自己上传下载从而占用资源, 你就会觉得卡, 这一个道理.\n    scanner.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n测试数据：hello world！\n\n结果：只输出了hello。\n\n接下来我们使用另一个方法来接收数据：nextline()\n\npublic static void main(string[] args) {\n    scanner scan = new scanner(system.in);\n    // 从键盘接收数据\n    // nextline方式接收字符串\n    system.out.println("nextline方式接收：");\n    // 判断是否还有输入\n    if (scan.hasnextline()) {\n        string str2 = scan.nextline();\n        system.out.println("输入内容：" + str2);\n    }\n    scan.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试数据：hello world！\n\n结果：输出了hello world！\n\n两者区别：\n\nnext():\n\n * 一定要读取到有效字符后才可以结束输入。\n * 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n * 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n * next() 不能得到带有空格的字符串。\n\nnextline()：\n\n * 以enter为结束符,也就是说 nextline()方法返回的是输入回车之前的所有字符。\n * 可以获得空白。\n\n\n# 3、其他方法\n\n如果要输入 int 或 float 类型的数据，在 scanner 类中也有支持，但是在输入之前最好先使用 hasnextxxx() 方法进行验证，再使用 nextxxx() 来读取：\n\npublic static void main(string[] args) {\n    scanner scan = new scanner(system.in);\n    // 从键盘接收数据\n    int i = 0;\n    float f = 0.0f;\n    system.out.print("输入整数：");\n    if (scan.hasnextint()) {\n        // 判断输入的是否是整数\n        i = scan.nextint();\n        // 接收整数\n        system.out.println("整数数据：" + i);\n    } else {\n        // 输入错误的信息\n        system.out.println("输入的不是整数！");\n    }\n    system.out.print("输入小数：");\n    if (scan.hasnextfloat()) {\n        // 判断输入的是否是小数\n        f = scan.nextfloat();\n        // 接收小数\n        system.out.println("小数数据：" + f);\n    } else {\n        // 输入错误的信息\n        system.out.println("输入的不是小数！");\n    }\n    scan.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n具体scanner类都有什么方法，可查看其中的源码，ctrl+鼠标左键 点中idea中的scanner\n\n以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入，并输出执行结果：\n\npublic static void main(string[] args) {\n    //扫描器接收键盘数据\n    scanner scan = new scanner(system.in);\n    double sum = 0; //和\n    int m = 0; //输入了多少个数字\n    //通过循环判断是否还有输入，并在里面对每一次进行求和和统计\n    while (scan.hasnextdouble()) {\n        double x = scan.nextdouble();\n        m = m + 1;\n        sum = sum + x;\n    }\n    system.out.println(m + "个数的和为" + sum);\n    system.out.println(m + "个数的平均值是" + (sum / m));\n    scan.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n可能很多小伙伴到这里就看不懂写的什么东西了！这里我们使用了我们一会要学的流程控制语句，我们 接下来就去学习这些语句的具体作用！\n\njava中的流程控制语句可以这样分类：顺序结构，选择结构，循环结构！这三种结构就足够解决所有的 问题了！',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"方法",frontmatter:{title:"方法",date:"2021-04-15T22:46:09.000Z",permalink:"/java/se/method/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/04.%E6%96%B9%E6%B3%95.html",relativePath:"01.Java/02.java-基础/04.方法.md",key:"v-1fb534ce",path:"/java/se/method/",headers:[{level:2,title:"1、何谓方法？",slug:"_1、何谓方法",normalizedTitle:"1、何谓方法？",charIndex:16},{level:2,title:"2、方法的定义",slug:"_2、方法的定义",normalizedTitle:"2、方法的定义",charIndex:437},{level:2,title:"3、方法调用",slug:"_3、方法调用",normalizedTitle:"3、方法调用",charIndex:1391},{level:2,title:"4、方法的重载",slug:"_4、方法的重载",normalizedTitle:"4、方法的重载",charIndex:2293},{level:2,title:"5、拓展命令行传参",slug:"_5、拓展命令行传参",normalizedTitle:"5、拓展命令行传参",charIndex:2925},{level:2,title:"6、可变参数",slug:"_6、可变参数",normalizedTitle:"6、可变参数",charIndex:3402},{level:2,title:"7、递归",slug:"_7、递归",normalizedTitle:"7、递归",charIndex:4137}],headersStr:"1、何谓方法？ 2、方法的定义 3、方法调用 4、方法的重载 5、拓展命令行传参 6、可变参数 7、递归",content:'# JavaSE-方法\n\n\n# 1、何谓方法？\n\n在前面几个章节中我们经常使用到 System.out.println()，那么它是什么呢？\n\n * println() 是一个方法。\n * System 是系统类。\n * out 是标准输出对象。\n\n这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。\n\n那么什么是方法呢？\n\nJava方法是语句的集合，它们在一起执行一个功能。\n\n * 方法是解决一类问题的步骤的有序组合\n * 方法包含于类或对象中\n * 方法在程序中被创建，在其他地方被引用\n\n设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最 好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。\n\n方法的优点\n\n * 使程序变得更简短而清晰。\n * 有利于程序维护。\n * 可以提高程序开发的效率。\n * 提高了代码的重用性。\n\n回顾：方法的命名规则？\n\n\n# 2、方法的定义\n\nJava的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法 包含以下语法：\n\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * 修饰符\n   \n   修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n\n * 返回值类型\n   \n   方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需 的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。\n\n * 方法名\n   \n   是方法的实际名称。方法名和参数表共同构成方法签名。\n\n * 参数类型\n   \n   参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n   \n   * 形式参数：在方法被调用时用于接收外界输入的数据。\n   * 实参：调用方法时实际传给方法的数据。\n   \n   \n\n * 方法体\n   \n   方法体包含具体的语句，定义该方法的功能。\n\n比如我们写一个比大小的方法：\n\n【演示】下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。\n\n/** 返回两个整型变量数据的较大值 */\npublic static int max(int num1, int num2) {\n    int result;\n    if (num1 > num2){\n        result = num1;\n    }\n    else{\n        result = num2;\n    }\n        \n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【演示：加法】\n\npublic int add(int num1, int num2) {\n    return num1+num2;\n}\n\n\n1\n2\n3\n\n\n\n# 3、方法调用\n\nJava 支持两种调用方法的方式，根据方法是否返回值来选择。\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\n当方法返回一个值的时候，方法调用通常被当做一个值。例如：\n\nint larger = max(30, 40);\n\n\n1\n\n\nJava语言中使用下述形式调用方法：对象名.方法名(实参列表)\n\n如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：\n\nSystem.out.println("Hello,kuangshen!");\n\n\n1\n\n\n【演示：定义方法并且调用它】\n\npublic static void main(String[] args) {\n    int i = 5;\n    int j = 2;\n    int k = max(i, j);\n    System.out.println( i + " 和 " + j + " 比较，最大值是：" + k);\n}\n\n/** 返回两个整数变量较大的值 */\npublic static int max(int num1, int num2) {\n    int result;\n    if (num1 > num2){\n        result = num1;\n    }  \n    else{\n        result = num2;\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这个程序包含 main 方法和 max 方法。main 方法是被 JVM 调用的，除此之外，main 方法和其它方法 没什么区别。JAVA中只有值传递！\n\nmain 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。\n\n\n# 4、方法的重载\n\n上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？\n\n解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：\n\npublic static double max(double num1, double num2) {\n    if (num1 > num2)\n    return num1;\n    else\n    return num2;\n}\n\npublic static int max(int num1, int num2) {\n    int result;\n    if (num1 > num2)\n    result = num1;\n    else\n    result = num2;\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；\n\n如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；\n\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\n\nJava编译器根据方法签名判断哪个方法应该被调用。\n\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n\n\n# 5、拓展命令行传参\n\n有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。\n\n命令行参数是在执行程序时候紧跟在程序名字后面的信息。\n\n【下面的程序打印所有的命令行参数】\n\npublic class CommandLine {\n\tpublic static void main(String args[]){\n\t\tfor(int i=0; i<args.length; i++){\n\t\t\tSystem.out.println("args[" + i + "]: " + args[i]);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【命令行】\n\njavac CommandLine.java\njava CommandLine this is a command line 200 -100\n\n\n1\n2\n\n\n> args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]: 200 args[6]: -100\n\n\n# 6、可变参数\n\nJDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。\n\n方法的可变参数的声明如下所示：\n\n> typeName... parameterName\n\n在方法声明中，在指定参数类型后加一个省略号(...)\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\npublic static void main(String[] args) {\n    // 调用可变参数的方法\n    printMax(34, 3, 3, 2, 56.5);\n    printMax(new double[]{1, 2, 3});\n}\n\npublic static void printMax(double... numbers) {\n    if (numbers.length == 0) {\n        System.out.println("No argument passed");\n        return;\n    }\n    double result = numbers[0];\n    //排序！\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > result) {\n            result = numbers[i];\n        }\n    }\n    System.out.println("The max value is " + result);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 7、递归\n\nA方法调用B方法，我们很容易理解！\n\n递归就是：A方法调用A方法！就是自己调用自己，因此我们在设计递归算法时，一定要指明什么时候自己不调用自己。否则，就是个死循环！\n\n递归算法重点：\n\n递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。\n\n利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原 问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计 算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。\n\n递归结构包括两个部分：\n\n * 递归头\n   \n   什么时候不调用自身方法。如果没有头，将陷入死循环。\n\n * 递归体\n\n什么时候需要调用自身方法。\n\n【演示：利用代码计算5的乘阶！】\n\n//5*4*3*2*1\npublic static void main(String[] args) {\n    System.out.println(f(5));\n}\npublic static int f(int n) {\n    if (1 == n)\n    \treturn 1;\n    else\n    \treturn n*f(n-1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n此题中，按照递归的三个条件来分析：\n\n(1)边界条件：阶乘，乘到最后一个数，即1的时候，返回1，程序执行到底； (2)递归前进段：当前的参数不等于1的时候，继续调用自身； (3)递归返回段：从最大的数开始乘，如果当前参数是5，那么就是5* 4，即5 (5-1)，即n * (n-1)\n\n递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理 解，容易编程。但递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一 些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许 多额外的时间开销。所以在深度大时，它的时空性就不好了。（会占用大量的内存空间）\n\n而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但 缺点就是不容易理解，编写复杂问题时困难。\n\n能不用递归就不用递归，递归都可以用迭代来代替',normalizedContent:'# javase-方法\n\n\n# 1、何谓方法？\n\n在前面几个章节中我们经常使用到 system.out.println()，那么它是什么呢？\n\n * println() 是一个方法。\n * system 是系统类。\n * out 是标准输出对象。\n\n这句话的用法是调用系统类 system 中的标准输出对象 out 中的方法 println()。\n\n那么什么是方法呢？\n\njava方法是语句的集合，它们在一起执行一个功能。\n\n * 方法是解决一类问题的步骤的有序组合\n * 方法包含于类或对象中\n * 方法在程序中被创建，在其他地方被引用\n\n设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最 好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。\n\n方法的优点\n\n * 使程序变得更简短而清晰。\n * 有利于程序维护。\n * 可以提高程序开发的效率。\n * 提高了代码的重用性。\n\n回顾：方法的命名规则？\n\n\n# 2、方法的定义\n\njava的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法 包含以下语法：\n\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * 修饰符\n   \n   修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n\n * 返回值类型\n   \n   方法可能会返回值。returnvaluetype 是方法返回值的数据类型。有些方法执行所需 的操作，但没有返回值。在这种情况下，returnvaluetype 是关键字void。\n\n * 方法名\n   \n   是方法的实际名称。方法名和参数表共同构成方法签名。\n\n * 参数类型\n   \n   参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n   \n   * 形式参数：在方法被调用时用于接收外界输入的数据。\n   * 实参：调用方法时实际传给方法的数据。\n   \n   \n\n * 方法体\n   \n   方法体包含具体的语句，定义该方法的功能。\n\n比如我们写一个比大小的方法：\n\n【演示】下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。\n\n/** 返回两个整型变量数据的较大值 */\npublic static int max(int num1, int num2) {\n    int result;\n    if (num1 > num2){\n        result = num1;\n    }\n    else{\n        result = num2;\n    }\n        \n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【演示：加法】\n\npublic int add(int num1, int num2) {\n    return num1+num2;\n}\n\n\n1\n2\n3\n\n\n\n# 3、方法调用\n\njava 支持两种调用方法的方式，根据方法是否返回值来选择。\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\n当方法返回一个值的时候，方法调用通常被当做一个值。例如：\n\nint larger = max(30, 40);\n\n\n1\n\n\njava语言中使用下述形式调用方法：对象名.方法名(实参列表)\n\n如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：\n\nsystem.out.println("hello,kuangshen!");\n\n\n1\n\n\n【演示：定义方法并且调用它】\n\npublic static void main(string[] args) {\n    int i = 5;\n    int j = 2;\n    int k = max(i, j);\n    system.out.println( i + " 和 " + j + " 比较，最大值是：" + k);\n}\n\n/** 返回两个整数变量较大的值 */\npublic static int max(int num1, int num2) {\n    int result;\n    if (num1 > num2){\n        result = num1;\n    }  \n    else{\n        result = num2;\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这个程序包含 main 方法和 max 方法。main 方法是被 jvm 调用的，除此之外，main 方法和其它方法 没什么区别。java中只有值传递！\n\nmain 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 string[] 类型参数。string[] 表明参数是字符串数组。\n\n\n# 4、方法的重载\n\n上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？\n\n解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：\n\npublic static double max(double num1, double num2) {\n    if (num1 > num2)\n    return num1;\n    else\n    return num2;\n}\n\npublic static int max(int num1, int num2) {\n    int result;\n    if (num1 > num2)\n    result = num1;\n    else\n    result = num2;\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；\n\n如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；\n\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\n\njava编译器根据方法签名判断哪个方法应该被调用。\n\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n\n\n# 5、拓展命令行传参\n\n有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。\n\n命令行参数是在执行程序时候紧跟在程序名字后面的信息。\n\n【下面的程序打印所有的命令行参数】\n\npublic class commandline {\n\tpublic static void main(string args[]){\n\t\tfor(int i=0; i<args.length; i++){\n\t\t\tsystem.out.println("args[" + i + "]: " + args[i]);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【命令行】\n\njavac commandline.java\njava commandline this is a command line 200 -100\n\n\n1\n2\n\n\n> args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]: 200 args[6]: -100\n\n\n# 6、可变参数\n\njdk 1.5 开始，java支持传递同类型的可变参数给一个方法。\n\n方法的可变参数的声明如下所示：\n\n> typename... parametername\n\n在方法声明中，在指定参数类型后加一个省略号(...)\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\npublic static void main(string[] args) {\n    // 调用可变参数的方法\n    printmax(34, 3, 3, 2, 56.5);\n    printmax(new double[]{1, 2, 3});\n}\n\npublic static void printmax(double... numbers) {\n    if (numbers.length == 0) {\n        system.out.println("no argument passed");\n        return;\n    }\n    double result = numbers[0];\n    //排序！\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > result) {\n            result = numbers[i];\n        }\n    }\n    system.out.println("the max value is " + result);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 7、递归\n\na方法调用b方法，我们很容易理解！\n\n递归就是：a方法调用a方法！就是自己调用自己，因此我们在设计递归算法时，一定要指明什么时候自己不调用自己。否则，就是个死循环！\n\n递归算法重点：\n\n递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。\n\n利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原 问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计 算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。\n\n递归结构包括两个部分：\n\n * 递归头\n   \n   什么时候不调用自身方法。如果没有头，将陷入死循环。\n\n * 递归体\n\n什么时候需要调用自身方法。\n\n【演示：利用代码计算5的乘阶！】\n\n//5*4*3*2*1\npublic static void main(string[] args) {\n    system.out.println(f(5));\n}\npublic static int f(int n) {\n    if (1 == n)\n    \treturn 1;\n    else\n    \treturn n*f(n-1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n此题中，按照递归的三个条件来分析：\n\n(1)边界条件：阶乘，乘到最后一个数，即1的时候，返回1，程序执行到底； (2)递归前进段：当前的参数不等于1的时候，继续调用自身； (3)递归返回段：从最大的数开始乘，如果当前参数是5，那么就是5* 4，即5 (5-1)，即n * (n-1)\n\n递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理 解，容易编程。但递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一 些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许 多额外的时间开销。所以在深度大时，它的时空性就不好了。（会占用大量的内存空间）\n\n而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但 缺点就是不容易理解，编写复杂问题时困难。\n\n能不用递归就不用递归，递归都可以用迭代来代替',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaSE-数组",frontmatter:{title:null,date:"2021-04-15T22:46:20.000Z",permalink:"/java/se/array/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/05.%E6%95%B0%E7%BB%84.html",relativePath:"01.Java/02.java-基础/05.数组.md",key:"v-6d754144",path:"/java/se/array/",headers:[{level:2,title:"数组概述",slug:"数组概述",normalizedTitle:"数组概述",charIndex:16},{level:2,title:"数组声明创建",slug:"数组声明创建",normalizedTitle:"数组声明创建",charIndex:703},{level:3,title:"1、声明数组",slug:"_1、声明数组",normalizedTitle:"1、声明数组",charIndex:714},{level:3,title:"2、创建数组",slug:"_2、创建数组",normalizedTitle:"2、创建数组",charIndex:1030},{level:3,title:"3、内存分析",slug:"_3、内存分析",normalizedTitle:"3、内存分析",charIndex:1999},{level:3,title:"4、三种初始化",slug:"_4、三种初始化",normalizedTitle:"4、三种初始化",charIndex:2452},{level:3,title:"5、数组边界",slug:"_5、数组边界",normalizedTitle:"5、数组边界",charIndex:3050},{level:3,title:"6、小结",slug:"_6、小结",normalizedTitle:"6、小结",charIndex:3321},{level:2,title:"数组使用",slug:"数组使用",normalizedTitle:"数组使用",charIndex:3436},{level:3,title:"1、For-Each 循环",slug:"_1、for-each-循环",normalizedTitle:"1、for-each 循环",charIndex:4159},{level:3,title:"2、数组作方法入参",slug:"_2、数组作方法入参",normalizedTitle:"2、数组作方法入参",charIndex:4522},{level:3,title:"3、数组作返回值",slug:"_3、数组作返回值",normalizedTitle:"3、数组作返回值",charIndex:4737},{level:2,title:"多维数组",slug:"多维数组",normalizedTitle:"多维数组",charIndex:5012},{level:2,title:"Arrays 类",slug:"arrays-类",normalizedTitle:"arrays 类",charIndex:5580},{level:3,title:"1、打印数组",slug:"_1、打印数组",normalizedTitle:"1、打印数组",charIndex:6661},{level:3,title:"2、数组排序",slug:"_2、数组排序",normalizedTitle:"2、数组排序",charIndex:6844},{level:3,title:"3、二分法查找",slug:"_3、二分法查找",normalizedTitle:"3、二分法查找",charIndex:7083},{level:3,title:"4、元素填充",slug:"_4、元素填充",normalizedTitle:"4、元素填充",charIndex:7422},{level:3,title:"5、数组转换为List集合",slug:"_5、数组转换为list集合",normalizedTitle:"5、数组转换为list集合",charIndex:7696},{level:2,title:"常见排序算法",slug:"常见排序算法",normalizedTitle:"常见排序算法",charIndex:7952},{level:3,title:"1、冒泡排序",slug:"_1、冒泡排序",normalizedTitle:"1、冒泡排序",charIndex:7963},{level:3,title:"2、选择排序",slug:"_2、选择排序",normalizedTitle:"2、选择排序",charIndex:9416},{level:3,title:"3、直接插入排序",slug:"_3、直接插入排序",normalizedTitle:"3、直接插入排序",charIndex:10565},{level:3,title:"4、希尔排序",slug:"_4、希尔排序",normalizedTitle:"4、希尔排序",charIndex:11155},{level:3,title:"5、快速排序",slug:"_5、快速排序",normalizedTitle:"5、快速排序",charIndex:11166},{level:3,title:"6、归并排序",slug:"_6、归并排序",normalizedTitle:"6、归并排序",charIndex:11177},{level:3,title:"7、基数排序",slug:"_7、基数排序",normalizedTitle:"7、基数排序",charIndex:11188},{level:3,title:"8、堆排序",slug:"_8、堆排序",normalizedTitle:"8、堆排序",charIndex:11199},{level:2,title:"稀疏数组",slug:"稀疏数组",normalizedTitle:"稀疏数组",charIndex:11209}],headersStr:"数组概述 数组声明创建 1、声明数组 2、创建数组 3、内存分析 4、三种初始化 5、数组边界 6、小结 数组使用 1、For-Each 循环 2、数组作方法入参 3、数组作返回值 多维数组 Arrays 类 1、打印数组 2、数组排序 3、二分法查找 4、元素填充 5、数组转换为List集合 常见排序算法 1、冒泡排序 2、选择排序 3、直接插入排序 4、希尔排序 5、快速排序 6、归并排序 7、基数排序 8、堆排序 稀疏数组",content:'# JavaSE-数组\n\n\n# 数组概述\n\n关于数组我们可以把它看作是一个类型的所有数据的一个集合，并用一个数组下标来区分或指定每一个数，例如一个足球队通常会有几十个人，但是我们来认识他们的时候首先会把他们看作是某某对的成员，然后再利用他们的号码来区分每一个队员，这时候，球队就是一个数组，而号码就是数组的下标， 当我们指明是几号队员的时候就找到了这个队员。 同样在编程中，如果我们有一组相同数据类型的数据，例如有10个数字，这时候如果我们要用变量来存放它们的话，就要分别使用10个变量，而且要记住这10个变量的名字，这会十分的麻烦，这时候我们就可以用一个数组变量来存放他们，例如在VB中我们 就可以使用dim a(9) as integer（注意：数组的下标是从0开始的，所以第10个数的话，下标就是 9，a(0)=1）。 使用数组会让程序变的简单，而且避免了定义多个变量的麻烦。\n\n数组的定义：\n\n * 数组是相同类型数据的有序集合\n * 数组描述的是相同类型的若干个数据,按照一定的先后次序排列组合而成\n * 其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们.\n\n数组的四个基本特点：\n\n * 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。\n * 其元素必须是相同类型，不允许出现混合类型。\n * 数组中的元素可以是任何数据类型，包括基本类型和引用类型。\n * 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。\n\n\n# 数组声明创建\n\n\n# 1、声明数组\n\n首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：\n\ndataType[] arrayRefVar; // 首选的方法\n\ndataType arrayRefVar[]; // 效果相同，但不是首选方法\n\n\n1\n2\n3\n\n\n建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。\n\ndouble[] myList; // 首选的方法\ndouble myList[]; // 效果相同，但不是首选方法\n\n\n1\n2\n\n\n\n# 2、创建数组\n\nJava语言使用new操作符来创建数组，语法如下：\n\narrayRefVar = new dataType[arraySize];\n\n\n1\n\n\n上面的语法语句做了两件事：\n\n * 使用 dataType[arraySize] 创建了一个数组。\n * 把新创建的数组的引用赋值给变量 arrayRefVar。\n\n数组变量的声明，和创建数组可以用一条语句完成，如下所示：\n\ndataType[] arrayRefVar = new dataType[arraySize];\n//例如，创建一个类型ini，大小为10的数组\nint[] myList =  new int[10];\n\n\n1\n2\n3\n\n\n获取数组长度：arrayRefVar.length\n\n数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1\n\n【演示创建一个数组，并赋值，进行访问】\n\npublic static void main(String[] args) {\n    //1.声明一个数组\n    int[] myList = null;\n    //2.创建一个数组\n    myList = new int[10];\n    //3.像数组中存值\n    myList[0] = 1;\n    myList[1] = 2;\n    myList[2] = 3;\n    myList[3] = 4;\n    myList[4] = 5;\n    myList[5] = 6;\n    myList[6] = 7;\n    myList[7] = 8;\n    myList[8] = 9;\n    myList[9] = 10;\n    // 计算所有元素的总和\n    double total = 0;\n    for (int i = 0; i < myList.length; i++) {\n        total += myList[i];\n    }\n    System.out.println("总和为： " + total);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 3、内存分析\n\nJava内存分析 ：\n\n\n\n 1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。因此，声明数组时不能指定其长度(数组中元素的个数)\n    \n    例如： int a[5]; //非法\n\n 2. 声明一个数组的时候并没有数组被真正的创建。\n\n 3. 构造一个数组，必须指定长度\n\n//1.声明一个数组\nint[] myList = null;\n\n\n1\n2\n\n\n\n\n//2.创建一个数组\nmyList = new int[10];\n\n\n1\n2\n\n\n\n\n//3.像数组中存值\nmyList[0] = 1;\nmyList[1] = 2;\nmyList[2] = 3;\nmyList[3] = 4;\nmyList[4] = 5;\nmyList[5] = 6;\nmyList[6] = 7;\nmyList[7] = 8;\nmyList[8] = 9;\nmyList[9] = 10;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n\n# 4、三种初始化\n\n1、静态初始化\n\n除了用new关键字来产生数组以外,还可以直接在定义数组的同时就为数组元素分配空间并赋值。\n\nint[] a = {1,2,3};\nMan[] mans = {new Man(1,1),new Man(2,2)};\n\n\n1\n2\n\n\n2、动态初始化\n\n数组定义、为数组元素分配空间、赋值的操作、分开进行。\n\nint[] a = new int[2];\na[0]=1;\na[1]=2;\n\n\n1\n2\n3\n\n\n3、数组的默认初始化\n\n数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。\n\npublic static void main(String[] args) {\n    int[] a=new int[2];\n    boolean[] b = new boolean[2];\n    String[] s = new String[2];\n    System.out.println(a[0]+":"+a[1]); //0,0\n    System.out.println(b[0]+":"+b[1]); //false,false\n    System.out.println(s[0]+":"+s[1]); //null, null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5、数组边界\n\n下标的合法区间：[0, length-1]，如果越界就会报错；\n\npublic static void main(String[] args) {\n    int[] a=new int[2];\n    System.out.println(a[2]);\n}\n\n\n1\n2\n3\n4\n\n\n> Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 2\n\nArrayIndexOutOfBoundsException : 数组下标越界异常！\n\n\n# 6、小结\n\n数组是相同数据类型(数据类型可以为任意类型)的有序集合\n\n数组也是对象。数组元素相当于对象的成员变量(详情请见内存图)\n\n数组长度的确定的，不可变的。如果越界，则报：ArrayIndexOutofBounds\n\n\n# 数组使用\n\n数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 ForEach 循环。\n\n【该实例完整地展示了如何创建、初始化和操纵数组】\n\npublic static void main(String[] args) {\n    double[] myList = {1.9, 2.9, 3.4, 3.5};\n    // 打印所有数组元素\n    for (int i = 0; i < myList.length; i++) {\n        System.out.println(myList[i] + " ");\n    }\n    // 计算所有元素的总和\n    double total = 0;\n    for (int i = 0; i < myList.length; i++) {\n        total += myList[i];\n    }\n    System.out.println("Total is " + total);\n    // 查找最大元素\n    double max = myList[0];\n    for (int i = 1; i < myList.length; i++) {\n        if (myList[i] > max) {\n            max = myList[i];\n        }\n    }\n    System.out.println("Max is " + max);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 1、For-Each 循环\n\nJDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。\n\nfor(type element: array){\n    System.out.println(element);\n}\n\n\n1\n2\n3\n\n\n【示例】\n\npublic static void main(String[] args) {\n    double[] myList = {1.9, 2.9, 3.4, 3.5};\n    \n    // 打印所有数组元素\n    for (double element: myList) {\n        System.out.println(element);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2、数组作方法入参\n\n数组可以作为参数传递给方法。\n\n例如，下面的例子就是一个打印 int 数组中元素的方法 :\n\npublic static void printArray(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        System.out.print(array[i] + " ");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3、数组作返回值\n\npublic static int[] reverse(int[] list) {\n    int[] result = new int[list.length];\n    \n    for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n        result[j] = list[i];\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n以上实例中 result 数组作为函数的返回值。\n\n\n# 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n\n1、多维数组的动态初始化：（以二维数组为例）\n\n直接为每一维分配空间，格式如下：\n\ntype[][] typeName = new type[typeLength1][typeLength2];\n\n\n1\n\n\ntype 可以为基本数据类型和复合数据类型，arraylenght1 和 arraylenght2 必须为正整数， arraylenght1 为行数，arraylenght2 为列数。\n\n比如定义一个二维数组：\n\nint a[][] = new int[2][5];\n\n\n1\n\n\n解析：二维数组 a 可以看成一个两行三列的数组。\n\n2、多维数组的引用（以二维数组为例）\n\n对二维数组中的每个元素，引用方式为 arrayName[index1] [index2]，例如：\n\n> num[1] [0];\n\n其实二维甚至多维数组十分好理解，我们把两个或者多个值当做定位就好。\n\n原来的数组就是一条线，我们知道一个位置就好\n\n二维就是一个面，两点确定一个位置\n\n三维呢，就需要三个点来确定\n\n3、获取数组长度：\n\na.length获取的二维数组第一维数组的长度，a[0].length才是获取第二维第一个数组长度。\n\n\n# Arrays 类\n\n数组的工具类java.util.Arrays\n\n由于数组对象本身并没有什么方法可以供我们调用,但API中提供了一个工具类Arrays供我们使用,从 而可以对数据对象进行一些基本的操作。\n\n文档简介：\n\n\n\n这个文档，百度即可下载：jdk1.8中文文档\n\nArrays类中的方法都是static修饰的静态方法,在使用的时候可以直接使用类名进行调用，而"不用"使用对象来调用(注意：是"不用" 而不是 "不能")\n\njava.util.Arrays 类能方便地操作数组. 使用之前需要导包！\n\n具有以下常用功能：\n\n * 给数组赋值：通过 fill 方法。\n * 对数组排序：通过 sort 方法,按升序。\n * 比较数组：通过 equals 方法比较数组中元素值是否相等。\n * 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\n\n具体说明请查看下表：\n\n序号   方法和说明\n1    public static int binarySearch(Object[] a, Object key)\n     用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回\n     (-(插入点) - 1)。\n2    public static boolean equals(long[] a, long[] a2) 如果两个指定的\n     long 型数组彼此相等，则返回\n     true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。\n3    public static void fill(int[] a, int val) 将指定的 int 值分配给指定\n     int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。\n4    public static void sort(Object[] a)\n     对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。\n\n来源菜鸟教程，一个编程的基础技术教程网站，适合初学者查看资料，我PHP基础就是在这里学的。\n\n\n# 1、打印数组\n\npublic static void main(String[] args) {\n    int[] a = {1,2};\n    System.out.println(a); //[I@1b6d3586\n    System.out.println(Arrays.toString(a)); //[1, 2]\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2、数组排序\n\n对指定的 int 型数组按数字升序进行排序\n\npublic static void main(String[] args) {\n    int[] a = {1,2,323,23,543,12,59};\n    System.out.println(Arrays.toString(a));\n    Arrays.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、二分法查找\n\n在数组中查找指定元素并返回其下标\n\n注意：使用二分搜索法来搜索指定的数组，以获得指定的值。必须在进行此调用之前对数组进行排序(通过sort方法等)。如果没有对数组进行排序，则结果是不确定的。\n\n如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。\n\npublic static void main(String[] args) {\n    int[] a = {1,2,323,23,543,12,59};\n    Arrays.sort(a); //使用二分法查找，必须先对数组进行排序\n    System.out.println("该元素的索引："+Arrays.binarySearch(a, 12));\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4、元素填充\n\npublic static void main(String[] args) {\n    int[] a = {1,2,323,23,543,12,59};\n    Arrays.sort(a); //使用二分法查找，必须先对数组进行排序\n    Arrays.fill(a, 2, 4, 100); //将2到4索引的元素替换为100\n    System.out.println(Arrays.toString(a));//[1, 2, 100, 100, 59, 323, 543]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5、数组转换为List集合\n\nint[] a = {3,5,1,9,7};\nList<int[]> list = Arrays.asList(a);\n\n\n1\n2\n\n\n我们写代码的时候，可以不用刻意去记住List<int[]> 在idea中，输入Arrays.asList(a); 按下alt + 回车键，会自动补全全面的信息，非常方便。\n\n学校中教学一般用的是eclipse，别问为啥，问就是这个免费，idea要钱。想用的小伙伴自行百度解决💪，学计算机的人，pojie版的资源找不到就说不过去了。😊\n\n\n# 常见排序算法\n\n\n# 1、冒泡排序\n\n冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。\n\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n\n冒泡排序算法的原理如下：\n\n * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n * 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数\n * 针对所有的元素重复以上的步骤，除了最后一个。\n * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n冒泡排序——《图解算法》\n\nclass Bubble {\n    public int[] sort(int[] array) {\n        int temp = 0;\n        // 外层循环，它决定一共走几趟 //-1为了防止溢出\n        for (int i = 0; i < array.length - 1; i++) {\n            int flag = 0; //通过符号位可以减少无谓的比较，如果已经有序了，就退出循环\n            //内层循环，它决定每趟走一次\n            for (int j = 0; j < array.length - i - 1; j++) {\n                //如果后一个大于前一个,则换位\n                if (array[j + 1] > array[j]) {\n                    temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                    flag = 1;\n                }\n            }\n            if (flag == 0) {\n                break;\n            }\n        }\n        return array;\n    }\n\n    public static void main(String[] args) {\n        Bubble bubble = new Bubble();\n        int[] array = {2, 5, 1, 6, 4, 9, 8, 5, 3, 1, 2, 0};\n        int[] sort = bubble.sort(array);\n        for (int num : sort) {\n            System.out.print(num + "\\t");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 2、选择排序\n\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中 选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小 （大）元素，然后放到排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳 定的排序方法。\n\nclass SelectSort {\n    public int[] sort(int arr[]) {\n        int temp = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            // 认为目前的数就是最小的, 记录最小数的下标\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[minIndex] > arr[j]) {// 修改最小值的下标\n                    minIndex = j;\n                }\n            }// 当退出for就找到这次的最小值,就需要交换位置了\n            if (i != minIndex) {//交换当前值和找到的最小值的位置\n                temp = arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        SelectSort selectSort = new SelectSort();\n        int[] array = {2, 5, 1, 6, 4, 9, 8, 5, 3, 1, 2, 0};\n        int[] sort = selectSort.sort(array);\n        for (int num : sort) {\n            System.out.print(num + "\\t");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3、直接插入排序\n\n排序原理：基本操作是将一条记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表。\n\n例如：\n\n原始数据： 49,38,65,97,76,13,27\n\n[49],38,65,97,76,13,27 从1索引开始插入\n[38,49],65,97,76,13,27\n[38,49,65],97,76,13,27\n[38,49,65,97],76,13,27\n[38,49,65,76,97],13,27\n[13,38,49,65,76,97],27\n[13,27,38,49,65,76,97]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n代码实现：\n\nint arr[]={49,38,65,97,76,13,27};\nfor (int i = 1; i < arr.length; i++) {\n    for(int j=i; j>0;j--){\n        if(arr[j]<arr[j-1]){\n            int f=arr[j];\n            arr[j]=arr[j-1];\n            arr[j-1]=f;\n        }\n    }\n}\nSystem.out.println(Arrays.toString(arr));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4、希尔排序\n\n\n# 5、快速排序\n\n\n# 6、归并排序\n\n\n# 7、基数排序\n\n\n# 8、堆排序\n\n\n# 稀疏数组\n\nhttps://blog.csdn.net/baolingye/article/details/99943083',normalizedContent:'# javase-数组\n\n\n# 数组概述\n\n关于数组我们可以把它看作是一个类型的所有数据的一个集合，并用一个数组下标来区分或指定每一个数，例如一个足球队通常会有几十个人，但是我们来认识他们的时候首先会把他们看作是某某对的成员，然后再利用他们的号码来区分每一个队员，这时候，球队就是一个数组，而号码就是数组的下标， 当我们指明是几号队员的时候就找到了这个队员。 同样在编程中，如果我们有一组相同数据类型的数据，例如有10个数字，这时候如果我们要用变量来存放它们的话，就要分别使用10个变量，而且要记住这10个变量的名字，这会十分的麻烦，这时候我们就可以用一个数组变量来存放他们，例如在vb中我们 就可以使用dim a(9) as integer（注意：数组的下标是从0开始的，所以第10个数的话，下标就是 9，a(0)=1）。 使用数组会让程序变的简单，而且避免了定义多个变量的麻烦。\n\n数组的定义：\n\n * 数组是相同类型数据的有序集合\n * 数组描述的是相同类型的若干个数据,按照一定的先后次序排列组合而成\n * 其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们.\n\n数组的四个基本特点：\n\n * 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。\n * 其元素必须是相同类型，不允许出现混合类型。\n * 数组中的元素可以是任何数据类型，包括基本类型和引用类型。\n * 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。\n\n\n# 数组声明创建\n\n\n# 1、声明数组\n\n首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：\n\ndatatype[] arrayrefvar; // 首选的方法\n\ndatatype arrayrefvar[]; // 效果相同，但不是首选方法\n\n\n1\n2\n3\n\n\n建议使用 datatype[] arrayrefvar 的声明风格声明数组变量。 datatype arrayrefvar[] 风格是来自 c/c++ 语言 ，在java中采用是为了让 c/c++ 程序员能够快速理解java语言。\n\ndouble[] mylist; // 首选的方法\ndouble mylist[]; // 效果相同，但不是首选方法\n\n\n1\n2\n\n\n\n# 2、创建数组\n\njava语言使用new操作符来创建数组，语法如下：\n\narrayrefvar = new datatype[arraysize];\n\n\n1\n\n\n上面的语法语句做了两件事：\n\n * 使用 datatype[arraysize] 创建了一个数组。\n * 把新创建的数组的引用赋值给变量 arrayrefvar。\n\n数组变量的声明，和创建数组可以用一条语句完成，如下所示：\n\ndatatype[] arrayrefvar = new datatype[arraysize];\n//例如，创建一个类型ini，大小为10的数组\nint[] mylist =  new int[10];\n\n\n1\n2\n3\n\n\n获取数组长度：arrayrefvar.length\n\n数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayrefvar.length-1\n\n【演示创建一个数组，并赋值，进行访问】\n\npublic static void main(string[] args) {\n    //1.声明一个数组\n    int[] mylist = null;\n    //2.创建一个数组\n    mylist = new int[10];\n    //3.像数组中存值\n    mylist[0] = 1;\n    mylist[1] = 2;\n    mylist[2] = 3;\n    mylist[3] = 4;\n    mylist[4] = 5;\n    mylist[5] = 6;\n    mylist[6] = 7;\n    mylist[7] = 8;\n    mylist[8] = 9;\n    mylist[9] = 10;\n    // 计算所有元素的总和\n    double total = 0;\n    for (int i = 0; i < mylist.length; i++) {\n        total += mylist[i];\n    }\n    system.out.println("总和为： " + total);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 3、内存分析\n\njava内存分析 ：\n\n\n\n 1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，jvm才分配空间，这时才与长度有关。因此，声明数组时不能指定其长度(数组中元素的个数)\n    \n    例如： int a[5]; //非法\n\n 2. 声明一个数组的时候并没有数组被真正的创建。\n\n 3. 构造一个数组，必须指定长度\n\n//1.声明一个数组\nint[] mylist = null;\n\n\n1\n2\n\n\n\n\n//2.创建一个数组\nmylist = new int[10];\n\n\n1\n2\n\n\n\n\n//3.像数组中存值\nmylist[0] = 1;\nmylist[1] = 2;\nmylist[2] = 3;\nmylist[3] = 4;\nmylist[4] = 5;\nmylist[5] = 6;\nmylist[6] = 7;\nmylist[7] = 8;\nmylist[8] = 9;\nmylist[9] = 10;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n\n# 4、三种初始化\n\n1、静态初始化\n\n除了用new关键字来产生数组以外,还可以直接在定义数组的同时就为数组元素分配空间并赋值。\n\nint[] a = {1,2,3};\nman[] mans = {new man(1,1),new man(2,2)};\n\n\n1\n2\n\n\n2、动态初始化\n\n数组定义、为数组元素分配空间、赋值的操作、分开进行。\n\nint[] a = new int[2];\na[0]=1;\na[1]=2;\n\n\n1\n2\n3\n\n\n3、数组的默认初始化\n\n数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。\n\npublic static void main(string[] args) {\n    int[] a=new int[2];\n    boolean[] b = new boolean[2];\n    string[] s = new string[2];\n    system.out.println(a[0]+":"+a[1]); //0,0\n    system.out.println(b[0]+":"+b[1]); //false,false\n    system.out.println(s[0]+":"+s[1]); //null, null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5、数组边界\n\n下标的合法区间：[0, length-1]，如果越界就会报错；\n\npublic static void main(string[] args) {\n    int[] a=new int[2];\n    system.out.println(a[2]);\n}\n\n\n1\n2\n3\n4\n\n\n> exception in thread "main" java.lang.arrayindexoutofboundsexception: 2\n\narrayindexoutofboundsexception : 数组下标越界异常！\n\n\n# 6、小结\n\n数组是相同数据类型(数据类型可以为任意类型)的有序集合\n\n数组也是对象。数组元素相当于对象的成员变量(详情请见内存图)\n\n数组长度的确定的，不可变的。如果越界，则报：arrayindexoutofbounds\n\n\n# 数组使用\n\n数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。\n\n【该实例完整地展示了如何创建、初始化和操纵数组】\n\npublic static void main(string[] args) {\n    double[] mylist = {1.9, 2.9, 3.4, 3.5};\n    // 打印所有数组元素\n    for (int i = 0; i < mylist.length; i++) {\n        system.out.println(mylist[i] + " ");\n    }\n    // 计算所有元素的总和\n    double total = 0;\n    for (int i = 0; i < mylist.length; i++) {\n        total += mylist[i];\n    }\n    system.out.println("total is " + total);\n    // 查找最大元素\n    double max = mylist[0];\n    for (int i = 1; i < mylist.length; i++) {\n        if (mylist[i] > max) {\n            max = mylist[i];\n        }\n    }\n    system.out.println("max is " + max);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 1、for-each 循环\n\njdk 1.5 引进了一种新的循环类型，被称为 for-each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。\n\nfor(type element: array){\n    system.out.println(element);\n}\n\n\n1\n2\n3\n\n\n【示例】\n\npublic static void main(string[] args) {\n    double[] mylist = {1.9, 2.9, 3.4, 3.5};\n    \n    // 打印所有数组元素\n    for (double element: mylist) {\n        system.out.println(element);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2、数组作方法入参\n\n数组可以作为参数传递给方法。\n\n例如，下面的例子就是一个打印 int 数组中元素的方法 :\n\npublic static void printarray(int[] array) {\n    for (int i = 0; i < array.length; i++) {\n        system.out.print(array[i] + " ");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3、数组作返回值\n\npublic static int[] reverse(int[] list) {\n    int[] result = new int[list.length];\n    \n    for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n        result[j] = list[i];\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n以上实例中 result 数组作为函数的返回值。\n\n\n# 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n\n1、多维数组的动态初始化：（以二维数组为例）\n\n直接为每一维分配空间，格式如下：\n\ntype[][] typename = new type[typelength1][typelength2];\n\n\n1\n\n\ntype 可以为基本数据类型和复合数据类型，arraylenght1 和 arraylenght2 必须为正整数， arraylenght1 为行数，arraylenght2 为列数。\n\n比如定义一个二维数组：\n\nint a[][] = new int[2][5];\n\n\n1\n\n\n解析：二维数组 a 可以看成一个两行三列的数组。\n\n2、多维数组的引用（以二维数组为例）\n\n对二维数组中的每个元素，引用方式为 arrayname[index1] [index2]，例如：\n\n> num[1] [0];\n\n其实二维甚至多维数组十分好理解，我们把两个或者多个值当做定位就好。\n\n原来的数组就是一条线，我们知道一个位置就好\n\n二维就是一个面，两点确定一个位置\n\n三维呢，就需要三个点来确定\n\n3、获取数组长度：\n\na.length获取的二维数组第一维数组的长度，a[0].length才是获取第二维第一个数组长度。\n\n\n# arrays 类\n\n数组的工具类java.util.arrays\n\n由于数组对象本身并没有什么方法可以供我们调用,但api中提供了一个工具类arrays供我们使用,从 而可以对数据对象进行一些基本的操作。\n\n文档简介：\n\n\n\n这个文档，百度即可下载：jdk1.8中文文档\n\narrays类中的方法都是static修饰的静态方法,在使用的时候可以直接使用类名进行调用，而"不用"使用对象来调用(注意：是"不用" 而不是 "不能")\n\njava.util.arrays 类能方便地操作数组. 使用之前需要导包！\n\n具有以下常用功能：\n\n * 给数组赋值：通过 fill 方法。\n * 对数组排序：通过 sort 方法,按升序。\n * 比较数组：通过 equals 方法比较数组中元素值是否相等。\n * 查找数组元素：通过 binarysearch 方法能对排序好的数组进行二分查找法操作。\n\n具体说明请查看下表：\n\n序号   方法和说明\n1    public static int binarysearch(object[] a, object key)\n     用二分查找算法在给定数组中搜索给定值的对象(byte,int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回\n     (-(插入点) - 1)。\n2    public static boolean equals(long[] a, long[] a2) 如果两个指定的\n     long 型数组彼此相等，则返回\n     true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（byte，short，int等）。\n3    public static void fill(int[] a, int val) 将指定的 int 值分配给指定\n     int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（byte，short，int等）。\n4    public static void sort(object[] a)\n     对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（byte，short，int等）。\n\n来源菜鸟教程，一个编程的基础技术教程网站，适合初学者查看资料，我php基础就是在这里学的。\n\n\n# 1、打印数组\n\npublic static void main(string[] args) {\n    int[] a = {1,2};\n    system.out.println(a); //[i@1b6d3586\n    system.out.println(arrays.tostring(a)); //[1, 2]\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2、数组排序\n\n对指定的 int 型数组按数字升序进行排序\n\npublic static void main(string[] args) {\n    int[] a = {1,2,323,23,543,12,59};\n    system.out.println(arrays.tostring(a));\n    arrays.sort(a);\n    system.out.println(arrays.tostring(a));\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、二分法查找\n\n在数组中查找指定元素并返回其下标\n\n注意：使用二分搜索法来搜索指定的数组，以获得指定的值。必须在进行此调用之前对数组进行排序(通过sort方法等)。如果没有对数组进行排序，则结果是不确定的。\n\n如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。\n\npublic static void main(string[] args) {\n    int[] a = {1,2,323,23,543,12,59};\n    arrays.sort(a); //使用二分法查找，必须先对数组进行排序\n    system.out.println("该元素的索引："+arrays.binarysearch(a, 12));\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4、元素填充\n\npublic static void main(string[] args) {\n    int[] a = {1,2,323,23,543,12,59};\n    arrays.sort(a); //使用二分法查找，必须先对数组进行排序\n    arrays.fill(a, 2, 4, 100); //将2到4索引的元素替换为100\n    system.out.println(arrays.tostring(a));//[1, 2, 100, 100, 59, 323, 543]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5、数组转换为list集合\n\nint[] a = {3,5,1,9,7};\nlist<int[]> list = arrays.aslist(a);\n\n\n1\n2\n\n\n我们写代码的时候，可以不用刻意去记住list<int[]> 在idea中，输入arrays.aslist(a); 按下alt + 回车键，会自动补全全面的信息，非常方便。\n\n学校中教学一般用的是eclipse，别问为啥，问就是这个免费，idea要钱。想用的小伙伴自行百度解决💪，学计算机的人，pojie版的资源找不到就说不过去了。😊\n\n\n# 常见排序算法\n\n\n# 1、冒泡排序\n\n冒泡排序（bubble sort），是一种计算机科学领域的较简单的排序算法。\n\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从z到a）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n\n冒泡排序算法的原理如下：\n\n * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n * 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数\n * 针对所有的元素重复以上的步骤，除了最后一个。\n * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n冒泡排序——《图解算法》\n\nclass bubble {\n    public int[] sort(int[] array) {\n        int temp = 0;\n        // 外层循环，它决定一共走几趟 //-1为了防止溢出\n        for (int i = 0; i < array.length - 1; i++) {\n            int flag = 0; //通过符号位可以减少无谓的比较，如果已经有序了，就退出循环\n            //内层循环，它决定每趟走一次\n            for (int j = 0; j < array.length - i - 1; j++) {\n                //如果后一个大于前一个,则换位\n                if (array[j + 1] > array[j]) {\n                    temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                    flag = 1;\n                }\n            }\n            if (flag == 0) {\n                break;\n            }\n        }\n        return array;\n    }\n\n    public static void main(string[] args) {\n        bubble bubble = new bubble();\n        int[] array = {2, 5, 1, 6, 4, 9, 8, 5, 3, 1, 2, 0};\n        int[] sort = bubble.sort(array);\n        for (int num : sort) {\n            system.out.print(num + "\\t");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 2、选择排序\n\n选择排序（selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中 选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小 （大）元素，然后放到排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳 定的排序方法。\n\nclass selectsort {\n    public int[] sort(int arr[]) {\n        int temp = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            // 认为目前的数就是最小的, 记录最小数的下标\n            int minindex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[minindex] > arr[j]) {// 修改最小值的下标\n                    minindex = j;\n                }\n            }// 当退出for就找到这次的最小值,就需要交换位置了\n            if (i != minindex) {//交换当前值和找到的最小值的位置\n                temp = arr[i];\n                arr[i] = arr[minindex];\n                arr[minindex] = temp;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(string[] args) {\n        selectsort selectsort = new selectsort();\n        int[] array = {2, 5, 1, 6, 4, 9, 8, 5, 3, 1, 2, 0};\n        int[] sort = selectsort.sort(array);\n        for (int num : sort) {\n            system.out.print(num + "\\t");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3、直接插入排序\n\n排序原理：基本操作是将一条记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表。\n\n例如：\n\n原始数据： 49,38,65,97,76,13,27\n\n[49],38,65,97,76,13,27 从1索引开始插入\n[38,49],65,97,76,13,27\n[38,49,65],97,76,13,27\n[38,49,65,97],76,13,27\n[38,49,65,76,97],13,27\n[13,38,49,65,76,97],27\n[13,27,38,49,65,76,97]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n代码实现：\n\nint arr[]={49,38,65,97,76,13,27};\nfor (int i = 1; i < arr.length; i++) {\n    for(int j=i; j>0;j--){\n        if(arr[j]<arr[j-1]){\n            int f=arr[j];\n            arr[j]=arr[j-1];\n            arr[j-1]=f;\n        }\n    }\n}\nsystem.out.println(arrays.tostring(arr));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4、希尔排序\n\n\n# 5、快速排序\n\n\n# 6、归并排序\n\n\n# 7、基数排序\n\n\n# 8、堆排序\n\n\n# 稀疏数组\n\nhttps://blog.csdn.net/baolingye/article/details/99943083',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"break和continue",frontmatter:{title:"break和continue",date:"2021-04-15T22:45:56.000Z",permalink:"/java/se/process-control/break-continue",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/03.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/05.break%E5%92%8Ccontinue.html",relativePath:"01.Java/02.java-基础/03.流程控制/05.break和continue.md",key:"v-0bc483d1",path:"/java/se/process-control/break-continue/",headers:[{level:2,title:"break & continue",slug:"break-continue",normalizedTitle:"break &amp; continue",charIndex:null},{level:3,title:"1、break 关键字",slug:"_1、break-关键字",normalizedTitle:"1、break 关键字",charIndex:39},{level:3,title:"2、continue 关键字",slug:"_2、continue-关键字",normalizedTitle:"2、continue 关键字",charIndex:372},{level:3,title:"3、两者区别",slug:"_3、两者区别",normalizedTitle:"3、两者区别",charIndex:764},{level:3,title:"4、带标签的continue",slug:"_4、带标签的continue",normalizedTitle:"4、带标签的continue",charIndex:924}],headersStr:"break & continue 1、break 关键字 2、continue 关键字 3、两者区别 4、带标签的continue",content:'# JavaSE-流程控制\n\n\n# break & continue\n\n\n# 1、break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n【演示：跳出循环】\n\npublic static void main(String[] args) {\n    int i = 0;\n    while (i < 100) {\n        i++;\n        System.out.println(i);\n        if (i == 30) {\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nswitch 语句中break在上面已经详细说明了\n\n\n# 2、continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n\npublic static void main(String[] args) {\n    int i = 0;\n    while (i < 100) {\n        i++;\n        if (i % 10 == 0) {\n            System.out.println();\n            continue;\n        }\n        System.out.print(i);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3、两者区别\n\nbreak在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句也在switch语句中使用)\n\ncontinue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。\n\n\n# 4、带标签的continue\n\n【了解即可】\n\n 1. goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用；Java没有goto。然而，在break和continue这两个关键字的身上，我们仍然能看出一些 goto的影子---带标签的break和continue。\n\n 2. “标签”是指后面跟一个冒号的标识符，例如：label:\n\n 3. 对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。\n\n 4. 带标签的break和continue的例子：\n    \n    【演示：打印101-150之间所有的质数】\n    \n    public static void main(String[] args) {\n        int count = 0;\n        outer: for (int i = 101; i < 150; i ++) {\n            for (int j = 2; j < i / 2; j++) {\n                if (i % j == 0){\n                     continue outer;\n                }\n            }\n            System.out.print(i+ " ");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n【看不懂没关系，只是了解一下即可，知道goto这个保留字和标签的写法】',normalizedContent:'# javase-流程控制\n\n\n# break & continue\n\n\n# 1、break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n【演示：跳出循环】\n\npublic static void main(string[] args) {\n    int i = 0;\n    while (i < 100) {\n        i++;\n        system.out.println(i);\n        if (i == 30) {\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nswitch 语句中break在上面已经详细说明了\n\n\n# 2、continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n\npublic static void main(string[] args) {\n    int i = 0;\n    while (i < 100) {\n        i++;\n        if (i % 10 == 0) {\n            system.out.println();\n            continue;\n        }\n        system.out.print(i);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3、两者区别\n\nbreak在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句也在switch语句中使用)\n\ncontinue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。\n\n\n# 4、带标签的continue\n\n【了解即可】\n\n 1. goto关键字很早就在程序设计语言中出现。尽管goto仍是java的一个保留字，但并未在语言中得到正式使用；java没有goto。然而，在break和continue这两个关键字的身上，我们仍然能看出一些 goto的影子---带标签的break和continue。\n\n 2. “标签”是指后面跟一个冒号的标识符，例如：label:\n\n 3. 对java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。\n\n 4. 带标签的break和continue的例子：\n    \n    【演示：打印101-150之间所有的质数】\n    \n    public static void main(string[] args) {\n        int count = 0;\n        outer: for (int i = 101; i < 150; i ++) {\n            for (int j = 2; j < i / 2; j++) {\n                if (i % j == 0){\n                     continue outer;\n                }\n            }\n            system.out.print(i+ " ");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n【看不懂没关系，只是了解一下即可，知道goto这个保留字和标签的写法】',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"异常机制",frontmatter:{title:"异常机制",date:"2021-04-15T22:46:39.000Z",permalink:"/java/se/exception/",categories:["java","java-se"]},regularPath:"/01.Java/02.java-%E5%9F%BA%E7%A1%80/07.%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java/02.java-基础/07.异常机制.md",key:"v-26212a8a",path:"/java/se/exception/",headers:[{level:2,title:"异常概念",slug:"异常概念",normalizedTitle:"异常概念",charIndex:18},{level:2,title:"异常体系结构",slug:"异常体系结构",normalizedTitle:"异常体系结构",charIndex:1232},{level:2,title:"异常之间的区别与联系",slug:"异常之间的区别与联系",normalizedTitle:"异常之间的区别与联系",charIndex:1657},{level:3,title:"1、Error",slug:"_1、error",normalizedTitle:"1、error",charIndex:1672},{level:3,title:"2、Exception",slug:"_2、exception",normalizedTitle:"2、exception",charIndex:2046},{level:3,title:"3、检查异常和不受检查异常",slug:"_3、检查异常和不受检查异常",normalizedTitle:"3、检查异常和不受检查异常",charIndex:2666},{level:2,title:"Java异常处理机制",slug:"java异常处理机制",normalizedTitle:"java异常处理机制",charIndex:2963},{level:3,title:"1、抛出异常",slug:"_1、抛出异常",normalizedTitle:"1、抛出异常",charIndex:3e3},{level:3,title:"2、捕获异常",slug:"_2、捕获异常",normalizedTitle:"2、捕获异常",charIndex:3602},{level:3,title:"3、异常处理五个关键字",slug:"_3、异常处理五个关键字",normalizedTitle:"3、异常处理五个关键字",charIndex:4128},{level:2,title:"处理异常",slug:"处理异常",normalizedTitle:"处理异常",charIndex:1215},{level:3,title:"1、try -catch",slug:"_1、try-catch",normalizedTitle:"1、try -catch",charIndex:4522},{level:3,title:"2、thorw",slug:"_2、thorw",normalizedTitle:"2、thorw",charIndex:8961},{level:3,title:"3、throws",slug:"_3、throws",normalizedTitle:"3、throws",charIndex:10317},{level:3,title:"4、finally",slug:"_4、finally",normalizedTitle:"4、finally",charIndex:11875},{level:3,title:"执行顺序",slug:"执行顺序",normalizedTitle:"执行顺序",charIndex:13414},{level:2,title:"自定义异常",slug:"自定义异常",normalizedTitle:"自定义异常",charIndex:13507},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:15249}],headersStr:"异常概念 异常体系结构 异常之间的区别与联系 1、Error 2、Exception 3、检查异常和不受检查异常 Java异常处理机制 1、抛出异常 2、捕获异常 3、异常处理五个关键字 处理异常 1、try -catch 2、thorw 3、throws 4、finally 执行顺序 自定义异常 总结",content:'# JavaSE-异常机制\n\n\n# 异常概念\n\n在我们日常生活中，有时会出现各种各样的异常。例如：职工小王开车去上班，在正常情况下，小王会准时到达单位。但是天有不测风云，在小王去上班时，可能会遇到一些异常情况，比如小王的车子出了故障，小王只能改为步行。\n\n实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。\n\n软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception， 意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。\n\n异常：指程序运行中出现的不期而至的各种状况，如:文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，它影响了正常的程序执行流程。\n\n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error ；\n\n如果你用 System.out.println(11/0) ，因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。\n\n异常发生的原因有很多，通常包含以下几大类：\n\n * 用户输入了非法数据。\n * 要打开的文件不存在。\n * 网络通信时连接中断，或者JVM内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。\n\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n * 检查性异常：\n   \n   最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如，要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n\n * 运行时异常：\n   \n   运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n\n * 错误：\n   \n   错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出 时，一个错误就发生了，它们在编译也检查不到的。\n\n异常指不期而至的各种状况，如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个 事件，它发生在程序运行期间，干扰了正常的指令流程。\n\nJava语言在设计的当初就考虑到这些问题，提出异常处理的框架的方案，所有的异常都可以用一个 异常类 来表示，不同类型的异常对应不同的子类异常（目前我们所说的异常包括错误概念），定义异常处理的规范，在 JDK1.4 版本以后增加了异常链机制，从而便于跟踪异常。\n\nJava异常是一个描述在代码段中发生异常的对象，当发生异常情况时，一个代表该异常的对象被创建并且在导致该异常的方法中被抛出，而该方法可以选择自己处理异常或者传递该异常。\n\n\n# 异常体系结构\n\nJava把异常当作对象来处理，并定义一个基类 java.lang.Throwable作为所有异常的超类。\n\n在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。\n\nJava异常层次结构图：\n\n\n\n从图中可以看出所有异常类型都是内置类 Throwable 的子类，因而 Throwable 在异常类的层次结构的顶层。\n\n接下来 Throwable 分成了两个不同的分支，一个分支是Error，它表示不希望被程序捕获或者是程序无法处理的错误。另一个分支是Exception，它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常。\n\n其中异常类 Exception 又分为运行时异常( RuntimeException )和非运行时异常。Java异常又可以分为不受检查异常（ Unchecked Exception ）和检查异常（ Checked Exception ）。\n\n\n# 异常之间的区别与联系\n\n\n# 1、Error\n\nError 类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。\n\n比如说：\n\nJava虚拟机运行错误（ Virtual MachineError ），当JVM不再有继续执行操作所需的内存资源时， 将出现 OutOfMemoryError 。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；\n\n还有发生在虚拟机试图执行应用时，如类定义错误（ NoClassDefFoundError )、链接错误 (LinkageError) 这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。\n\n对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状 况。在Java中，错误通常是使用 Error 的子类描述。\n\n\n# 2、Exception\n\n在 Exception 分支中有一个重要的子类RuntimeException （运行时异常），该类型的异常自动为你所编写的程序定义 ArrayIndexOutOfBoundsException （数组下标越界）、 NullPointerException （空指针异常）、ArithmeticException （算术异常）、 MissingResourceException （丢失资源）、 ClassNotFoundException （找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处 理，也可以不处理。\n\n这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而 RuntimeException 之外的异常我们统称为非运行时异常，类型上属于 Exception 类及其子类，\n\n从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException 、 SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。\n\n注意： Error 和 Exception 的区别： Error 通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程； Exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。\n\n\n# 3、检查异常和不受检查异常\n\n检查异常：在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。\n\n解析：除了RuntimeException及其子类以外，其他的Exception类及其子类都属于检查异常，当程序中可能出现这类异常，要么使用try-catch语句进行捕获，要么用throws子句抛出，否则编译无法通过。\n\n不受检查异常：包括RuntimeException及其子类和Error。\n\n分析： 不受检查异常 为编译器不要求强制处理的异常， 检查异常 则是编译器要求必须处置的异常。\n\n\n# Java异常处理机制\n\njava异常处理本质：抛出异常和捕获异常\n\n\n# 1、抛出异常\n\n要理解抛出异常，首先要明白什么是异常情形（exception condition），它是指阻止当前方法或作用域继续执行的问题。其次把异常情形和普通问题相区分，普通问题是指在当前环境下能得到足够的信息， 总能处理这个错误。\n\n对于异常情形，已经无法继续下去了，因为在当前环境下无法获得必要的信息来解决问题，你所能做的就是从当前环境中跳出，并把问题提交给上一级环境，这就是抛出异常时所发生的事情。抛出异常后，会有几件事随之发生。\n\n首先，是像创建普通的java对象一样将使用 new 在堆上创建一个异常对象；然后，当前的执行路径 （已经无法继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序\n\n这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要 么换一种方式运行，要么继续运行下去。\n\n举例：\n\n假使我们创建了一个学生对象Student的一个引用stu，在调用的时候可能还没有初始化。所以在使用这个对象引用调用其他方法之前，要先对它进行检查，可以创建一个代表错误信息的对象，并且将它从当前环境中抛出，这样就把错误信息传播到更大的环境中。\n\nif(stu == null){\n    throw new NullPointerException();\n}\n\n\n1\n2\n3\n\n\n\n# 2、捕获异常\n\n在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。\n\n注意：\n\n对于 运行时异常 、错误 和 检查异常 ，Java技术所要求的异常处理方式有所不同。\n\n由于运行时异常及其子类的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。\n\n对于方法运行中可能出现的Error ，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。\n\n> 对于所有的检查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常。\n\n\n# 3、异常处理五个关键字\n\n分别是： try 、 catch 、 finally 、 throw 、 throws\n\ntry ：用于监听。将要被监听的代码（可能抛出异常的代码）放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\n\ncatch ： 用于捕获异常。catch用来捕获try语句块中发生的异常。\n\nfinally ：finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源（如数据库连接、网络 连接和磁盘文件）。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语 句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。\n\nthrow ： 用于抛出异常。\n\nthrows ： 用在方法签名中，用于声明该方法可能抛出的异常。\n\n\n# 处理异常\n\n\n# 1、try -catch\n\ntry{\n\t//code that might generate exceptions\n}catch(Exception e){\n\t//the code of handling exception1\n}catch(Exception e){\n\t//the code of handling exception2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要明白异常捕获，还要理解 监控区域 （guarded region）的概念。它是一段可能产生异常的代码， 并且后面跟着处理这些异常的代码。\n\n因而可知，上述 try-catch 所描述的即是监控区域，关键词 try后的一对大括号将一块可能发生异常的代码包起来，即为监控区域。Java方法在运行过程中发生了异常，则创建异常对象。\n\n将异常抛出监控区域之外，由Java运行时系统负责寻找匹配的 catch 子句来捕获异常。若有一个 catch 语句匹配到了，则执行该 catch 块中的异常处理代码，就不再尝试匹配别的 catch 块 了。\n\n匹配原则：如果抛出的异常对象属于 catch 子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与 catch 块捕获的异常类型相匹配。\n\n【演示】\n\npublic class TestException {\n    public static void main(String[] args) {\n        int a = 1;\n        int b = 0;\n        try { // try监控区域\n            if (b == 0) throw new ArithmeticException(); // 通过throw语句抛出\n            异常\n            System.out.println("a/b的值是：" + a / b);\n            System.out.println("this will not be printed!");\n        }\n        catch (ArithmeticException e) { // catch捕捉异常\n            System.out.println("程序出现异常，变量b不能为0！");\n        }\n        System.out.println("程序正常结束。");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 输出：\n> \n> 程序出现异常，变量b不能为0！ 程序正常结束。\n\n注意：显示一个异常的描述， Throwable 重载了 toString( ) 方法（由 Object 定义），所以 它将返回一个包含异常描述的字符串。例如，将前面的 catch 块重写成：\n\ncatch (ArithmeticException e) { // catch捕捉异常\n    System.out.println("程序出现异常" + e);\n}\n//输出\n// 程序出现异常java.lang.ArithmeticException\n\n\n1\n2\n3\n4\n5\n\n\n算术异常属于运行时异常，因而实际上该异常不需要程序抛出，运行时系统自动抛出。如果不用try-catch程序就不会往下执行了。\n\n【演示】\n\npublic class TestException {\n    public static void main(String[] args) {\n        int a = 1;\n        int b = 0;\n        System.out.println("a/b的值是：" + a / b);\n        System.out.println("this will not be printed!");\n    }\n}\n/*\n结果：\nException in thread "main" java.lang.ArithmeticException: / by zero\nat TestException.main(TestException.java:7)\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n使用多重的catch语句：很多情况下，由单个的代码段可能引起多个异常。处理这种情况，我们需要定义两个或者更多的 catch 子句，每个子句捕获一种类型的异常，当异常被引发时，每个 catch 子 句被依次检查，第一个匹配异常类型的子句执行，当一个 catch 子句执行以后，其他的子句将被旁路。\n\n编写多重catch语句块注意事项：\n\n顺序问题：先小后大，即先子类后父类\n\n注意：\n\nJava通过异常类描述异常类型。对于有多个 catch 子句的异常程序而言，应该尽量将捕获底层异常类的 catch 子句放在前面，同时尽量将捕获相对高层的异常类的 catch 子句放在后面。否则，捕获 底层异常类的 catch 子句将可能会被屏蔽。\n\n嵌套try语句： try 语句可以被嵌套。也就是说，一个 try 语句可以在另一个 try 块的内部。每次进入 try 语句，异常的前后关系都会被推入堆栈。如果一个内部的 try 语句不含特殊异常的 catch 处理程序，堆栈将弹出，下一个 try 语句的 catch 处理程序将检查是否与之匹配。这个 过程将继续直到一个 catch 语句被匹配成功，或者是直到所有的嵌套 try 语句被检查完毕。如果没有 catch 语句匹配，Java运行时系统将处理这个异常。\n\n【演示】\n\npublic class NestTry {\n    public static void main(String[] args) {\n        try {\n            int a = args.length;\n            int b = 42 / a;\n            System.out.println("a = " + a);\n            try {\n                if (a == 1) {\n                    a = a / (a - a);\n                }\n                if (a == 2) {\n                    int c[] = {1};\n                    c[42] = 99;\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                System.out.println("ArrayIndexOutOfBounds :" + e);\n            }\n        } catch (ArithmeticException e) {\n            System.out.println("Divide by 0" + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 分析运行：\n> \n> javac NestTry.java\n> \n> java NestTry one a = 1 Divide by 0java.lang.ArithmeticException: / by zero\n> \n> java NestTry one two a = 2 ArrayIndexOutOfBounds :java.lang.ArrayIndexOutOfBoundsException: 42\n\n分析：正如程序中所显示的，该程序在一个try块中嵌套了另一个 try 块。程序工作如下：当你在没有命令行参数的情况下执行该程序，外面的 try 块将产生一个被0除的异常。\n\n程序在有一个命令行参数条件下执行，由嵌套的 try 块产生一个被0除的异常，由于内部的 catch 块不匹配这个异常，它将把异常传给外部的 try 块，在外部异常被处理。如果你在具有两个命令行参数的条件下执行该程序，将由内部 try 块产生一个数组边界异常。\n\n注意：当有方法调用时， try 语句的嵌套可以很隐蔽的发生。例如，我们可以将对方法的调用放在一 个 try 块中。在该方法的内部，有另一个 try 语句。\n\n在这种情况下，方法内部的 try 仍然是嵌套在外部调用该方法的 try 块中的。下面我们将对上述例子进行修改，嵌套的 try 块移到方法nesttry()的内部：结果依旧相同！\n\npublic class NestTry {\n    static void nesttry(int a) {\n        try {\n            if (a == 1) {\n                a = a / (a - a);\n            }\n            if (a == 2) {\n                int c[] = {1};\n                c[42] = 99;\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println("ArrayIndexOutOfBounds :" + e);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            int a = args.length;\n            int b = 42 / a;\n            System.out.println("a = " + a);\n            nesttry(a);\n        } catch (ArithmeticException e) {\n            System.out.println("Divide by 0" + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2、thorw\n\n到目前为止，我们只是获取了被Java运行时系统引发的异常。然而，我们还可以用throw语句抛出明确的异常。\n\n语法形式：throw ThrowableInstance;\n\n这里的ThrowableInstance一定是 Throwable 类类型或者 Throwable 子类类型的一个对象。简单的数据类型，例如 int ,char 以及非 Throwable 类，例如 String 或 Object ，不能用作异常。\n\n有两种方法可以获取 Throwable 对象：在 catch 子句中使用参数或者使用 new 操作符创建。程序执行完 throw 语句之后立即停止；throw 后面的任何语句不被执行，最邻近的 try 块用来检 查它是否含有一个与异常类型匹配的 catch 语句。\n\n如果发现了匹配的块，控制转向该语句；如果没有发现，次包围的 try 块来检查，以此类推。如果没有发现匹配的 catch 块，默认异常处理程序中断程序的执行并且打印堆栈轨迹。\n\nclass TestThrow {\n    static void proc() {\n        try {\n            throw new NullPointerException("demo");\n        } catch (NullPointerException e) {\n            System.out.println("Caught inside proc");\n            throw e;\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            proc();\n        } catch (NullPointerException e) {\n            System.out.println("Recaught: " + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n该程序两次处理相同的错误，首先， main() 方法设立了一个异常关系然后调用proc( )。proc( )方法设立了另一个异常处理关系并且立即抛出一个 NullPointerException 实例，NullPointerException 在 main() 中被再次捕获。\n\n该程序阐述了怎样创建Java的标准异常对象，特别注意这一行：\n\nthrow new NullPointerException("demo");\n\n\n1\n\n\n分析：此处 new 用来构造一个 NullPointerException 实例，所有的Java内置的运行时异常有两个构造方法：一个没有参数，一个带有一个字符串参数。\n\n当用第二种形式时，参数指定描述异常的字符串。如果对象用作 print( ) 或者 println( ) 的参数 时，该字符串被显示。这同样可以通过调用getMessage( )来实现，getMessage( )是由 Throwable 定义的。\n\n\n# 3、throws\n\n如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。要做到这点，我们可以在方法声明中包含一个 throws 子句。\n\n一个 throws 子句列举了一个方法可能引发的所有异常类型。这对于除了 Error 或 RuntimeException 及它们子类以外类型的所有异常是必要的。一个方法可以引发的所有其他类型的异常必须在 throws 子句中声明，否则会导致编译错误。\n\npublic void info() throws Exception\n{\n    //body of method\n}\n\n\n1\n2\n3\n4\n\n\nException 是该方法可能引发的所有的异常，也可以是异常列表，中间以逗号隔开。\n\n【例子】\n\nclass TestThrows{\n    static void throw1(){\n        System.out.println("Inside throw1 . ");\n        throw new IllegalAccessException("demo");\n    }\n    \n    public static void main(String[] args){\n        throw1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上述例子中有两个地方存在错误，你看出来了吗？\n\n该例子中存在两个错误，首先，throw1( )方法不想处理所导致的异常，因而它必须声明 throws 子句 来列举可能引发的异常即 IllegalAccessException ；其次， main() 方法必须定义 try/catch 语句来捕获该异常。\n\n正确例子如下：\n\nclass TestThrows {\n    static void throw1() throws IllegalAccessException {\n        System.out.println("Inside throw1 . ");\n        throw new IllegalAccessException("demo");\n    }\n\n    public static void main(String[] args) {\n        try {\n            throw1();\n        } catch (IllegalAccessException e) {\n            System.out.println("Caught " + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthrows 抛出异常的规则：\n\n * 如果是不受检查异常（ unchecked exception ），即 Error 、 RuntimeException 或它们的子类，那么可以不使用 throws 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。\n * 必须声明方法可抛出的任何检查异常（ checked exception ）。即如果一个方法可能出现受可查异常，要么用 try-catch 语句捕获，要么用 throws 子句声明将它抛出，否则会导致编译错误\n * 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。\n * 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。\n\n\n# 4、finally\n\n当异常发生时，通常方法的执行将做一个陡峭的非线性的转向，它甚至会过早的导致方法返回。例如， 如果一个方法打开了一个文件并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。 finally 关键字为处理这种意外而设计。\n\nfinally 创建的代码块在 try/catch 块完成之后另一个 try/catch 出现之前执行。 finally 块无论有没有异常抛出都会执行。如果抛出异常，即使没有 catch 子句匹配， finally 也会执行。\n\n一个方法将从一个 try/catch 块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明确的返回语句， finally 子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时被分配的其他资源是很有用。\n\n注意： finally 子句是可选项，可以有也可以无，但是每个 try 语句至少需要一个 catch 或 者 finally 子句。\n\n【例子】\n\nclass TestFinally {\n    static void proc1() {\n        try {\n            System.out.println("inside proc1");\n            throw new RuntimeException("demo");\n        } finally {\n            System.out.println("proc1\'s finally");\n        }\n    }\n\n    static void proc2() {\n        try {\n            System.out.println("inside proc2");\n            return;\n        } finally {\n            System.out.println("proc2\'s finally");\n        }\n    }\n\n    static void proc3() {\n        try {\n            System.out.println("inside proc3");\n        } finally {\n            System.out.println("proc3\'s finally");\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            proc1();\n        } catch (Exception e) {\n            System.out.println("Exception caught");\n        }\n        proc2();\n        proc3();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 执行结果：\n> \n> inside proc1 proc1\'s finally Exception caught inside proc2 proc2\'s finally inside proc3 proc3\'s finally\n\n注：如果 finally 块与一个 try 联合使用， finally 块将在 try 结束之前执行。\n\n\n# 执行顺序\n\ntry, catch,finally ,return 执行顺序\n\n 1. 执行try，catch ， 给返回值赋值\n 2. 执行finally\n 3. return\n\n\n# 自定义异常\n\n使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。 用户自定义异常类，只需继承 Exception 类即可。\n\n在程序中使用自定义异常类，大体可分为以下几个步骤：\n\n * 创建自定义异常类。\n * 在方法中通过 throw 关键字抛出异常对象。\n * 如果在当前抛出异常的方法中处理异常，可以使用 try-catch 语句捕获并处理；否则在方法的声明处通过 throws 关键字指明要抛出给方法调用者的异常，继续进行下一步操作。\n * 在出现异常方法的调用者中捕获并处理异常。\n\n【举例】\n\nclass MyException extends Exception {\n    private int detail;\n    MyException(int a){\n        detail = a;\n    }\n    public String toString(){\n        return "MyException ["+ detail + "]";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npublic class TestMyException {\n    static void compute(int a) throws MyException {\n        System.out.println("Called compute(" + a + ")");\n        if (a > 10) {\n            throw new MyException(a);\n        }\n        System.out.println("Normal exit!");\n    }\n\n    public static void main(String[] args) {\n        try {\n            compute(1);\n            compute(20);\n        } catch (MyException me) {\n            System.out.println("Caught " + me);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 输出：\n> \n> Called compute(1) Normal exit! Called compute(20) Caught MyException [20]\n\n举例二：输入年龄时，年龄不能为负数，否则就报错\n\npublic class AgeException extends Exception{\n    public AgeException() {\n    }\n\n    public AgeException(String message) {\n        super(message);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\npublic class Demo {\n    public static void main(String[] args) {\n        try {\n            check(-10);\n        } catch (AgeException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void check(int age) throws AgeException {\n        if (age < 0) {\n            throw new AgeException("年龄不能小于0");\n        } else {\n            System.out.println(age);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n\n# 总结\n\n\n\n实际应用中的经验与总结\n\n 1. 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理\n\n 2. 在多重catch块后面，可以加一个catch ( Exception )来处理可能会被遗漏的异常\n\n 3. 对于不确定的代码，也可以加上try-catch，处理潜在的异常\n\n 4. 尽量去处理异常，切忌只是简单的调用printStackTrace)去打印输出\n\n 5. 具体如何处理异常，要根据不同的业务需求和异常类型去决定\n\n 6. 尽量添加finally语句块去释放占用的资源',normalizedContent:'# javase-异常机制\n\n\n# 异常概念\n\n在我们日常生活中，有时会出现各种各样的异常。例如：职工小王开车去上班，在正常情况下，小王会准时到达单位。但是天有不测风云，在小王去上班时，可能会遇到一些异常情况，比如小王的车子出了故障，小王只能改为步行。\n\n实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。\n\n软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：exception， 意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。\n\n异常：指程序运行中出现的不期而至的各种状况，如:文件找不到、网络连接失败、非法参数等。 异常发生在程序运行期间，它影响了正常的程序执行流程。\n\n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.error ；\n\n如果你用 system.out.println(11/0) ，因为你用0做了除数，会抛出 java.lang.arithmeticexception 的异常。\n\n异常发生的原因有很多，通常包含以下几大类：\n\n * 用户输入了非法数据。\n * 要打开的文件不存在。\n * 网络通信时连接中断，或者jvm内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。\n\n要理解java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n * 检查性异常：\n   \n   最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如，要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n\n * 运行时异常：\n   \n   运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n\n * 错误：\n   \n   错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出 时，一个错误就发生了，它们在编译也检查不到的。\n\n异常指不期而至的各种状况，如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个 事件，它发生在程序运行期间，干扰了正常的指令流程。\n\njava语言在设计的当初就考虑到这些问题，提出异常处理的框架的方案，所有的异常都可以用一个 异常类 来表示，不同类型的异常对应不同的子类异常（目前我们所说的异常包括错误概念），定义异常处理的规范，在 jdk1.4 版本以后增加了异常链机制，从而便于跟踪异常。\n\njava异常是一个描述在代码段中发生异常的对象，当发生异常情况时，一个代表该异常的对象被创建并且在导致该异常的方法中被抛出，而该方法可以选择自己处理异常或者传递该异常。\n\n\n# 异常体系结构\n\njava把异常当作对象来处理，并定义一个基类 java.lang.throwable作为所有异常的超类。\n\n在java api中已经定义了许多异常类，这些异常类分为两大类，错误error和异常exception。\n\njava异常层次结构图：\n\n\n\n从图中可以看出所有异常类型都是内置类 throwable 的子类，因而 throwable 在异常类的层次结构的顶层。\n\n接下来 throwable 分成了两个不同的分支，一个分支是error，它表示不希望被程序捕获或者是程序无法处理的错误。另一个分支是exception，它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常。\n\n其中异常类 exception 又分为运行时异常( runtimeexception )和非运行时异常。java异常又可以分为不受检查异常（ unchecked exception ）和检查异常（ checked exception ）。\n\n\n# 异常之间的区别与联系\n\n\n# 1、error\n\nerror 类对象由 java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。\n\n比如说：\n\njava虚拟机运行错误（ virtual machineerror ），当jvm不再有继续执行操作所需的内存资源时， 将出现 outofmemoryerror 。这些异常发生时，java虚拟机（jvm）一般会选择线程终止；\n\n还有发生在虚拟机试图执行应用时，如类定义错误（ noclassdeffounderror )、链接错误 (linkageerror) 这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。\n\n对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状 况。在java中，错误通常是使用 error 的子类描述。\n\n\n# 2、exception\n\n在 exception 分支中有一个重要的子类runtimeexception （运行时异常），该类型的异常自动为你所编写的程序定义 arrayindexoutofboundsexception （数组下标越界）、 nullpointerexception （空指针异常）、arithmeticexception （算术异常）、 missingresourceexception （丢失资源）、 classnotfoundexception （找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处 理，也可以不处理。\n\n这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而 runtimeexception 之外的异常我们统称为非运行时异常，类型上属于 exception 类及其子类，\n\n从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 ioexception 、 sqlexception 等以及用户自定义的 exception 异常，一般情况下不自定义检查异常。\n\n注意： error 和 exception 的区别： error 通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，java虚拟机（jvm）一般会选择终止线程； exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。\n\n\n# 3、检查异常和不受检查异常\n\n检查异常：在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。\n\n解析：除了runtimeexception及其子类以外，其他的exception类及其子类都属于检查异常，当程序中可能出现这类异常，要么使用try-catch语句进行捕获，要么用throws子句抛出，否则编译无法通过。\n\n不受检查异常：包括runtimeexception及其子类和error。\n\n分析： 不受检查异常 为编译器不要求强制处理的异常， 检查异常 则是编译器要求必须处置的异常。\n\n\n# java异常处理机制\n\njava异常处理本质：抛出异常和捕获异常\n\n\n# 1、抛出异常\n\n要理解抛出异常，首先要明白什么是异常情形（exception condition），它是指阻止当前方法或作用域继续执行的问题。其次把异常情形和普通问题相区分，普通问题是指在当前环境下能得到足够的信息， 总能处理这个错误。\n\n对于异常情形，已经无法继续下去了，因为在当前环境下无法获得必要的信息来解决问题，你所能做的就是从当前环境中跳出，并把问题提交给上一级环境，这就是抛出异常时所发生的事情。抛出异常后，会有几件事随之发生。\n\n首先，是像创建普通的java对象一样将使用 new 在堆上创建一个异常对象；然后，当前的执行路径 （已经无法继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序\n\n这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要 么换一种方式运行，要么继续运行下去。\n\n举例：\n\n假使我们创建了一个学生对象student的一个引用stu，在调用的时候可能还没有初始化。所以在使用这个对象引用调用其他方法之前，要先对它进行检查，可以创建一个代表错误信息的对象，并且将它从当前环境中抛出，这样就把错误信息传播到更大的环境中。\n\nif(stu == null){\n    throw new nullpointerexception();\n}\n\n\n1\n2\n3\n\n\n\n# 2、捕获异常\n\n在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着java程序的终止。\n\n注意：\n\n对于 运行时异常 、错误 和 检查异常 ，java技术所要求的异常处理方式有所不同。\n\n由于运行时异常及其子类的不可查性，为了更合理、更容易地实现应用程序，java规定，运行时异常将由java运行时系统自动抛出，允许应用程序忽略运行时异常。\n\n对于方法运行中可能出现的error ，当运行方法不欲捕捉时，java允许该方法不做任何抛出声明。因为，大多数 error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。\n\n> 对于所有的检查异常，java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常。\n\n\n# 3、异常处理五个关键字\n\n分别是： try 、 catch 、 finally 、 throw 、 throws\n\ntry ：用于监听。将要被监听的代码（可能抛出异常的代码）放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\n\ncatch ： 用于捕获异常。catch用来捕获try语句块中发生的异常。\n\nfinally ：finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源（如数据库连接、网络 连接和磁盘文件）。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语 句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。\n\nthrow ： 用于抛出异常。\n\nthrows ： 用在方法签名中，用于声明该方法可能抛出的异常。\n\n\n# 处理异常\n\n\n# 1、try -catch\n\ntry{\n\t//code that might generate exceptions\n}catch(exception e){\n\t//the code of handling exception1\n}catch(exception e){\n\t//the code of handling exception2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要明白异常捕获，还要理解 监控区域 （guarded region）的概念。它是一段可能产生异常的代码， 并且后面跟着处理这些异常的代码。\n\n因而可知，上述 try-catch 所描述的即是监控区域，关键词 try后的一对大括号将一块可能发生异常的代码包起来，即为监控区域。java方法在运行过程中发生了异常，则创建异常对象。\n\n将异常抛出监控区域之外，由java运行时系统负责寻找匹配的 catch 子句来捕获异常。若有一个 catch 语句匹配到了，则执行该 catch 块中的异常处理代码，就不再尝试匹配别的 catch 块 了。\n\n匹配原则：如果抛出的异常对象属于 catch 子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与 catch 块捕获的异常类型相匹配。\n\n【演示】\n\npublic class testexception {\n    public static void main(string[] args) {\n        int a = 1;\n        int b = 0;\n        try { // try监控区域\n            if (b == 0) throw new arithmeticexception(); // 通过throw语句抛出\n            异常\n            system.out.println("a/b的值是：" + a / b);\n            system.out.println("this will not be printed!");\n        }\n        catch (arithmeticexception e) { // catch捕捉异常\n            system.out.println("程序出现异常，变量b不能为0！");\n        }\n        system.out.println("程序正常结束。");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 输出：\n> \n> 程序出现异常，变量b不能为0！ 程序正常结束。\n\n注意：显示一个异常的描述， throwable 重载了 tostring( ) 方法（由 object 定义），所以 它将返回一个包含异常描述的字符串。例如，将前面的 catch 块重写成：\n\ncatch (arithmeticexception e) { // catch捕捉异常\n    system.out.println("程序出现异常" + e);\n}\n//输出\n// 程序出现异常java.lang.arithmeticexception\n\n\n1\n2\n3\n4\n5\n\n\n算术异常属于运行时异常，因而实际上该异常不需要程序抛出，运行时系统自动抛出。如果不用try-catch程序就不会往下执行了。\n\n【演示】\n\npublic class testexception {\n    public static void main(string[] args) {\n        int a = 1;\n        int b = 0;\n        system.out.println("a/b的值是：" + a / b);\n        system.out.println("this will not be printed!");\n    }\n}\n/*\n结果：\nexception in thread "main" java.lang.arithmeticexception: / by zero\nat testexception.main(testexception.java:7)\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n使用多重的catch语句：很多情况下，由单个的代码段可能引起多个异常。处理这种情况，我们需要定义两个或者更多的 catch 子句，每个子句捕获一种类型的异常，当异常被引发时，每个 catch 子 句被依次检查，第一个匹配异常类型的子句执行，当一个 catch 子句执行以后，其他的子句将被旁路。\n\n编写多重catch语句块注意事项：\n\n顺序问题：先小后大，即先子类后父类\n\n注意：\n\njava通过异常类描述异常类型。对于有多个 catch 子句的异常程序而言，应该尽量将捕获底层异常类的 catch 子句放在前面，同时尽量将捕获相对高层的异常类的 catch 子句放在后面。否则，捕获 底层异常类的 catch 子句将可能会被屏蔽。\n\n嵌套try语句： try 语句可以被嵌套。也就是说，一个 try 语句可以在另一个 try 块的内部。每次进入 try 语句，异常的前后关系都会被推入堆栈。如果一个内部的 try 语句不含特殊异常的 catch 处理程序，堆栈将弹出，下一个 try 语句的 catch 处理程序将检查是否与之匹配。这个 过程将继续直到一个 catch 语句被匹配成功，或者是直到所有的嵌套 try 语句被检查完毕。如果没有 catch 语句匹配，java运行时系统将处理这个异常。\n\n【演示】\n\npublic class nesttry {\n    public static void main(string[] args) {\n        try {\n            int a = args.length;\n            int b = 42 / a;\n            system.out.println("a = " + a);\n            try {\n                if (a == 1) {\n                    a = a / (a - a);\n                }\n                if (a == 2) {\n                    int c[] = {1};\n                    c[42] = 99;\n                }\n            } catch (arrayindexoutofboundsexception e) {\n                system.out.println("arrayindexoutofbounds :" + e);\n            }\n        } catch (arithmeticexception e) {\n            system.out.println("divide by 0" + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 分析运行：\n> \n> javac nesttry.java\n> \n> java nesttry one a = 1 divide by 0java.lang.arithmeticexception: / by zero\n> \n> java nesttry one two a = 2 arrayindexoutofbounds :java.lang.arrayindexoutofboundsexception: 42\n\n分析：正如程序中所显示的，该程序在一个try块中嵌套了另一个 try 块。程序工作如下：当你在没有命令行参数的情况下执行该程序，外面的 try 块将产生一个被0除的异常。\n\n程序在有一个命令行参数条件下执行，由嵌套的 try 块产生一个被0除的异常，由于内部的 catch 块不匹配这个异常，它将把异常传给外部的 try 块，在外部异常被处理。如果你在具有两个命令行参数的条件下执行该程序，将由内部 try 块产生一个数组边界异常。\n\n注意：当有方法调用时， try 语句的嵌套可以很隐蔽的发生。例如，我们可以将对方法的调用放在一 个 try 块中。在该方法的内部，有另一个 try 语句。\n\n在这种情况下，方法内部的 try 仍然是嵌套在外部调用该方法的 try 块中的。下面我们将对上述例子进行修改，嵌套的 try 块移到方法nesttry()的内部：结果依旧相同！\n\npublic class nesttry {\n    static void nesttry(int a) {\n        try {\n            if (a == 1) {\n                a = a / (a - a);\n            }\n            if (a == 2) {\n                int c[] = {1};\n                c[42] = 99;\n            }\n        } catch (arrayindexoutofboundsexception e) {\n            system.out.println("arrayindexoutofbounds :" + e);\n        }\n    }\n\n    public static void main(string[] args) {\n        try {\n            int a = args.length;\n            int b = 42 / a;\n            system.out.println("a = " + a);\n            nesttry(a);\n        } catch (arithmeticexception e) {\n            system.out.println("divide by 0" + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2、thorw\n\n到目前为止，我们只是获取了被java运行时系统引发的异常。然而，我们还可以用throw语句抛出明确的异常。\n\n语法形式：throw throwableinstance;\n\n这里的throwableinstance一定是 throwable 类类型或者 throwable 子类类型的一个对象。简单的数据类型，例如 int ,char 以及非 throwable 类，例如 string 或 object ，不能用作异常。\n\n有两种方法可以获取 throwable 对象：在 catch 子句中使用参数或者使用 new 操作符创建。程序执行完 throw 语句之后立即停止；throw 后面的任何语句不被执行，最邻近的 try 块用来检 查它是否含有一个与异常类型匹配的 catch 语句。\n\n如果发现了匹配的块，控制转向该语句；如果没有发现，次包围的 try 块来检查，以此类推。如果没有发现匹配的 catch 块，默认异常处理程序中断程序的执行并且打印堆栈轨迹。\n\nclass testthrow {\n    static void proc() {\n        try {\n            throw new nullpointerexception("demo");\n        } catch (nullpointerexception e) {\n            system.out.println("caught inside proc");\n            throw e;\n        }\n    }\n\n    public static void main(string[] args) {\n        try {\n            proc();\n        } catch (nullpointerexception e) {\n            system.out.println("recaught: " + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n该程序两次处理相同的错误，首先， main() 方法设立了一个异常关系然后调用proc( )。proc( )方法设立了另一个异常处理关系并且立即抛出一个 nullpointerexception 实例，nullpointerexception 在 main() 中被再次捕获。\n\n该程序阐述了怎样创建java的标准异常对象，特别注意这一行：\n\nthrow new nullpointerexception("demo");\n\n\n1\n\n\n分析：此处 new 用来构造一个 nullpointerexception 实例，所有的java内置的运行时异常有两个构造方法：一个没有参数，一个带有一个字符串参数。\n\n当用第二种形式时，参数指定描述异常的字符串。如果对象用作 print( ) 或者 println( ) 的参数 时，该字符串被显示。这同样可以通过调用getmessage( )来实现，getmessage( )是由 throwable 定义的。\n\n\n# 3、throws\n\n如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。要做到这点，我们可以在方法声明中包含一个 throws 子句。\n\n一个 throws 子句列举了一个方法可能引发的所有异常类型。这对于除了 error 或 runtimeexception 及它们子类以外类型的所有异常是必要的。一个方法可以引发的所有其他类型的异常必须在 throws 子句中声明，否则会导致编译错误。\n\npublic void info() throws exception\n{\n    //body of method\n}\n\n\n1\n2\n3\n4\n\n\nexception 是该方法可能引发的所有的异常，也可以是异常列表，中间以逗号隔开。\n\n【例子】\n\nclass testthrows{\n    static void throw1(){\n        system.out.println("inside throw1 . ");\n        throw new illegalaccessexception("demo");\n    }\n    \n    public static void main(string[] args){\n        throw1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上述例子中有两个地方存在错误，你看出来了吗？\n\n该例子中存在两个错误，首先，throw1( )方法不想处理所导致的异常，因而它必须声明 throws 子句 来列举可能引发的异常即 illegalaccessexception ；其次， main() 方法必须定义 try/catch 语句来捕获该异常。\n\n正确例子如下：\n\nclass testthrows {\n    static void throw1() throws illegalaccessexception {\n        system.out.println("inside throw1 . ");\n        throw new illegalaccessexception("demo");\n    }\n\n    public static void main(string[] args) {\n        try {\n            throw1();\n        } catch (illegalaccessexception e) {\n            system.out.println("caught " + e);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nthrows 抛出异常的规则：\n\n * 如果是不受检查异常（ unchecked exception ），即 error 、 runtimeexception 或它们的子类，那么可以不使用 throws 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。\n * 必须声明方法可抛出的任何检查异常（ checked exception ）。即如果一个方法可能出现受可查异常，要么用 try-catch 语句捕获，要么用 throws 子句声明将它抛出，否则会导致编译错误\n * 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。\n * 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。\n\n\n# 4、finally\n\n当异常发生时，通常方法的执行将做一个陡峭的非线性的转向，它甚至会过早的导致方法返回。例如， 如果一个方法打开了一个文件并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。 finally 关键字为处理这种意外而设计。\n\nfinally 创建的代码块在 try/catch 块完成之后另一个 try/catch 出现之前执行。 finally 块无论有没有异常抛出都会执行。如果抛出异常，即使没有 catch 子句匹配， finally 也会执行。\n\n一个方法将从一个 try/catch 块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明确的返回语句， finally 子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时被分配的其他资源是很有用。\n\n注意： finally 子句是可选项，可以有也可以无，但是每个 try 语句至少需要一个 catch 或 者 finally 子句。\n\n【例子】\n\nclass testfinally {\n    static void proc1() {\n        try {\n            system.out.println("inside proc1");\n            throw new runtimeexception("demo");\n        } finally {\n            system.out.println("proc1\'s finally");\n        }\n    }\n\n    static void proc2() {\n        try {\n            system.out.println("inside proc2");\n            return;\n        } finally {\n            system.out.println("proc2\'s finally");\n        }\n    }\n\n    static void proc3() {\n        try {\n            system.out.println("inside proc3");\n        } finally {\n            system.out.println("proc3\'s finally");\n        }\n    }\n\n    public static void main(string[] args) {\n        try {\n            proc1();\n        } catch (exception e) {\n            system.out.println("exception caught");\n        }\n        proc2();\n        proc3();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 执行结果：\n> \n> inside proc1 proc1\'s finally exception caught inside proc2 proc2\'s finally inside proc3 proc3\'s finally\n\n注：如果 finally 块与一个 try 联合使用， finally 块将在 try 结束之前执行。\n\n\n# 执行顺序\n\ntry, catch,finally ,return 执行顺序\n\n 1. 执行try，catch ， 给返回值赋值\n 2. 执行finally\n 3. return\n\n\n# 自定义异常\n\n使用java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。 用户自定义异常类，只需继承 exception 类即可。\n\n在程序中使用自定义异常类，大体可分为以下几个步骤：\n\n * 创建自定义异常类。\n * 在方法中通过 throw 关键字抛出异常对象。\n * 如果在当前抛出异常的方法中处理异常，可以使用 try-catch 语句捕获并处理；否则在方法的声明处通过 throws 关键字指明要抛出给方法调用者的异常，继续进行下一步操作。\n * 在出现异常方法的调用者中捕获并处理异常。\n\n【举例】\n\nclass myexception extends exception {\n    private int detail;\n    myexception(int a){\n        detail = a;\n    }\n    public string tostring(){\n        return "myexception ["+ detail + "]";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npublic class testmyexception {\n    static void compute(int a) throws myexception {\n        system.out.println("called compute(" + a + ")");\n        if (a > 10) {\n            throw new myexception(a);\n        }\n        system.out.println("normal exit!");\n    }\n\n    public static void main(string[] args) {\n        try {\n            compute(1);\n            compute(20);\n        } catch (myexception me) {\n            system.out.println("caught " + me);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 输出：\n> \n> called compute(1) normal exit! called compute(20) caught myexception [20]\n\n举例二：输入年龄时，年龄不能为负数，否则就报错\n\npublic class ageexception extends exception{\n    public ageexception() {\n    }\n\n    public ageexception(string message) {\n        super(message);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\npublic class demo {\n    public static void main(string[] args) {\n        try {\n            check(-10);\n        } catch (ageexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    public static void check(int age) throws ageexception {\n        if (age < 0) {\n            throw new ageexception("年龄不能小于0");\n        } else {\n            system.out.println(age);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n\n# 总结\n\n\n\n实际应用中的经验与总结\n\n 1. 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理\n\n 2. 在多重catch块后面，可以加一个catch ( exception )来处理可能会被遗漏的异常\n\n 3. 对于不确定的代码，也可以加上try-catch，处理潜在的异常\n\n 4. 尽量去处理异常，切忌只是简单的调用printstacktrace)去打印输出\n\n 5. 具体如何处理异常，要根据不同的业务需求和异常类型去决定\n\n 6. 尽量添加finally语句块去释放占用的资源',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"面向对象",frontmatter:{title:"面向对象",date:"2021-04-15T22:46:32.000Z",permalink:"/java/se/object/",categories:["java","java-se"]},regularPath:"/01.Java/03.java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/06.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.Java/03.java-面向对象/06.面向对象.md",key:"v-0d0a72db",path:"/java/se/object/",headers:[{level:2,title:"面向过程&面向对象",slug:"面向过程-面向对象",normalizedTitle:"面向过程&amp;面向对象",charIndex:null},{level:2,title:"OOP详解",slug:"oop详解",normalizedTitle:"oop详解",charIndex:772},{level:3,title:"1、什么是面向对象",slug:"_1、什么是面向对象",normalizedTitle:"1、什么是面向对象",charIndex:782},{level:3,title:"2、类与对象的关系",slug:"_2、类与对象的关系",normalizedTitle:"2、类与对象的关系",charIndex:1852},{level:3,title:"3、对象和引用的关系",slug:"_3、对象和引用的关系",normalizedTitle:"3、对象和引用的关系",charIndex:2348},{level:2,title:"方法回顾及加深",slug:"方法回顾及加深",normalizedTitle:"方法回顾及加深",charIndex:2519},{level:3,title:"1、方法的定义",slug:"_1、方法的定义",normalizedTitle:"1、方法的定义",charIndex:2552},{level:3,title:"2、方法调用",slug:"_2、方法调用",normalizedTitle:"2、方法调用",charIndex:3972},{level:3,title:"3、调用方法时的传参",slug:"_3、调用方法时的传参",normalizedTitle:"3、调用方法时的传参",charIndex:5259},{level:3,title:"4、this关键字",slug:"_4、this关键字",normalizedTitle:"4、this关键字",charIndex:6414},{level:2,title:"创建与初始化对象",slug:"创建与初始化对象",normalizedTitle:"创建与初始化对象",charIndex:8784},{level:2,title:"构造器",slug:"构造器",normalizedTitle:"构造器",charIndex:2835},{level:2,title:"内存分析",slug:"内存分析",normalizedTitle:"内存分析",charIndex:10322},{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:893},{level:3,title:"1、封装的步骤",slug:"_1、封装的步骤",normalizedTitle:"1、封装的步骤",charIndex:11689},{level:3,title:"2、作用和意义",slug:"_2、作用和意义",normalizedTitle:"2、作用和意义",charIndex:12934},{level:3,title:"3、方法重载",slug:"_3、方法重载",normalizedTitle:"3、方法重载",charIndex:13073},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:1365},{level:3,title:"1、继承",slug:"_1、继承",normalizedTitle:"1、继承",charIndex:14045},{level:3,title:"2、Object类",slug:"_2、object类",normalizedTitle:"2、object类",charIndex:14798},{level:3,title:"3、Super关键字",slug:"_3、super关键字",normalizedTitle:"3、super关键字",charIndex:15261},{level:3,title:"4、方法重写",slug:"_4、方法重写",normalizedTitle:"4、方法重写",charIndex:17896},{level:2,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:1662},{level:3,title:"1、认识多态",slug:"_1、认识多态",normalizedTitle:"1、认识多态",charIndex:19478},{level:3,title:"2、重写、重载和多态的关系",slug:"_2、重写、重载和多态的关系",normalizedTitle:"2、重写、重载和多态的关系",charIndex:21834},{level:3,title:"3、多态的注意事项",slug:"_3、多态的注意事项",normalizedTitle:"3、多态的注意事项",charIndex:22026},{level:3,title:"4、多态存在的条件",slug:"_4、多态存在的条件",normalizedTitle:"4、多态存在的条件",charIndex:22215},{level:3,title:"5、方法绑定(method binding)",slug:"_5、方法绑定-method-binding",normalizedTitle:"5、方法绑定(method binding)",charIndex:22536},{level:3,title:"6、instanceof和类型转换",slug:"_6、instanceof和类型转换",normalizedTitle:"6、instanceof和类型转换",charIndex:22796},{level:2,title:"修饰符",slug:"修饰符",normalizedTitle:"修饰符",charIndex:2567},{level:3,title:"1、static修饰符",slug:"_1、static修饰符",normalizedTitle:"1、static修饰符",charIndex:25475},{level:3,title:"2、final修饰符",slug:"_2、final修饰符",normalizedTitle:"2、final修饰符",charIndex:31551},{level:3,title:"3、abstract修饰符",slug:"_3、abstract修饰符",normalizedTitle:"3、abstract修饰符",charIndex:32883},{level:3,title:"3、特点及作用",slug:"_3、特点及作用",normalizedTitle:"3、特点及作用",charIndex:33307},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:1247},{level:3,title:"1、接口的本质",slug:"_1、接口的本质",normalizedTitle:"1、接口的本质",charIndex:34213},{level:3,title:"2、接口与抽象类的区别",slug:"_2、接口与抽象类的区别",normalizedTitle:"2、接口与抽象类的区别",charIndex:34809},{level:3,title:"3、接口中的方法都是抽象方法",slug:"_3、接口中的方法都是抽象方法",normalizedTitle:"3、接口中的方法都是抽象方法",charIndex:35162},{level:3,title:"4、接口中的变量都是静态常量",slug:"_4、接口中的变量都是静态常量",normalizedTitle:"4、接口中的变量都是静态常量",charIndex:35363},{level:3,title:"5、一个类可以实现多个接口",slug:"_5、一个类可以实现多个接口",normalizedTitle:"5、一个类可以实现多个接口",charIndex:35744},{level:3,title:"6、一个接口可以继承多个父接口",slug:"_6、一个接口可以继承多个父接口",normalizedTitle:"6、一个接口可以继承多个父接口",charIndex:36160},{level:3,title:"7、接口的作用",slug:"_7、接口的作用",normalizedTitle:"7、接口的作用",charIndex:37154},{level:2,title:"内部类",slug:"内部类",normalizedTitle:"内部类",charIndex:38699},{level:3,title:"1、内部类概述",slug:"_1、内部类概述",normalizedTitle:"1、内部类概述",charIndex:38811},{level:3,title:"2、成员内部类",slug:"_2、成员内部类",normalizedTitle:"2、成员内部类",charIndex:39018},{level:3,title:"3、静态内部类",slug:"_3、静态内部类",normalizedTitle:"3、静态内部类",charIndex:43620},{level:3,title:"4、局部内部类",slug:"_4、局部内部类",normalizedTitle:"4、局部内部类",charIndex:45747},{level:3,title:"5、匿名内部类",slug:"_5、匿名内部类",normalizedTitle:"5、匿名内部类",charIndex:48865}],headersStr:"面向过程&面向对象 OOP详解 1、什么是面向对象 2、类与对象的关系 3、对象和引用的关系 方法回顾及加深 1、方法的定义 2、方法调用 3、调用方法时的传参 4、this关键字 创建与初始化对象 构造器 内存分析 封装 1、封装的步骤 2、作用和意义 3、方法重载 继承 1、继承 2、Object类 3、Super关键字 4、方法重写 多态 1、认识多态 2、重写、重载和多态的关系 3、多态的注意事项 4、多态存在的条件 5、方法绑定(method binding) 6、instanceof和类型转换 修饰符 1、static修饰符 2、final修饰符 3、abstract修饰符 3、特点及作用 接口 1、接口的本质 2、接口与抽象类的区别 3、接口中的方法都是抽象方法 4、接口中的变量都是静态常量 5、一个类可以实现多个接口 6、一个接口可以继承多个父接口 7、接口的作用 内部类 1、内部类概述 2、成员内部类 3、静态内部类 4、局部内部类 5、匿名内部类",content:'# JavaSE-面向对象\n\n\n# 面向过程&面向对象\n\n语言的进化发展跟生物的进化发展其实是一回事，都是”物以类聚”。相近的感光细胞聚到一起变成了我们的眼睛，相近的嗅觉细胞聚到一起变成了我们的鼻子。\n\n语句多了，我们将完成同样功能的相近的语句，聚到了一块儿，便于我们使用。于是，方法出现了！\n\n变量多了，我们将功能相近的变量组在一起，聚到一起归类，便于我们调用。于是，结构体出现了！\n\n再后来，方法多了，变量多了！结构体不够用了！我们就将功能相近的变量和方法聚到了一起，于是类和对象出现了！\n\n寥寥数语，就深刻的展示了语言的进化历史！其实，都非常自然，”物以类聚”。希望大家能记住这句话。\n\n企业的发展也是”物以类聚”的过程，完成市场推广的人员聚到一起形成了市场部。完成技术开发的人员聚到一起形成了开发部！\n\n面向过程的思维模式\n\n面向过程的思维模式是简单的线性思维，思考问题首先陷入第一步做什么、第二步做什么的细节中。这种思维模式适合处理简单的事情，比如：上厕所。\n\n如果面对复杂的事情，这种思维模式会陷入令人发疯的状态！比如：如何造神舟十号！\n\n面向对象的思维模式\n\n面向对象的思维模式说白了就是分类思维模式。思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。\n\n这样就可以形成很好的协作分工。比如：设计师分了10个类，然后将10个类交给了10个人分别进行详细设计和编码！\n\n显然，面向对象适合处理复杂的问题，适合处理需要多人协作的问题！\n\n如果一个问题需要多人协作一起解决，那么你一定要用面向对象的方式来思考！\n\n对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整 个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。\n\n\n# OOP详解\n\n\n# 1、什么是面向对象\n\nJava的编程语言是面向对象的，采用这种语言进行编程称为面向对象编程(Object-Oriented Programming, OOP)。\n\n面向对象编程的本质就是：以类的方式组织代码，以对象的组织(封装)数据。\n\n抽象(abstract)\n\n忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了 解全部问题，而只是选择其中的一部分，暂时不用关注细节。\n\n> 例如：要设计一个学生成绩管理系统，那么对于学生，只关心他的班级、学号、成绩等，而不用去关心他的 身高、体重这些信息。 抽象是什么？就是将多个物体共同点归纳出来，就是抽出像的部分！\n\n封装(Encapsulation)\n\n封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访 问只能通过指定的方式。\n\n在定义一个对象的特性的时候，有必要决定这些特性的可见性，即哪些特性对外部是可见的，哪些特性用于表示内部状态。\n\n通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。\n\n信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。\n\n封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部， 因而可以将应用程序修改带来的影响减少到最低限度。\n\n继承(inheritance)\n\n继承是一种联结类的层次模型，并且允许和支持类的重用，它提供了一种明确表述共性的方法\n\n新类继承了原始类后,新类就继承了原始类的特性，新类称为原始类的派生类(子类)，而原始类称为新类的基类(父类)。\n\n派生类(子类)可以从它的基类(父类)那里继承方法和实例变量，并且派生类(子类)中可以修改或增加新的方法使之更适合特殊的需要继承性很好的解决了软件的可重用性问题。比如说，所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。\n\n多态(polymorphism)\n\n多态性是指允许不同类的对象对同一消息作出响应。\n\n多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n\n相同类域的不同对象,调用相同方法,表现出不同的结果\n\n从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。\n\n从代码运行角度考虑是先有类后有对象。类是对象的模板。\n\n\n# 2、类与对象的关系\n\n类是一种抽象的数据类型,它是对某一类事物整体描述/定义,但是并不能代表某一个具体的事物\n\n> 例如：我们生活中所说的词语：动物、植物、手机、电脑等等。这些也都是抽象的概念，而不是指的某一个 具体的东西。\n\n例如: Person类、Pet类、Car类等，这些类都是用来 描述/定义 某一类具体的事物应该具备的特点和行为\n\n对象是抽象概念的具体实例\n\n> 例如：张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例。能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。\n\n【示例】\n\nStudent s = new Student(1,"tom",20);\ns.study();\n\nCar c = new Car(1,"BWM",500000);\nc.run();\n\n\n1\n2\n3\n4\n5\n\n\n对象s就是Student类的一个实例，对象c就是Car类的一个具体实例，能够使用的是具体实例，而不是类。类只是给对象的创建提供了一个参考的模板而已。\n\n但是在java中，没有类就没有对象，然而类又是根据具体的功能需求，进行实际的分析，最终抽象出来的。\n\n\n# 3、对象和引用的关系\n\n引用 "指向" 对象\n\n使用类类型、数组类型、接口类型声明出的变量，都可以指向对象，这种变量就是引用类型变量，简称引用。\n\n在程序中，创建出对象后，直接使用并不方便，所以一般会用一个引用类型的变量去接收这个对象，这个就是所说的引用指向对象。\n\n总结：对象和引用的关系，就如电视机和遥控器，风筝和线的关系一样。\n\n\n# 方法回顾及加深\n\n方法一定是定义在类中的，属于类的成员。\n\n\n# 1、方法的定义\n\n> 格式： 修饰符 返回类型 方法名(参数列表)异常抛出类型{...}\n\n 1. 修饰符\n    \n    public、static、abstract、final等等都是修饰符，一个方法可以有多个修饰符。例如程序入口 main方法，就使用了public static这个俩个修饰符\n    \n    注：如果一个方法或者属性有多个修饰符，这多个修饰符是没有先后顺序的\n\n 2. 返回类型\n    \n    方法执行完如果有要返回的数据，那么就要声明返回数据的类型，如果没有返回的数据，那么返回类型就必须写void\n    \n    只有构造方法(构造器)不写任何返回类型也不写void\n    \n    【示例】\n    \n    public String sayHello(){\n        return "hello";\n    }\n    public int max(int a,int b){\n        return a>b?a:b;\n    }\n    public void print(String msg){\n        System.out.println(msg);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    思考：声明返回类型的方法中一定要出现return语句，那么没有返回类型(void)的方法中，能不能出现 return语句?\n    \n    break和return的区别\n    \n    return 语句的作用\n    \n    > (1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。 (2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。 (3) return后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回 调用函数处。\n    \n    break语句的作用\n    \n    > (1)break在循环体内，强行结束循环的执行，也就是结束整个循环过程，不在判断执行循环的条件是否成立，直接转向循环语句下面的语句。\n    > \n    > (2)当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。\n\n 3. 方法名\n    \n    遵守java中标示符的命名规则即可.\n\n 4. 参数列表\n    \n    根据需求定义,方法可以是无参的,也可以有一个参数,也可以有多个参数\n\n 5. 异常抛出类型\n    \n    如果方法中的代码在执行过程中，可能会出现一些异常情况，那么就可以在方法上把这些异常声明并抛出， 也可以同时声明抛出多个异常，使用逗号隔开即可。\n    \n    public void readFile(String file)throws IOException{\n    }\n    \n    public void readFile(String file)throws IOException,ClassNotFoundException{\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 2、方法调用\n\n在类中定义了方法，这个方法中的代码并不会执行，当这个方法被调用的时候，方法中的代码才会被一行一 行顺序执行。\n\n 1. 非静态方法\n    \n    没有使用static修饰符修饰的方法，就是非静态方法。\n    \n    调用这种方法的时候，是"一定"要使用对象的调用。因为非静态方法是属于对象的。(非静态属性也是一样的)\n    \n    【例子】\n    \n    > public class Student{ public void say(){} }\n    > \n    > main:\n    > \n    > Student s = new Student();\n    > \n    > s.say();\n\n 2. 静态方法\n    \n    使用static修饰符修饰的方法,就是静态方法。\n    \n    调用这种方法的时候，"可以"使用对象调用，也"可以"使用类来调用，但是推荐使用类进行调用。因为静态方法是属于类的。(静态属性也是一样的)\n    \n    【例子】\n    \n    > public class Student{ public static void say(){} }\n    > \n    > main:\n    > \n    > Student.say();\n\n 3. 类中方法之间的调用\n    \n    假设同一个类中有俩个方法，a方法和b方法，a和b都是非静态方法，相互之间可以直接调用。\n    \n    public void a(){\n        b();\n    }\n    public void b(){\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    a和b都是静态方法,相互之间可以直接调用\n    \n    public static void a(){\n        b();\n    }\n    public static void b(){\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    a静态方法，b是非静态方法，a方法中不能直接调用b方法，但是b方法中可以直接调用a方法。静态方法不能 调用非静态方法！\n    \n    public static void a(){\n        //b();报错\n    }\n    public void b(){\n        a();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    另外：在同一个类中，静态方法内不能直接访问到类中的非静态属性。\n    \n    总结：类中方法中的调用，两个方法都是静态或者非静态都可以互相调用，当一个方法是静态，一个方 法是非静态的时候，非静态方法可以调用静态方法，反之不能。\n\n\n# 3、调用方法时的传参\n\n1、形参和实参\n\npublic static void test(int a){\n\n}\n\npublic static void main(String[] args) {\n    int x = 1;\n    test(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n参数列表中的a是方法test的形参(形式上的参数) 调用方法时的x是方法test的实参(实际上的参数)\n\n注意：形参的名字和实参的名字都只是一个变量的名字,是可以随便写的,我们并不关心这个名字,而是关 心变量的类型以及变量接收的值。\n\n2、值传递和引用传递\n\n调用方法进行传参时，分为值传递和引用传递两种。\n\n如果参数的类型是基本数据类型，那么就是值传递。\n\n如果参数的类型是引用数据类型，那么就是引用传递。\n\n值传递是实参把自己变量本身存的简单数值赋值给形参。 引用传递是实参把自己变量本身存的对象内存地址值赋值给形参。\n\n所以值传递和引用传递本质上是一回事，只不过传递的东西的意义不同而已。\n\n【示例：值传递】\n\npublic static void changeNum(int a) {\n    a = 10;\n}\n\npublic static void main(String[] args) {\n    int a = 1;\n    System.out.println("before: a = " + a); //1\n    changeNum(a);\n    System.out.println("after: a = " + a); //1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【示例：引用传递】\n\npublic class Test {\n    public static void changeName(Student s) {\n        s.name = "tom";\n    }\n\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println("before: name = " + s.name); //null\n        changeName(s);\n        System.out.println("after: name = " + s.name); //tom\n    }\n\n    static class Student {\n        String name;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4、this关键字\n\n在类中，可以使用this关键字表示一些特殊的作用。\n\n1、this在类中的作用\n\n区别成员变量和局部变量\n\npublic class Student{\n    private String name;\n    public void setName(String name){\n        //this.name表示类中的属性name\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用类中的其他方法\n\npublic class Student{\n    private String name;\n    public void setName(String name){\n        this.name = name;\n    }\n    public void print(){\n        //表示调用当前类中的setName方法\n        this.setName("tom");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注：默认情况下，setName("tom")和this.setName("tom")的效果是一样的。\n\n调用类中的其他构造器\n\npublic class Student{\n    private String name;\n    public Student(){\n        //调用一个参数的构造器,并且参数的类型是String\n        this("tom");\n    }\n    public Student(String name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注：this的这种用法，只能在构造器中使用。普通的方法是不能用的。并且这局调用的代码只能出现在构造器中的第一句。\n\n【示例】\n\npublic class Student{\n    private String name;\n    //编译报错,因为this("tom")不是构造器中的第一句代码.\n    public Student(){\n        System.out.println("hello");\n        this("tom");\n    }\n    public Student(String name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2、this关键字在类中的意义\n\nthis在类中表示当前类将来创建出的对象。\n\n【例子】\n\npublic class Student {\n    private String name;\n\n    public Student() {\n        System.out.println("this = " + this);\n    }\n\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println("s = " + s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行后看结果可知，this和s打印的结果是一样的，那么其实也就是变量s是从对象的外部执行对象，而this是在对象的内部执行对象本身。\n\n这样也就能理解为什么this.name代表的是成员变量，this.setName("tom")代表的是调用成员方法。因为这俩句代码从本质上讲，和在对象外部使用变量s来调用是一样的，s.name和s.setName("tom")\n\n【this和s打印出来的内存地址是一样的，使用==比较的结果为true。】\n\npublic class Student{\n    public Student getStudent(){\n        return this;\n    }\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        Student s2 = s1.getStudent();\n        System.out.println(s1 == s2);//true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【调用类中的this，s1和s2不相等】\n\npublic class Student{\n    private String name;\n    public void test(){\n        System.out.println(this);\n    }\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        Student s2 = new Student();\n        s1.test();\n        s2.test();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注：这句话是要这么来描述的，s1对象中的this和s1相等，s2对象中的this和s2相等，因为类是模板，模板中写的this并不是只有一个，每个对象中都有一个属于自己的this，就是每个对象中都一个属于自己的name属性一样。\n\n\n# 创建与初始化对象\n\n使用new关键字创建对象\n\n使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化，以及对类中构造器的调用。\n\n那么对main方法中的以下代码：Student s = new Student();\n\n1） 为对象分配内存空间，将对象的实例变量自动初始化默认值为0/false/null。(实例变量的隐式赋值)\n\n2） 如果代码中实例变量有显式赋值，那么就将之前的默认值覆盖掉。(之后可以通过例子看到这个现象)\n\n例如：显式赋值，private String name = "tom";\n\n\n3） 调用构造器\n\n4） 把对象内存地址值赋值给变量。(=号赋值操作)\n\n\n# 构造器\n\n类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点:\n\n 1. 必须和类的名字相同\n 2. 必须没有返回类型,也不能写void\n\n构造器的作用:\n\n 1. 使用new创建对象的时候必须使用类的构造器\n 2. 构造器中的代码执行后，可以给对象中的属性初始化赋值\n\n【演示】\n\npublic class Student{\n    private String name;\n    \n    public Student(){\n        name = "tom";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n构造器重载\n\n除了无参构造器之外，很多时候我们还会使用有参构造器，在创建对象时候可以给属性赋值。\n\n【例子】\n\npublic class Student{\n    private String name;\n    public Student(){\n        name = "tom";\n    }\n    public Student(String name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n构造器之间的调用\n\n使用this关键字，在一个构造器中可以调用另一个构造器的代码。\n\n注意：this的这种用法不会产生新的对象，只是调用了构造器中的代码而已。一般情况下只有使用new关键字才会创建新对象。\n\n【演示】\n\npublic class Student{\n    private String name;\n    public Student(){\n        this();\n    }\n    public Student(String name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n默认构造器\n\n在java中，即使我们在编写类的时候没有写构造器，那么在编译之后也会自动的添加一个无参构造器，这个无参构造器也被称为默认的构造器。\n\n【示例】\n\npublic class Student{\n    \n}\n\nmain:\n//编译通过,因为有无参构造器\nStudent s = new Student();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是,如果我们手动的编写了一个构造器,那么编译后就不会添加任何构造器了\n\n【示例】\n\npublic class Student{\n    private String name;\n    public Student(String name){\n        this.name = name;\n    }\n}\n\nmain:\n//编译报错,因为没有无参构造器\nStudent s = new Student();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 内存分析\n\nJAVA程序运行的内存分析\n\n栈 stack：\n\n 1. 每个线程私有，不能实现线程间的共享！\n 2. 局部变量放置于栈中。\n 3. 栈是由系统自动分配，速度快！栈是一个连续的内存空间！\n\n堆 heap：\n\n 1. 放置new出来的对象！\n 2. 堆是一个不连续的内存空间，分配灵活，速度慢！\n\n方法区(也是堆)：\n\n 1. 被所有线程共享！\n 2. 用来存放程序中永远是不变或唯一的内容。（类代码信息、静态变量、字符串常量）\n\n\n\n注意：本次内存分析，我们的主要目的是让大家了解基本的内存概念。类加载器、Class对象这些更加详细的内容，我们将在后面专门讲反射的课程里面讲。\n\n引用类型的概念\n\n 1. java中，除了基本数据类型之外的其他类型称之为引用类型。\n 2. java中的对象是通过引用来操作的。(引用：reference)说白了，引用指的就是对象的地址！\n\n属性（field，或者叫成员变量）\n\n 1. 属性用于定义该类或该类对象包含的数据或者说静态属性。\n\n 2. 属性作用范围是整个类体。\n\n 3. 属性的默认初始化：\n\n在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化(数值：0,0.0 char：u0000, boolean：false, 所有引用类型：null)\n\n 4. 属性定义格式：\n    \n    > [修饰符] 属性类型 属性名 = [默认值]\n\n类的方法\n\n方法是类和对象动态行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序有一个个函数调用组成；面向对象中，整个程序的基本单位是类，方法是从属于类或对象的。\n\n方法定义格式：\n\n[修饰符] 方法返回值类型 方法名(形参列表) {\n    // n条语句\n}\n\n\n1\n2\n3\n\n\njava对象的创建和使用\n\n * 必须使用 new 关键字创建对象。\n   \n   Person person= new Person ();\n\n * 使用对象（引用）.成员变量来引用对象的成员变量。\n   \n   person.age\n\n * 使用对象（引用）. 方法（参数列表）来调用对象的方法\n   \n   person.setAge(18)\n\n类中就是：静态的数据 动态的行为\n\n学习完类与对象终于认识到什么是类，什么是对象了。\n\n接下来要看的就是java的三大特征：继承、封 装、多态。\n\n\n# 封装\n\n我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗？有必要碰碰显像管吗？\n\n制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如： 电源开关。需要让用户知道的暴露出来，不需要让用户了解的全部隐藏起来。这就是封装。\n\n白话：该露的露，该藏的藏\n\n专业：我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。\n\n封装（数据的隐藏）\n\n在定义一个对象的特性的时候，有必要决定这些特性的可见性，即哪些特性对外部是可见的，哪些特性用于表示内部状态。\n\n通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。\n\n\n# 1、封装的步骤\n\n 1. 使用private 修饰需要封装的成员变量。\n\n 2. 提供一个公开的方法设置或者访问私有的属性\n    \n    设置 通过set方法，命名格式： set属性名（）; 属性的首字母要大写\n    \n    访问 通过get方法，命名格式： get属性名（）; 属性的首字母要大写\n\n【演示】\n\n//对象能在类的外部"直接"访问\npublic class Student{\n    public String name;\n    public void println(){\n        System.out.println(this.name);\n    }\n}\npublic class Test{\n    public static void main(String[] args){\n        Student s = new Student();\n        s.name = "tom";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在类中一般不会把数据直接暴露在外部的，而使用private(私有)关键字把数据隐藏起来\n\n【演示】\n\npublic class Student{\n    private String name;\n}\npublic class Test{\n    public static void main(String[] args){\n        Student s = new Student();\n        //编译报错,在类的外部不能直接访问类中的私有成员\n        s.name = "tom";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果在类的外部需要访问这些私有属性,那么可以在类中提供对于的get和set方法,以便让用户在类的外部 可以间接的访问到私有属性\n\n【示例】\n\n//set负责给属性赋值\n//get负责返回属性的值\npublic class Student{\n    private String name;\n    public void setName(String name){\n    this.name = name;\n\t}\n\tpublic String getName(){\n        return this.name;\n\t}\n}\npublic class Test{\n    public static void main(String[] args){\n        Student s = new Student();\n        s.setName("tom");\n        System.out.println(s.getName());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2、作用和意义\n\n 1. 提高程序的安全性，保护数据。\n 2. 隐藏代码的实现细节\n 3. 统一用户的调用接口\n 4. 提高系统的可维护性\n 5. 便于调用者调用。\n\n良好的封装，便于修改内部代码，提高可维护性。\n\n良好的封装，可进行数据完整性检测，保证数据的有效性。\n\n\n# 3、方法重载\n\n类中有多个方法，有着相同的方法名，但是方法的参数各不相同,这种情况被称为方法的重载。方法的重载可以提供方法调用的灵活性。\n\n思考：HelloWorld中的System.out.println()方法，为什么可以把不同类型的参数传给这个方法?\n\n【演示：查看println方法的重载】 idea中ctrl+左键点击println\n\n例如:\n\npublic class Test{\n    public void test(String str){\n        \n    }\n    public void test(int a){\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n方法重载必须满足以下条件\n\n 1. 方法名必须相同\n\n 2. 参数列表必须不同(参数的类型、个数、顺序的不同)\n    \n    public void test(Strig str){}\n    public void test(int a){}\n    \n    public void test(Strig str,double d){}\n    public void test(Strig str){}\n    \n    public void test(Strig str,double d){}\n    public void test(double d,Strig str){}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 方法的返回值可以不同，也可以相同。\n\n在java中，判断一个类中的俩个方法是否相同，主要参考俩个方面：方法名字和参数列表\n\n\n# 继承\n\n继承：extands\n\n现实世界中的继承无处不在。比如：\n\n动物：哺乳动物、爬行动物\n\n哺乳动物：灵长目、鲸目等。\n\n继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\n\n为什么需要继承？继承的作用？\n\n第一好处：继承的本质在于抽象。类是对对象的抽象，继承是对某一批类的抽象。\n\n第二好处：为了提高代码的复用性。\n\nextands的意思是“扩展”。子类是父类的扩展。\n\n【注】JAVA中类只有单继承，没有多继承！ 接口可以多继承！\n\n\n# 1、继承\n\n 1. 继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等。\n\n 2. 继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。子类继承父类，使用关键字extends来表示。\n    \n    public class student extends Person{\n    }\n    \n    \n    1\n    2\n    \n\n 3. 子类和父类之间，从意义上讲应该具有"is a"的关系。\n    \n    > student is a person\n    > \n    > dog is a animal\n\n 4. 类和类之间的继承是单继承\n    \n    一个子类只能"直接"继承一个父类,就像是一个人只能有一个亲生父亲 一个父类可以被多子类继承,就像一个父亲可以有多个孩子\n    \n    注:java中接口和接口之间,有可以继承,并且是多继承。\n\n 5. 父类中的属性和方法可以被子类继承\n    \n    子类中继承了父类中的属性和方法后,在子类中能不能直接使用这些属性和方法,是和这些属性和方法原有 的修饰符(public protected default private)相关的。\n    \n    例如：\n    \n    父类中的属性和方法使用public修饰，在子类中继承后"可以直接"使用 父类中的属性和方法使用private修饰，在子类中继承后"不可以直接"使用\n    \n    注：具体细则在修饰符部分详细说明\n    \n    父类中的构造器是不能被子类继承的，但是子类的构造器中，会隐式的调用父类中的无参构造器（默认使用 super关键字）。\n    \n    注:具体细节在super关键字部分详细说明\n\n\n# 2、Object类\n\njava中的每一个类都是"直接" 或者 "间接"的继承了Object类。所以每一个对象都和Object类有"is a"的关系。从API文档中，可以看到任何一个类最上层的父类都是Object。(Object类本身除外)AnyClass is a Object。\n\n> System.out.println(任何对象 instanceof Object);\n> \n> 输出结果:true 注:任何对象也包含数组对象\n\n例如:\n\n//编译后,Person类会默认继承Object\npublic class Person{}\n\n//Student是间接的继承了Object\npublic class Student extends Person{}\n\n\n1\n2\n3\n4\n5\n\n\n在Object类中，提供了一些方法被子类继承，那么就意味着，在java中，任何一个对象都可以调用这些被继承过来的方法。(因为Object是所以类的父类)\n\n例如：toString方法、equals方法、getClass方法等\n\n\n# 3、Super关键字\n\n子类继承父类之后，在子类中可以使用this来表示访问或调用子类中的属性或方法，使用super就表示访问或调用父类中的属性和方法。\n\n1、super的使用\n\n【访问父类中的属性】\n\npublic class Person{\n    protected String name = "zs";\n}\n\n\n1\n2\n3\n\n\npublic class Student extends Person{\n    private String name = "lisi";\n    public void tes(String name){\n        System.out.println(name);\n        System.out.println(this.name);\n        System.out.println(super.name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【调用父类中的方法】\n\npublic class Person{\n    public void print(){\n        System.out.println("Person");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class Student extends Person{\n    public void print(){\n        System.out.println("Student");\n    }\n    public void test(){\n        print();\n        this.print();\n        super.print();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【调用父类中的构造器】\n\npublic class Person{\n}\n\npublic class Student extends Person{\n    //编译通过,子类构造器中会隐式的调用父类的无参构造器\n    //super();\n    public Student(){\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n父类没有无参构造\n\npublic class Person{\n    protected String name;\n    public Person(String name){\n        this.name = name;\n    }\n}\npublic class Student extends Person{\n    //编译报错,子类构造器中会隐式的调用父类的无参构造器,但是父类中没有无参构造器\n    //super();\n    public Student(){\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【显式的调用父类的有参构造器】\n\npublic class Person{\n    protected String name;\n    public Person(String name){\n    this.name = name;\n\t}\n}\n\npublic class Student extends Person{\n    //编译通过,子类构造器中显式的调用父类的有参构造器\n    public Student(){\n        super("tom");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注：不管是显式还是隐式的父类的构造器，super语句一定要出现在子类构造器中第一行代码。所以this和 super不可能同时使用它们调用构造器的功能，因为它们都要出现在第一行代码位置。\n\n【例子】\n\npublic class Person{\n    protected String name;\n    public Person(String name){\n        this.name = name;\n    }\n}\n\npublic class Student extends Person{\n    //编译报错,super调用构造器的语句不是第一行代码\n    public Student(){\n        System.out.println("Student");\n        super("tom");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n【例子】\n\npublic class Person{\n    protected String name;\n    public Person(String name){\n        this.name = name;\n    }\n}\n//编译通过\npublic class Student extends Person{\n    private int age;\n    public Student(){\n        this(20);\n    }\n    public Student(int age){\n        super("tom");\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nsuper使用的注意的地方\n\n * 用super调用父类构造方法，必须是构造方法中的第一个语句。\n * super只能出现在子类的方法或者构造方法中\n * super 和 this 不能够同时调用构造方法。（因为this也是在构造方法的第一个语句）\n\nsuper 和 this 的区别\n\n 1. 代表的事物不一样：\n    \n    this：代表所属方法的调用者对象。\n    \n    super：代表父类对象的引用空间。\n\n 2. 使用前提不一致：\n    \n    this：在非继承的条件下也可以使用。\n    \n    super：只能在继承的条件下才能使用。\n\n 3. 调用构造方法：\n    \n    this：调用本类的构造方法。\n    \n    super：调用的父类的构造方法\n\n\n# 4、方法重写\n\n方法的重写（override）\n\n * 方法重写只存在于子类和父类(包括直接父类和间接父类)之间。在同一个类中方法只能被重载，不能被重写\n * 静态方法不能重写\n   1. 父类的静态方法不能被子类重写为非静态方法 //编译出错\n   2. 父类的非静态方法不能被子类重写为静态方法；//编译出错\n   3. 子类可以定义与父类的静态方法同名的静态方法(但是这个不是覆盖)\n\n【例子】\n\n> A类继承B类 A和B中都一个相同的静态方法test\n> \n> B a = new A(); a.test();//调用到的是B类中的静态方法test\n> \n> A a = new A(); a.test();//调用到的是A类中的静态方法test\n> \n> 可以看出静态方法的调用只和变量声明的类型相关 这个和非静态方法的重写之后的效果完全不同\n\n私有方法不能被子类重写，子类继承父类后,是不能直接访问父类中的私有方法的,那么就更谈不上重写了\n\npublic class Person{\n    private void run(){}\n    \n}\n\n//编译通过,但这不是重写,只是俩个类中分别有自己的私有方法\npublic class Student extends Person{\n    private void run(){}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n重写的语法\n\n 1. 方法名必须相同\n\n 2. 参数列表必须相同\n\n 3. 访问控制修饰符可以被扩大，但是不能被缩小： public protected default private\n\n 4. 抛出异常类型的范围可以被缩小,但是不能被扩大\n    \n    ClassNotFoundException ---\x3e Exception（不能扩大）\n\n 5. 返回类型可以相同，也可以不同。\n    \n    如果不同的话，子类重写后的方法返回类型必须是父类方法返回类型的子类型。\n    \n    例如：父类方法的返回类型是Person，子类重写后的返回类可以是Person也可以是Person的子类型\n\n注：一般情况下，重写的方法会和父类中的方法的声明完全保持一致，只有方法的实现不同。(也就是大括号中代码不一样)\n\npublic class Person{\n    public void run(){}\n    protected Object test()throws Exception{\n        return null;\n    }\n}\n\n//编译通过,子类继承父类,重写了run和test方法.\npublic class Student extends Person{\n    public void run(){}\n    public String test(){\n        return "";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为什么要重写？\n\n子类继承父类，继承了父类中的方法，但是父类中的方法并不一定能满足子类中的功能需要，所以子类中需要把方法进行重写。\n\n总结：\n\n 1. 方法重写的时候，必须存在继承关系。\n 2. 方法重写的时候，方法名和形式参数必须跟父类是一致的。\n 3. 方法重写的时候，子类的权限修饰符必须要大于或者等于父类的权限修饰符。( private < protected < public，friendly < public )\n 4. 方法重写的时候，子类的返回值类型必须小于或者等于父类的返回值类型。( 子类 < 父类 ) 数据类型没有明确的上下级关系\n 5. 方法重写的时候，子类的异常类型要小于或者等于父类的异常类型。\n\n\n# 多态\n\n\n# 1、认识多态\n\n多态性是OOP中的一个重要特性，主要是用来实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。\n\n多态可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，从而实现更加灵活的编程，提高系统的可扩展性。\n\n允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。\n\n相同类域的不同对象,调用相同的方法,执行结果是不同的\n\n 1. 一个对象的实际类型是确定的\n    \n    例如: new Student(); new Person();等\n\n 2. 可以指向对象的引用的类型有很多\n    \n    一个对象的实现类型虽然是确定的，但是这个对象所属的类型可能有很多种。\n    \n    例如：Student继承了Person类\n    \n    Student s1 = new Student();\n    Person s2 = new Student();\n    Object s3 = new Student();\n    \n    \n    1\n    2\n    3\n    \n    \n    因为Person和Object都是Student的父类型\n    \n    \n\n注：一个对象的实际类型是确定，但是可以指向这个对象的引用的类型，却是可以是这对象实际类型的任意父类型。\n\n一个父类引用可以指向它的任何一个子类对象\n\n例如：\n\nObject o = new AnyClass();\nPerson p = null;\np = new Student();\np = new Teacher();\np = new Person();\n\n\n1\n2\n3\n4\n5\n\n\n多态中的方法调用\n\npublic class Person{\n    public void run(){}\n}\n\npublic class Student extends Person{\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用到的run方法,是Student从Person继承过来的run方法\n\nPerson p = new Student();\np.run();\n\n\n1\n2\n\n\n例如：\n\npublic class Person{\n    public void run(){}\n}\n\npublic class Student extends Person{\n    public void run(){\n    //重写run方法\n    }\n}\n\n//调用到的run方法,是Student中重写的run方法\npublic static void main(String[] args) {\n    Person p = new Student();\n    p.run();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注：子类继承父类,调用a方法，如果a方法在子类中没有重写,那么就是调用的是子类继承父类的a方法, 如果重写了,那么调用的就是重写之后的方法。\n\n子类中独有方法的调用\n\npublic class Person{\n    public void run(){}\n}\n\npublic class Student extends Person{\n    public void test(){\n    }\n}\n\nmain:\nPerson p = new Student();\n//调用到继承的run方法\np.run();\n\n//编译报错,因为编译器检查变量p的类型是Person,但是在Person类中并没有发现test方法,所以编译报错.\np.test();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注：一个变量x，调用一个方法test，编译器是否能让其编译通过，主要是看声明变量x的类型中有没有定义 test方法，如果有则编译通过，如果没有则编译报错。而不是看x所指向的对象中有没有test方法。\n\n原理：编译看左边，运行不一定看右边。\n\n> 编译看左边的意思：java 编译器在编译的时候会检测引用类型中含有指定的成员，如果没有就会报错。 子类的成员是特有的，父类的没有的，所以他是找不到的。\n> \n> 所以看左边，Person 中没有test()方法，于是编译报错\n\n子类引用和父类引用指向对象的区别\n\nStudent s = new Student();\nPerson p = new Student();\n\n\n1\n2\n\n\n变量s能调用的方法是Student中有的方法(包括继承过来的)，变量p能调用的方法是Person中有的方法(包括继承过来的)。\n\n但是变量p是父类型的，p不仅可以指向Student对象，还可以指向Teacher类型对象等，但是变量s只能指 Studnet类型对象，及Student子类型对象。变量p能指向对象的范围是比变量s大的。\n\nObject类型的变量o，能指向所有对象，它的范围最大，但是使用变量o能调用到的方法也是最少的，只能调用到Object中的声明的方法，因为变量o声明的类型就是Object。\n\n注：java中的方法调用,是运行时动态和对象绑定的,不到运行的时候,是不知道到底哪个方法被调用的。\n\n多态的好处与弊端\n\n * 好处：提高了程序的拓展性\n   \n   具体表现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作\n\n * 弊端：不能使用子类的特有功能\n\n\n# 2、重写、重载和多态的关系\n\n重载是编译时多态\n\n> 调用重载的方法,在编译期间就要确定调用的方法是谁,如果不能确定则编译报错\n\n重写是运行时多态\n\n> 调用重写的方法，在运行期间才能确定这个方法到底是哪个对象中的。这个取决于调用方法的引用，在运行 期间所指向的对象是谁，这个引用指向哪个对象那么调用的就是哪个对象中的方法。(java中的方法调用，是运行时动态和对象绑定的)\n\n\n# 3、多态的注意事项\n\n 1. 多态是方法的多态，属性没有多态性。\n 2. 编写程序时，如果想调用运行时类型的方法，只能进行类型转换。不然通不过编译器的检查。但是如果两个没有关联的类进行强制转换，会报：ClassCastException。 比如：本来是狗，我把它转成猫。就会报这个异常。\n 3. 多态的存在要有3个必要条件：要有继承，要有方法重写，父类引用指向子类对象\n\n\n# 4、多态存在的条件\n\n * 有继承关系\n * 子类重写父类方法\n * 父类引用指向子类对象\n\n补充一下第二点，既然多态存在必须要有“子类重写父类方法”这一条件，那么以下三种类型的方法是没有办法表现出多态特性的（因为不能被重写）：\n\n 1. static方法，因为被static修饰的方法是属于类的，而不是属于实例的\n 2. final方法，因为被final修饰的方法无法被子类重写\n 3. private方法和protected方法，前者是因为被private修饰的方法对子类不可见，后者是因为尽管被 protected修饰的方法可以被子类见到，也可以被子类重写，但是它是无法被外部所引用的，一个不能被外部引用的方法，怎么能谈多态呢\n\n\n# 5、方法绑定(method binding)\n\n执行调用方法时，系统根据相关信息，能够执行内存地址中代表该方法的代码。分为静态绑定和动态绑定。\n\n静态绑定：\n\n在编译期完成，可以提高代码执行速度。\n\n动态绑定：\n\n通过对象调用的方法，采用动态绑定机制。这虽然让我们编程灵活，但是降低了代码的执行速度。这也是JAVA比C/C++速度慢的主要因素之一。JAVA中除了final类、final方、static方法，所有方法都是JVM在运行期才进行动态绑定的。\n\n多态：如果编译时类型和运行时类型不一致，就会造成多态。\n\n\n# 6、instanceof和类型转换\n\n1、instanceof\n\n三个不同java文件\n\npublic class Person{\n    public void run(){}\n}\n\npublic class Student extends Person{\n}\n\npublic class Teacher extends Person{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nmain：方法下\n\nObject o = new Student();\nSystem.out.println(o instanceof Student);//true\nSystem.out.println(o instanceof Person);//true\nSystem.out.println(o instanceof Object);//true\nSystem.out.println(o instanceof Teacher);//false\nSystem.out.println(o instanceof String);//false\n\n\n1\n2\n3\n4\n5\n6\n\n\nPerson o = new Student();\nSystem.out.println(o instanceof Student);//true\nSystem.out.println(o instanceof Person);//true\nSystem.out.println(o instanceof Object);//true\nSystem.out.println(o instanceof Teacher);//false\n//编译报错\nSystem.out.println(o instanceof String);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nStudent o = new Student();\nSystem.out.println(o instanceof Student);//true\nSystem.out.println(o instanceof Person);//true\nSystem.out.println(o instanceof Object);//true\n//编译报错\nSystem.out.println(o instanceof Teacher);\n//编译报错\nSystem.out.println(o instanceof String);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> System.out.println(x instanceof Y);\n\n【分析1】\n\n该代码能否编译通过，主要是看声明变量x的类型和Y是否存在子父类的关系。有"子父类关"系就编译通过，没有子父类关系就是编译报错。\n\n之后学习到的接口类型和这个是有点区别的。\n\n【分析2】\n\n输出结果是true还是false,主要是看变量x所指向的对象实际类型是不是Y类型的"子类型".\n\nObject o = new Person();\nSystem.out.println(o instanceof Student);//false\nSystem.out.println(o instanceof Person);//true\nSystem.out.println(o instanceof Object);//true\nSystem.out.println(o instanceof Teacher);//false\nSystem.out.println(o instanceof String);//false\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、类型转换\n\npublic class Person{\n    public void run(){}\n}\n\npublic class Student extends Person{\n    public void go(){}\n}\n\npublic class Teacher extends Person{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n为什么要类型转换\n\n//编译报错,因为p声明的类型Person中没有go方法\nPerson p = new Student();\np.go();\n\n//需要把变量p的类型进行转换\nPerson p = new Student();\nStudent s = (Student)p;\ns.go();\n\n//或者\n//注意这种形式前面必须要俩个小括号\nPerson p = new Student();\n((Student)p).go();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n类型转换中的问题\n\n//编译通过 运行没问题\nObject o = new Student();\nPerson p = (Person)o;\n\n//编译通过 运行没问题\nObject o = new Student();\nStudent s = (Student)o;\n\n//编译通过,运行报错\nObject o = new Teacher();\nStudent s = (Student)o;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n即: X x = (X)o;\n\n运行是否报错，主要是变量o所指向的对象实现类型，是不是X类型的子类型，如果不是则运行就会报错。\n\n【总结】\n\n 1. 父类引用可以指向子类对象，子类引用不能指向父类对象。\n\n 2. 把子类对象直接赋给父类引用叫向上转型（upcasting），不用强制转型。\n    \n    如Father father = new Son();\n\n 3. 把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。\n    \n    如father就是一个指向子类对象的父类引用，把father赋给子类引用son\n    \n    即Son son =（Son） father；\n    \n    其中father前面的（Son）必须添加，进行强制转换。\n\n 4. upcasting 会丢失子类特有的方法，但是子类overriding 父类的方法，子类方法有效\n\n 5. 向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。\n\n\n# 修饰符\n\n\n# 1、static修饰符\n\n1、static变量\n\n在类中,使用static修饰的成员变量,就是静态变量,反之为非静态变量。\n\n静态变量和非静态变量的区别\n\n静态变量属于类的，"可以"使用类名来访问，非静态变量是属于对象的，"必须"使用对象来访问。\n\npublic class Student{\n    private static int age;\n    private double score;\n    public static void main(String[] args) {\n        Student s = new Student();\n        //推荐使用类名访问静态成员\n        System.out.println(Student.age);\n        System.out.println(s.age);\n        \n        System.out.println(s.score);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n静态变量对于类而言在内存中只有一个，能被类的所有实例所共享。实例变量对于类的每个实例都有一份, 它们之间互不影响。（在基础语法中粗略解释过静态变量）\n\npublic class Student {\n    private static int count;\n    private int num;\n\n    public Student() {\n        count++;\n        num++;\n    }\n\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        Student s2 = new Student();\n        Student s3 = new Student();\n        Student s4 = new Student();\n        //因为还是在类中,所以可以直接访问私有属性\n        System.out.println(s1.num);//1\n        System.out.println(s2.num);\n        System.out.println(s3.num);\n        System.out.println(s4.num);\n        System.out.println(Student.count);\n        \n        System.out.println(s1.count);//4\n        System.out.println(s2.count);\n        System.out.println(s3.count);\n        System.out.println(s4.count);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在加载类的过程中为静态变量分配内存，实例变量在创建对象时分配内存，所以静态变量可以使用类名来直接访问，而不需要使用对象来访问。\n\n2、static方法\n\n在类中，使用static修饰的成员方法，就是静态方法，反之为非静态方法。\n\n静态方法和非静态方法的区别\n\n> 静态方法数属于类的，"可以"使用类名来调用，非静态方法是属于对象的，"必须"使用对象来调用。\n\n静态方法"不可以"直接访问类中的非静态变量和非静态方法，但是"可以"直接访问类中的静态变量和静态方法\n\n注意：this和super在类中属于非静态的变量.(静态方法中不能使用)\n\npublic class Student {\n    private static int count;\n    private int num;\n    public void run(){}\n    public static void go(){}\n    public static void test(){\n        //编译通过\n        System.out.println(count);\n        go();\n        \n        //编译报错\n        System.out.println(num);\n        run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n非静态方法"可以"直接访问类中的非静态变量和非静态方法，也"可以"直接访问类中的静态变量和静态方法\n\npublic class Student {\n    private static int count;\n    private int num;\n\n    public void run() {\n    }\n\n    public static void go() {\n    }\n    public void test() {\n        //编译通过\n        System.out.println(count);\n        go();\n        //编译通过\n        System.out.println(num);\n        run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n思考：为什么静态方法和非静态方法不能直接相互访问？ 加载顺序的问题！\n\n父类的静态方法可以被子类继承，但是不能被子类重写\n\npublic class Person {\n    public static void method() {}\n}\n\n//编译报错\npublic class Student extends Person {\n    public void method(){}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npublic class Person {\n    public static void test() {\n        System.out.println("Person");\n    }\n}\n//编译通过,但不是重写\npublic class Student extends Person {\n    public static void test(){\n        System.out.println("Student");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n//main:\nPerosn p = new Student();\np.test();//输出Person\np = new Person();\np.test();//输出Perosn\n\n\n1\n2\n3\n4\n5\n\n\n父类的非静态方法不能被子类重写为静态方法 ；\n\npublic class Person {\n    public void test() {\n        System.out.println("Person");\n    }\n}\n//编译报错\npublic class Student extends Person {\n    public static void test(){\n        System.out.println("Student");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3、代码块和静态代码块\n\n【类中可以编写代码块和静态代码块】\n\npublic class Person {\n    {\n        //代码块(匿名代码块)\n    }\n    static{\n        //静态代码块\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【匿名代码块和静态代码块的执行】\n\n因为没有名字,在程序并不能主动调用这些代码块。\n\n匿名代码块是在创建对象的时候自动执行的，并且在构造器执行之前，在静态代码块之后。同时匿名代码块在每次创建对象的时候都会自动执行。\n\n静态代码块是在类加载完成之后就自动执行，并且只执行一次。\n\n注：每个类在第一次被使用的时候就会被加载，并且一般只会加载一次。\n\npublic class Student {\n    {\n        System.out.println("匿名代码块");\n    }\n    \n    static{\n        System.out.println("静态代码块");\n    }\n    \n    public Student(){\n        System.out.println("构造器");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n//main:\nStudent s1 = new Student();\nStudent s2 = new Student();\nStudent s3 = new Student();\n\n\n1\n2\n3\n4\n\n\n输出：\n\n> 静态代码块 匿名代码块 构造器\n> \n> 匿名代码块 构造器\n> \n> 匿名代码块 构造器\n\n【匿名代码块和静态代码块的作用】\n\n匿名代码块的作用是给对象的成员变量初始化赋值，但是因为构造器也能完成这项工作，所以匿名代码块使用的并不多。\n\n静态代码块的作用是给类中的静态成员变量初始化赋值。\n\npublic class Person {\n    public static String name;\n    static{\n        name = "tom";\n    }\n    public Person(){\n        name = "zs";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> main: System.out.println( Person.name ); //tom\n\n注：在构造器中给静态变量赋值，并不能保证能赋值成功，因为构造器是在创建对象的时候才指向，但是静态变量可以不创建对象而直接使用类名来访问。\n\n4、创建和初始化对象的过程\n\nStudent s = new Student();\n\n\n1\n\n\n【Student类之前没有进行类加载的过程】\n\n 1. 类加载，同时初始化类中静态的属性\n 2. 执行静态代码块\n 3. 分配内存空间，同时初始化非静态的属性(赋默认值,0/false/null)\n 4. 调用Student的父类构造器\n 5. 对Student中的属性进行显示赋值(如果有的话)\n 6. 执行匿名代码块\n 7. 执行构造器\n 8. 返回内存地址\n\n注：子类中非静态属性的显示赋值是在父类构造器执行完之后和子类中的匿名代码块执行之前的时候\n\npublic class Person{\n    private String name = "zs";\n    public Person() {\n        System.out.println("Person构造器");\n        print();\n    }\n    public void print(){\n        System.out.println("Person print方法: name = "+name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\npublic class Student extends Person{\n    private String name = "tom";\n    {\n        System.out.println("Student匿名代码块");\n    }\n    static{\n        System.out.println("Student静态代码块");\n    }\n    public Student(){\n        System.out.println("Student构造器");\n    }\n    public void print(){\n        System.out.println("student print方法: name = "+name);\n    }\n    public static void main(String[] args) {\n        new Student();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\n> Student静态代码块 Person构造器 student print方法: name = null Student匿名代码块 Student构造器\n\nStudent s = new Student();\n//Student类之前已经进行了类加载\n//1.分配内存空间,同时初始化非静态的属性(赋默认值,0/false/null)\n//2.调用Student的父类构造器\n//3.对Student中的属性进行显示赋值(如果有的话)\n//4.执行匿名代码块\n//5.执行构造器\n//6.返回内存地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n5、静态导入\n\n静态导包就是java包的静态导入，用import static代替import静态导入包是JDK1.5中的新特性。\n\n意思是导入这个类里的静态方法。\n\n好处：这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一 个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便。\n\nimport static java.lang.Math.random;\nimport static java.lang.Math.PI;\n\npublic class Test {\n    public static void main(String[] args) {\n        //之前是需要Math.random()调用的\n        System.out.println(random());\n        System.out.println(PI);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2、final修饰符\n\n1、修饰类\n\n用final修饰的类不能被继承，没有子类\n\n例如：我们是无法写一个类去继承String类，然后对String类型扩展的。因为API中已经被String类定义为final\n\n我们也可以定义final修饰的类:\n\npublic final class Action{\n    \n}\n\n//编译报错\npublic class Go extends Action{\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n2、修饰方法\n\n用final修饰的方法可以被继承，但是不能被子类的重写。\n\n例如：每个类都是Object类的子类，继承了Object中的众多方法，在子类中可以重写toString方法、equals方法等，但是不能重写getClass方法、wait方法等，因为这些方法都是使用fianl修饰的。\n\n我们也可以定义final修饰的方法：\n\npublic class Person{\n    public final void print(){}\n}\n\n//编译报错\npublic class Student extends Person{\n    public void print(){\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n3、修饰变量\n\n用final修饰的变量表示常量，只能被赋一次值。使用final修饰的变量也就成了常量了，因为值不会再变了。\n\n【修饰局部变量】\n\npublic class Person{\n    public void print(final int a){\n    //编译报错,不能再次赋值,传参的时候已经赋过了\n    a = 1;\n    }\n}\n\npublic class Person{\n    public void print(){\n        final int a;\n        a = 1;\n        //编译报错,不能再次赋值\n        a = 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n【修饰成员变量-非静态成员变量】\n\npublic class Person{\n    private final int a;\n}\n/*\n只有一次机会,可以给此变量a赋值的位置:\n声明的同时赋值\n匿名代码块中赋值\n构造器中赋值(类中出现的所有构造器都要写)\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n【修饰成员变量-静态成员变量】\n\npublic class Person{\n    private static final int a;\n}\n/*\n只有一次机会,可以给此变量a赋值的位置:\n声明的同时赋值\n静态代码块中赋值\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【修饰引用对象】\n\nfinal Student s = new Student();\n//编译通过\ns.setName("tom");\ns.setName("zs");\n\n//编译报错,不能修改引用s指向的内存地址\ns = new Student();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、abstract修饰符\n\nabstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法。如果修饰类，那么该类就是抽象类。\n\n1、抽象类和抽象方法的关系\n\n抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。\n\n2、语法\n\npublic abstract class Action{\n    public abstract void doSomething();\n}\n\npublic void doSomething(){...}\n\n\n1\n2\n3\n4\n5\n\n\n对于这个普通方法来讲：\n\n"public void doSomething()"这部分是方法的声明。 "{...}"这部分是方法的实现,如果大括号中什么都没写,就叫方法的空实现\n\n声明类的同时，加上abstract修饰符就是抽象类 声明方法的时候，加上abstract修饰符，并且去掉方法的大口号，同时结尾加上分号，该方法就是抽象方法。\n\n\n# 3、特点及作用\n\n抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。\n\n注：子类继承抽象类后，需要实现抽象类中没有实现的抽象方法，否则这个子类也要声明为抽象类。\n\npublic abstract class Action{\n    public abstract void doSomething();\n}\n\nmain:\n//编译报错,抽象类不能new对象\nAction a = new Action();\n\n//子类继承抽象类\npublic class Eat extends Action{\n    //实现父类中没有实现的抽象方法\n    public void doSomething(){\n        //code\n    }\n}\n\nmain:\nAction a = new Eat();\na.doSomething();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注：子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。\n\n4、思考\n\n思考1 : 抽象类不能new对象，那么抽象类中有没有构造器？\n\n> 抽象类是不能被实例化，抽象类的目的就是为实现多态中的共同点，抽象类的构造器会在子类实例化时调用，因此它也是用来实现多态中的共同点构造，不建议这样使用！\n\n思考2 : 抽象类和抽象方法意义（为什么要编写抽象类、抽象方法）\n\n> 打个比方，要做一个游戏。如果要创建一个角色，如果反复创建类和方法会很繁琐和麻烦。建一个抽象类 后。若要创建角色可直接继承抽象类中的字段和方法，而抽象类中又有抽象方法。如果一个角色有很多种 职业，每个职业又有很多技能，要是依次实例这些技能方法会显得想当笨拙。定义抽象方法，在需要时继 承后重写调用，可以省去很多代码。\n> \n> 总之抽象类和抽象方法起到一个框架作用。很方便后期的调用和重写 抽象方法是为了程序的可扩展性。重写抽象方法时即可实现同名方法但又非同目的的要求。\n\n\n# 接口\n\n\n# 1、接口的本质\n\n普通类：只有具体实现 抽象类：具体实现和规范(抽象方法) 都有！ 接口：只有规范！\n\n为什么需要接口？接口和抽象类的区别？\n\n * 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。\n * 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。\n * 从接口的实现者角度看，接口定义了可以向外部提供的服务。\n * 从接口的调用者角度看，接口定义了实现者能提供那些服务。\n * 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的系统之间模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。\n\n接口的本质探讨\n\n * 接口就是规范，定义的是一组规则，体现了现实世界中”如果你是…则必须能…“的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。\n * 接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。\n * OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。\n\n\n# 2、接口与抽象类的区别\n\n抽象类也是类，除了可以写抽象方法以及不能直接new对象之外，其他的和普通类没有什么不一样的。接口已经另一种类型了，和类是有本质的区别的，所以不能用类的标准去衡量接口。\n\n声明类的关键字是class，声明接口的关键字是interface。\n\n抽象类是用来被继承的，java中的类是单继承。\n\n类A继承了抽象类B，那么类A的对象就属于B类型了，可以使用多态 一个父类的引用，可以指向这个父类的任意子类对象 注：继承的关键字是extends\n\n接口是用来被类实现的，java中的接口可以被多实现。 类A实现接口B、C、D、E..，那么类A的对象就属于B、C、D、E等类型了，可以使用多态 一个接口的引用，可以指向这个接口的任意实现类对象 注：实现的关键字是implements\n\n\n# 3、接口中的方法都是抽象方法\n\n接口中可以不写任何方法，但如果写方法了，该方法必须是抽象方法\n\npublic interface Action{\n    public abstract void run();\n    \n    //默认就是public abstract修饰的\n    void test();\n    public void go();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4、接口中的变量都是静态常量\n\npublic static final修饰\n\n接口中可以不写任何属性，但如果写属性了，该属性必须是public static final修饰的静态常量。 注：可以直接使用接口名访问其属性。因为是public static修饰的\n\n注：声明的同时就必须赋值(因为接口中不能编写静态代码块)\n\npublic interface Action{\n    public static final String NAME = "tom";\n    //默认就是public static final修饰的\n    int AGE = 20;\n}\n\nmain:\nSystem.out.println(Action.NAME);\nSystem.out.println(Action.AGE);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5、一个类可以实现多个接口\n\npublic class Student implements A,B,C,D{\n    //Student需要实现接口A B C D中所有的抽象方法\n    //否则Student类就要声明为抽象类,因为有抽象方法没实现\n}\n\nmain:\nA s1 = new Student();\nB s2 = new Student();\nC s3 = new Student();\nD s4 = new Student();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注： s1只能调用接口A中声明的方法以及Object中的方法 s2只能调用接口B中声明的方法以及Object中的方法 s3只能调用接口C中声明的方法以及Object中的方法 s4只能调用接口D中声明的方法以及Object中的方法\n\n注：必要时可以类型强制转换\n\n例如 : 接口A 中有test() ， 接口B 中有run()\n\n\n# 6、一个接口可以继承多个父接口\n\npublic interface A{\n    public void testA();\n}\n\npublic interface B{\n    public void testB();\n}\n\n//接口C把接口A B中的方法都继承过来了\npublic interface C extends A,B{\n    public void testC();\n}\n\n//Student相当于实现了A B C三个接口,需要实现所有的抽象方法\n//Student的对象也就同时属于A类型 B类型 C类型\npublic class Student implements C{\n    public viod testA(){}\n    public viod testB(){}\n    public viod testC(){}\n}\n\nmain:\n\nC o = new Student();\nSystem.out.println(o instanceof A);//true\nSystem.out.println(o instanceof B);//true\nSystem.out.println(o instanceof C);//true\nSystem.out.println(o instanceof Student);//true\nSystem.out.println(o instanceof Object);//true\nSystem.out.println(o instanceof Teacher);//false\n\n//编译报错\nSystem.out.println(o instanceof String);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n注：System.out.println(o instanceof X);\n\n> 如果o是一个接口类型声明的变量，那么只要X不是一个final修饰的类，该代码就能通过编译，至于其结果是不是true，就要看变量o指向的对象的实际类型，是不是X的子类或者实现类了。\n\n注：一个引用所指向的对象，是有可能实现任何一个接口的。(java中的多实现)\n\n\n# 7、接口的作用\n\n接口的最主要的作用是达到统一访问，就是在创建对象的时候用接口创建\n\n【接口名】 【对象名】= new 【实现接口的类】\n\n这样你像用哪个类的对象就可以new哪个对象了，不需要改原来的代码。\n\n假如我们两个类中都有个function()的方法，如果我用接口，那样我new a()；就是用a的方法，new b() 就是用b的方法。\n\n这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同\n\n总结：\n\n 1. Java接口中的成员变量默认都是public,static,final类型的(都可省略)，必须被显示初始化，即接口中的成员变量为常量(大写,单词之间用"_"分隔)\n 2. Java接口中的方法默认都是public,abstract类型的(都可省略)，没有方法体,不能被实例化\n 3. Java接口中只能包含public,static,final类型的成员变量和public,abstract类型的成员方法\n 4. 接口中没有构造方法,不能被实例化\n 5. 一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口\n 6. Java接口必须通过类来实现它的抽象方法\n 7. 当类实现了某个Java接口时，它必须实现接口中的所有抽象方法，否则这个类必须声明为抽象类\n 8. 不允许创建接口的实例（实例化），但允许定义接口类型的引用变量，该引用变量引用实现了这个接口的类的实例\n 9. 一个类只能继承一个直接的父类，但可以实现多个接口，间接的实现了多继承。\n\ninterface SwimInterface{\n    void swim();\n}\n\nclass Fish{\n    int fins=4;\n}\n\nclass Duck {\n    int leg=2;\n    void egg(){};\n}\n\nclass Goldfish extends Fish implements SwimInterface {\n    @Override\n    public void swim() {\n        System.out.println("Goldfish can swim ");\n    }\n}\n\nclass SmallDuck extends Duck implements SwimInterface {\n    public void egg(){\n        System.out.println("SmallDuck can lay eggs ");\n    }\n    @Override\n    public void swim() {\n  \t  System.out.println("SmallDuck can swim ");\n    }\n}\n\npublic class InterfaceDemo {\n    public static void main(String[] args) {\n        Goldfish goldfish=new Goldfish();\n        goldfish.swim();\n        \n        SmallDuck smallDuck= new SmallDuck();\n        smallDuck.swim();\n        smallDuck.egg();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 内部类\n\n上一小节，我们学习了接口，在以后的工作中接口是我们经常要碰到的，所以一定要多去回顾。接下来介绍一下内部类。很多时候我们创建类的对象的时候并不需要使用很多次，每次只使用一次，这个时候我们就可以使用内部类了。\n\n\n# 1、内部类概述\n\n内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。\n\n内部类不是在一个java源文件中编写俩个平行的俩个类，而是在一个类的内部再定义另外一个类。 我们可以把外边的类称为外部类，在其内部编写的类称为内部类。\n\n内部类分为四种：\n\n 1. 成员内部类\n 2. 静态内部类\n 3. 局部内部类\n 4. 匿名内部类\n\n\n# 2、成员内部类\n\n成员内部类（实例内部类、非静态内部类）\n\n注：成员内部类中不能写静态属性和方法\n\n【定义一个内部类】\n\n//在A类中申明了一个B类，此B类就在A的内部，并且在成员变量的位置上，所以就称为成员内部类\npublic class Outer {\n    private int id;\n    public void out(){\n        System.out.println("这是外部类方法");\n    }\n    \n    class Inner{\n        public void in(){\n     \t   System.out.println("这是内部类方法");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【实例化内部类】\n\n实例化内部类，首先需要实例化外部类，通过外部类去调用内部类\n\npublic class Outer {\n    private int id;\n    public void out(){\n  \t  System.out.println("这是外部类方法");\n    }\n    \n    class Inner{\n        public void in(){\n        System.out.println("这是内部类方法");\n    }\n    }\n}\n\npublic class Test{\n    public static void main(String[] args) {\n        //实例化成员内部类分两步\n        //1、实例化外部类\n        Outer outObject = new Outer();\n        //2、通过外部类调用内部类\n        Outer.Inner inObject = outObject.new Inner();\n        //测试，调用内部类中的方法\n        inObject.in();//打印：这是内部类方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n分析：想想如果你要使用一个类中方法或者属性，你就必须要先有该类的一个对象，同理，一个类在另 一个类的内部，那么想要使用这个内部类，就必须先要有外部类的一个实例对象，然后在通过该对象去使用内部类。\n\n【成员内部类能干什么？】\n\n * 访问外部类的所有属性(这里的属性包括私有的成员变量，方法)\n\npublic class Outer {\n    private int id;\n    public void out(){\n        System.out.println("这是外部类方法");\n    }\n    \n    class Inner{\n        public void in(){\n            System.out.println("这是内部类方法");\n        }\n        //内部类访问外部类私有的成员变量\n        public void useId(){\n            System.out.println(id+3);。\n        }\n        //内部类访问外部类的方法\n        public void useOut(){\n            out();\n        }\n    }\n}\n\npublic class Test{\n    public static void main(String[] args) {\n        //实例化成员内部类分两步\n        //1、实例化外部类\n        Outer outObject = new Outer();\n        //2、通过外部类调用内部类\n        Outer.Inner inObject = outObject.new Inner();\n        //测试\n        inObject.useId();//打印3，因为id初始化值为0，0+3就为3，其中在内部类就使用了外部类的私有成员变量id。\n        inObject.useOut();//打印：这是外部类方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n * 如果内部类中的变量名和外部类的成员变量名一样，要通过创建外部类对象"."属性来访问外部类属性，通过this.属性访问内部类成员属性\n\npublic class Outer {\n    private int id;//默认初始化0\n\n    public void out() {\n        System.out.println("这是外部类方法");\n    }\n\n    class Inner {\n        private int id = 8; //这个id跟外部类的属性id名称一样。\n\n        public void in() {\n            System.out.println("这是内部类方法");\n        }\n\n        public void test() {\n            System.out.println(id);//输出8，内部类中的变量会暂时将外部类的成员变量给隐藏\n            // 如何调用外部类的成员变量呢？通过Outer.this\n            // 想要知道为什么能通过这个来调用，就得明白下面这个原理\n            // 想实例化内部类对象，就必须通过外部类对象，当外部类对象来new出内部类对象时，会把自己(外部类对象)的引用传到了内部类中，\n            // 所以内部类就可以通过Outer.this来访问外部类的属性和方法\n            // 到这里，你也就可以知道为什么内部类可以访问外部类的属性和方法，这里由于有两个相同的属性名称，\n\n            // 所以需要显示的用Outer.this来调用外部类的属性，平常如果属性名不重复\n            // 那么我们在内部类中调用外部类的属性和方法时，前面就隐式的调用了Outer.this。\n            System.out.println(Outer.this.id);//输出外部类的属性id。也就是输出0\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n借助成员内部类，来总结内部类(包括4种内部类)的通用用法：\n\n 1. 要想访问内部类中的内容，必须通过外部类对象来实例化内部类。\n\n 2. 能够访问外部类所有的属性和方法，原理就是在通过外部类对象实例化内部类对象时，外部类对象把自己的引用传进了内部类，使内部类可以用通过Outer.this去调用外部类的属性和方法。\n    \n    一般都是隐式调用了，但是当内部类中有属性或者方法名和外部类中的属性或方法名相同的时候，就需要通过显式调用Outer.this了。\n\n【写的一个小例子】\n\npublic class MemberInnerClassTest {\n    private String name;\n    private static int age;\n\n    public void run() {\n    }\n\n    public static void go() {\n    }\n\n    public class MemberInnerClass {\n        private String name;\n\n        //内部类访问外部类\n        public void test(String name) {\n            System.out.println(name);\n            System.out.println(this.name);\n            System.out.println(MemberInnerClassTest.this.name);\n            System.out.println(MemberInnerClassTest.age);\n            MemberInnerClassTest.this.run();\n            MemberInnerClassTest.go();\n        }\n    }\n\n    //外部类访问成员内部类\n    //成员内部类的对象要 依赖于外部类的对象的存在\n    public void test() {\n        //MemberInnerClass mic = MemberInnerClassTest.this.new MemberInnerClass();\n        //MemberInnerClass mic = this.new MemberInnerClass();\n        MemberInnerClass mic = new MemberInnerClass();\n        mic.name = "tom";\n        mic.test("hua");\n    }\n\n    public static void main(String[] args) {\n        //MemberInnerClass mic = new MemberInnerClass();这个是不行的，this是动态的。\n        //所以要使用要先创建外部类对象，才能使用\n        MemberInnerClassTest out = new MemberInnerClassTest();\n        MemberInnerClass mic = out.new MemberInnerClass();\n        //如果内部类是private,则不能访问，只能铜鼓内部方法来调用内部类\n        mic.name = "jik";\n        mic.test("kkk");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 3、静态内部类\n\n看到名字就知道，使用static修饰的内部类就叫静态内部类。\n\n既然提到了static，那我们就来复习一下它的用法：一般只修饰变量和方法，平常不可以修饰类，但是内部类却可以被static修饰。\n\n 1. static修饰成员变量：整个类的实例共享静态变量\n 2. static修饰方法：静态方法，只能够访问用static修饰的属性或方法，而非静态方法可以访问static修饰的方法或属性\n 3. 被static修饰了的成员变量和方法能直接被类名调用。\n 4. static不能修饰局部变量，切记，不要搞混淆了，static平常就用来修饰成员变量和方法。\n\n例子：\n\npublic class StaticInnerClassTest {\n\n    private String name;\n    private static int age;\n\n    public void run() {\n    }\n\n    public static void go() {\n    }\n\n    //外部类访问静态内部类\n    public void test() {\n        StaticInnerClass sic = new StaticInnerClass(); //静态的内部类不需要依赖外部类，所以不用this\n        sic.name = "tom";\n\n        sic.test1("jack");\n        StaticInnerClass.age = 10;\n        StaticInnerClass.test2("xixi");\n    }\n\n    private static class StaticInnerClass {\n        private String name;\n        private static int age;\n\n        public void test1(String name) {\n            System.out.println(name);\n            System.out.println(this.name);\n            System.out.println(StaticInnerClass.age);\n            System.out.println(StaticInnerClassTest.age);\n            //System.out.println(StaticInnerClassTest.this.name);静态类不能访问非静态属性\n            StaticInnerClassTest.go();\n            //StaticInnerClassTest.this.run();静态类不能访问非静态方法\n        }\n\n        public static void test2(String name) {\n            //只能访问自己和外部类的静态属性和方法\n            System.out.println(name);\n            //System.out.println(this.name);静态方法里面连自己类的非静态属性都不能访问\n            System.out.println(StaticInnerClass.age);\n            System.out.println(StaticInnerClassTest.age);\n            //System.out.println(StaticInnerClassTest.this.name);静态方法不能访问非静态属性\n            StaticInnerClassTest.go();\n            //StaticInnerClassTest.this.run();静态方法不能访问非静态方法\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n注意：\n\n 1. 我们上面说的内部类能够调用外部类的方法和属性，在静态内部类中就行了，因为静态内部类没有 了指向外部类对象的引用。除非外部类中的方法或者属性也是静态的。这就回归到了static关键字的用法。\n\n 2. 静态内部类能够直接被外部类给实例化，不需要使用外部类对象\n    \n    Outer.Inner inner = new Outer.Inner();\n    \n    \n    1\n    \n\n 3. 静态内部类中可以声明静态方法和静态变量，但是非静态内部类中就不可以声明静态方法和静态变量\n\n\n# 4、局部内部类\n\n局部内部类是在一个方法内部声明的一个类 局部内部类中可以访问外部类的成员变量及方法 局部内部类中如果要访问该内部类所在方法中的局部变量，那么这个局部变量就必须是final修饰的\n\npublic class Outer {\n    private int id;\n\n    //在method01方法中有一个Inner内部类，这个内部类就称为局部内部类\n    public void method01() {\n        class Inner {\n            public void in() {\n                System.out.println("这是局部内部类");\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n局部内部类一般的作用跟在成员内部类中总结的差不多，但是有两个要注意的地方：\n\n1、在局部内部类中，如果要访问局部变量，那么该局部变量要用final修饰\n\n为什么需要使用final？\n\nfinal修饰变量：变为常量，会在常量池中放着，逆向思维想这个问题，如果不实用final修饰，当局部内部类被实例化后，方法弹栈，局部变量随着跟着消失，这个时候局部内部类对象在想去调用该局部变量，就会报错，因为该局部变量已经没了，当局部变量用fanal修饰后，就会将其加入常量池中，即使方法弹栈了，该局部变量还在常量池中呆着，局部内部类也就是够调用。所以局部内部类想要调用局部变 量时，需要使用final修饰，不使用，编译度通不过。\n\npublic class Outer {\n    private int id;\n\n    public void method01() {\n        //这个就是局部变量cid。要让局部内部类使用，就得变为final并且赋值，如果不使用final修饰，就会报错\n        final int cid = 3;\n        class Inner {\n            //内部类的第一个方法\n            public void in() {\n                System.out.println("这是局部内部类");\n            }\n\n            //内部类中的使用局部变量cid的方法\n            public void useCid() {\n                System.out.println(cid);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象 调用自己类中的方法。\n\n看下面例子就知道如何用了。\n\npublic class Outer {\n    private int id;\n\n    public void out() {\n        System.out.println("外部类方法");\n    }\n\n    public void method01() {\n        class Inner {\n            public void in() {\n                System.out.println("这是局部内部类");\n            }\n        }\n        //关键在这里，如需要在method01方法中自己创建内部类实例，\n        // 然后调用内部类中的方法，等待外部类调用method01方法，\n        // 就可以执行到内部类中的方法了。\n        Inner In = new Inner();\n        In.in();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n使用局部内部类需要注意的地方就刚才上面说的：\n\n 1. 在局部内部类中，如果要访问局部变量，那么该局部变量要用final修饰\n\n 2. 如何调用局部内部类方法。\n    \n    public class LocalInnerClassTest {\n        private String name;\n        private static int age;\n    \n        public void run() {\n        }\n    \n        public static void go() {\n        }\n    \n        //局部内部类要定义在方法中\n        public void test() {\n            final String myname = "";\n            class LocalInnerClass {\n                private String name;\n    \n                // private static int age;不能定义静态属性\n                public void test(String name) {\n                    System.out.println(name);\n                    System.out.println(this.name);\n                    System.out.println(myname);\n                    System.out.println(LocalInnerClassTest.this.name);\n                    LocalInnerClassTest.this.run();\n                    LocalInnerClassTest.go();\n                }\n            }\n            // 局部内部类只能在自己的方法中用\n            // 因为局部内部类相当于一个局部变量，出了方法就找不到了。\n            LocalInnerClass lic = new LocalInnerClass();\n            lic.name = "tom";\n            lic.test("test");\n            \n        }\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    \n\n\n# 5、匿名内部类\n\n在这四种内部类中，以后的工作可能遇到最多的是匿名内部类，所以说匿名内部类是最常用的一种 内部类。\n\n什么是匿名对象？如果一个对象只要使用一次，那么我们就是需要new Object().method()。 就可以了，而不需要给这个实例保存到该类型变量中去。这就是匿名对象。\n\npublic class Test {\n    public static void main(String[] args) {\n        //讲new出来的Apple实例赋给apple变量保存起来，但是我们只需要用一次，就可以这样写\n        Apple apple = new Apple();\n        apple.eat();\n        //这种就叫做匿名对象的使用，不把实例保存到变量中。\n        new Apple().eat();\n    }\n}\n\nclass Apple{\n    public void eat(){\n        System.out.println("我要被吃了");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n匿名内部类跟匿名对象是一个道理：\n\n匿名对象：我只需要用一次，那么我就不用声明一个该类型变量来保存对象了，\n\n匿名内部类：我也只需要用一次，那我就不需要在类中先定义一个内部类，而是等待需要用的时候，我就在临时实现这个内部类，因为用次数少，可能就这一次，那么这样写内部类，更方便。不然先写出一 个内部类的全部实现来，然后就调用它一次，岂不是用完之后就一直将其放在那，那就没必要那样。\n\n 1. 匿名内部类需要依托于其他类或者接口来创建\n    * 如果依托的是类，那么创建出来的匿名内部类就默认是这个类的子类\n    * 如果依托的是接口，那么创建出来的匿名内部类就默认是这个接口的实现类。\n 2. 匿名内部类的声明必须是在使用new关键字的时候\n    * 匿名内部类的声明及创建对象必须一气呵成，并且之后能反复使用，因为没有名字\n\n【示例】\n\nA是一个类(普通类、抽象类都可以)，依托于A类创建一个匿名内部类对象\n\nmain:\n\nA a = new A(){\n    //实现A中的抽象方法\n    //或者重写A中的普通方法\n};\n\n注:这个大括号里面其实就是这个内部类的代码,只不过是声明该内部类的同时就是要new创建了其对象,\n并且不能反复使用,因为没有名字。\n    \n例如:\nB是一个接口，依托于B接口创建一个匿名内部类对象\n\nB b = new B(){\n\t//实现B中的抽象方法\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 1. 匿名内部类除了依托的类或接口之外，不能指定继承或者实现其他类或接口，同时也不能被其他类所继承，因为没有名字。\n 2. 匿名内部中，我们不能写出其构造器，因为没有名字。\n 3. 匿名内部中，除了重写上面的方法外，一般不会再写其他独有的方法，因为从外部不能直接调用到。(间接是调用到的)\n\npublic interface Work{\n    void doWork();\n}\n\npublic class AnonymousOutterClass{\n    private String name;\n    private static int age;\n    public void say(){}\n    public static void go(){}\n    \n    public void test(){\n        final int i = 90;\n        \n        Work w = new Work(){\n            public void doWork(){\n                System.out.println(AnonymousOutterClass.this.name);\n                System.out.println(AnonymousOutterClass.age);\n                AnonymousOutterClass.this.say();\n                AnonymousOutterClass.go();\n                \n                System.out.println(i);\n            }\n        };\n        w.doWork();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们可以试一下不 用匿名内部类 和 用匿名内部类 实现一个接口中的方法的区别\n\n【不用匿名内部类】\n\npublic class Test {\n    public static void main(String[] args) {\n        // 如果我们需要使用接口中的方法，我们就需要走3步，\n        // 1、实现接口 2、创建实现接口类的实例对象 3、通过对象调用方法\n        //第二步\n        Test02 test = new Test02();\n        //第三步\n        test.method();\n    }\n}\n\n//接口Test1\ninterface Test01{\n    public void method();\n}\n\n//第一步、实现Test01接口\nclass Test02 implements Test01{\n    @Override\n    public void method() {\n        System.out.println("实现了Test接口的方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n【使用匿名内部类】\n\npublic class Test {\n    public static void main(String[] args) {\n\t\t//如果我们需要使用接口中的方法，我们只需要走一步，就是使用匿名内部类，直接将其类的对象创建出来。\n        new Test1(){\n            public void method(){\n                System.out.println("实现了Test接口的方法");\n            }\n        }.method();\n    }\n}\n\ninterface Test1{\n    public void method();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n解析：\n\n其实只要明白一点，new Test1( ){ 实现接口中方法的代码 };\n\nTest1(){...} 这个的作用就是将接口给实现了，只不过这里实现该接口的是一个匿名类，也就是说这个类没名字，只能使用这一次，我们知道了这是一个类， 将其new出来，就能获得一个实现了Test1接口的类的实例对象，通过该实例对象，就能调用该类中的方法了，因为其匿名类是在一个类中实现的，所以叫其匿名内部类。\n\n不要纠结为什么 Test1( ){...} 就相当于实现了Test1接口，这其中的原理等足够强大了，在去学习，不要钻牛角尖，这里就仅仅是需要知道他的作用是什么，做了些什么东西就行。',normalizedContent:'# javase-面向对象\n\n\n# 面向过程&面向对象\n\n语言的进化发展跟生物的进化发展其实是一回事，都是”物以类聚”。相近的感光细胞聚到一起变成了我们的眼睛，相近的嗅觉细胞聚到一起变成了我们的鼻子。\n\n语句多了，我们将完成同样功能的相近的语句，聚到了一块儿，便于我们使用。于是，方法出现了！\n\n变量多了，我们将功能相近的变量组在一起，聚到一起归类，便于我们调用。于是，结构体出现了！\n\n再后来，方法多了，变量多了！结构体不够用了！我们就将功能相近的变量和方法聚到了一起，于是类和对象出现了！\n\n寥寥数语，就深刻的展示了语言的进化历史！其实，都非常自然，”物以类聚”。希望大家能记住这句话。\n\n企业的发展也是”物以类聚”的过程，完成市场推广的人员聚到一起形成了市场部。完成技术开发的人员聚到一起形成了开发部！\n\n面向过程的思维模式\n\n面向过程的思维模式是简单的线性思维，思考问题首先陷入第一步做什么、第二步做什么的细节中。这种思维模式适合处理简单的事情，比如：上厕所。\n\n如果面对复杂的事情，这种思维模式会陷入令人发疯的状态！比如：如何造神舟十号！\n\n面向对象的思维模式\n\n面向对象的思维模式说白了就是分类思维模式。思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。\n\n这样就可以形成很好的协作分工。比如：设计师分了10个类，然后将10个类交给了10个人分别进行详细设计和编码！\n\n显然，面向对象适合处理复杂的问题，适合处理需要多人协作的问题！\n\n如果一个问题需要多人协作一起解决，那么你一定要用面向对象的方式来思考！\n\n对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整 个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。\n\n\n# oop详解\n\n\n# 1、什么是面向对象\n\njava的编程语言是面向对象的，采用这种语言进行编程称为面向对象编程(object-oriented programming, oop)。\n\n面向对象编程的本质就是：以类的方式组织代码，以对象的组织(封装)数据。\n\n抽象(abstract)\n\n忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了 解全部问题，而只是选择其中的一部分，暂时不用关注细节。\n\n> 例如：要设计一个学生成绩管理系统，那么对于学生，只关心他的班级、学号、成绩等，而不用去关心他的 身高、体重这些信息。 抽象是什么？就是将多个物体共同点归纳出来，就是抽出像的部分！\n\n封装(encapsulation)\n\n封装是面向对象的特征之一，是对象和类概念的主要特性。封装是把过程和数据包围起来，对数据的访 问只能通过指定的方式。\n\n在定义一个对象的特性的时候，有必要决定这些特性的可见性，即哪些特性对外部是可见的，哪些特性用于表示内部状态。\n\n通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。\n\n信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。\n\n封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部， 因而可以将应用程序修改带来的影响减少到最低限度。\n\n继承(inheritance)\n\n继承是一种联结类的层次模型，并且允许和支持类的重用，它提供了一种明确表述共性的方法\n\n新类继承了原始类后,新类就继承了原始类的特性，新类称为原始类的派生类(子类)，而原始类称为新类的基类(父类)。\n\n派生类(子类)可以从它的基类(父类)那里继承方法和实例变量，并且派生类(子类)中可以修改或增加新的方法使之更适合特殊的需要继承性很好的解决了软件的可重用性问题。比如说，所有的windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。\n\n多态(polymorphism)\n\n多态性是指允许不同类的对象对同一消息作出响应。\n\n多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n\n相同类域的不同对象,调用相同方法,表现出不同的结果\n\n从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。\n\n从代码运行角度考虑是先有类后有对象。类是对象的模板。\n\n\n# 2、类与对象的关系\n\n类是一种抽象的数据类型,它是对某一类事物整体描述/定义,但是并不能代表某一个具体的事物\n\n> 例如：我们生活中所说的词语：动物、植物、手机、电脑等等。这些也都是抽象的概念，而不是指的某一个 具体的东西。\n\n例如: person类、pet类、car类等，这些类都是用来 描述/定义 某一类具体的事物应该具备的特点和行为\n\n对象是抽象概念的具体实例\n\n> 例如：张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例。能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。\n\n【示例】\n\nstudent s = new student(1,"tom",20);\ns.study();\n\ncar c = new car(1,"bwm",500000);\nc.run();\n\n\n1\n2\n3\n4\n5\n\n\n对象s就是student类的一个实例，对象c就是car类的一个具体实例，能够使用的是具体实例，而不是类。类只是给对象的创建提供了一个参考的模板而已。\n\n但是在java中，没有类就没有对象，然而类又是根据具体的功能需求，进行实际的分析，最终抽象出来的。\n\n\n# 3、对象和引用的关系\n\n引用 "指向" 对象\n\n使用类类型、数组类型、接口类型声明出的变量，都可以指向对象，这种变量就是引用类型变量，简称引用。\n\n在程序中，创建出对象后，直接使用并不方便，所以一般会用一个引用类型的变量去接收这个对象，这个就是所说的引用指向对象。\n\n总结：对象和引用的关系，就如电视机和遥控器，风筝和线的关系一样。\n\n\n# 方法回顾及加深\n\n方法一定是定义在类中的，属于类的成员。\n\n\n# 1、方法的定义\n\n> 格式： 修饰符 返回类型 方法名(参数列表)异常抛出类型{...}\n\n 1. 修饰符\n    \n    public、static、abstract、final等等都是修饰符，一个方法可以有多个修饰符。例如程序入口 main方法，就使用了public static这个俩个修饰符\n    \n    注：如果一个方法或者属性有多个修饰符，这多个修饰符是没有先后顺序的\n\n 2. 返回类型\n    \n    方法执行完如果有要返回的数据，那么就要声明返回数据的类型，如果没有返回的数据，那么返回类型就必须写void\n    \n    只有构造方法(构造器)不写任何返回类型也不写void\n    \n    【示例】\n    \n    public string sayhello(){\n        return "hello";\n    }\n    public int max(int a,int b){\n        return a>b?a:b;\n    }\n    public void print(string msg){\n        system.out.println(msg);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    思考：声明返回类型的方法中一定要出现return语句，那么没有返回类型(void)的方法中，能不能出现 return语句?\n    \n    break和return的区别\n    \n    return 语句的作用\n    \n    > (1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。 (2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。 (3) return后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回 调用函数处。\n    \n    break语句的作用\n    \n    > (1)break在循环体内，强行结束循环的执行，也就是结束整个循环过程，不在判断执行循环的条件是否成立，直接转向循环语句下面的语句。\n    > \n    > (2)当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。\n\n 3. 方法名\n    \n    遵守java中标示符的命名规则即可.\n\n 4. 参数列表\n    \n    根据需求定义,方法可以是无参的,也可以有一个参数,也可以有多个参数\n\n 5. 异常抛出类型\n    \n    如果方法中的代码在执行过程中，可能会出现一些异常情况，那么就可以在方法上把这些异常声明并抛出， 也可以同时声明抛出多个异常，使用逗号隔开即可。\n    \n    public void readfile(string file)throws ioexception{\n    }\n    \n    public void readfile(string file)throws ioexception,classnotfoundexception{\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 2、方法调用\n\n在类中定义了方法，这个方法中的代码并不会执行，当这个方法被调用的时候，方法中的代码才会被一行一 行顺序执行。\n\n 1. 非静态方法\n    \n    没有使用static修饰符修饰的方法，就是非静态方法。\n    \n    调用这种方法的时候，是"一定"要使用对象的调用。因为非静态方法是属于对象的。(非静态属性也是一样的)\n    \n    【例子】\n    \n    > public class student{ public void say(){} }\n    > \n    > main:\n    > \n    > student s = new student();\n    > \n    > s.say();\n\n 2. 静态方法\n    \n    使用static修饰符修饰的方法,就是静态方法。\n    \n    调用这种方法的时候，"可以"使用对象调用，也"可以"使用类来调用，但是推荐使用类进行调用。因为静态方法是属于类的。(静态属性也是一样的)\n    \n    【例子】\n    \n    > public class student{ public static void say(){} }\n    > \n    > main:\n    > \n    > student.say();\n\n 3. 类中方法之间的调用\n    \n    假设同一个类中有俩个方法，a方法和b方法，a和b都是非静态方法，相互之间可以直接调用。\n    \n    public void a(){\n        b();\n    }\n    public void b(){\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    a和b都是静态方法,相互之间可以直接调用\n    \n    public static void a(){\n        b();\n    }\n    public static void b(){\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    a静态方法，b是非静态方法，a方法中不能直接调用b方法，但是b方法中可以直接调用a方法。静态方法不能 调用非静态方法！\n    \n    public static void a(){\n        //b();报错\n    }\n    public void b(){\n        a();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    另外：在同一个类中，静态方法内不能直接访问到类中的非静态属性。\n    \n    总结：类中方法中的调用，两个方法都是静态或者非静态都可以互相调用，当一个方法是静态，一个方 法是非静态的时候，非静态方法可以调用静态方法，反之不能。\n\n\n# 3、调用方法时的传参\n\n1、形参和实参\n\npublic static void test(int a){\n\n}\n\npublic static void main(string[] args) {\n    int x = 1;\n    test(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n参数列表中的a是方法test的形参(形式上的参数) 调用方法时的x是方法test的实参(实际上的参数)\n\n注意：形参的名字和实参的名字都只是一个变量的名字,是可以随便写的,我们并不关心这个名字,而是关 心变量的类型以及变量接收的值。\n\n2、值传递和引用传递\n\n调用方法进行传参时，分为值传递和引用传递两种。\n\n如果参数的类型是基本数据类型，那么就是值传递。\n\n如果参数的类型是引用数据类型，那么就是引用传递。\n\n值传递是实参把自己变量本身存的简单数值赋值给形参。 引用传递是实参把自己变量本身存的对象内存地址值赋值给形参。\n\n所以值传递和引用传递本质上是一回事，只不过传递的东西的意义不同而已。\n\n【示例：值传递】\n\npublic static void changenum(int a) {\n    a = 10;\n}\n\npublic static void main(string[] args) {\n    int a = 1;\n    system.out.println("before: a = " + a); //1\n    changenum(a);\n    system.out.println("after: a = " + a); //1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【示例：引用传递】\n\npublic class test {\n    public static void changename(student s) {\n        s.name = "tom";\n    }\n\n    public static void main(string[] args) {\n        student s = new student();\n        system.out.println("before: name = " + s.name); //null\n        changename(s);\n        system.out.println("after: name = " + s.name); //tom\n    }\n\n    static class student {\n        string name;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 4、this关键字\n\n在类中，可以使用this关键字表示一些特殊的作用。\n\n1、this在类中的作用\n\n区别成员变量和局部变量\n\npublic class student{\n    private string name;\n    public void setname(string name){\n        //this.name表示类中的属性name\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用类中的其他方法\n\npublic class student{\n    private string name;\n    public void setname(string name){\n        this.name = name;\n    }\n    public void print(){\n        //表示调用当前类中的setname方法\n        this.setname("tom");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注：默认情况下，setname("tom")和this.setname("tom")的效果是一样的。\n\n调用类中的其他构造器\n\npublic class student{\n    private string name;\n    public student(){\n        //调用一个参数的构造器,并且参数的类型是string\n        this("tom");\n    }\n    public student(string name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注：this的这种用法，只能在构造器中使用。普通的方法是不能用的。并且这局调用的代码只能出现在构造器中的第一句。\n\n【示例】\n\npublic class student{\n    private string name;\n    //编译报错,因为this("tom")不是构造器中的第一句代码.\n    public student(){\n        system.out.println("hello");\n        this("tom");\n    }\n    public student(string name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2、this关键字在类中的意义\n\nthis在类中表示当前类将来创建出的对象。\n\n【例子】\n\npublic class student {\n    private string name;\n\n    public student() {\n        system.out.println("this = " + this);\n    }\n\n    public static void main(string[] args) {\n        student s = new student();\n        system.out.println("s = " + s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行后看结果可知，this和s打印的结果是一样的，那么其实也就是变量s是从对象的外部执行对象，而this是在对象的内部执行对象本身。\n\n这样也就能理解为什么this.name代表的是成员变量，this.setname("tom")代表的是调用成员方法。因为这俩句代码从本质上讲，和在对象外部使用变量s来调用是一样的，s.name和s.setname("tom")\n\n【this和s打印出来的内存地址是一样的，使用==比较的结果为true。】\n\npublic class student{\n    public student getstudent(){\n        return this;\n    }\n    public static void main(string[] args) {\n        student s1 = new student();\n        student s2 = s1.getstudent();\n        system.out.println(s1 == s2);//true\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【调用类中的this，s1和s2不相等】\n\npublic class student{\n    private string name;\n    public void test(){\n        system.out.println(this);\n    }\n    public static void main(string[] args) {\n        student s1 = new student();\n        student s2 = new student();\n        s1.test();\n        s2.test();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注：这句话是要这么来描述的，s1对象中的this和s1相等，s2对象中的this和s2相等，因为类是模板，模板中写的this并不是只有一个，每个对象中都有一个属于自己的this，就是每个对象中都一个属于自己的name属性一样。\n\n\n# 创建与初始化对象\n\n使用new关键字创建对象\n\n使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化，以及对类中构造器的调用。\n\n那么对main方法中的以下代码：student s = new student();\n\n1） 为对象分配内存空间，将对象的实例变量自动初始化默认值为0/false/null。(实例变量的隐式赋值)\n\n2） 如果代码中实例变量有显式赋值，那么就将之前的默认值覆盖掉。(之后可以通过例子看到这个现象)\n\n例如：显式赋值，private string name = "tom";\n\n\n3） 调用构造器\n\n4） 把对象内存地址值赋值给变量。(=号赋值操作)\n\n\n# 构造器\n\n类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点:\n\n 1. 必须和类的名字相同\n 2. 必须没有返回类型,也不能写void\n\n构造器的作用:\n\n 1. 使用new创建对象的时候必须使用类的构造器\n 2. 构造器中的代码执行后，可以给对象中的属性初始化赋值\n\n【演示】\n\npublic class student{\n    private string name;\n    \n    public student(){\n        name = "tom";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n构造器重载\n\n除了无参构造器之外，很多时候我们还会使用有参构造器，在创建对象时候可以给属性赋值。\n\n【例子】\n\npublic class student{\n    private string name;\n    public student(){\n        name = "tom";\n    }\n    public student(string name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n构造器之间的调用\n\n使用this关键字，在一个构造器中可以调用另一个构造器的代码。\n\n注意：this的这种用法不会产生新的对象，只是调用了构造器中的代码而已。一般情况下只有使用new关键字才会创建新对象。\n\n【演示】\n\npublic class student{\n    private string name;\n    public student(){\n        this();\n    }\n    public student(string name){\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n默认构造器\n\n在java中，即使我们在编写类的时候没有写构造器，那么在编译之后也会自动的添加一个无参构造器，这个无参构造器也被称为默认的构造器。\n\n【示例】\n\npublic class student{\n    \n}\n\nmain:\n//编译通过,因为有无参构造器\nstudent s = new student();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是,如果我们手动的编写了一个构造器,那么编译后就不会添加任何构造器了\n\n【示例】\n\npublic class student{\n    private string name;\n    public student(string name){\n        this.name = name;\n    }\n}\n\nmain:\n//编译报错,因为没有无参构造器\nstudent s = new student();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 内存分析\n\njava程序运行的内存分析\n\n栈 stack：\n\n 1. 每个线程私有，不能实现线程间的共享！\n 2. 局部变量放置于栈中。\n 3. 栈是由系统自动分配，速度快！栈是一个连续的内存空间！\n\n堆 heap：\n\n 1. 放置new出来的对象！\n 2. 堆是一个不连续的内存空间，分配灵活，速度慢！\n\n方法区(也是堆)：\n\n 1. 被所有线程共享！\n 2. 用来存放程序中永远是不变或唯一的内容。（类代码信息、静态变量、字符串常量）\n\n\n\n注意：本次内存分析，我们的主要目的是让大家了解基本的内存概念。类加载器、class对象这些更加详细的内容，我们将在后面专门讲反射的课程里面讲。\n\n引用类型的概念\n\n 1. java中，除了基本数据类型之外的其他类型称之为引用类型。\n 2. java中的对象是通过引用来操作的。(引用：reference)说白了，引用指的就是对象的地址！\n\n属性（field，或者叫成员变量）\n\n 1. 属性用于定义该类或该类对象包含的数据或者说静态属性。\n\n 2. 属性作用范围是整个类体。\n\n 3. 属性的默认初始化：\n\n在定义成员变量时可以对其初始化，如果不对其初始化，java使用默认的值对其初始化(数值：0,0.0 char：u0000, boolean：false, 所有引用类型：null)\n\n 4. 属性定义格式：\n    \n    > [修饰符] 属性类型 属性名 = [默认值]\n\n类的方法\n\n方法是类和对象动态行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序有一个个函数调用组成；面向对象中，整个程序的基本单位是类，方法是从属于类或对象的。\n\n方法定义格式：\n\n[修饰符] 方法返回值类型 方法名(形参列表) {\n    // n条语句\n}\n\n\n1\n2\n3\n\n\njava对象的创建和使用\n\n * 必须使用 new 关键字创建对象。\n   \n   person person= new person ();\n\n * 使用对象（引用）.成员变量来引用对象的成员变量。\n   \n   person.age\n\n * 使用对象（引用）. 方法（参数列表）来调用对象的方法\n   \n   person.setage(18)\n\n类中就是：静态的数据 动态的行为\n\n学习完类与对象终于认识到什么是类，什么是对象了。\n\n接下来要看的就是java的三大特征：继承、封 装、多态。\n\n\n# 封装\n\n我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗？有必要碰碰显像管吗？\n\n制造厂家为了方便我们使用电视，把复杂的内部细节全部封装起来，只给我们暴露简单的接口，比如： 电源开关。需要让用户知道的暴露出来，不需要让用户了解的全部隐藏起来。这就是封装。\n\n白话：该露的露，该藏的藏\n\n专业：我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。\n\n封装（数据的隐藏）\n\n在定义一个对象的特性的时候，有必要决定这些特性的可见性，即哪些特性对外部是可见的，哪些特性用于表示内部状态。\n\n通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。\n\n\n# 1、封装的步骤\n\n 1. 使用private 修饰需要封装的成员变量。\n\n 2. 提供一个公开的方法设置或者访问私有的属性\n    \n    设置 通过set方法，命名格式： set属性名（）; 属性的首字母要大写\n    \n    访问 通过get方法，命名格式： get属性名（）; 属性的首字母要大写\n\n【演示】\n\n//对象能在类的外部"直接"访问\npublic class student{\n    public string name;\n    public void println(){\n        system.out.println(this.name);\n    }\n}\npublic class test{\n    public static void main(string[] args){\n        student s = new student();\n        s.name = "tom";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在类中一般不会把数据直接暴露在外部的，而使用private(私有)关键字把数据隐藏起来\n\n【演示】\n\npublic class student{\n    private string name;\n}\npublic class test{\n    public static void main(string[] args){\n        student s = new student();\n        //编译报错,在类的外部不能直接访问类中的私有成员\n        s.name = "tom";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果在类的外部需要访问这些私有属性,那么可以在类中提供对于的get和set方法,以便让用户在类的外部 可以间接的访问到私有属性\n\n【示例】\n\n//set负责给属性赋值\n//get负责返回属性的值\npublic class student{\n    private string name;\n    public void setname(string name){\n    this.name = name;\n\t}\n\tpublic string getname(){\n        return this.name;\n\t}\n}\npublic class test{\n    public static void main(string[] args){\n        student s = new student();\n        s.setname("tom");\n        system.out.println(s.getname());\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2、作用和意义\n\n 1. 提高程序的安全性，保护数据。\n 2. 隐藏代码的实现细节\n 3. 统一用户的调用接口\n 4. 提高系统的可维护性\n 5. 便于调用者调用。\n\n良好的封装，便于修改内部代码，提高可维护性。\n\n良好的封装，可进行数据完整性检测，保证数据的有效性。\n\n\n# 3、方法重载\n\n类中有多个方法，有着相同的方法名，但是方法的参数各不相同,这种情况被称为方法的重载。方法的重载可以提供方法调用的灵活性。\n\n思考：helloworld中的system.out.println()方法，为什么可以把不同类型的参数传给这个方法?\n\n【演示：查看println方法的重载】 idea中ctrl+左键点击println\n\n例如:\n\npublic class test{\n    public void test(string str){\n        \n    }\n    public void test(int a){\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n方法重载必须满足以下条件\n\n 1. 方法名必须相同\n\n 2. 参数列表必须不同(参数的类型、个数、顺序的不同)\n    \n    public void test(strig str){}\n    public void test(int a){}\n    \n    public void test(strig str,double d){}\n    public void test(strig str){}\n    \n    public void test(strig str,double d){}\n    public void test(double d,strig str){}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 方法的返回值可以不同，也可以相同。\n\n在java中，判断一个类中的俩个方法是否相同，主要参考俩个方面：方法名字和参数列表\n\n\n# 继承\n\n继承：extands\n\n现实世界中的继承无处不在。比如：\n\n动物：哺乳动物、爬行动物\n\n哺乳动物：灵长目、鲸目等。\n\n继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\n\n为什么需要继承？继承的作用？\n\n第一好处：继承的本质在于抽象。类是对对象的抽象，继承是对某一批类的抽象。\n\n第二好处：为了提高代码的复用性。\n\nextands的意思是“扩展”。子类是父类的扩展。\n\n【注】java中类只有单继承，没有多继承！ 接口可以多继承！\n\n\n# 1、继承\n\n 1. 继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等。\n\n 2. 继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。子类继承父类，使用关键字extends来表示。\n    \n    public class student extends person{\n    }\n    \n    \n    1\n    2\n    \n\n 3. 子类和父类之间，从意义上讲应该具有"is a"的关系。\n    \n    > student is a person\n    > \n    > dog is a animal\n\n 4. 类和类之间的继承是单继承\n    \n    一个子类只能"直接"继承一个父类,就像是一个人只能有一个亲生父亲 一个父类可以被多子类继承,就像一个父亲可以有多个孩子\n    \n    注:java中接口和接口之间,有可以继承,并且是多继承。\n\n 5. 父类中的属性和方法可以被子类继承\n    \n    子类中继承了父类中的属性和方法后,在子类中能不能直接使用这些属性和方法,是和这些属性和方法原有 的修饰符(public protected default private)相关的。\n    \n    例如：\n    \n    父类中的属性和方法使用public修饰，在子类中继承后"可以直接"使用 父类中的属性和方法使用private修饰，在子类中继承后"不可以直接"使用\n    \n    注：具体细则在修饰符部分详细说明\n    \n    父类中的构造器是不能被子类继承的，但是子类的构造器中，会隐式的调用父类中的无参构造器（默认使用 super关键字）。\n    \n    注:具体细节在super关键字部分详细说明\n\n\n# 2、object类\n\njava中的每一个类都是"直接" 或者 "间接"的继承了object类。所以每一个对象都和object类有"is a"的关系。从api文档中，可以看到任何一个类最上层的父类都是object。(object类本身除外)anyclass is a object。\n\n> system.out.println(任何对象 instanceof object);\n> \n> 输出结果:true 注:任何对象也包含数组对象\n\n例如:\n\n//编译后,person类会默认继承object\npublic class person{}\n\n//student是间接的继承了object\npublic class student extends person{}\n\n\n1\n2\n3\n4\n5\n\n\n在object类中，提供了一些方法被子类继承，那么就意味着，在java中，任何一个对象都可以调用这些被继承过来的方法。(因为object是所以类的父类)\n\n例如：tostring方法、equals方法、getclass方法等\n\n\n# 3、super关键字\n\n子类继承父类之后，在子类中可以使用this来表示访问或调用子类中的属性或方法，使用super就表示访问或调用父类中的属性和方法。\n\n1、super的使用\n\n【访问父类中的属性】\n\npublic class person{\n    protected string name = "zs";\n}\n\n\n1\n2\n3\n\n\npublic class student extends person{\n    private string name = "lisi";\n    public void tes(string name){\n        system.out.println(name);\n        system.out.println(this.name);\n        system.out.println(super.name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【调用父类中的方法】\n\npublic class person{\n    public void print(){\n        system.out.println("person");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class student extends person{\n    public void print(){\n        system.out.println("student");\n    }\n    public void test(){\n        print();\n        this.print();\n        super.print();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n【调用父类中的构造器】\n\npublic class person{\n}\n\npublic class student extends person{\n    //编译通过,子类构造器中会隐式的调用父类的无参构造器\n    //super();\n    public student(){\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n父类没有无参构造\n\npublic class person{\n    protected string name;\n    public person(string name){\n        this.name = name;\n    }\n}\npublic class student extends person{\n    //编译报错,子类构造器中会隐式的调用父类的无参构造器,但是父类中没有无参构造器\n    //super();\n    public student(){\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【显式的调用父类的有参构造器】\n\npublic class person{\n    protected string name;\n    public person(string name){\n    this.name = name;\n\t}\n}\n\npublic class student extends person{\n    //编译通过,子类构造器中显式的调用父类的有参构造器\n    public student(){\n        super("tom");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注：不管是显式还是隐式的父类的构造器，super语句一定要出现在子类构造器中第一行代码。所以this和 super不可能同时使用它们调用构造器的功能，因为它们都要出现在第一行代码位置。\n\n【例子】\n\npublic class person{\n    protected string name;\n    public person(string name){\n        this.name = name;\n    }\n}\n\npublic class student extends person{\n    //编译报错,super调用构造器的语句不是第一行代码\n    public student(){\n        system.out.println("student");\n        super("tom");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n【例子】\n\npublic class person{\n    protected string name;\n    public person(string name){\n        this.name = name;\n    }\n}\n//编译通过\npublic class student extends person{\n    private int age;\n    public student(){\n        this(20);\n    }\n    public student(int age){\n        super("tom");\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nsuper使用的注意的地方\n\n * 用super调用父类构造方法，必须是构造方法中的第一个语句。\n * super只能出现在子类的方法或者构造方法中\n * super 和 this 不能够同时调用构造方法。（因为this也是在构造方法的第一个语句）\n\nsuper 和 this 的区别\n\n 1. 代表的事物不一样：\n    \n    this：代表所属方法的调用者对象。\n    \n    super：代表父类对象的引用空间。\n\n 2. 使用前提不一致：\n    \n    this：在非继承的条件下也可以使用。\n    \n    super：只能在继承的条件下才能使用。\n\n 3. 调用构造方法：\n    \n    this：调用本类的构造方法。\n    \n    super：调用的父类的构造方法\n\n\n# 4、方法重写\n\n方法的重写（override）\n\n * 方法重写只存在于子类和父类(包括直接父类和间接父类)之间。在同一个类中方法只能被重载，不能被重写\n * 静态方法不能重写\n   1. 父类的静态方法不能被子类重写为非静态方法 //编译出错\n   2. 父类的非静态方法不能被子类重写为静态方法；//编译出错\n   3. 子类可以定义与父类的静态方法同名的静态方法(但是这个不是覆盖)\n\n【例子】\n\n> a类继承b类 a和b中都一个相同的静态方法test\n> \n> b a = new a(); a.test();//调用到的是b类中的静态方法test\n> \n> a a = new a(); a.test();//调用到的是a类中的静态方法test\n> \n> 可以看出静态方法的调用只和变量声明的类型相关 这个和非静态方法的重写之后的效果完全不同\n\n私有方法不能被子类重写，子类继承父类后,是不能直接访问父类中的私有方法的,那么就更谈不上重写了\n\npublic class person{\n    private void run(){}\n    \n}\n\n//编译通过,但这不是重写,只是俩个类中分别有自己的私有方法\npublic class student extends person{\n    private void run(){}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n重写的语法\n\n 1. 方法名必须相同\n\n 2. 参数列表必须相同\n\n 3. 访问控制修饰符可以被扩大，但是不能被缩小： public protected default private\n\n 4. 抛出异常类型的范围可以被缩小,但是不能被扩大\n    \n    classnotfoundexception ---\x3e exception（不能扩大）\n\n 5. 返回类型可以相同，也可以不同。\n    \n    如果不同的话，子类重写后的方法返回类型必须是父类方法返回类型的子类型。\n    \n    例如：父类方法的返回类型是person，子类重写后的返回类可以是person也可以是person的子类型\n\n注：一般情况下，重写的方法会和父类中的方法的声明完全保持一致，只有方法的实现不同。(也就是大括号中代码不一样)\n\npublic class person{\n    public void run(){}\n    protected object test()throws exception{\n        return null;\n    }\n}\n\n//编译通过,子类继承父类,重写了run和test方法.\npublic class student extends person{\n    public void run(){}\n    public string test(){\n        return "";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为什么要重写？\n\n子类继承父类，继承了父类中的方法，但是父类中的方法并不一定能满足子类中的功能需要，所以子类中需要把方法进行重写。\n\n总结：\n\n 1. 方法重写的时候，必须存在继承关系。\n 2. 方法重写的时候，方法名和形式参数必须跟父类是一致的。\n 3. 方法重写的时候，子类的权限修饰符必须要大于或者等于父类的权限修饰符。( private < protected < public，friendly < public )\n 4. 方法重写的时候，子类的返回值类型必须小于或者等于父类的返回值类型。( 子类 < 父类 ) 数据类型没有明确的上下级关系\n 5. 方法重写的时候，子类的异常类型要小于或者等于父类的异常类型。\n\n\n# 多态\n\n\n# 1、认识多态\n\n多态性是oop中的一个重要特性，主要是用来实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。\n\n多态可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，从而实现更加灵活的编程，提高系统的可扩展性。\n\n允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。\n\n相同类域的不同对象,调用相同的方法,执行结果是不同的\n\n 1. 一个对象的实际类型是确定的\n    \n    例如: new student(); new person();等\n\n 2. 可以指向对象的引用的类型有很多\n    \n    一个对象的实现类型虽然是确定的，但是这个对象所属的类型可能有很多种。\n    \n    例如：student继承了person类\n    \n    student s1 = new student();\n    person s2 = new student();\n    object s3 = new student();\n    \n    \n    1\n    2\n    3\n    \n    \n    因为person和object都是student的父类型\n    \n    \n\n注：一个对象的实际类型是确定，但是可以指向这个对象的引用的类型，却是可以是这对象实际类型的任意父类型。\n\n一个父类引用可以指向它的任何一个子类对象\n\n例如：\n\nobject o = new anyclass();\nperson p = null;\np = new student();\np = new teacher();\np = new person();\n\n\n1\n2\n3\n4\n5\n\n\n多态中的方法调用\n\npublic class person{\n    public void run(){}\n}\n\npublic class student extends person{\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用到的run方法,是student从person继承过来的run方法\n\nperson p = new student();\np.run();\n\n\n1\n2\n\n\n例如：\n\npublic class person{\n    public void run(){}\n}\n\npublic class student extends person{\n    public void run(){\n    //重写run方法\n    }\n}\n\n//调用到的run方法,是student中重写的run方法\npublic static void main(string[] args) {\n    person p = new student();\n    p.run();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注：子类继承父类,调用a方法，如果a方法在子类中没有重写,那么就是调用的是子类继承父类的a方法, 如果重写了,那么调用的就是重写之后的方法。\n\n子类中独有方法的调用\n\npublic class person{\n    public void run(){}\n}\n\npublic class student extends person{\n    public void test(){\n    }\n}\n\nmain:\nperson p = new student();\n//调用到继承的run方法\np.run();\n\n//编译报错,因为编译器检查变量p的类型是person,但是在person类中并没有发现test方法,所以编译报错.\np.test();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注：一个变量x，调用一个方法test，编译器是否能让其编译通过，主要是看声明变量x的类型中有没有定义 test方法，如果有则编译通过，如果没有则编译报错。而不是看x所指向的对象中有没有test方法。\n\n原理：编译看左边，运行不一定看右边。\n\n> 编译看左边的意思：java 编译器在编译的时候会检测引用类型中含有指定的成员，如果没有就会报错。 子类的成员是特有的，父类的没有的，所以他是找不到的。\n> \n> 所以看左边，person 中没有test()方法，于是编译报错\n\n子类引用和父类引用指向对象的区别\n\nstudent s = new student();\nperson p = new student();\n\n\n1\n2\n\n\n变量s能调用的方法是student中有的方法(包括继承过来的)，变量p能调用的方法是person中有的方法(包括继承过来的)。\n\n但是变量p是父类型的，p不仅可以指向student对象，还可以指向teacher类型对象等，但是变量s只能指 studnet类型对象，及student子类型对象。变量p能指向对象的范围是比变量s大的。\n\nobject类型的变量o，能指向所有对象，它的范围最大，但是使用变量o能调用到的方法也是最少的，只能调用到object中的声明的方法，因为变量o声明的类型就是object。\n\n注：java中的方法调用,是运行时动态和对象绑定的,不到运行的时候,是不知道到底哪个方法被调用的。\n\n多态的好处与弊端\n\n * 好处：提高了程序的拓展性\n   \n   具体表现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作\n\n * 弊端：不能使用子类的特有功能\n\n\n# 2、重写、重载和多态的关系\n\n重载是编译时多态\n\n> 调用重载的方法,在编译期间就要确定调用的方法是谁,如果不能确定则编译报错\n\n重写是运行时多态\n\n> 调用重写的方法，在运行期间才能确定这个方法到底是哪个对象中的。这个取决于调用方法的引用，在运行 期间所指向的对象是谁，这个引用指向哪个对象那么调用的就是哪个对象中的方法。(java中的方法调用，是运行时动态和对象绑定的)\n\n\n# 3、多态的注意事项\n\n 1. 多态是方法的多态，属性没有多态性。\n 2. 编写程序时，如果想调用运行时类型的方法，只能进行类型转换。不然通不过编译器的检查。但是如果两个没有关联的类进行强制转换，会报：classcastexception。 比如：本来是狗，我把它转成猫。就会报这个异常。\n 3. 多态的存在要有3个必要条件：要有继承，要有方法重写，父类引用指向子类对象\n\n\n# 4、多态存在的条件\n\n * 有继承关系\n * 子类重写父类方法\n * 父类引用指向子类对象\n\n补充一下第二点，既然多态存在必须要有“子类重写父类方法”这一条件，那么以下三种类型的方法是没有办法表现出多态特性的（因为不能被重写）：\n\n 1. static方法，因为被static修饰的方法是属于类的，而不是属于实例的\n 2. final方法，因为被final修饰的方法无法被子类重写\n 3. private方法和protected方法，前者是因为被private修饰的方法对子类不可见，后者是因为尽管被 protected修饰的方法可以被子类见到，也可以被子类重写，但是它是无法被外部所引用的，一个不能被外部引用的方法，怎么能谈多态呢\n\n\n# 5、方法绑定(method binding)\n\n执行调用方法时，系统根据相关信息，能够执行内存地址中代表该方法的代码。分为静态绑定和动态绑定。\n\n静态绑定：\n\n在编译期完成，可以提高代码执行速度。\n\n动态绑定：\n\n通过对象调用的方法，采用动态绑定机制。这虽然让我们编程灵活，但是降低了代码的执行速度。这也是java比c/c++速度慢的主要因素之一。java中除了final类、final方、static方法，所有方法都是jvm在运行期才进行动态绑定的。\n\n多态：如果编译时类型和运行时类型不一致，就会造成多态。\n\n\n# 6、instanceof和类型转换\n\n1、instanceof\n\n三个不同java文件\n\npublic class person{\n    public void run(){}\n}\n\npublic class student extends person{\n}\n\npublic class teacher extends person{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nmain：方法下\n\nobject o = new student();\nsystem.out.println(o instanceof student);//true\nsystem.out.println(o instanceof person);//true\nsystem.out.println(o instanceof object);//true\nsystem.out.println(o instanceof teacher);//false\nsystem.out.println(o instanceof string);//false\n\n\n1\n2\n3\n4\n5\n6\n\n\nperson o = new student();\nsystem.out.println(o instanceof student);//true\nsystem.out.println(o instanceof person);//true\nsystem.out.println(o instanceof object);//true\nsystem.out.println(o instanceof teacher);//false\n//编译报错\nsystem.out.println(o instanceof string);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nstudent o = new student();\nsystem.out.println(o instanceof student);//true\nsystem.out.println(o instanceof person);//true\nsystem.out.println(o instanceof object);//true\n//编译报错\nsystem.out.println(o instanceof teacher);\n//编译报错\nsystem.out.println(o instanceof string);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> system.out.println(x instanceof y);\n\n【分析1】\n\n该代码能否编译通过，主要是看声明变量x的类型和y是否存在子父类的关系。有"子父类关"系就编译通过，没有子父类关系就是编译报错。\n\n之后学习到的接口类型和这个是有点区别的。\n\n【分析2】\n\n输出结果是true还是false,主要是看变量x所指向的对象实际类型是不是y类型的"子类型".\n\nobject o = new person();\nsystem.out.println(o instanceof student);//false\nsystem.out.println(o instanceof person);//true\nsystem.out.println(o instanceof object);//true\nsystem.out.println(o instanceof teacher);//false\nsystem.out.println(o instanceof string);//false\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、类型转换\n\npublic class person{\n    public void run(){}\n}\n\npublic class student extends person{\n    public void go(){}\n}\n\npublic class teacher extends person{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n为什么要类型转换\n\n//编译报错,因为p声明的类型person中没有go方法\nperson p = new student();\np.go();\n\n//需要把变量p的类型进行转换\nperson p = new student();\nstudent s = (student)p;\ns.go();\n\n//或者\n//注意这种形式前面必须要俩个小括号\nperson p = new student();\n((student)p).go();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n类型转换中的问题\n\n//编译通过 运行没问题\nobject o = new student();\nperson p = (person)o;\n\n//编译通过 运行没问题\nobject o = new student();\nstudent s = (student)o;\n\n//编译通过,运行报错\nobject o = new teacher();\nstudent s = (student)o;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n即: x x = (x)o;\n\n运行是否报错，主要是变量o所指向的对象实现类型，是不是x类型的子类型，如果不是则运行就会报错。\n\n【总结】\n\n 1. 父类引用可以指向子类对象，子类引用不能指向父类对象。\n\n 2. 把子类对象直接赋给父类引用叫向上转型（upcasting），不用强制转型。\n    \n    如father father = new son();\n\n 3. 把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。\n    \n    如father就是一个指向子类对象的父类引用，把father赋给子类引用son\n    \n    即son son =（son） father；\n    \n    其中father前面的（son）必须添加，进行强制转换。\n\n 4. upcasting 会丢失子类特有的方法，但是子类overriding 父类的方法，子类方法有效\n\n 5. 向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了java的抽象编程思想。\n\n\n# 修饰符\n\n\n# 1、static修饰符\n\n1、static变量\n\n在类中,使用static修饰的成员变量,就是静态变量,反之为非静态变量。\n\n静态变量和非静态变量的区别\n\n静态变量属于类的，"可以"使用类名来访问，非静态变量是属于对象的，"必须"使用对象来访问。\n\npublic class student{\n    private static int age;\n    private double score;\n    public static void main(string[] args) {\n        student s = new student();\n        //推荐使用类名访问静态成员\n        system.out.println(student.age);\n        system.out.println(s.age);\n        \n        system.out.println(s.score);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n静态变量对于类而言在内存中只有一个，能被类的所有实例所共享。实例变量对于类的每个实例都有一份, 它们之间互不影响。（在基础语法中粗略解释过静态变量）\n\npublic class student {\n    private static int count;\n    private int num;\n\n    public student() {\n        count++;\n        num++;\n    }\n\n    public static void main(string[] args) {\n        student s1 = new student();\n        student s2 = new student();\n        student s3 = new student();\n        student s4 = new student();\n        //因为还是在类中,所以可以直接访问私有属性\n        system.out.println(s1.num);//1\n        system.out.println(s2.num);\n        system.out.println(s3.num);\n        system.out.println(s4.num);\n        system.out.println(student.count);\n        \n        system.out.println(s1.count);//4\n        system.out.println(s2.count);\n        system.out.println(s3.count);\n        system.out.println(s4.count);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在加载类的过程中为静态变量分配内存，实例变量在创建对象时分配内存，所以静态变量可以使用类名来直接访问，而不需要使用对象来访问。\n\n2、static方法\n\n在类中，使用static修饰的成员方法，就是静态方法，反之为非静态方法。\n\n静态方法和非静态方法的区别\n\n> 静态方法数属于类的，"可以"使用类名来调用，非静态方法是属于对象的，"必须"使用对象来调用。\n\n静态方法"不可以"直接访问类中的非静态变量和非静态方法，但是"可以"直接访问类中的静态变量和静态方法\n\n注意：this和super在类中属于非静态的变量.(静态方法中不能使用)\n\npublic class student {\n    private static int count;\n    private int num;\n    public void run(){}\n    public static void go(){}\n    public static void test(){\n        //编译通过\n        system.out.println(count);\n        go();\n        \n        //编译报错\n        system.out.println(num);\n        run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n非静态方法"可以"直接访问类中的非静态变量和非静态方法，也"可以"直接访问类中的静态变量和静态方法\n\npublic class student {\n    private static int count;\n    private int num;\n\n    public void run() {\n    }\n\n    public static void go() {\n    }\n    public void test() {\n        //编译通过\n        system.out.println(count);\n        go();\n        //编译通过\n        system.out.println(num);\n        run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n思考：为什么静态方法和非静态方法不能直接相互访问？ 加载顺序的问题！\n\n父类的静态方法可以被子类继承，但是不能被子类重写\n\npublic class person {\n    public static void method() {}\n}\n\n//编译报错\npublic class student extends person {\n    public void method(){}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npublic class person {\n    public static void test() {\n        system.out.println("person");\n    }\n}\n//编译通过,但不是重写\npublic class student extends person {\n    public static void test(){\n        system.out.println("student");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n//main:\nperosn p = new student();\np.test();//输出person\np = new person();\np.test();//输出perosn\n\n\n1\n2\n3\n4\n5\n\n\n父类的非静态方法不能被子类重写为静态方法 ；\n\npublic class person {\n    public void test() {\n        system.out.println("person");\n    }\n}\n//编译报错\npublic class student extends person {\n    public static void test(){\n        system.out.println("student");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3、代码块和静态代码块\n\n【类中可以编写代码块和静态代码块】\n\npublic class person {\n    {\n        //代码块(匿名代码块)\n    }\n    static{\n        //静态代码块\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【匿名代码块和静态代码块的执行】\n\n因为没有名字,在程序并不能主动调用这些代码块。\n\n匿名代码块是在创建对象的时候自动执行的，并且在构造器执行之前，在静态代码块之后。同时匿名代码块在每次创建对象的时候都会自动执行。\n\n静态代码块是在类加载完成之后就自动执行，并且只执行一次。\n\n注：每个类在第一次被使用的时候就会被加载，并且一般只会加载一次。\n\npublic class student {\n    {\n        system.out.println("匿名代码块");\n    }\n    \n    static{\n        system.out.println("静态代码块");\n    }\n    \n    public student(){\n        system.out.println("构造器");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n//main:\nstudent s1 = new student();\nstudent s2 = new student();\nstudent s3 = new student();\n\n\n1\n2\n3\n4\n\n\n输出：\n\n> 静态代码块 匿名代码块 构造器\n> \n> 匿名代码块 构造器\n> \n> 匿名代码块 构造器\n\n【匿名代码块和静态代码块的作用】\n\n匿名代码块的作用是给对象的成员变量初始化赋值，但是因为构造器也能完成这项工作，所以匿名代码块使用的并不多。\n\n静态代码块的作用是给类中的静态成员变量初始化赋值。\n\npublic class person {\n    public static string name;\n    static{\n        name = "tom";\n    }\n    public person(){\n        name = "zs";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> main: system.out.println( person.name ); //tom\n\n注：在构造器中给静态变量赋值，并不能保证能赋值成功，因为构造器是在创建对象的时候才指向，但是静态变量可以不创建对象而直接使用类名来访问。\n\n4、创建和初始化对象的过程\n\nstudent s = new student();\n\n\n1\n\n\n【student类之前没有进行类加载的过程】\n\n 1. 类加载，同时初始化类中静态的属性\n 2. 执行静态代码块\n 3. 分配内存空间，同时初始化非静态的属性(赋默认值,0/false/null)\n 4. 调用student的父类构造器\n 5. 对student中的属性进行显示赋值(如果有的话)\n 6. 执行匿名代码块\n 7. 执行构造器\n 8. 返回内存地址\n\n注：子类中非静态属性的显示赋值是在父类构造器执行完之后和子类中的匿名代码块执行之前的时候\n\npublic class person{\n    private string name = "zs";\n    public person() {\n        system.out.println("person构造器");\n        print();\n    }\n    public void print(){\n        system.out.println("person print方法: name = "+name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\npublic class student extends person{\n    private string name = "tom";\n    {\n        system.out.println("student匿名代码块");\n    }\n    static{\n        system.out.println("student静态代码块");\n    }\n    public student(){\n        system.out.println("student构造器");\n    }\n    public void print(){\n        system.out.println("student print方法: name = "+name);\n    }\n    public static void main(string[] args) {\n        new student();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输出：\n\n> student静态代码块 person构造器 student print方法: name = null student匿名代码块 student构造器\n\nstudent s = new student();\n//student类之前已经进行了类加载\n//1.分配内存空间,同时初始化非静态的属性(赋默认值,0/false/null)\n//2.调用student的父类构造器\n//3.对student中的属性进行显示赋值(如果有的话)\n//4.执行匿名代码块\n//5.执行构造器\n//6.返回内存地址\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n5、静态导入\n\n静态导包就是java包的静态导入，用import static代替import静态导入包是jdk1.5中的新特性。\n\n意思是导入这个类里的静态方法。\n\n好处：这种方法的好处就是可以简化一些操作，例如打印操作system.out.println(…);就可以将其写入一 个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便。\n\nimport static java.lang.math.random;\nimport static java.lang.math.pi;\n\npublic class test {\n    public static void main(string[] args) {\n        //之前是需要math.random()调用的\n        system.out.println(random());\n        system.out.println(pi);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2、final修饰符\n\n1、修饰类\n\n用final修饰的类不能被继承，没有子类\n\n例如：我们是无法写一个类去继承string类，然后对string类型扩展的。因为api中已经被string类定义为final\n\n我们也可以定义final修饰的类:\n\npublic final class action{\n    \n}\n\n//编译报错\npublic class go extends action{\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n2、修饰方法\n\n用final修饰的方法可以被继承，但是不能被子类的重写。\n\n例如：每个类都是object类的子类，继承了object中的众多方法，在子类中可以重写tostring方法、equals方法等，但是不能重写getclass方法、wait方法等，因为这些方法都是使用fianl修饰的。\n\n我们也可以定义final修饰的方法：\n\npublic class person{\n    public final void print(){}\n}\n\n//编译报错\npublic class student extends person{\n    public void print(){\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n3、修饰变量\n\n用final修饰的变量表示常量，只能被赋一次值。使用final修饰的变量也就成了常量了，因为值不会再变了。\n\n【修饰局部变量】\n\npublic class person{\n    public void print(final int a){\n    //编译报错,不能再次赋值,传参的时候已经赋过了\n    a = 1;\n    }\n}\n\npublic class person{\n    public void print(){\n        final int a;\n        a = 1;\n        //编译报错,不能再次赋值\n        a = 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n【修饰成员变量-非静态成员变量】\n\npublic class person{\n    private final int a;\n}\n/*\n只有一次机会,可以给此变量a赋值的位置:\n声明的同时赋值\n匿名代码块中赋值\n构造器中赋值(类中出现的所有构造器都要写)\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n【修饰成员变量-静态成员变量】\n\npublic class person{\n    private static final int a;\n}\n/*\n只有一次机会,可以给此变量a赋值的位置:\n声明的同时赋值\n静态代码块中赋值\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【修饰引用对象】\n\nfinal student s = new student();\n//编译通过\ns.setname("tom");\ns.setname("zs");\n\n//编译报错,不能修改引用s指向的内存地址\ns = new student();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、abstract修饰符\n\nabstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法。如果修饰类，那么该类就是抽象类。\n\n1、抽象类和抽象方法的关系\n\n抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。\n\n2、语法\n\npublic abstract class action{\n    public abstract void dosomething();\n}\n\npublic void dosomething(){...}\n\n\n1\n2\n3\n4\n5\n\n\n对于这个普通方法来讲：\n\n"public void dosomething()"这部分是方法的声明。 "{...}"这部分是方法的实现,如果大括号中什么都没写,就叫方法的空实现\n\n声明类的同时，加上abstract修饰符就是抽象类 声明方法的时候，加上abstract修饰符，并且去掉方法的大口号，同时结尾加上分号，该方法就是抽象方法。\n\n\n# 3、特点及作用\n\n抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。\n\n注：子类继承抽象类后，需要实现抽象类中没有实现的抽象方法，否则这个子类也要声明为抽象类。\n\npublic abstract class action{\n    public abstract void dosomething();\n}\n\nmain:\n//编译报错,抽象类不能new对象\naction a = new action();\n\n//子类继承抽象类\npublic class eat extends action{\n    //实现父类中没有实现的抽象方法\n    public void dosomething(){\n        //code\n    }\n}\n\nmain:\naction a = new eat();\na.dosomething();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注：子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。\n\n4、思考\n\n思考1 : 抽象类不能new对象，那么抽象类中有没有构造器？\n\n> 抽象类是不能被实例化，抽象类的目的就是为实现多态中的共同点，抽象类的构造器会在子类实例化时调用，因此它也是用来实现多态中的共同点构造，不建议这样使用！\n\n思考2 : 抽象类和抽象方法意义（为什么要编写抽象类、抽象方法）\n\n> 打个比方，要做一个游戏。如果要创建一个角色，如果反复创建类和方法会很繁琐和麻烦。建一个抽象类 后。若要创建角色可直接继承抽象类中的字段和方法，而抽象类中又有抽象方法。如果一个角色有很多种 职业，每个职业又有很多技能，要是依次实例这些技能方法会显得想当笨拙。定义抽象方法，在需要时继 承后重写调用，可以省去很多代码。\n> \n> 总之抽象类和抽象方法起到一个框架作用。很方便后期的调用和重写 抽象方法是为了程序的可扩展性。重写抽象方法时即可实现同名方法但又非同目的的要求。\n\n\n# 接口\n\n\n# 1、接口的本质\n\n普通类：只有具体实现 抽象类：具体实现和规范(抽象方法) 都有！ 接口：只有规范！\n\n为什么需要接口？接口和抽象类的区别？\n\n * 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。\n * 抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。\n * 从接口的实现者角度看，接口定义了可以向外部提供的服务。\n * 从接口的调用者角度看，接口定义了实现者能提供那些服务。\n * 接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的系统之间模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。\n\n接口的本质探讨\n\n * 接口就是规范，定义的是一组规则，体现了现实世界中”如果你是…则必须能…“的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。\n * 接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。\n * oo的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。\n\n\n# 2、接口与抽象类的区别\n\n抽象类也是类，除了可以写抽象方法以及不能直接new对象之外，其他的和普通类没有什么不一样的。接口已经另一种类型了，和类是有本质的区别的，所以不能用类的标准去衡量接口。\n\n声明类的关键字是class，声明接口的关键字是interface。\n\n抽象类是用来被继承的，java中的类是单继承。\n\n类a继承了抽象类b，那么类a的对象就属于b类型了，可以使用多态 一个父类的引用，可以指向这个父类的任意子类对象 注：继承的关键字是extends\n\n接口是用来被类实现的，java中的接口可以被多实现。 类a实现接口b、c、d、e..，那么类a的对象就属于b、c、d、e等类型了，可以使用多态 一个接口的引用，可以指向这个接口的任意实现类对象 注：实现的关键字是implements\n\n\n# 3、接口中的方法都是抽象方法\n\n接口中可以不写任何方法，但如果写方法了，该方法必须是抽象方法\n\npublic interface action{\n    public abstract void run();\n    \n    //默认就是public abstract修饰的\n    void test();\n    public void go();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4、接口中的变量都是静态常量\n\npublic static final修饰\n\n接口中可以不写任何属性，但如果写属性了，该属性必须是public static final修饰的静态常量。 注：可以直接使用接口名访问其属性。因为是public static修饰的\n\n注：声明的同时就必须赋值(因为接口中不能编写静态代码块)\n\npublic interface action{\n    public static final string name = "tom";\n    //默认就是public static final修饰的\n    int age = 20;\n}\n\nmain:\nsystem.out.println(action.name);\nsystem.out.println(action.age);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5、一个类可以实现多个接口\n\npublic class student implements a,b,c,d{\n    //student需要实现接口a b c d中所有的抽象方法\n    //否则student类就要声明为抽象类,因为有抽象方法没实现\n}\n\nmain:\na s1 = new student();\nb s2 = new student();\nc s3 = new student();\nd s4 = new student();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注： s1只能调用接口a中声明的方法以及object中的方法 s2只能调用接口b中声明的方法以及object中的方法 s3只能调用接口c中声明的方法以及object中的方法 s4只能调用接口d中声明的方法以及object中的方法\n\n注：必要时可以类型强制转换\n\n例如 : 接口a 中有test() ， 接口b 中有run()\n\n\n# 6、一个接口可以继承多个父接口\n\npublic interface a{\n    public void testa();\n}\n\npublic interface b{\n    public void testb();\n}\n\n//接口c把接口a b中的方法都继承过来了\npublic interface c extends a,b{\n    public void testc();\n}\n\n//student相当于实现了a b c三个接口,需要实现所有的抽象方法\n//student的对象也就同时属于a类型 b类型 c类型\npublic class student implements c{\n    public viod testa(){}\n    public viod testb(){}\n    public viod testc(){}\n}\n\nmain:\n\nc o = new student();\nsystem.out.println(o instanceof a);//true\nsystem.out.println(o instanceof b);//true\nsystem.out.println(o instanceof c);//true\nsystem.out.println(o instanceof student);//true\nsystem.out.println(o instanceof object);//true\nsystem.out.println(o instanceof teacher);//false\n\n//编译报错\nsystem.out.println(o instanceof string);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n注：system.out.println(o instanceof x);\n\n> 如果o是一个接口类型声明的变量，那么只要x不是一个final修饰的类，该代码就能通过编译，至于其结果是不是true，就要看变量o指向的对象的实际类型，是不是x的子类或者实现类了。\n\n注：一个引用所指向的对象，是有可能实现任何一个接口的。(java中的多实现)\n\n\n# 7、接口的作用\n\n接口的最主要的作用是达到统一访问，就是在创建对象的时候用接口创建\n\n【接口名】 【对象名】= new 【实现接口的类】\n\n这样你像用哪个类的对象就可以new哪个对象了，不需要改原来的代码。\n\n假如我们两个类中都有个function()的方法，如果我用接口，那样我new a()；就是用a的方法，new b() 就是用b的方法。\n\n这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同\n\n总结：\n\n 1. java接口中的成员变量默认都是public,static,final类型的(都可省略)，必须被显示初始化，即接口中的成员变量为常量(大写,单词之间用"_"分隔)\n 2. java接口中的方法默认都是public,abstract类型的(都可省略)，没有方法体,不能被实例化\n 3. java接口中只能包含public,static,final类型的成员变量和public,abstract类型的成员方法\n 4. 接口中没有构造方法,不能被实例化\n 5. 一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口\n 6. java接口必须通过类来实现它的抽象方法\n 7. 当类实现了某个java接口时，它必须实现接口中的所有抽象方法，否则这个类必须声明为抽象类\n 8. 不允许创建接口的实例（实例化），但允许定义接口类型的引用变量，该引用变量引用实现了这个接口的类的实例\n 9. 一个类只能继承一个直接的父类，但可以实现多个接口，间接的实现了多继承。\n\ninterface swiminterface{\n    void swim();\n}\n\nclass fish{\n    int fins=4;\n}\n\nclass duck {\n    int leg=2;\n    void egg(){};\n}\n\nclass goldfish extends fish implements swiminterface {\n    @override\n    public void swim() {\n        system.out.println("goldfish can swim ");\n    }\n}\n\nclass smallduck extends duck implements swiminterface {\n    public void egg(){\n        system.out.println("smallduck can lay eggs ");\n    }\n    @override\n    public void swim() {\n  \t  system.out.println("smallduck can swim ");\n    }\n}\n\npublic class interfacedemo {\n    public static void main(string[] args) {\n        goldfish goldfish=new goldfish();\n        goldfish.swim();\n        \n        smallduck smallduck= new smallduck();\n        smallduck.swim();\n        smallduck.egg();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 内部类\n\n上一小节，我们学习了接口，在以后的工作中接口是我们经常要碰到的，所以一定要多去回顾。接下来介绍一下内部类。很多时候我们创建类的对象的时候并不需要使用很多次，每次只使用一次，这个时候我们就可以使用内部类了。\n\n\n# 1、内部类概述\n\n内部类就是在一个类的内部在定义一个类，比如，a类中定义一个b类，那么b类相对a类来说就称为内部类，而a类相对b类来说就是外部类了。\n\n内部类不是在一个java源文件中编写俩个平行的俩个类，而是在一个类的内部再定义另外一个类。 我们可以把外边的类称为外部类，在其内部编写的类称为内部类。\n\n内部类分为四种：\n\n 1. 成员内部类\n 2. 静态内部类\n 3. 局部内部类\n 4. 匿名内部类\n\n\n# 2、成员内部类\n\n成员内部类（实例内部类、非静态内部类）\n\n注：成员内部类中不能写静态属性和方法\n\n【定义一个内部类】\n\n//在a类中申明了一个b类，此b类就在a的内部，并且在成员变量的位置上，所以就称为成员内部类\npublic class outer {\n    private int id;\n    public void out(){\n        system.out.println("这是外部类方法");\n    }\n    \n    class inner{\n        public void in(){\n     \t   system.out.println("这是内部类方法");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【实例化内部类】\n\n实例化内部类，首先需要实例化外部类，通过外部类去调用内部类\n\npublic class outer {\n    private int id;\n    public void out(){\n  \t  system.out.println("这是外部类方法");\n    }\n    \n    class inner{\n        public void in(){\n        system.out.println("这是内部类方法");\n    }\n    }\n}\n\npublic class test{\n    public static void main(string[] args) {\n        //实例化成员内部类分两步\n        //1、实例化外部类\n        outer outobject = new outer();\n        //2、通过外部类调用内部类\n        outer.inner inobject = outobject.new inner();\n        //测试，调用内部类中的方法\n        inobject.in();//打印：这是内部类方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n分析：想想如果你要使用一个类中方法或者属性，你就必须要先有该类的一个对象，同理，一个类在另 一个类的内部，那么想要使用这个内部类，就必须先要有外部类的一个实例对象，然后在通过该对象去使用内部类。\n\n【成员内部类能干什么？】\n\n * 访问外部类的所有属性(这里的属性包括私有的成员变量，方法)\n\npublic class outer {\n    private int id;\n    public void out(){\n        system.out.println("这是外部类方法");\n    }\n    \n    class inner{\n        public void in(){\n            system.out.println("这是内部类方法");\n        }\n        //内部类访问外部类私有的成员变量\n        public void useid(){\n            system.out.println(id+3);。\n        }\n        //内部类访问外部类的方法\n        public void useout(){\n            out();\n        }\n    }\n}\n\npublic class test{\n    public static void main(string[] args) {\n        //实例化成员内部类分两步\n        //1、实例化外部类\n        outer outobject = new outer();\n        //2、通过外部类调用内部类\n        outer.inner inobject = outobject.new inner();\n        //测试\n        inobject.useid();//打印3，因为id初始化值为0，0+3就为3，其中在内部类就使用了外部类的私有成员变量id。\n        inobject.useout();//打印：这是外部类方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n * 如果内部类中的变量名和外部类的成员变量名一样，要通过创建外部类对象"."属性来访问外部类属性，通过this.属性访问内部类成员属性\n\npublic class outer {\n    private int id;//默认初始化0\n\n    public void out() {\n        system.out.println("这是外部类方法");\n    }\n\n    class inner {\n        private int id = 8; //这个id跟外部类的属性id名称一样。\n\n        public void in() {\n            system.out.println("这是内部类方法");\n        }\n\n        public void test() {\n            system.out.println(id);//输出8，内部类中的变量会暂时将外部类的成员变量给隐藏\n            // 如何调用外部类的成员变量呢？通过outer.this\n            // 想要知道为什么能通过这个来调用，就得明白下面这个原理\n            // 想实例化内部类对象，就必须通过外部类对象，当外部类对象来new出内部类对象时，会把自己(外部类对象)的引用传到了内部类中，\n            // 所以内部类就可以通过outer.this来访问外部类的属性和方法\n            // 到这里，你也就可以知道为什么内部类可以访问外部类的属性和方法，这里由于有两个相同的属性名称，\n\n            // 所以需要显示的用outer.this来调用外部类的属性，平常如果属性名不重复\n            // 那么我们在内部类中调用外部类的属性和方法时，前面就隐式的调用了outer.this。\n            system.out.println(outer.this.id);//输出外部类的属性id。也就是输出0\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n借助成员内部类，来总结内部类(包括4种内部类)的通用用法：\n\n 1. 要想访问内部类中的内容，必须通过外部类对象来实例化内部类。\n\n 2. 能够访问外部类所有的属性和方法，原理就是在通过外部类对象实例化内部类对象时，外部类对象把自己的引用传进了内部类，使内部类可以用通过outer.this去调用外部类的属性和方法。\n    \n    一般都是隐式调用了，但是当内部类中有属性或者方法名和外部类中的属性或方法名相同的时候，就需要通过显式调用outer.this了。\n\n【写的一个小例子】\n\npublic class memberinnerclasstest {\n    private string name;\n    private static int age;\n\n    public void run() {\n    }\n\n    public static void go() {\n    }\n\n    public class memberinnerclass {\n        private string name;\n\n        //内部类访问外部类\n        public void test(string name) {\n            system.out.println(name);\n            system.out.println(this.name);\n            system.out.println(memberinnerclasstest.this.name);\n            system.out.println(memberinnerclasstest.age);\n            memberinnerclasstest.this.run();\n            memberinnerclasstest.go();\n        }\n    }\n\n    //外部类访问成员内部类\n    //成员内部类的对象要 依赖于外部类的对象的存在\n    public void test() {\n        //memberinnerclass mic = memberinnerclasstest.this.new memberinnerclass();\n        //memberinnerclass mic = this.new memberinnerclass();\n        memberinnerclass mic = new memberinnerclass();\n        mic.name = "tom";\n        mic.test("hua");\n    }\n\n    public static void main(string[] args) {\n        //memberinnerclass mic = new memberinnerclass();这个是不行的，this是动态的。\n        //所以要使用要先创建外部类对象，才能使用\n        memberinnerclasstest out = new memberinnerclasstest();\n        memberinnerclass mic = out.new memberinnerclass();\n        //如果内部类是private,则不能访问，只能铜鼓内部方法来调用内部类\n        mic.name = "jik";\n        mic.test("kkk");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 3、静态内部类\n\n看到名字就知道，使用static修饰的内部类就叫静态内部类。\n\n既然提到了static，那我们就来复习一下它的用法：一般只修饰变量和方法，平常不可以修饰类，但是内部类却可以被static修饰。\n\n 1. static修饰成员变量：整个类的实例共享静态变量\n 2. static修饰方法：静态方法，只能够访问用static修饰的属性或方法，而非静态方法可以访问static修饰的方法或属性\n 3. 被static修饰了的成员变量和方法能直接被类名调用。\n 4. static不能修饰局部变量，切记，不要搞混淆了，static平常就用来修饰成员变量和方法。\n\n例子：\n\npublic class staticinnerclasstest {\n\n    private string name;\n    private static int age;\n\n    public void run() {\n    }\n\n    public static void go() {\n    }\n\n    //外部类访问静态内部类\n    public void test() {\n        staticinnerclass sic = new staticinnerclass(); //静态的内部类不需要依赖外部类，所以不用this\n        sic.name = "tom";\n\n        sic.test1("jack");\n        staticinnerclass.age = 10;\n        staticinnerclass.test2("xixi");\n    }\n\n    private static class staticinnerclass {\n        private string name;\n        private static int age;\n\n        public void test1(string name) {\n            system.out.println(name);\n            system.out.println(this.name);\n            system.out.println(staticinnerclass.age);\n            system.out.println(staticinnerclasstest.age);\n            //system.out.println(staticinnerclasstest.this.name);静态类不能访问非静态属性\n            staticinnerclasstest.go();\n            //staticinnerclasstest.this.run();静态类不能访问非静态方法\n        }\n\n        public static void test2(string name) {\n            //只能访问自己和外部类的静态属性和方法\n            system.out.println(name);\n            //system.out.println(this.name);静态方法里面连自己类的非静态属性都不能访问\n            system.out.println(staticinnerclass.age);\n            system.out.println(staticinnerclasstest.age);\n            //system.out.println(staticinnerclasstest.this.name);静态方法不能访问非静态属性\n            staticinnerclasstest.go();\n            //staticinnerclasstest.this.run();静态方法不能访问非静态方法\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n注意：\n\n 1. 我们上面说的内部类能够调用外部类的方法和属性，在静态内部类中就行了，因为静态内部类没有 了指向外部类对象的引用。除非外部类中的方法或者属性也是静态的。这就回归到了static关键字的用法。\n\n 2. 静态内部类能够直接被外部类给实例化，不需要使用外部类对象\n    \n    outer.inner inner = new outer.inner();\n    \n    \n    1\n    \n\n 3. 静态内部类中可以声明静态方法和静态变量，但是非静态内部类中就不可以声明静态方法和静态变量\n\n\n# 4、局部内部类\n\n局部内部类是在一个方法内部声明的一个类 局部内部类中可以访问外部类的成员变量及方法 局部内部类中如果要访问该内部类所在方法中的局部变量，那么这个局部变量就必须是final修饰的\n\npublic class outer {\n    private int id;\n\n    //在method01方法中有一个inner内部类，这个内部类就称为局部内部类\n    public void method01() {\n        class inner {\n            public void in() {\n                system.out.println("这是局部内部类");\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n局部内部类一般的作用跟在成员内部类中总结的差不多，但是有两个要注意的地方：\n\n1、在局部内部类中，如果要访问局部变量，那么该局部变量要用final修饰\n\n为什么需要使用final？\n\nfinal修饰变量：变为常量，会在常量池中放着，逆向思维想这个问题，如果不实用final修饰，当局部内部类被实例化后，方法弹栈，局部变量随着跟着消失，这个时候局部内部类对象在想去调用该局部变量，就会报错，因为该局部变量已经没了，当局部变量用fanal修饰后，就会将其加入常量池中，即使方法弹栈了，该局部变量还在常量池中呆着，局部内部类也就是够调用。所以局部内部类想要调用局部变 量时，需要使用final修饰，不使用，编译度通不过。\n\npublic class outer {\n    private int id;\n\n    public void method01() {\n        //这个就是局部变量cid。要让局部内部类使用，就得变为final并且赋值，如果不使用final修饰，就会报错\n        final int cid = 3;\n        class inner {\n            //内部类的第一个方法\n            public void in() {\n                system.out.println("这是局部内部类");\n            }\n\n            //内部类中的使用局部变量cid的方法\n            public void usecid() {\n                system.out.println(cid);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象 调用自己类中的方法。\n\n看下面例子就知道如何用了。\n\npublic class outer {\n    private int id;\n\n    public void out() {\n        system.out.println("外部类方法");\n    }\n\n    public void method01() {\n        class inner {\n            public void in() {\n                system.out.println("这是局部内部类");\n            }\n        }\n        //关键在这里，如需要在method01方法中自己创建内部类实例，\n        // 然后调用内部类中的方法，等待外部类调用method01方法，\n        // 就可以执行到内部类中的方法了。\n        inner in = new inner();\n        in.in();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n使用局部内部类需要注意的地方就刚才上面说的：\n\n 1. 在局部内部类中，如果要访问局部变量，那么该局部变量要用final修饰\n\n 2. 如何调用局部内部类方法。\n    \n    public class localinnerclasstest {\n        private string name;\n        private static int age;\n    \n        public void run() {\n        }\n    \n        public static void go() {\n        }\n    \n        //局部内部类要定义在方法中\n        public void test() {\n            final string myname = "";\n            class localinnerclass {\n                private string name;\n    \n                // private static int age;不能定义静态属性\n                public void test(string name) {\n                    system.out.println(name);\n                    system.out.println(this.name);\n                    system.out.println(myname);\n                    system.out.println(localinnerclasstest.this.name);\n                    localinnerclasstest.this.run();\n                    localinnerclasstest.go();\n                }\n            }\n            // 局部内部类只能在自己的方法中用\n            // 因为局部内部类相当于一个局部变量，出了方法就找不到了。\n            localinnerclass lic = new localinnerclass();\n            lic.name = "tom";\n            lic.test("test");\n            \n        }\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    \n\n\n# 5、匿名内部类\n\n在这四种内部类中，以后的工作可能遇到最多的是匿名内部类，所以说匿名内部类是最常用的一种 内部类。\n\n什么是匿名对象？如果一个对象只要使用一次，那么我们就是需要new object().method()。 就可以了，而不需要给这个实例保存到该类型变量中去。这就是匿名对象。\n\npublic class test {\n    public static void main(string[] args) {\n        //讲new出来的apple实例赋给apple变量保存起来，但是我们只需要用一次，就可以这样写\n        apple apple = new apple();\n        apple.eat();\n        //这种就叫做匿名对象的使用，不把实例保存到变量中。\n        new apple().eat();\n    }\n}\n\nclass apple{\n    public void eat(){\n        system.out.println("我要被吃了");\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n匿名内部类跟匿名对象是一个道理：\n\n匿名对象：我只需要用一次，那么我就不用声明一个该类型变量来保存对象了，\n\n匿名内部类：我也只需要用一次，那我就不需要在类中先定义一个内部类，而是等待需要用的时候，我就在临时实现这个内部类，因为用次数少，可能就这一次，那么这样写内部类，更方便。不然先写出一 个内部类的全部实现来，然后就调用它一次，岂不是用完之后就一直将其放在那，那就没必要那样。\n\n 1. 匿名内部类需要依托于其他类或者接口来创建\n    * 如果依托的是类，那么创建出来的匿名内部类就默认是这个类的子类\n    * 如果依托的是接口，那么创建出来的匿名内部类就默认是这个接口的实现类。\n 2. 匿名内部类的声明必须是在使用new关键字的时候\n    * 匿名内部类的声明及创建对象必须一气呵成，并且之后能反复使用，因为没有名字\n\n【示例】\n\na是一个类(普通类、抽象类都可以)，依托于a类创建一个匿名内部类对象\n\nmain:\n\na a = new a(){\n    //实现a中的抽象方法\n    //或者重写a中的普通方法\n};\n\n注:这个大括号里面其实就是这个内部类的代码,只不过是声明该内部类的同时就是要new创建了其对象,\n并且不能反复使用,因为没有名字。\n    \n例如:\nb是一个接口，依托于b接口创建一个匿名内部类对象\n\nb b = new b(){\n\t//实现b中的抽象方法\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 1. 匿名内部类除了依托的类或接口之外，不能指定继承或者实现其他类或接口，同时也不能被其他类所继承，因为没有名字。\n 2. 匿名内部中，我们不能写出其构造器，因为没有名字。\n 3. 匿名内部中，除了重写上面的方法外，一般不会再写其他独有的方法，因为从外部不能直接调用到。(间接是调用到的)\n\npublic interface work{\n    void dowork();\n}\n\npublic class anonymousoutterclass{\n    private string name;\n    private static int age;\n    public void say(){}\n    public static void go(){}\n    \n    public void test(){\n        final int i = 90;\n        \n        work w = new work(){\n            public void dowork(){\n                system.out.println(anonymousoutterclass.this.name);\n                system.out.println(anonymousoutterclass.age);\n                anonymousoutterclass.this.say();\n                anonymousoutterclass.go();\n                \n                system.out.println(i);\n            }\n        };\n        w.dowork();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们可以试一下不 用匿名内部类 和 用匿名内部类 实现一个接口中的方法的区别\n\n【不用匿名内部类】\n\npublic class test {\n    public static void main(string[] args) {\n        // 如果我们需要使用接口中的方法，我们就需要走3步，\n        // 1、实现接口 2、创建实现接口类的实例对象 3、通过对象调用方法\n        //第二步\n        test02 test = new test02();\n        //第三步\n        test.method();\n    }\n}\n\n//接口test1\ninterface test01{\n    public void method();\n}\n\n//第一步、实现test01接口\nclass test02 implements test01{\n    @override\n    public void method() {\n        system.out.println("实现了test接口的方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n【使用匿名内部类】\n\npublic class test {\n    public static void main(string[] args) {\n\t\t//如果我们需要使用接口中的方法，我们只需要走一步，就是使用匿名内部类，直接将其类的对象创建出来。\n        new test1(){\n            public void method(){\n                system.out.println("实现了test接口的方法");\n            }\n        }.method();\n    }\n}\n\ninterface test1{\n    public void method();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n解析：\n\n其实只要明白一点，new test1( ){ 实现接口中方法的代码 };\n\ntest1(){...} 这个的作用就是将接口给实现了，只不过这里实现该接口的是一个匿名类，也就是说这个类没名字，只能使用这一次，我们知道了这是一个类， 将其new出来，就能获得一个实现了test1接口的类的实例对象，通过该实例对象，就能调用该类中的方法了，因为其匿名类是在一个类中实现的，所以叫其匿名内部类。\n\n不要纠结为什么 test1( ){...} 就相当于实现了test1接口，这其中的原理等足够强大了，在去学习，不要钻牛角尖，这里就仅仅是需要知道他的作用是什么，做了些什么东西就行。',charsets:{cjk:!0},lastUpdated:"2023/12/24, 7:12:00",lastUpdatedTimestamp:1703403105e3},{title:"常用类",frontmatter:{title:"常用类",date:"2021-04-15T22:47:14.000Z",permalink:"/java/se/commonly-used-class/",categories:["java","java-se"]},regularPath:"/01.Java/04.Java-%E5%B8%B8%E7%94%A8%E7%B1%BB/08.%E5%B8%B8%E7%94%A8%E7%B1%BB.html",relativePath:"01.Java/04.Java-常用类/08.常用类.md",key:"v-458cddd9",path:"/java/se/commonly-used-class/",headers:[{level:2,title:"Object类",slug:"object类",normalizedTitle:"object类",charIndex:19},{level:3,title:"1  clone() 方法",slug:"_1-clone-方法",normalizedTitle:"1  clone() 方法",charIndex:null},{level:3,title:"2  toString()方法",slug:"_2-tostring-方法",normalizedTitle:"2  tostring()方法",charIndex:null},{level:3,title:"3  getClass()方法",slug:"_3-getclass-方法",normalizedTitle:"3  getclass()方法",charIndex:null},{level:3,title:"4  finalize()方法",slug:"_4-finalize-方法",normalizedTitle:"4  finalize()方法",charIndex:null},{level:3,title:"5  equals()方法",slug:"_5-equals-方法",normalizedTitle:"5  equals()方法",charIndex:null},{level:3,title:"6  hashCode()方法",slug:"_6-hashcode-方法",normalizedTitle:"6  hashcode()方法",charIndex:null},{level:3,title:"7  wait()方法",slug:"_7-wait-方法",normalizedTitle:"7  wait()方法",charIndex:null},{level:3,title:"8  notify()方法",slug:"_8-notify-方法",normalizedTitle:"8  notify()方法",charIndex:null},{level:2,title:"包装类",slug:"包装类",normalizedTitle:"包装类",charIndex:180},{level:3,title:"1、包装类介绍",slug:"_1、包装类介绍",normalizedTitle:"1、包装类介绍",charIndex:189},{level:3,title:"2、包装类的应用",slug:"_2、包装类的应用",normalizedTitle:"2、包装类的应用",charIndex:202},{level:3,title:"3、将整数转换为字符串",slug:"_3、将整数转换为字符串",normalizedTitle:"3、将整数转换为字符串",charIndex:216},{level:3,title:"3、自动拆箱和装箱",slug:"_3、自动拆箱和装箱",normalizedTitle:"3、自动拆箱和装箱",charIndex:233},{level:2,title:"Math类",slug:"math类",normalizedTitle:"math类",charIndex:246},{level:2,title:"Random类",slug:"random类",normalizedTitle:"random类",charIndex:255},{level:2,title:"日期时间类",slug:"日期时间类",normalizedTitle:"日期时间类",charIndex:266},{level:3,title:"1\tDate类",slug:"_1date类",normalizedTitle:"1\tdate类",charIndex:null},{level:3,title:"2、SimpleDateFormat",slug:"_2、simpledateformat",normalizedTitle:"2、simpledateformat",charIndex:290},{level:3,title:"3、Calendar类",slug:"_3、calendar类",normalizedTitle:"3、calendar类",charIndex:314},{level:2,title:"String类",slug:"string类",normalizedTitle:"string类",charIndex:329},{level:3,title:"1、String概述",slug:"_1、string概述",normalizedTitle:"1、string概述",charIndex:342},{level:3,title:"2、创建字符串对象方式",slug:"_2、创建字符串对象方式",normalizedTitle:"2、创建字符串对象方式",charIndex:358},{level:3,title:"3、String常用的方法",slug:"_3、string常用的方法",normalizedTitle:"3、string常用的方法",charIndex:375},{level:4,title:"String的判断",slug:"string的判断",normalizedTitle:"string的判断",charIndex:27628},{level:4,title:"String的截取",slug:"string的截取",normalizedTitle:"string的截取",charIndex:28604},{level:4,title:"String的转换",slug:"string的转换",normalizedTitle:"string的转换",charIndex:29865},{level:4,title:"其他方法",slug:"其他方法",normalizedTitle:"其他方法",charIndex:30510},{level:3,title:"4、String的不可变性",slug:"_4、string的不可变性",normalizedTitle:"4、string的不可变性",charIndex:394},{level:3,title:"5、字符串常量池",slug:"_5、字符串常量池",normalizedTitle:"5、字符串常量池",charIndex:413},{level:2,title:"StringBuilder和StringBuffer",slug:"stringbuilder和stringbuffer",normalizedTitle:"stringbuilder和stringbuffer",charIndex:425},{level:3,title:"1、概述",slug:"_1、概述",normalizedTitle:"1、概述",charIndex:457},{level:3,title:"2、常用方法",slug:"_2、常用方法",normalizedTitle:"2、常用方法",charIndex:467},{level:4,title:"insert",slug:"insert",normalizedTitle:"insert",charIndex:38201},{level:4,title:"append",slug:"append",normalizedTitle:"append",charIndex:34925},{level:4,title:"replace",slug:"replace",normalizedTitle:"replace",charIndex:37998},{level:4,title:"delete",slug:"delete",normalizedTitle:"delete",charIndex:4240},{level:4,title:"index",slug:"index",normalizedTitle:"index",charIndex:28665},{level:4,title:"其他API",slug:"其他api",normalizedTitle:"其他api",charIndex:48098},{level:3,title:"3、StringBuffer",slug:"_3、stringbuffer",normalizedTitle:"3、stringbuffer",charIndex:479},{level:3,title:"4、小结",slug:"_4、小结",normalizedTitle:"4、小结",charIndex:499},{level:3,title:"5、面试题的回答",slug:"_5、面试题的回答",normalizedTitle:"5、面试题的回答",charIndex:509},{level:2,title:"File类",slug:"file类",normalizedTitle:"file类",charIndex:521},{level:3,title:"1、File类的基本用法",slug:"_1、file类的基本用法",normalizedTitle:"1、file类的基本用法",charIndex:532}],headersStr:"Object类 1  clone() 方法 2  toString()方法 3  getClass()方法 4  finalize()方法 5  equals()方法 6  hashCode()方法 7  wait()方法 8  notify()方法 包装类 1、包装类介绍 2、包装类的应用 3、将整数转换为字符串 3、自动拆箱和装箱 Math类 Random类 日期时间类 1\tDate类 2、SimpleDateFormat 3、Calendar类 String类 1、String概述 2、创建字符串对象方式 3、String常用的方法 String的判断 String的截取 String的转换 其他方法 4、String的不可变性 5、字符串常量池 StringBuilder和StringBuffer 1、概述 2、常用方法 insert append replace delete index 其他API 3、StringBuffer 4、小结 5、面试题的回答 File类 1、File类的基本用法",content:'# JavaSE-常用类\n\n\n\n * Object类\n   * 1 clone() 方法\n   * 2 toString()方法\n   * 3 getClass()方法\n   * 4 finalize()方法\n   * 5 equals()方法\n   * 6 hashCode()方法\n   * 7 wait()方法\n   * 8 notify()方法\n * 包装类\n   * 1、包装类介绍\n   * 2、包装类的应用\n   * 3、将整数转换为字符串\n   * 3、自动拆箱和装箱\n * Math类\n * Random类\n * 日期时间类\n   * 1 Date类\n   * 2、SimpleDateFormat\n   * 3、Calendar类\n * String类\n   * 1、String概述\n   * 2、创建字符串对象方式\n   * 3、String常用的方法\n   * 4、String的不可变性\n   * 5、字符串常量池\n * StringBuilder和StringBuffer\n   * 1、概述\n   * 2、常用方法\n   * 3、StringBuffer\n   * 4、小结\n   * 5、面试题的回答\n * File类\n   * 1、File类的基本用法\n\n\n\n\n# Object类\n\n理论上Object类是所有类的父类，即直接或间接的继承java.lang.Object类。\n\n由于所有的类都继承在Object类，因此省略了extends Object关键字。\n\n该类中主要有以下方法：\n\n * toString( )\n * getClass( )\n * equals( )\n * clone( )\n * finalize( )\n\n其中toString()，getClass()，equals是其中最重要的方法。\n\n查看Object类源码\n\n\n\n看图可知，在jdk15中最后一个方法过时了，但我们运营一般都是jdk1.8\n\n注意： Object类中的getClass(),notify(),notifyAll(),wait()等方法被定义为final类型，因此不能重写。\n\n\n# 1 clone() 方法\n\n详解文章：https://blog.csdn.net/zhangjg_blog/article/details/18369201#0-qzone-1-28144-d020d2d2a4e8d1a374a433f596ad1440\n\n protected native Object clone() throws CloneNotSupportedException;\n\n\n1\n\n\nclone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几种方式可以创建对象呢？\n\n * 使用new操作符创建一个对象\n * 使用clone方法复制一个对象\n\n那么这两种方式有什么相同和不同呢？ new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后， 再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。\n\nclone与copy的区别\n\n假设现在有一个Employee对象，Employee tobby = new Employee(“CMTobby”,5000)\n\n通常我们会有这样的赋值Employee cindyelf = tobby，这个时候只是简单了copy了一下reference。cindyelf和tobby都指向内存中同一个object，这样cindyelf或者tobby的一个操作都可能影响到对方。打个比方，如果我们通过cindyelf.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法，得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。我们希望得到tobby的一个精确拷贝，同时两者互不影响，这时候， 我们就可以使用Clone来满足我们的需求。Employee cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法。\n\nShallow Clone与Deep Clone\n\n浅克隆和深克隆\n\n * 浅克隆：\n   \n   是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。\n\n * 深克隆：\n   \n   不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。\n\n举例来说更加清楚。\n\n\n\n主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用，我们有时候不希望在方法里将参数改变，这是就需要在类中复写clone方法（实现深复制）。\n\nClone是如何完成的呢？Object在对某个对象实施Clone时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。这样，问题就来了咯。\n\n以Employee为例，它里面有一个域hireDay不是基本数据类型的变量，而是一个reference变量，经过Clone之后就会产生一个新的Date型的reference，\n\n它和原始对象中对应的域指向同一个Date对象，这样克隆类就和原始类共享了一部分信息，而这样显然是不利的，过程下图所示：\n\n\n\n这个时候我们就需要进行deep Clone了，对那些非基本类型的域进行特殊的处理，例如本例中的 hireDay。我们可以重新定义Clone方法，对hireDay做特殊处理，如下代码所示：\n\nclass Employee implements Cloneable {\n    public Object clone() throws CloneNotSupportedException {\n        Employee cloned = (Employee) super.clone();\n        cloned.hireDay = (Date) hireDay.clone()\n        return cloned;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nclone方法的保护机制\n\n在Object中Clone()是被声明为protected的，这样做是有一定的道理的，以Employee类为例，通过声明为protected，就可以保证只有Employee类里面才能“克隆”Employee对象。\n\nclone方法的使用\n\n什么时候使用shallow Clone，什么时候使用deep Clone，这个主要看具体对象的域是什么性质的，基本型别还是reference variable\n\n调用Clone()方法的对象所属的类(Class)必须implements Clonable接口，否则在调用Clone方法的时候 会抛出CloneNotSupportedException\n\n推荐： 浅克隆(ShallowClone)和深克隆(DeepClone)区别以及实现\n\n\n# 2 toString()方法\n\npublic String toString() {\n\treturn getClass().getName() + "@" + Integer.toHexString(hashCode());\n}\n\n\n1\n2\n3\n\n\nObject 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@” 和此对象哈希码的无符号十六进制表示组成。\n\n该方法用得比较多，一般子类都有覆盖。\n\npublic static void main(String[] args){\n    Object o1 = new Object();\n    System.out.println(o1.toString());\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3 getClass()方法\n\npublic final native Class<?> getClass();\n\n\n1\n\n\n返回次Object的运行时类类型。\n\n不可重写，要调用的话，一般和getName()联合使用，如getClass().getName();\n\npublic static void main(String[] args) {\n    Object o = new Object();\n    System.out.println(o.getClass());\n    //class java.lang.Object\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4 finalize()方法\n\nprotected void finalize() throws Throwable { }\n\n\n1\n\n\n该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。\n\nJava允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。\n\n关于垃圾回收，有三点需要记住：\n\n1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。\n\n2、垃圾回收并不等于“析构”。\n\n科普：析构函数(destructor) 与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。\n\n3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。\n\nfinalize()的用途：\n\n无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。\n\n这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。\n\n\n# 5 equals()方法\n\npublic boolean equals(Object obj) {\n\treturn (this == obj);\n}\n\n\n1\n2\n3\n\n\nObject中的equals方法是直接判断this和obj本身的值是否相等，即用来判断调用equals的对象和形参 obj所引用的对象是否是同一对象\n\n所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true，如果this和obj指向的不是同一块内存，则返回false。\n\n注意：即便是内容完全相等的两块不同的内存对象，也返回false。\n\n如果是同一块内存，则object中的equals方法返回true，如果是不同的内存，则返回false\n\n如果希望不同内存但相同内容的两个对象equals时返回true，则我们需要重写父类的equal方法\n\nString类已经重写了object中的equals方法（这样就是比较内容是否相等了）\n\n查看String类源码equals方法\n\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6 hashCode()方法\n\npublic native int hashCode();\n\n\n1\n\n\n返回该对象的哈希码值。\n\n该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写 hashCode方法。这个方法在一些具有哈希功能的Collection中用到。\n\n一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashCode() == obj2.hashCode()，但是 hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\n\n\n# 7 wait()方法\n\npublic final void wait(long timeoutMillis, int nanos) throws InterruptedException {\n    if (timeoutMillis < 0) {\n        throw new IllegalArgumentException("timeoutMillis value is negative");\n    }\n\n    if (nanos < 0 || nanos > 999999) {\n        throw new IllegalArgumentException(\n                            "nanosecond timeout value out of range");\n    }\n\n    if (nanos > 0 && timeoutMillis < Long.MAX_VALUE) {\n        timeoutMillis++;\n    }\n\n    wait(timeoutMillis);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可以看到有三种重载，wait什么意思呢？\n\n\n\n方法中的异常：\n\n\n\nwait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。\n\nwait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔\n\n如果在规定时间内没有获得锁就返回。\n\n调用该方法后当前线程进入睡眠状态，直到以下事件发生。\n\n（1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。\n\n此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。\n\n\n# 8 notify()方法\n\npublic final native void notify();\n\n\n1\n\n\n该方法唤醒在该对象上等待的某个线程。\n\npublic final native void notifyAll();\n\n\n1\n\n\n该方法唤醒在该对象上等待的所有线程。\n\n\n# 包装类\n\n\n# 1、包装类介绍\n\n虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。\n\n这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。\n\n基本数据类型    对应的包装类\nbyte      Byte\nshort     Short\nint       Integer\nlong      Long\nchar      Character\nfloat     Float\ndouble    Double\nboolean   Boolean\n\n每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一 经创建，其内容（所封装的基本类型数据值）不可改变。\n\n基本类型和对应的包装类可以相互装换：\n\n * 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；\n * 包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。\n\n\n# 2、包装类的应用\n\n1、 实现 int 和 Integer 的相互转换\n\n可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。\n\npublic static void main(String[] args) {\n    int m = 500;\n    Integer obj = new Integer(m); // 手动装箱\n    int n = obj.intValue(); // 手动拆箱\n    System.out.println("n = " + n);\n    \n    Integer obj1 = new Integer(500);\n    System.out.println("obj 等价于 obj1？" + obj.equals(obj1));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、 将字符串转换为整数\n\nInteger 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：\n\nparseInt(String s, int radix);\n//s 为要转换的字符串，radix 为进制，可选，默认为十进制。\n\n\n1\n2\n\n\n下面的代码将会告诉你什么样的字符串可以转换为整数：\n\npublic static void main(String[] args) {\n    String[] strs = {"123", "123abc", "abc123", "abcxyz"};\n    for (String str : strs) {\n        try {\n            int m = Integer.parseInt(str, 10);\n            System.out.println(str + " 可以转换为整数 " + m);\n        } catch (Exception e) {\n            System.out.println(str + " 无法转换为整数");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n> 123 可以转换为整数 123 123abc 无法转换为整数 abc123 无法转换为整数 abcxyz 无法转换为整数\n\n\n# 3、将整数转换为字符串\n\nInteger 类有一个静态的 toString() 方法，可以将整数转换为字符串。或者直接在整数后面加空字符串！\n\npublic static void main(String[] args) {\n    int m = 500;\n    String s = Integer.toString(m);\n    \n    String s2 = m +"";\n    System.out.println("s = " + s);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、自动拆箱和装箱\n\n上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。\n\nJava 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。\n\npublic static void main(String[] args) {\n    int m = 500;\n    Integer obj = m; // 自动装箱\n    int n = obj; // 自动拆箱\n    System.out.println("n = " + n);\n    Integer obj1 = 500;\n    System.out.println("obj 等价于 obj1？" + obj.equals(obj1));\n}\n//结果：\n// n = 500\n// obj 等价于 obj1？true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n自动装箱与拆箱的功能事实上是编译器来帮您的忙，编译器在编译时期依您所编写的语法，决定是否进行装箱或拆箱动作。例如：\n\nInteger i = 100;\n//相当于编译器自动为您作以下的语法编译：\nInteger i = new Integer(100);\n\n\n1\n2\n3\n\n\n所以自动装箱与拆箱的功能是所谓的“编译器蜜糖”(Compiler Sugar)，虽然使用这个功能很方便，但在程序运行阶段你要了解Java的语义。例如下面的程序是可以通过编译的：\n\nInteger i = null;\nint j = i;\n\n\n1\n2\n\n\n这样的语法在编译时期是合法的，但是在运行时期会有错误，因为这种写法相当于：\n\nInteger i = null;\nint j = i.intValue();\n\n\n1\n2\n\n\nnull表示i 没有参考至任何的对象实体，它可以合法地指定给对象参考名称。由于实际上 i 并没有参考至任何的对象，所以也就不可能操作intValue()方法，这样上面的写法在运行时会出现NullPointerException 错误。\n\n自动拆箱装箱是常用的一个功能，需要重点掌握。\n\n一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。\n\n所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。\n\n\n# Math类\n\nJava 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用\n\n【演示：查看Math类的源码】\n\npublic final class Math{\n\t//数学方法\n}\n\n\n1\n2\n3\n\n\n【常用值与函数】\n\nMath.PI 记录的圆周率 Math.E 记录e的常量\n\nMath中还有一些类似的常量，都是一些工程数学常用量。\n\nMath.abs 求绝对值 Math.sin 正弦函数 Math.asin 反正弦函数 Math.cos 余弦函数 Math.acos 反余弦函数 Math.tan 正切函数 Math.atan 反正切函数 Math.atan2 商的反正切函数 Math.toDegrees 弧度转化为角度 Math.toRadians 角度转化为弧度 Math.ceil 得到不小于某数的最大整数 Math.floor 得到不大于某数的最大整数 Math.IEEEremainder 求余 Math.max 求两数中最大 Math.min 求两数中最小 Math.sqrt 求开方 Math.pow 求某数的任意次方, 抛出ArithmeticException处理溢出异常\n\nMath.exp 求e的任意次方 Math.log10 以10为底的对数 Math.log 自然对数 Math.rint 求距离某数最近的整数（可能比某数大，也可能比它小） Math.round 同上，返回int型或者long型（上一个函数返回double型） Math.random 返回0，1之间的一个随机数\n\npublic static void main(String[] args) {\n    /**\n     *Math.sqrt()//计算平方根\n     *Math.cbrt()//计算立方根\n     *Math.pow(a, b)//计算a的b次方\n     *Math.max( , );//计算最大值\n     *Math.min( , );//计算最小值\n     */\n    System.out.println(Math.sqrt(16)); //4.0\n    System.out.println(Math.cbrt(8)); //2.0\n    System.out.println(Math.pow(3, 2)); //9.0\n    System.out.println(Math.max(2.3, 4.5));//4.5\n    System.out.println(Math.min(2.3, 4.5));//2.3\n    /**\n     * abs求绝对值\n     */\n    System.out.println(Math.abs(-10.4)); //10.4\n    System.out.println(Math.abs(10.1)); //10.1\n    /**\n     * ceil天花板的意思，就是返回大的值\n     */\n    System.out.println(Math.ceil(-10.1)); //-10.0\n    System.out.println(Math.ceil(10.7)); //11.0\n    System.out.println(Math.ceil(-0.7)); //-0.0\n    System.out.println(Math.ceil(0.0)); //0.0\n    System.out.println(Math.ceil(-0.0)); //-0.0\n    System.out.println(Math.ceil(-1.7)); //-1.0\n    /**\n     * floor地板的意思，就是返回小的值\n     */\n    System.out.println(Math.floor(-10.1)); //-11.0\n    System.out.println(Math.floor(10.7)); //10.0\n    System.out.println(Math.floor(-0.7)); //-1.0\n    System.out.println(Math.floor(0.0)); //0.0\n    System.out.println(Math.floor(-0.0)); //-0.0\n    /**\n     * random 取得一个大于或者等于0.0小于不等于1.0的随机数 [0,1)\n     */\n    System.out.println(Math.random()); //小于1大于0的double类型的数\n    System.out.println(Math.random() + 1);//大于1小于2的double类型的数\n    /**\n     * rint 四舍五入，返回double值\n     * 注意.5的时候会取偶数 异常的尴尬=。=\n     */\n    System.out.println(Math.rint(10.1)); //10.0\n    System.out.println(Math.rint(10.7)); //11.0\n    System.out.println(Math.rint(11.5)); //12.0\n    System.out.println(Math.rint(10.5)); //10.0\n    System.out.println(Math.rint(10.51)); //11.0\n    System.out.println(Math.rint(-10.5)); //-10.0\n    System.out.println(Math.rint(-11.5)); //-12.0\n    System.out.println(Math.rint(-10.51)); //-11.0\n    System.out.println(Math.rint(-10.6)); //-11.0\n    System.out.println(Math.rint(-10.2)); //-10.0\n    /**\n     * round 四舍五入，float时返回int值，double时返回long值\n     */\n    System.out.println(Math.round(10.1)); //10\n    System.out.println(Math.round(10.7)); //11\n    System.out.println(Math.round(10.5)); //11\n    System.out.println(Math.round(10.51)); //11\n    System.out.println(Math.round(-10.5)); //-10\n    System.out.println(Math.round(-10.51)); //-11\n    System.out.println(Math.round(-10.6)); //-11\n    System.out.println(Math.round(-10.2)); //-10\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# Random类\n\nJava中存在着两种Random函数：\n\n1、java.lang.Math.Random;\n\n调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是 [0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。例子如下：\n\npublic static void main(String[] args) {\n    // 结果是个double类型的值，区间为[0.0,1.0）\n    System.out.println("Math.random()=" + Math.random());\n    int num = (int) (Math.random() * 3);\n    // 注意不要写成(int)Math.random()*3，这个结果为0或1，因为先执行了强制转换\n    System.out.println("num=" + num);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n2、java.util.Random\n\n下面是Random()的两种构造方法：\n\nRandom()：创建一个新的随机数生成器 Random(long seed)：使用单个 long 种子创建一个新的随机数生成器。\n\n你在创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。\n\n如下面的Java代码：\n\n【演示一】\n\n在没带参数构造函数生成的Random对象的种子是当前系统时间的毫秒数。\n\nrand.nextInt(100)中的100是随机数的上限,产生的随机数为0-100的整数，不包括100。\n\npublic static void main(String[] args) {\n    Random rand = new Random();\n    int i = rand.nextInt(100);\n    System.out.println(i);\n}\n\n\n1\n2\n3\n4\n5\n\n\n【演示二】\n\n对于种子相同的Random对象，多次执行后生成的随机数序列是一样的。\n\npublic static void main(String[] args) {\n    Random ran1 = new Random(25);\n    System.out.println("使用种子为25的Random对象生成[0,100)内随机整数序列: ");\n    for (int i = 0; i < 10; i++) {\n        System.out.print(ran1.nextInt(100) + " ");\n    }\n    System.out.println();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【方法摘要】\n\n 1.  protected int next(int bits)：生成下一个伪随机数。\n 2.  boolean nextBoolean()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean值。\n 3.  void nextBytes(byte[] bytes)：生成随机字节并将其置于用户提供的 byte 数组中。\n 4.  double nextDouble()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间 均匀分布的 double值。\n 5.  float nextFloat()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布float值。\n 6.  double nextGaussian()：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。\n 7.  int nextInt()：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。\n 8.  int nextInt(int n)：返回一个伪随机数，它是取自此随机数生成器序列的、在（包括和指定值（不包括）之间均匀分布的int值。\n 9.  long nextLong()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。\n 10. void setSeed(long seed)：使用单个 long 种子设置此随机数生成器的种子。\n\n【例子】\n\n 1. 生成[0,1.0)区间的小数：double d1 = r.nextDouble();\n 2. 生成[0,5.0)区间的小数：double d2 = r.nextDouble() * 5;\n 3. 生成[1,2.5)区间的小数：double d3 = r.nextDouble() * 1.5 + 1;\n 4. 生成[0,10)区间的整数：int n2 = r.nextInt(10);\n\n\n# 日期时间类\n\n\n# 1 Date类\n\njava.util 包提供了 Date 类来封装当前的日期和时间。\n\nDate 类提供两个构造函数来实例化 Date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\nDate()\n\n\n1\n\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。\n\nDate(long millisec)\n\n\n1\n\n\nDate对象创建以后，可以调用下面的方法。\n\n序号   方法和描述\n1    boolean after(Date date)\n     若当调用此方法的Date对象在指定日期之后返回true,否则返回false。\n2    boolean before(Date date)\n     若当调用此方法的Date对象在指定日期之前返回true,否则返回false。\n3    Object clone( ) 返回此对象的副本。\n4    int compareTo(Date date)\n     比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。\n5    int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date)\n     。否则它抛出ClassCastException。\n6    boolean equals(Object date)\n     当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。\n7    long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date\n     对象表示的毫秒数。\n8    int hashCode( ) 返回此对象的哈希码值。\n9    void setTime(long time) 用自1970年1月1日00:00:00\n     GMT以后time毫秒数设置时间和日期。\n10   String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd\n     hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu,\n     Fri, Sat)。\n\n【演示：获取当前日期时间】\n\nJava中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间\n\npublic static void main(String args[]) {\n    // 初始化 Date 对象\n    Date date = new Date();\n\n    // 使用 toString() 函数显示日期时间\n    System.out.println(date.toString());\n    //Tue Mar 30 10:24:19 CST 2021\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【演示：日期比较】\n\n使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n\npublic static void main(String[] args) {\n    // 初始化 Date 对象\n    Date date = new Date();\n\n    long time = date.getTime();\n    long time2 = date.getTime();\n    System.out.println(time==time2);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。\n\npublic static void main(String[] args) {\n    boolean before = new Date(99, 01, 05).before(new Date(99, 11, 16));\n    System.out.println(before);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2、SimpleDateFormat\n\n格式化日期\n\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：\n\npublic static void main(String args[]) {\n    Date dNow = new Date( );\n    SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");\n    System.out.println("当前时间为: " + ft.format(dNow));\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。\n\n注意：有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。\n\n时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：\n\n字母   描述                     示例\nG    纪元标记                   AD\ny    四位年份                   2001\nM    月份                     July or 07\nd    一个月的日期                 10\nh    A.M./P.M. (1~12)格式小时   12\nH    一天中的小时 (0~23)          22\nm    分钟数                    30\ns    秒数                     55\nS    毫秒数                    234\nE    星期几                    Tuesday\nD    一年中的日子                 360\nF    一个月中第几周的周几             2 (second Wed. in July)\nw    一年中第几周                 40\nW    一个月中第几周                1\na    A.M./P.M. 标记           PM\nk    一天中的小时(1~24)           24\nK    A.M./P.M. (0~11)格式小时   10\nz    时区                     Eastern Standard Time\n\'    文字定界符                  Delimiter\n"    单引号                    `\n\n【演示：使用printf格式化日期】\n\nJava 格式化输出 printf 例子：https://www.runoob.com/w3cnote/java-printf-formate-demo.html\n\nprintf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。\n\npublic static void main(String[] args) {\n    // 初始化 Date 对象\n    Date date = new Date();\n    //c的使用\n    System.out.printf("全部日期和时间信息：%tc%n",date);\n    //f的使用\n    System.out.printf("年-月-日格式：%tF%n",date);\n    //d的使用\n    System.out.printf("月/日/年格式：%tD%n",date);\n    //r的使用\n    System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);\n    //t的使用\n    System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);\n    //R的使用\n    System.out.printf("HH:MM格式（24时制）：%tR",date);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\n> 全部日期和时间信息：周二 3月 30 10:37:02 CST 2021 年-月-日格式：2021-03-30 月/日/年格式：03/30/21 HH:MM:SS PM格式（12时制）：10:37:02 上午 HH:MM:SS格式（24时制）：10:37:02 HH:MM格式（24时制）：10:37\n\n【时间休眠：休眠(sleep)】\n\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。\n\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：\n\npublic static void main(String args[]) {\n    try {\n        System.out.println(new Date( ) + "\\n");\n        Thread.sleep(1000*3); // 休眠3秒\n        System.out.println(new Date( ) + "\\n");\n    } catch (Exception e) {\n        System.out.println("Got an exception!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3、Calendar类\n\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar类。Date中有很多方法都已经废弃了！\n\nCalendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。\n\nCalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\n创建一个代表系统当前日期的Calendar对象\n\npublic static void main(String args[]) {\n    Calendar c = Calendar.getInstance();//默认是当前日期\n    System.out.println(c);\n}\n\n\n1\n2\n3\n4\n\n\n输出：\n\n> java.util.GregorianCalendar[time=1617072097924,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2021,MONTH=2,WEEK_OF_YEAR=14,WEEK_OF_MONTH=5,DAY_OF_MONTH=30,DAY_OF_YEAR=89,DAY_OF_WEEK=3,DAY_OF_WEEK_IN_MONTH=5,AM_PM=0,HOUR=10,HOUR_OF_DAY=10,MINUTE=41,SECOND=37,MILLISECOND=924,ZONE_OFFSET=28800000,DST_OFFSET=0]\n\n创建一个指定日期的Calendar对象\n\n使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。\n\n//创建一个代表2019年4月27日的Calendar对象\nCalendar c1 = Calendar.getInstance();\nc1.set(2019, 4 - 1, 27);\n\n\n1\n2\n3\n\n\nCalendar类对象字段类型\n\nCalendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想\n\n常量                      描述\nCalendar.YEAR           年份\nCalendar.MONTH          月份\nCalendar.DATE           日期\nCalendar.DAY_OF_MONTH   日期，和上面的字段意义完全相同\nCalendar.HOUR           12小时制的小时\nCalendar.HOUR_OF_DAY    24小时制的小时\nCalendar.MINUTE         分钟\nCalendar.SECOND         秒\nCalendar.DAY_OF_WEEK    星期几\n\n// 获得年份\nint year = c1.get(Calendar.YEAR);\n// 获得月份\nint month = c1.get(Calendar.MONTH) + 1;\n// 获得日期\nint date = c1.get(Calendar.DATE);\n// 获得小时\nint hour = c1.get(Calendar.HOUR_OF_DAY);\n// 获得分钟\nint minute = c1.get(Calendar.MINUTE);\n// 获得秒\nint second = c1.get(Calendar.SECOND);\n// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）\nint day = c1.get(Calendar.DAY_OF_WEEK);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n设置完整日期\n\nCalendar c1 = Calendar.getInstance();\nc1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12\n\n\n1\n2\n\n\n设置某个字段\n\nc1.set(Calendar.DATE,10);\nc1.set(Calendar.YEAR,2008);\n//其他字段属性set的意义以此类推\n\n\n1\n2\n3\n\n\nadd设置\n\n//把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算\nc1.add(Calendar.DATE, 10);\n//把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算\nc1.add(Calendar.DATE, -10);\n\n\n1\n2\n3\n4\n\n\n【演示：GregorianCalendar】\n\npublic static void main(String[] args) {\n    String months[] = {\n            "Jan", "Feb", "Mar", "Apr",\n            "May", "Jun", "Jul", "Aug",\n            "Sep", "Oct", "Nov", "Dec"};\n\n    int year;\n    // 初始化 Gregorian 日历\n    // 使用当前时间和日期\n    // 默认为本地时间和时区\n    GregorianCalendar gcalendar = new GregorianCalendar();\n    // 显示当前时间和日期的信息\n    System.out.print("Date: ");\n    System.out.print(months[gcalendar.get(Calendar.MONTH)]);\n    System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");\n    System.out.println(year = gcalendar.get(Calendar.YEAR));\n    System.out.print("Time: ");\n    System.out.print(gcalendar.get(Calendar.HOUR) + ":");\n    System.out.print(gcalendar.get(Calendar.MINUTE) + ":");\n    System.out.println(gcalendar.get(Calendar.SECOND));\n\n    // 测试当前年份是否为闰年\n    if (gcalendar.isLeapYear(year)) {\n        System.out.println("当前年份是闰年");\n    } else {\n        System.out.println("当前年份不是闰年");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n输出：\n\n> Date: Mar 30 2021 Time: 10:49:35 当前年份不是闰年\n\n注意：Calender的月份是从0开始的，但日期和年份是从1开始的\n\n【演示】\n\npublic static void main(String[] args) {\n    Calendar c1 = Calendar.getInstance();\n    c1.set(2017, 1, 1);\n    System.out.println(c1.get(Calendar.YEAR)\n            + "-" + c1.get(Calendar.MONTH)\n            + "-" + c1.get(Calendar.DATE));\n    c1.set(2017, 1, 0);\n    System.out.println(c1.get(Calendar.YEAR)\n            + "-" + c1.get(Calendar.MONTH)\n            + "-" + c1.get(Calendar.DATE));\n}\n/*\n输出\n2017-1-1\n2017-0-31\n    /*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可见，将日期设为0以后，月份变成了上个月，但月份可以为0，把月份改为2试试：\n\npublic static void main(String[] args) {\n    Calendar c1 = Calendar.getInstance();\n    c1.set(2017, 2, 1);\n    System.out.println(c1.get(Calendar.YEAR)\n            + "-" + c1.get(Calendar.MONTH)\n            + "-" + c1.get(Calendar.DATE));\n    c1.set(2017, 2, 0);\n    System.out.println(c1.get(Calendar.YEAR)\n            + "-" + c1.get(Calendar.MONTH)\n            + "-" + c1.get(Calendar.DATE));\n}\n/*\n输出\n2017-2-1\n2017-1-28\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可以看到上个月的最后一天是28号，所以Calendar.MONTH为1的时候是2月 。\n\n\n# String类\n\n\n# 1、String概述\n\n在API中是这样描述：\n\nString 类代表字符串。Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。 字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的， 所以可以共享。\n\n【演示：查看String源码】\n\npublic final class String\nimplements java.io.Serializable, Comparable<String>, CharSequence {\n    \n}\n\n\n1\n2\n3\n4\n\n\n【String的成员变量】\n\n//String的属性值\nprivate final char value[];\n\n//数组被使用的开始位置\nprivate final int offset;\n\n//String中元素的个数\nprivate final int count;\n\n//String类型的hash值\nprivate int hash; // Default to 0\n\nprivate static final long serialVersionUID = -6849794470754667710L;\nprivate static final ObjectStreamField[] serialPersistentFields =\nnew ObjectStreamField[0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n从源码看出String底层使用一个字符数组来维护的。\n\n成员变量可以知道String类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的 String类型对象，存储String数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始。\n\n【String的构造方法】\n\nString()\n//初始化一个新创建的 String 对象，使其表示一个空字符序列。\n    \nString(byte[] bytes)\n//通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。\n    \nString(byte[] bytes, Charset charset)\n//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。\n    \nString(byte[] bytes, int offset, int length)\n//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。\n    \nString(byte[] bytes, int offset, int length, Charset charset)\n//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。\n    \nString(byte[] bytes, int offset, int length, String charsetName)\n//通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。\n    \nString(byte[] bytes, String charsetName)\n//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。\n    \nString(char[] value)\n//分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。\n    \nString(char[] value, int offset, int count)\n//分配一个新的 String，它包含取自字符数组参数一个子数组的字符。\n    \nString(int[] codePoints, int offset, int count)\n//分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。\n    \nString(String original)\n//初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。\n    \nString(StringBuffer buffer)\n//分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。\n    \nString(StringBuilder builder)\n//分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2、创建字符串对象方式\n\n直接赋值方式创建对象是在方法区的常量池\n\nString str="hello";//直接赋值的方式\n\n\n1\n\n\n通过构造方法创建字符串对象是在堆内存\n\nString str=new String("hello");//实例化的方式\n\n\n1\n\n\n【两种实例化方式的比较】\n\n编写代码比较\n\npublic static void main(String[] args) {\n    String str1 = "Lance";\n    String str2 = new String("Lance");\n    String str3 = str2; //引用传递，str3直接指向st2的堆内存地址\n    String str4 = "Lance";\n    /**\n     * ==:\n     * 基本数据类型：比较的是基本数据类型的值是否相同\n     * 引用数据类型：比较的是引用数据类型的地址值是否相同\n     * 所以在这里的话：String类对象==比较，比较的是地址，而不是内容\n     */\n    System.out.println(str1 == str2);//false\n    System.out.println(str1 == str3);//false\n    System.out.println(str3 == str2);//true\n    System.out.println(str1 == str4);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n内存图分析\n\n\n\n可能这里还是不够明显，构造方法实例化方式的内存图：String str = new String("Hello");\n\n\n\n当我们再一次的new一个String对象时：\n\n\n\n【字符串常量池】\n\n在字符串中，如果采用直接赋值的方式（String str="Lance"）进行对象的实例化，则会将匿名对象 “Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象，我们可以用对象手工入池；\n\npublic static void main(String args[]){\n    String str = new String("Lance").intern();//对匿名对象进行手工入池操作\n    String str1 = "Lance";\n    System.out.println(str==str1);//true\n}\n\n\n1\n2\n3\n4\n5\n\n\n【两种实例化方式的区别】\n\n 1. 直接赋值（String str = "hello"）\n    \n    只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。\n\n 2. 构造方法（String str= new String("hello");）\n    \n    会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。\n\n 3. 在开发的过程中不会采用构造方法进行字符串的实例化。\n\n【避免空指向】\n\n首先了解： == 和public boolean equals()比较字符串的区别\n\n==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中， equals()通过接受参数，可以避免空指向。\n\nString str = null;\nif(str.equals("hello")){//此时会出现空指向异常\n\n}\n\nif("hello".equals(str)){//此时equals会处理null值，可以避免空指向异常\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nString类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾\n\n\n\n\n# 3、String常用的方法\n\n\n\n# String的判断\n\n> boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String str)： 比较字符串的内容是否相同,忽略大小写 boolean startsWith(String str)： 判断字符串对象是否以指定的str开头 boolean endsWith(String str)： 判断字符串对象是否以指定的str结尾\n\n演示：\n\npublic static void main(String[] args) {\n    // 创建字符串对象\n    String s1 = "hello";\n    String s2 = "hello";\n    String s3 = "Hello";\n    \n    // boolean equals(Object obj):比较字符串的内容是否相同\n    System.out.println(s1.equals(s2)); //true\n    System.out.println(s1.equals(s3)); //false\n    System.out.println("-----------");\n    \n    // boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写\n    System.out.println(s1.equalsIgnoreCase(s2)); //true\n    System.out.println(s1.equalsIgnoreCase(s3)); //true\n    System.out.println("-----------");\n    \n    // boolean startsWith(String str):判断字符串对象是否以指定的str开头\n    System.out.println(s1.startsWith("he")); //true\n    System.out.println(s1.startsWith("ll")); //false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# String的截取\n\n> int length():获取字符串的长度，其实也就是字符个数 char charAt(int index):获取指定索引处的字符 int indexOf(String str):获取str在字符串对象中第一次出现的索引 String substring(int start):从start开始截取字符串 String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end\n\n演示\n\npublic static void main(String args[]) {\n    // 创建字符串对象\n    String s = "helloworld";\n    // int length():获取字符串的长度，其实也就是字符个数\n    System.out.println(s.length()); //10\n    System.out.println("--------");\n    // char charAt(int index):获取指定索引处的字符\n    System.out.println(s.charAt(0)); //h\n    System.out.println(s.charAt(1)); //e\n    System.out.println("--------");\n    // int indexOf(String str):获取str在字符串对象中第一次出现的索引\n    System.out.println(s.indexOf("l")); //2\n    System.out.println(s.indexOf("owo")); //4\n    System.out.println(s.indexOf("ak")); //-1\n    System.out.println("--------");\n    // String substring(int start):从start开始截取字符串\n    System.out.println(s.substring(0)); //helloworld\n    System.out.println(s.substring(5)); //world\n    System.out.println("--------");\n    // String substring(int start,int end):从start开始，到end结束截取字符串\n    System.out.println(s.substring(0, s.length())); //helloworld\n    System.out.println(s.substring(3, 8)); //lowor\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# String的转换\n\n> char[] toCharArray()：把字符串转换为字符数组 String toLowerCase()：把字符串转换为小写字符串 String toUpperCase()：把字符串转换为大写字符串\n\n演示\n\npublic static void main(String args[]) {\n\t// 创建字符串对象\n    String s = "abcde";\n    \n    // char[] toCharArray():把字符串转换为字符数组\n    char[] chs = s.toCharArray();\n    for (int x = 0; x < chs.length; x++) {\n        System.out.println(chs[x]);\n    }\n    \n    System.out.println("-----------");\n    \n    // String toLowerCase():把字符串转换为小写字符串\n    System.out.println("HelloWorld".toLowerCase());\n    // String toUpperCase():把字符串转换为大写字符串\n    System.out.println("HelloWorld".toUpperCase());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 其他方法\n\n> 去除字符串两端空格：String trim()\n> \n> 按照指定符号分割字符串：String[] split(String str)\n\npublic static void main(String args[]) {\n    // 创建字符串对象\n    String s1 = "helloworld";\n    String s2 = " helloworld ";\n    String s3 = " hello world ";\n    System.out.println("---" + s1 + "---");\n    System.out.println("---" + s1.trim() + "---");\n    System.out.println("---" + s2 + "---");\n    System.out.println("---" + s2.trim() + "---");\n    System.out.println("---" + s3 + "---");\n    System.out.println("---" + s3.trim() + "---");\n    System.out.println("-------------------");\n    \n    // String[] split(String str)\n    // 创建字符串对象\n    String s4 = "aa,bb,cc";\n    String[] strArray = s4.split(",");\n    for (int x = 0; x < strArray.length; x++) {\n        System.out.println(strArray[x]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4、String的不可变性\n\n当我们去阅读源代码的时候，会发现有这样的一句话：\n\n> Strings are constant; their values cannot be changed after they are created.\n\n意思就是说：String是个常量，从一出生就注定不可变\n\n我想大家应该就知道为什么String不可变了，String类被final修饰，官方注释说明创建后不能被改变，但 是为什么String要使用final修饰呢？\n\n了解一个经典的面试题\n\npublic static void main(String[] args) {\n    String a = "abc";\n    String b = "abc";\n    String c = new String("abc");\n    System.out.println(a==b); //true\n    System.out.println(a.equals(b)); //true\n    System.out.println(a==c); //false\n    System.out.println(a.equals(c)); //true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式，每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。\n\n需要说明一点的是，在object中，equals()是用来比较内存地址的，但是String重写了equals()方 法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。\n\nString不可变的好处\n\n * 可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。\n * 我们的程序中大量使用了String字符串，有可能是出于安全性考虑。\n * 大家都知道HashMap中key为String类型，如果可变将变的多么可怕。\n * 当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。\n\n\n# 5、字符串常量池\n\n字符串常量池概述：\n\n1、常量池表（Constant_Pool table）\n\nClass文件中存储所有常量（包括字符串）的table。这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。\n\n2、运行时常量池（Runtime Constant Pool）\n\nJVM内存中方法区的一部分，这是运行时的内容。这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池。上一句中说绝大部分是因为：除了 Class中常量池内 容，还可能包括动态生成并加入这里的内容。\n\n3、字符串常量池（String Pool）\n\n这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个。JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。\n\n【亨元模式】\n\n其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - > 共享元素模式 也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素\n\nJava中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”\n\n【详细分析】\n\nint x = 10;\nString y = "hello";\n\n\n1\n2\n\n\n① 首先， 10和 "hello"会在经过javac（或者其他编译器）编译过后变为Class文件中 constant_pool table 的内容\n\n② 当我们的程序运行时，也就是说JVM运行时，每个Class constant_pool table 中的内容会被加载到JVM内存中的方法区中各自Class的 Runtime Constant Pool。\n\n③ 一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是"hello"）会被加入到 String Pool中（HosSpot使用hashtable引用方式），步骤如下：\n\n 1. 在Java Heap（堆）中根据"hello"字面量create一个字符串对象\n\n 2. 将字面量"hello"与字符串对象的引用在hashtable中关联起来键 - 值\n    \n    形式是："hello" = 对象的引用地址。\n\n另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建 新对象呢？\n\n策略是这样：会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，就如同上面的第三步。\n\n如此，就实现了享元模式，提高的内存利用效率。\n\n举例：\n\n> 使用String s = new String("hello");会创建几个对象 答：会创建2个对象\n> \n> 首先，出现了字面量"hello"，那么去String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量"hello"首先创建1个String对象。\n> \n> 接着，new String("hello")，关键字new又在Java Heap中创建了1个对象，然后调用接收String 参数的构造器进行了初始化。最终s的引用是这个String对象.\n\n\n# StringBuilder和StringBuffer\n\n\n# 1、概述\n\n【演示：查看源码及API文档】\n\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence{\n    \n}\n\n\n1\n2\n3\n4\n5\n\n\nStringBuilder 是一个可变的字符序列。它继承于AbstractStringBuilder，实现了CharSequence接口。 StringBuffer 也是继承于AbstractStringBuilder的子类； 但是，StringBuilder和StringBuffer不同，前者是非线程安全的，后者是线程安全的。\n\nStringBuilder 和 CharSequence之间的关系图如下：\n\n\n\n【源码概览】\n\npackage java.lang;\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence {\n    \n    static final long serialVersionUID = 4383685877147921099L;\n    // 构造函数。默认的字符数组大小是16。\n    public StringBuilder() {\n        super(16);\n    }\n    \n    // 构造函数。指定StringBuilder的字符数组大小是capacity。\n        public StringBuilder(int capacity) {\n        super(capacity);\n    }\n    \n    // 构造函数。指定字符数组大小=str长度+15，且将str的值赋值到当前字符数组中。\n    public StringBuilder(String str) {\n        super(str.length() + 16);\n        append(str);\n    }\n    \n    // 构造函数。指定字符数组大小=seq长度+15，且将seq的值赋值到当前字符数组中。\n    public StringBuilder(CharSequence seq) {\n        this(seq.length() + 16);\n        append(seq);\n    }\n    \n    // 追加“对象obj对应的字符串”。String.valueOf(obj)实际上是调用obj.toString()\n    public StringBuilder append(Object obj) {\n        return append(String.valueOf(obj));\n    }\n    \n    // 追加“str”。\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n    \n      // 追加“sb的内容”。\n    private StringBuilder append(StringBuilder sb) {\n        if (sb == null)\n        \treturn append("null");\n        int len = sb.length();\n        int newcount = count + len;\n        if (newcount > value.length)\n        \texpandCapacity(newcount);\n        sb.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n    \n    // 追加“sb的内容”。\n    public StringBuilder append(StringBuffer sb) {\n        super.append(sb);\n        return this;\n    }\n    \n    // 追加“s的内容”。\n    public StringBuilder append(CharSequence s) {\n        if (s == null)\n            s = "null";\n        if (s instanceof String)\n            return this.append((String)s);\n        if (s instanceof StringBuffer)\n            return this.append((StringBuffer)s);\n        if (s instanceof StringBuilder)\n            return this.append((StringBuilder)s);\n        return this.append(s, 0, s.length());\n    }\n\n    // 追加“s从start(包括)到end(不包括)的内容”。\n    public StringBuilder append(CharSequence s, int start, int end) {\n        super.append(s, start, end);\n        return this;\n    }\n    \n    // 追加“str字符数组对应的字符串”\n    public StringBuilder append(char[] str) {\n        super.append(str);\n        return this;\n    }\n    \n    // 追加“str从offset开始的内容，内容长度是len”\n    public StringBuilder append(char[] str, int offset, int len) {\n        super.append(str, offset, len);\n        return this;\n    }\n    \n    // 追加“b对应的字符串”\n    public StringBuilder append(boolean b) {\n        super.append(b);\n        return this;\n    }\n    \n    // 追加“c”\n    public StringBuilder append(char c) {\n        super.append(c);\n        return this;\n    }\n    \n    // 追加“i”\n    public StringBuilder append(int i) {\n        super.append(i);\n        return this;\n    }\n    \n    // 追加“lng”\n    public StringBuilder append(long lng) {\n        super.append(lng);\n        return this;\n    }\n    \n    // 追加“f”\n    public StringBuilder append(float f) {\n        super.append(f);\n        return this;\n    }\n    \n    // 追加“d”\n    public StringBuilder append(double d) {\n        super.append(d);\n        return this;\n    }\n    \n    // 追加“codePoint”\n    public StringBuilder appendCodePoint(int codePoint) {\n        super.appendCodePoint(codePoint);\n        return this;\n    }\n    \n    // 删除“从start(包括)到end的内容”\n    public StringBuilder delete(int start, int end) {\n        super.delete(start, end);\n        return this;\n    }\n    \n    // 删除“位置index的内容”\n    public StringBuilder deleteCharAt(int index) {\n        super.deleteCharAt(index);\n        return this;\n    }\n    \n    // “用str替换StringBuilder中从start(包括)到end(不包括)的内容”\n    public StringBuilder replace(int start, int end, String str) {\n        super.replace(start, end, str);\n        return this;\n    }\n    \n    // “在StringBuilder的位置index处插入‘str中从offset开始的内容’，插入内容长度是len”\n    public StringBuilder insert(int index, char[] str, int offset,\n    int len)\n    {\n        super.insert(index, str, offset, len);\n        return this;\n    }\n    \n    // “在StringBuilder的位置offset处插入obj对应的字符串”\n    public StringBuilder insert(int offset, Object obj) {\n    \treturn insert(offset, String.valueOf(obj));\n    }\n    \n    // “在StringBuilder的位置offset处插入str”\n    public StringBuilder insert(int offset, String str) {\n        super.insert(offset, str);\n        return this;\n    }\n    \n    // “在StringBuilder的位置offset处插入str”\n    public StringBuilder insert(int offset, char[] str) {\n        super.insert(offset, str);\n        return this;\n    }\n    \n    // “在StringBuilder的位置dstOffset处插入s”\n    public StringBuilder insert(int dstOffset, CharSequence s) {\n        if (s == null)\n       \t \ts = "null";\n        if (s instanceof String)\n        \treturn this.insert(dstOffset, (String)s);\n        return this.insert(dstOffset, s, 0, s.length());\n    }\n    \n    // “在StringBuilder的位置dstOffset处插入\'s中从start到end的内容\'”\n    public StringBuilder insert(int dstOffset, CharSequence s,\n    int start, int end)\n    {\n        super.insert(dstOffset, s, start, end);\n        return this;\n    }\n    \n    // “在StringBuilder的位置Offset处插入b”\n    public StringBuilder insert(int offset, boolean b) {\n        super.insert(offset, b);\n        return this;\n    }\n    \n    // “在StringBuilder的位置Offset处插入c”\n    public StringBuilder insert(int offset, char c) {\n        super.insert(offset, c);\n        return this;\n    }\n    \n    // “在StringBuilder的位置Offset处插入i”\n    public StringBuilder insert(int offset, int i) {\n    \treturn insert(offset, String.valueOf(i));\n    }\n\n    // “在StringBuilder的位置Offset处插入l”\n    public StringBuilder insert(int offset, long l) {\n    \treturn insert(offset, String.valueOf(l));\n    }\n    \n    // “在StringBuilder的位置Offset处插入f”\n    public StringBuilder insert(int offset, float f) {\n    \treturn insert(offset, String.valueOf(f));\n    }\n    \n    // “在StringBuilder的位置Offset处插入d”\n    public StringBuilder insert(int offset, double d) {\n   \t\t return insert(offset, String.valueOf(d));\n    }\t\n    \n    // 返回“str”在StringBuilder的位置\n    public int indexOf(String str) {\n   \t\t return indexOf(str, 0);\n    }\n    \n    // 从fromIndex开始查找，返回“str”在StringBuilder的位置\n    public int indexOf(String str, int fromIndex) {\n        return String.indexOf(value, 0, count,\n        \tstr.toCharArray(), 0, str.length(),fromIndex);\n    }\n    \n    // 从后向前查找，返回“str”在StringBuilder的位置\n    public int lastIndexOf(String str) {\n   \t\t return lastIndexOf(str, count);\n    }\n    \n    // 从fromIndex开始，从后向前查找，返回“str”在StringBuilder的位置\n    public int lastIndexOf(String str, int fromIndex) {\n    return String.lastIndexOf(value, 0, count,\n    \tstr.toCharArray(), 0, str.length(),fromIndex);\n    }\n    \n    // 反转StringBuilder\n    public StringBuilder reverse() {\n        super.reverse();\n        return this;\n    }\n    \n    public String toString() {\n    // Create a copy, don\'t share the array\n    \treturn new String(value, 0, count);\n    }\n    \n    // 序列化对应的写入函数\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n            s.defaultWriteObject();\n            s.writeInt(count);\n            s.writeObject(value);\n    }\n    \n        // 序列化对应的读取函数\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n            s.defaultReadObject();\n            count = s.readInt();\n            value = (char[]) s.readObject();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n\n\n\n# 2、常用方法\n\n# insert\n\npublic static void main(String[] args) {\n    StringBuilder sbuilder = new StringBuilder();\n    // 在位置0处插入字符数组\n    sbuilder.insert(0, new char[]{\'a\', \'b\', \'c\', \'d\', \'e\'});\n    // 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度\n    sbuilder.insert(0, new char[]{\'A\', \'B\', \'C\', \'D\', \'E\'}, 0, 3);\n    // 在位置0处插入float\n    sbuilder.insert(0, 1.414f);\n    // 在位置0处插入double\n    sbuilder.insert(0, 3.14159d);\n    // 在位置0处插入boolean\n    sbuilder.insert(0, true);\n    // 在位置0处插入char\n    sbuilder.insert(0, \'\\n\');\n    // 在位置0处插入int\n    sbuilder.insert(0, 100);\n    // 在位置0处插入long\n    sbuilder.insert(0, 12345L);\n    // 在位置0处插入StringBuilder对象\n    sbuilder.insert(0, new StringBuilder("StringBuilder"));\n    // 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括)\n    sbuilder.insert(0, new StringBuilder("STRINGBUILDER"), 6, 13);\n    // 在位置0处插入StringBuffer对象。\n    sbuilder.insert(0, new StringBuffer("StringBuffer"));\n    // 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括)\n    sbuilder.insert(0, new StringBuffer("STRINGBUFFER"), 6, 12);\n    // 在位置0处插入String对象。\n    sbuilder.insert(0, "String");\n    // 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括)\n    sbuilder.insert(0, "0123456789", 1, 6);\n    sbuilder.insert(0, \'\\n\');\n    \n    // 在位置0处插入Object对象。此处以HashMap为例\n    HashMap map = new HashMap();\n    map.put("1", "one");\n    map.put("2", "two");\n    map.put("3", "three");\n    \n    sbuilder.insert(0, map);\n    \n    System.out.printf("%s\\n\\n", sbuilder);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# append\n\npublic static void main(String[] args) {\n    StringBuilder sbuilder = new StringBuilder();\n    // 追加字符数组\n    sbuilder.append(new char[]{\'a\', \'b\', \'c\', \'d\', \'e\'});\n    // 追加字符数组。0表示字符数组起始位置，3表示长度\n    sbuilder.append(new char[]{\'A\', \'B\', \'C\', \'D\', \'E\'}, 0, 3);\n    // 追加float\n    sbuilder.append(1.414f);\n    // 追加double\n    sbuilder.append(3.14159d);\n    // 追加boolean\n    sbuilder.append(true);\n    // 追加char\n    sbuilder.append(\'\\n\');\n    // 追加int\n    sbuilder.append(100);\n    // 追加long\n    sbuilder.append(12345L);\n    // 追加StringBuilder对象\n    sbuilder.append(new StringBuilder("StringBuilder"));\n    // 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括)\n    sbuilder.append(new StringBuilder("STRINGBUILDER"), 6, 13);\n    // 追加StringBuffer对象。\n    sbuilder.append(new StringBuffer("StringBuffer"));\n    // 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括)\n    sbuilder.append(new StringBuffer("STRINGBUFFER"), 6, 12);\n    // 追加String对象。\n    sbuilder.append("String");\n    // 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括)\n    sbuilder.append("0123456789", 1, 6);\n\n    sbuilder.append(\'\\n\');\n\n    // 追加Object对象。此处以HashMap为例\n    HashMap map = new HashMap();\n    map.put("1", "one");\n    map.put("2", "two");\n    map.put("3", "three");\n    sbuilder.append(map);\n    sbuilder.append(\'\\n\');\n\n    // 追加unicode编码\n    sbuilder.appendCodePoint(0x5b57); // 0x5b57是“字”的unicode编码\n    sbuilder.appendCodePoint(0x7b26); // 0x7b26是“符”的unicode编码\n    sbuilder.appendCodePoint(0x7f16); // 0x7f16是“编”的unicode编码\n    sbuilder.appendCodePoint(0x7801); // 0x7801是“码”的unicode编码\n\n    System.out.printf("%s\\n\\n", sbuilder);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# replace\n\npublic static void main(String[] args) {\n    StringBuilder sbuilder;\n    \n    sbuilder = new StringBuilder("0123456789");\n    sbuilder.replace(0, 3, "ABCDE");\n    System.out.printf("sbuilder=%s\\n", sbuilder);\n\n    sbuilder = new StringBuilder("0123456789");\n    sbuilder.reverse();\n    System.out.printf("sbuilder=%s\\n", sbuilder);\n\n    sbuilder = new StringBuilder("0123456789");\n    sbuilder.setCharAt(0, \'M\');\n    System.out.printf("sbuilder=%s\\n", sbuilder);\n    System.out.println();\n    /*\n    sbuilder=ABCDE3456789\n    sbuilder=9876543210\n    sbuilder=M123456789\n*/\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# delete\n\npublic static void main(String[] args) {\n    StringBuilder sbuilder = new StringBuilder("0123456789");\n\n    // 删除位置0的字符，剩余字符是“123456789”。\n    sbuilder.deleteCharAt(0);\n    // 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。\n    sbuilder.delete(3, 6);\n\n    // 获取sb中从位置1开始的字符串\n    String str1 = sbuilder.substring(1);\n    // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串\n    String str2 = sbuilder.substring(3, 5);\n    // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为String\n    String str3 = (String) sbuilder.subSequence(3, 5);\n    \n    System.out.printf("sbuilder=%s\\nstr1=%s\\nstr2=%s\\nstr3=%s\\n",\n            sbuilder, str1, str2, str3);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# index\n\npublic static void main(String[] args) {\n    StringBuilder sbuilder = new StringBuilder("abcAbcABCabCaBcAbCaBCabc");\n    \n    System.out.printf("sbuilder=%s\\n", sbuilder);\n    \n    // 1. 从前往后，找出"bc"第一次出现的位置\n    System.out.printf("%-30s = %d\\n", "sbuilder.indexOf(\\"bc\\")", sbuilder.indexOf("bc"));\n    \n    // 2. 从位置5开始，从前往后，找出"bc"第一次出现的位置\n    System.out.printf("%-30s = %d\\n", "sbuilder.indexOf(\\"bc\\", 5)", sbuilder.indexOf("bc", 5));\n    \n    // 3. 从后往前，找出"bc"第一次出现的位置\n    System.out.printf("%-30s = %d\\n", "sbuilder.lastIndexOf(\\"bc\\")", sbuilder.lastIndexOf("bc"));\n    \n    // 4. 从位置4开始，从后往前，找出"bc"第一次出现的位置\n    System.out.printf("%-30s = %d\\n", "sbuilder.lastIndexOf(\\"bc\\", 4)", sbuilder.lastIndexOf("bc", 4));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 其他API\n\npublic static void main(String[] args) {\n    StringBuilder sbuilder = new StringBuilder("0123456789");\n\n    int cap = sbuilder.capacity();\n    System.out.printf("cap=%d\\n", cap);\n\n    /*\n    capacity()返回的是字符串缓冲区的容量\n    StringBuffer( ); 分配16个字符的缓冲区\n    StringBuffer( int len ); 分配len个字符的缓冲区\n    StringBuffer( String s ); 除了按照s的大小分配空间外,再分配16个 字符的缓冲区\n    你的StringBuffer是用字符构造的，"0123456789"的长度是10另外再分配16个字符，所以一共是26。\n    */\n\n    char c = sbuilder.charAt(6);\n    System.out.printf("c=%c\\n", c);\n    \n    char[] carr = new char[4];\n    sbuilder.getChars(3, 7, carr, 0);\n    for (int i = 0; i < carr.length; i++) {\n        System.out.printf("carr[%d]=%c ", i, carr[i]);\n    }\n    System.out.println();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 3、StringBuffer\n\n和StringBulider用法差不多，不过多介绍，主要看一下三者的区别\n\nStringBuffer是线程安全的，推荐在多线程里使用。\n\n\n# 4、小结\n\nString、StringBuffer、StringBuilder之间的区别\n\n首先需要说明的是：\n\n * String 字符串常量\n * StringBuffer 字符串变量（线程安全）\n * StringBuilder 字符串变量（非线程安全）\n\n在大多数情况下三者在执行速度方面的比较：StringBuilder > StringBuffer > String\n\n解释：\n\nString 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象，因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n\n而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。\n\n为什么是大多数情况呢？\n\n在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接， 所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\nString S1 = “This is only a” + “ simple” + “ test”;\nStringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”);\n\n\n1\n2\n\n\n你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本 一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n\nString S1 = “This is only a” + “ simple” + “test”;\n\n其实就是：String S1 = “This is only a simple test”;\n\n所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象 的话，速度就没那么快了，譬如：\n\n> String S2 = “This is only a”; String S3 = “ simple”; String S4 = “ test”;\n\n大部分情况下StringBuilder的速度要大于StringBuffer：\n\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。（大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的）此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个 线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。\n\n对于三者使用的总结：\n\n * 如果要操作少量的数据用 ：String\n * 单线程操作字符串缓冲区 下操作大量数据 ：StringBuilder\n * 多线程操作字符串缓冲区 下操作大量数据 ： StringBuffer\n\n\n# 5、面试题的回答\n\nStringBuilder 与StringBuffer的区别，StringBuilder与String的区别。\n\n1）StringBuilder效率高，线程不安全，StringBuffer对比之下没它高，线程安全。\n\n2）String是不可变字符串，StringBuilder是可变字符串。为什么有这样的差异，可以深入源码去解析， 比如String类内的 priver final char value[] 等方法的原因。\n\n3）如果是简单的声明一个字符串没有后续过多的操作，使用String,StringBuilder均可，若后续对字符穿做频繁的添加，删除操作,或者是在循环当中动态的改变字符穿的长度应该用StringBuilder。使用String 会产生多余的字符串，占用内存空间。\n\n\n# File类\n\n\n# 1、File类的基本用法\n\njava.io.File类：文件和目录路径名的抽象表示形式。\n\nFile类的常见构造方法：\n\npublic File(String pathname)\n\n\n1\n\n\n以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir 中存储。\n\nFile的静态属性String separator存储了当前系统的路径分隔符。\n\n通过File对象可以访问文件的属性。\n\npublic boolean canRead()\npublic boolean exists()\npublic boolean isFile()\npublic long lastModified()\npublic String getName()\npublic boolean canWrite()\npublic boolean isDirectory()\npublic boolean isHidden()\npublic long length()\npublic String getPath()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n通过File对象创建空文件或目录（在该对象所指的文件或目录不存在的情况下）。\n\npublic boolean createNewFile()throws IOException\npublic boolean delete()\npublic boolean mkdir()， mkdirs()\n\n\n1\n2\n3\n\n\n常见构造器，方法\n\nimport java.io.File;\nimport java.io.IOException;\npublic class TestFile {\n    /**\n    * File文件类 1.代表文件 2.代表目录\n    */\n    public static void main(String[] args) {\n        File f = new File("d:/src3/TestObject.java");\n        File f2 = new File("d:/src3");\n        File f3 = new File(f2, "TestFile.java");\n        File f4 = new File(f2, "TestFile666.java");\n        File f5 = new File("d:/src3/aa/bb/cc/dd");\n        //f5.mkdirs();\n        f5.delete();\n\n        try {\n            f4.createNewFile();\n            System.out.println("文件创建成功！");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (f.isFile()) {\n            System.out.println("是一个文件！");\n        }\n        if (f2.isDirectory()) {\n            System.out.println("是一个目录！");\n        }\n        if (f3.isFile()) {\n            System.out.println("是一个文件奥");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',normalizedContent:'# javase-常用类\n\n\n\n * object类\n   * 1 clone() 方法\n   * 2 tostring()方法\n   * 3 getclass()方法\n   * 4 finalize()方法\n   * 5 equals()方法\n   * 6 hashcode()方法\n   * 7 wait()方法\n   * 8 notify()方法\n * 包装类\n   * 1、包装类介绍\n   * 2、包装类的应用\n   * 3、将整数转换为字符串\n   * 3、自动拆箱和装箱\n * math类\n * random类\n * 日期时间类\n   * 1 date类\n   * 2、simpledateformat\n   * 3、calendar类\n * string类\n   * 1、string概述\n   * 2、创建字符串对象方式\n   * 3、string常用的方法\n   * 4、string的不可变性\n   * 5、字符串常量池\n * stringbuilder和stringbuffer\n   * 1、概述\n   * 2、常用方法\n   * 3、stringbuffer\n   * 4、小结\n   * 5、面试题的回答\n * file类\n   * 1、file类的基本用法\n\n\n\n\n# object类\n\n理论上object类是所有类的父类，即直接或间接的继承java.lang.object类。\n\n由于所有的类都继承在object类，因此省略了extends object关键字。\n\n该类中主要有以下方法：\n\n * tostring( )\n * getclass( )\n * equals( )\n * clone( )\n * finalize( )\n\n其中tostring()，getclass()，equals是其中最重要的方法。\n\n查看object类源码\n\n\n\n看图可知，在jdk15中最后一个方法过时了，但我们运营一般都是jdk1.8\n\n注意： object类中的getclass(),notify(),notifyall(),wait()等方法被定义为final类型，因此不能重写。\n\n\n# 1 clone() 方法\n\n详解文章：https://blog.csdn.net/zhangjg_blog/article/details/18369201#0-qzone-1-28144-d020d2d2a4e8d1a374a433f596ad1440\n\n protected native object clone() throws clonenotsupportedexception;\n\n\n1\n\n\nclone顾名思义就是复制， 在java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几种方式可以创建对象呢？\n\n * 使用new操作符创建一个对象\n * 使用clone方法复制一个对象\n\n那么这两种方式有什么相同和不同呢？ new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后， 再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。\n\nclone与copy的区别\n\n假设现在有一个employee对象，employee tobby = new employee(“cmtobby”,5000)\n\n通常我们会有这样的赋值employee cindyelf = tobby，这个时候只是简单了copy了一下reference。cindyelf和tobby都指向内存中同一个object，这样cindyelf或者tobby的一个操作都可能影响到对方。打个比方，如果我们通过cindyelf.raisesalary()方法改变了salary域的值，那么tobby通过getsalary()方法，得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。我们希望得到tobby的一个精确拷贝，同时两者互不影响，这时候， 我们就可以使用clone来满足我们的需求。employee cindy=tobby.clone()，这时会生成一个新的employee对象，并且和tobby具有相同的属性值和方法。\n\nshallow clone与deep clone\n\n浅克隆和深克隆\n\n * 浅克隆：\n   \n   是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。\n\n * 深克隆：\n   \n   不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。\n\n举例来说更加清楚。\n\n\n\n主要是java里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用，我们有时候不希望在方法里将参数改变，这是就需要在类中复写clone方法（实现深复制）。\n\nclone是如何完成的呢？object在对某个对象实施clone时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是shallow clone。这样，问题就来了咯。\n\n以employee为例，它里面有一个域hireday不是基本数据类型的变量，而是一个reference变量，经过clone之后就会产生一个新的date型的reference，\n\n它和原始对象中对应的域指向同一个date对象，这样克隆类就和原始类共享了一部分信息，而这样显然是不利的，过程下图所示：\n\n\n\n这个时候我们就需要进行deep clone了，对那些非基本类型的域进行特殊的处理，例如本例中的 hireday。我们可以重新定义clone方法，对hireday做特殊处理，如下代码所示：\n\nclass employee implements cloneable {\n    public object clone() throws clonenotsupportedexception {\n        employee cloned = (employee) super.clone();\n        cloned.hireday = (date) hireday.clone()\n        return cloned;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nclone方法的保护机制\n\n在object中clone()是被声明为protected的，这样做是有一定的道理的，以employee类为例，通过声明为protected，就可以保证只有employee类里面才能“克隆”employee对象。\n\nclone方法的使用\n\n什么时候使用shallow clone，什么时候使用deep clone，这个主要看具体对象的域是什么性质的，基本型别还是reference variable\n\n调用clone()方法的对象所属的类(class)必须implements clonable接口，否则在调用clone方法的时候 会抛出clonenotsupportedexception\n\n推荐： 浅克隆(shallowclone)和深克隆(deepclone)区别以及实现\n\n\n# 2 tostring()方法\n\npublic string tostring() {\n\treturn getclass().getname() + "@" + integer.tohexstring(hashcode());\n}\n\n\n1\n2\n3\n\n\nobject 类的 tostring 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@” 和此对象哈希码的无符号十六进制表示组成。\n\n该方法用得比较多，一般子类都有覆盖。\n\npublic static void main(string[] args){\n    object o1 = new object();\n    system.out.println(o1.tostring());\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3 getclass()方法\n\npublic final native class<?> getclass();\n\n\n1\n\n\n返回次object的运行时类类型。\n\n不可重写，要调用的话，一般和getname()联合使用，如getclass().getname();\n\npublic static void main(string[] args) {\n    object o = new object();\n    system.out.println(o.getclass());\n    //class java.lang.object\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4 finalize()方法\n\nprotected void finalize() throws throwable { }\n\n\n1\n\n\n该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。\n\njava允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。\n\n关于垃圾回收，有三点需要记住：\n\n1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。\n\n2、垃圾回收并不等于“析构”。\n\n科普：析构函数(destructor) 与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。\n\n3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。\n\nfinalize()的用途：\n\n无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。\n\n这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在java中调用非java代码的方式。\n\n\n# 5 equals()方法\n\npublic boolean equals(object obj) {\n\treturn (this == obj);\n}\n\n\n1\n2\n3\n\n\nobject中的equals方法是直接判断this和obj本身的值是否相等，即用来判断调用equals的对象和形参 obj所引用的对象是否是同一对象\n\n所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true，如果this和obj指向的不是同一块内存，则返回false。\n\n注意：即便是内容完全相等的两块不同的内存对象，也返回false。\n\n如果是同一块内存，则object中的equals方法返回true，如果是不同的内存，则返回false\n\n如果希望不同内存但相同内容的两个对象equals时返回true，则我们需要重写父类的equal方法\n\nstring类已经重写了object中的equals方法（这样就是比较内容是否相等了）\n\n查看string类源码equals方法\n\npublic boolean equals(object anobject) {\n    if (this == anobject) {\n        return true;\n    }\n    if (anobject instanceof string) {\n        string anotherstring = (string)anobject;\n        int n = value.length;\n        if (n == anotherstring.value.length) {\n            char v1[] = value;\n            char v2[] = anotherstring.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6 hashcode()方法\n\npublic native int hashcode();\n\n\n1\n\n\n返回该对象的哈希码值。\n\n该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写 hashcode方法。这个方法在一些具有哈希功能的collection中用到。\n\n一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashcode() == obj2.hashcode()，但是 hashcode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\n\n\n# 7 wait()方法\n\npublic final void wait(long timeoutmillis, int nanos) throws interruptedexception {\n    if (timeoutmillis < 0) {\n        throw new illegalargumentexception("timeoutmillis value is negative");\n    }\n\n    if (nanos < 0 || nanos > 999999) {\n        throw new illegalargumentexception(\n                            "nanosecond timeout value out of range");\n    }\n\n    if (nanos > 0 && timeoutmillis < long.max_value) {\n        timeoutmillis++;\n    }\n\n    wait(timeoutmillis);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可以看到有三种重载，wait什么意思呢？\n\n\n\n方法中的异常：\n\n\n\nwait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。\n\nwait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔\n\n如果在规定时间内没有获得锁就返回。\n\n调用该方法后当前线程进入睡眠状态，直到以下事件发生。\n\n（1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyall方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。\n\n此时该线程就可以被调度了，如果是被中断的话就抛出一个interruptedexception异常。\n\n\n# 8 notify()方法\n\npublic final native void notify();\n\n\n1\n\n\n该方法唤醒在该对象上等待的某个线程。\n\npublic final native void notifyall();\n\n\n1\n\n\n该方法唤醒在该对象上等待的所有线程。\n\n\n# 包装类\n\n\n# 1、包装类介绍\n\n虽然 java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。\n\n这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 object 类的特性，要转换为 string 类型（经常有这种需要）时只要简单调用 object 类中定义的tostring()即可，而基本数据类型转换为 string 类型则要麻烦得多。为解决此类问题 ，java为每种基本数据类型分别设计了对应的类，称之为包装类(wrapper classes)，也有教材称为外覆类或数据类型类。\n\n基本数据类型    对应的包装类\nbyte      byte\nshort     short\nint       integer\nlong      long\nchar      character\nfloat     float\ndouble    double\nboolean   boolean\n\n每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一 经创建，其内容（所封装的基本类型数据值）不可改变。\n\n基本类型和对应的包装类可以相互装换：\n\n * 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 integer 类的对象；\n * 包装类向对应的基本类型转换称为拆箱，例如把 integer 类的对象重新简化为 int。\n\n\n# 2、包装类的应用\n\n1、 实现 int 和 integer 的相互转换\n\n可以通过 integer 类的构造方法将 int 装箱，通过 integer 类的 intvalue 方法将 integer 拆箱。\n\npublic static void main(string[] args) {\n    int m = 500;\n    integer obj = new integer(m); // 手动装箱\n    int n = obj.intvalue(); // 手动拆箱\n    system.out.println("n = " + n);\n    \n    integer obj1 = new integer(500);\n    system.out.println("obj 等价于 obj1？" + obj.equals(obj1));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、 将字符串转换为整数\n\ninteger 类有一个静态的 paseint() 方法，可以将字符串转换为整数，语法为：\n\nparseint(string s, int radix);\n//s 为要转换的字符串，radix 为进制，可选，默认为十进制。\n\n\n1\n2\n\n\n下面的代码将会告诉你什么样的字符串可以转换为整数：\n\npublic static void main(string[] args) {\n    string[] strs = {"123", "123abc", "abc123", "abcxyz"};\n    for (string str : strs) {\n        try {\n            int m = integer.parseint(str, 10);\n            system.out.println(str + " 可以转换为整数 " + m);\n        } catch (exception e) {\n            system.out.println(str + " 无法转换为整数");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n> 123 可以转换为整数 123 123abc 无法转换为整数 abc123 无法转换为整数 abcxyz 无法转换为整数\n\n\n# 3、将整数转换为字符串\n\ninteger 类有一个静态的 tostring() 方法，可以将整数转换为字符串。或者直接在整数后面加空字符串！\n\npublic static void main(string[] args) {\n    int m = 500;\n    string s = integer.tostring(m);\n    \n    string s2 = m +"";\n    system.out.println("s = " + s);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、自动拆箱和装箱\n\n上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。java 1.5(5.0) 之前必须手动拆箱装箱。\n\njava 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。\n\npublic static void main(string[] args) {\n    int m = 500;\n    integer obj = m; // 自动装箱\n    int n = obj; // 自动拆箱\n    system.out.println("n = " + n);\n    integer obj1 = 500;\n    system.out.println("obj 等价于 obj1？" + obj.equals(obj1));\n}\n//结果：\n// n = 500\n// obj 等价于 obj1？true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n自动装箱与拆箱的功能事实上是编译器来帮您的忙，编译器在编译时期依您所编写的语法，决定是否进行装箱或拆箱动作。例如：\n\ninteger i = 100;\n//相当于编译器自动为您作以下的语法编译：\ninteger i = new integer(100);\n\n\n1\n2\n3\n\n\n所以自动装箱与拆箱的功能是所谓的“编译器蜜糖”(compiler sugar)，虽然使用这个功能很方便，但在程序运行阶段你要了解java的语义。例如下面的程序是可以通过编译的：\n\ninteger i = null;\nint j = i;\n\n\n1\n2\n\n\n这样的语法在编译时期是合法的，但是在运行时期会有错误，因为这种写法相当于：\n\ninteger i = null;\nint j = i.intvalue();\n\n\n1\n2\n\n\nnull表示i 没有参考至任何的对象实体，它可以合法地指定给对象参考名称。由于实际上 i 并没有参考至任何的对象，所以也就不可能操作intvalue()方法，这样上面的写法在运行时会出现nullpointerexception 错误。\n\n自动拆箱装箱是常用的一个功能，需要重点掌握。\n\n一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，java 语言为每一个内置数据类型提供了对应的包装类。\n\n所有的包装类（integer、long、byte、double、float、short）都是抽象类 number 的子类。\n\n\n# math类\n\njava 的 math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nmath 的方法都被定义为 static 形式，通过 math 类可以在主函数中直接调用\n\n【演示：查看math类的源码】\n\npublic final class math{\n\t//数学方法\n}\n\n\n1\n2\n3\n\n\n【常用值与函数】\n\nmath.pi 记录的圆周率 math.e 记录e的常量\n\nmath中还有一些类似的常量，都是一些工程数学常用量。\n\nmath.abs 求绝对值 math.sin 正弦函数 math.asin 反正弦函数 math.cos 余弦函数 math.acos 反余弦函数 math.tan 正切函数 math.atan 反正切函数 math.atan2 商的反正切函数 math.todegrees 弧度转化为角度 math.toradians 角度转化为弧度 math.ceil 得到不小于某数的最大整数 math.floor 得到不大于某数的最大整数 math.ieeeremainder 求余 math.max 求两数中最大 math.min 求两数中最小 math.sqrt 求开方 math.pow 求某数的任意次方, 抛出arithmeticexception处理溢出异常\n\nmath.exp 求e的任意次方 math.log10 以10为底的对数 math.log 自然对数 math.rint 求距离某数最近的整数（可能比某数大，也可能比它小） math.round 同上，返回int型或者long型（上一个函数返回double型） math.random 返回0，1之间的一个随机数\n\npublic static void main(string[] args) {\n    /**\n     *math.sqrt()//计算平方根\n     *math.cbrt()//计算立方根\n     *math.pow(a, b)//计算a的b次方\n     *math.max( , );//计算最大值\n     *math.min( , );//计算最小值\n     */\n    system.out.println(math.sqrt(16)); //4.0\n    system.out.println(math.cbrt(8)); //2.0\n    system.out.println(math.pow(3, 2)); //9.0\n    system.out.println(math.max(2.3, 4.5));//4.5\n    system.out.println(math.min(2.3, 4.5));//2.3\n    /**\n     * abs求绝对值\n     */\n    system.out.println(math.abs(-10.4)); //10.4\n    system.out.println(math.abs(10.1)); //10.1\n    /**\n     * ceil天花板的意思，就是返回大的值\n     */\n    system.out.println(math.ceil(-10.1)); //-10.0\n    system.out.println(math.ceil(10.7)); //11.0\n    system.out.println(math.ceil(-0.7)); //-0.0\n    system.out.println(math.ceil(0.0)); //0.0\n    system.out.println(math.ceil(-0.0)); //-0.0\n    system.out.println(math.ceil(-1.7)); //-1.0\n    /**\n     * floor地板的意思，就是返回小的值\n     */\n    system.out.println(math.floor(-10.1)); //-11.0\n    system.out.println(math.floor(10.7)); //10.0\n    system.out.println(math.floor(-0.7)); //-1.0\n    system.out.println(math.floor(0.0)); //0.0\n    system.out.println(math.floor(-0.0)); //-0.0\n    /**\n     * random 取得一个大于或者等于0.0小于不等于1.0的随机数 [0,1)\n     */\n    system.out.println(math.random()); //小于1大于0的double类型的数\n    system.out.println(math.random() + 1);//大于1小于2的double类型的数\n    /**\n     * rint 四舍五入，返回double值\n     * 注意.5的时候会取偶数 异常的尴尬=。=\n     */\n    system.out.println(math.rint(10.1)); //10.0\n    system.out.println(math.rint(10.7)); //11.0\n    system.out.println(math.rint(11.5)); //12.0\n    system.out.println(math.rint(10.5)); //10.0\n    system.out.println(math.rint(10.51)); //11.0\n    system.out.println(math.rint(-10.5)); //-10.0\n    system.out.println(math.rint(-11.5)); //-12.0\n    system.out.println(math.rint(-10.51)); //-11.0\n    system.out.println(math.rint(-10.6)); //-11.0\n    system.out.println(math.rint(-10.2)); //-10.0\n    /**\n     * round 四舍五入，float时返回int值，double时返回long值\n     */\n    system.out.println(math.round(10.1)); //10\n    system.out.println(math.round(10.7)); //11\n    system.out.println(math.round(10.5)); //11\n    system.out.println(math.round(10.51)); //11\n    system.out.println(math.round(-10.5)); //-10\n    system.out.println(math.round(-10.51)); //-11\n    system.out.println(math.round(-10.6)); //-11\n    system.out.println(math.round(-10.2)); //-10\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# random类\n\njava中存在着两种random函数：\n\n1、java.lang.math.random;\n\n调用这个math.random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是 [0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。例子如下：\n\npublic static void main(string[] args) {\n    // 结果是个double类型的值，区间为[0.0,1.0）\n    system.out.println("math.random()=" + math.random());\n    int num = (int) (math.random() * 3);\n    // 注意不要写成(int)math.random()*3，这个结果为0或1，因为先执行了强制转换\n    system.out.println("num=" + num);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n2、java.util.random\n\n下面是random()的两种构造方法：\n\nrandom()：创建一个新的随机数生成器 random(long seed)：使用单个 long 种子创建一个新的随机数生成器。\n\n你在创建一个random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。\n\n如下面的java代码：\n\n【演示一】\n\n在没带参数构造函数生成的random对象的种子是当前系统时间的毫秒数。\n\nrand.nextint(100)中的100是随机数的上限,产生的随机数为0-100的整数，不包括100。\n\npublic static void main(string[] args) {\n    random rand = new random();\n    int i = rand.nextint(100);\n    system.out.println(i);\n}\n\n\n1\n2\n3\n4\n5\n\n\n【演示二】\n\n对于种子相同的random对象，多次执行后生成的随机数序列是一样的。\n\npublic static void main(string[] args) {\n    random ran1 = new random(25);\n    system.out.println("使用种子为25的random对象生成[0,100)内随机整数序列: ");\n    for (int i = 0; i < 10; i++) {\n        system.out.print(ran1.nextint(100) + " ");\n    }\n    system.out.println();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【方法摘要】\n\n 1.  protected int next(int bits)：生成下一个伪随机数。\n 2.  boolean nextboolean()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean值。\n 3.  void nextbytes(byte[] bytes)：生成随机字节并将其置于用户提供的 byte 数组中。\n 4.  double nextdouble()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间 均匀分布的 double值。\n 5.  float nextfloat()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布float值。\n 6.  double nextgaussian()：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。\n 7.  int nextint()：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。\n 8.  int nextint(int n)：返回一个伪随机数，它是取自此随机数生成器序列的、在（包括和指定值（不包括）之间均匀分布的int值。\n 9.  long nextlong()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。\n 10. void setseed(long seed)：使用单个 long 种子设置此随机数生成器的种子。\n\n【例子】\n\n 1. 生成[0,1.0)区间的小数：double d1 = r.nextdouble();\n 2. 生成[0,5.0)区间的小数：double d2 = r.nextdouble() * 5;\n 3. 生成[1,2.5)区间的小数：double d3 = r.nextdouble() * 1.5 + 1;\n 4. 生成[0,10)区间的整数：int n2 = r.nextint(10);\n\n\n# 日期时间类\n\n\n# 1 date类\n\njava.util 包提供了 date 类来封装当前的日期和时间。\n\ndate 类提供两个构造函数来实例化 date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\ndate()\n\n\n1\n\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。\n\ndate(long millisec)\n\n\n1\n\n\ndate对象创建以后，可以调用下面的方法。\n\n序号   方法和描述\n1    boolean after(date date)\n     若当调用此方法的date对象在指定日期之后返回true,否则返回false。\n2    boolean before(date date)\n     若当调用此方法的date对象在指定日期之前返回true,否则返回false。\n3    object clone( ) 返回此对象的副本。\n4    int compareto(date date)\n     比较当调用此方法的date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。\n5    int compareto(object obj) 若obj是date类型则操作等同于compareto(date)\n     。否则它抛出classcastexception。\n6    boolean equals(object date)\n     当调用此方法的date对象和指定日期相等时候返回true,否则返回false。\n7    long gettime( ) 返回自 1970 年 1 月 1 日 00:00:00 gmt 以来此 date\n     对象表示的毫秒数。\n8    int hashcode( ) 返回此对象的哈希码值。\n9    void settime(long time) 用自1970年1月1日00:00:00\n     gmt以后time毫秒数设置时间和日期。\n10   string tostring( ) 把此 date 对象转换为以下形式的 string： dow mon dd\n     hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (sun, mon, tue, wed, thu,\n     fri, sat)。\n\n【演示：获取当前日期时间】\n\njava中获取当前日期和时间很简单，使用 date 对象的 tostring() 方法来打印当前日期和时间\n\npublic static void main(string args[]) {\n    // 初始化 date 对象\n    date date = new date();\n\n    // 使用 tostring() 函数显示日期时间\n    system.out.println(date.tostring());\n    //tue mar 30 10:24:19 cst 2021\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【演示：日期比较】\n\n使用 gettime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n\npublic static void main(string[] args) {\n    // 初始化 date 对象\n    date date = new date();\n\n    long time = date.gettime();\n    long time2 = date.gettime();\n    system.out.println(time==time2);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new date(99, 2, 12).before(new date (99, 2, 18)) 返回true。\n\npublic static void main(string[] args) {\n    boolean before = new date(99, 01, 05).before(new date(99, 11, 16));\n    system.out.println(before);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2、simpledateformat\n\n格式化日期\n\nsimpledateformat 是一个以语言环境敏感的方式来格式化和分析日期的类。simpledateformat 允许你选择任何用户自定义日期时间格式来运行。例如：\n\npublic static void main(string args[]) {\n    date dnow = new date( );\n    simpledateformat ft = new simpledateformat ("yyyy-mm-dd hh:mm:ss");\n    system.out.println("当前时间为: " + ft.format(dnow));\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中 yyyy 是完整的公元年，mm 是月份，dd 是日期，hh:mm:ss 是时、分、秒。\n\n注意：有的格式大写，有的格式小写，例如 mm 是月份，mm 是分；hh 是 24 小时制，而 hh 是 12 小时制。\n\n时间模式字符串用来指定时间格式。在此模式中，所有的 ascii 字母被保留为模式字母，定义如下：\n\n字母   描述                     示例\ng    纪元标记                   ad\ny    四位年份                   2001\nm    月份                     july or 07\nd    一个月的日期                 10\nh    a.m./p.m. (1~12)格式小时   12\nh    一天中的小时 (0~23)          22\nm    分钟数                    30\ns    秒数                     55\ns    毫秒数                    234\ne    星期几                    tuesday\nd    一年中的日子                 360\nf    一个月中第几周的周几             2 (second wed. in july)\nw    一年中第几周                 40\nw    一个月中第几周                1\na    a.m./p.m. 标记           pm\nk    一天中的小时(1~24)           24\nk    a.m./p.m. (0~11)格式小时   10\nz    时区                     eastern standard time\n\'    文字定界符                  delimiter\n"    单引号                    `\n\n【演示：使用printf格式化日期】\n\njava 格式化输出 printf 例子：https://www.runoob.com/w3cnote/java-printf-formate-demo.html\n\nprintf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。\n\npublic static void main(string[] args) {\n    // 初始化 date 对象\n    date date = new date();\n    //c的使用\n    system.out.printf("全部日期和时间信息：%tc%n",date);\n    //f的使用\n    system.out.printf("年-月-日格式：%tf%n",date);\n    //d的使用\n    system.out.printf("月/日/年格式：%td%n",date);\n    //r的使用\n    system.out.printf("hh:mm:ss pm格式（12时制）：%tr%n",date);\n    //t的使用\n    system.out.printf("hh:mm:ss格式（24时制）：%tt%n",date);\n    //r的使用\n    system.out.printf("hh:mm格式（24时制）：%tr",date);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\n> 全部日期和时间信息：周二 3月 30 10:37:02 cst 2021 年-月-日格式：2021-03-30 月/日/年格式：03/30/21 hh:mm:ss pm格式（12时制）：10:37:02 上午 hh:mm:ss格式（24时制）：10:37:02 hh:mm格式（24时制）：10:37\n\n【时间休眠：休眠(sleep)】\n\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出cpu的使用、目的是不让当前线程独自霸占该进程所获的cpu资源，以留一定时间给其他线程执行的机会。\n\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：\n\npublic static void main(string args[]) {\n    try {\n        system.out.println(new date( ) + "\\n");\n        thread.sleep(1000*3); // 休眠3秒\n        system.out.println(new date( ) + "\\n");\n    } catch (exception e) {\n        system.out.println("got an exception!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3、calendar类\n\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用calendar类。date中有很多方法都已经废弃了！\n\ncalendar类的功能要比date类强大很多，而且在实现方式上也比date类要复杂一些。\n\ncalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getinstance方法创建即可。\n\n创建一个代表系统当前日期的calendar对象\n\npublic static void main(string args[]) {\n    calendar c = calendar.getinstance();//默认是当前日期\n    system.out.println(c);\n}\n\n\n1\n2\n3\n4\n\n\n输出：\n\n> java.util.gregoriancalendar[time=1617072097924,arefieldsset=true,areallfieldsset=true,lenient=true,zone=sun.util.calendar.zoneinfo[id="asia/shanghai",offset=28800000,dstsavings=0,usedaylight=false,transitions=31,lastrule=null],firstdayofweek=1,minimaldaysinfirstweek=1,era=1,year=2021,month=2,week_of_year=14,week_of_month=5,day_of_month=30,day_of_year=89,day_of_week=3,day_of_week_in_month=5,am_pm=0,hour=10,hour_of_day=10,minute=41,second=37,millisecond=924,zone_offset=28800000,dst_offset=0]\n\n创建一个指定日期的calendar对象\n\n使用calendar类代表特定的时间，需要首先创建一个calendar的对象，然后再设定该对象中的年月日参数来完成。\n\n//创建一个代表2019年4月27日的calendar对象\ncalendar c1 = calendar.getinstance();\nc1.set(2019, 4 - 1, 27);\n\n\n1\n2\n3\n\n\ncalendar类对象字段类型\n\ncalendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想\n\n常量                      描述\ncalendar.year           年份\ncalendar.month          月份\ncalendar.date           日期\ncalendar.day_of_month   日期，和上面的字段意义完全相同\ncalendar.hour           12小时制的小时\ncalendar.hour_of_day    24小时制的小时\ncalendar.minute         分钟\ncalendar.second         秒\ncalendar.day_of_week    星期几\n\n// 获得年份\nint year = c1.get(calendar.year);\n// 获得月份\nint month = c1.get(calendar.month) + 1;\n// 获得日期\nint date = c1.get(calendar.date);\n// 获得小时\nint hour = c1.get(calendar.hour_of_day);\n// 获得分钟\nint minute = c1.get(calendar.minute);\n// 获得秒\nint second = c1.get(calendar.second);\n// 获得星期几（注意（这个与date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）\nint day = c1.get(calendar.day_of_week);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n设置完整日期\n\ncalendar c1 = calendar.getinstance();\nc1.set(2009, 6 - 1, 12);//把calendar对象c1的年月日分别设这为：2009、6、12\n\n\n1\n2\n\n\n设置某个字段\n\nc1.set(calendar.date,10);\nc1.set(calendar.year,2008);\n//其他字段属性set的意义以此类推\n\n\n1\n2\n3\n\n\nadd设置\n\n//把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算\nc1.add(calendar.date, 10);\n//把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算\nc1.add(calendar.date, -10);\n\n\n1\n2\n3\n4\n\n\n【演示：gregoriancalendar】\n\npublic static void main(string[] args) {\n    string months[] = {\n            "jan", "feb", "mar", "apr",\n            "may", "jun", "jul", "aug",\n            "sep", "oct", "nov", "dec"};\n\n    int year;\n    // 初始化 gregorian 日历\n    // 使用当前时间和日期\n    // 默认为本地时间和时区\n    gregoriancalendar gcalendar = new gregoriancalendar();\n    // 显示当前时间和日期的信息\n    system.out.print("date: ");\n    system.out.print(months[gcalendar.get(calendar.month)]);\n    system.out.print(" " + gcalendar.get(calendar.date) + " ");\n    system.out.println(year = gcalendar.get(calendar.year));\n    system.out.print("time: ");\n    system.out.print(gcalendar.get(calendar.hour) + ":");\n    system.out.print(gcalendar.get(calendar.minute) + ":");\n    system.out.println(gcalendar.get(calendar.second));\n\n    // 测试当前年份是否为闰年\n    if (gcalendar.isleapyear(year)) {\n        system.out.println("当前年份是闰年");\n    } else {\n        system.out.println("当前年份不是闰年");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n输出：\n\n> date: mar 30 2021 time: 10:49:35 当前年份不是闰年\n\n注意：calender的月份是从0开始的，但日期和年份是从1开始的\n\n【演示】\n\npublic static void main(string[] args) {\n    calendar c1 = calendar.getinstance();\n    c1.set(2017, 1, 1);\n    system.out.println(c1.get(calendar.year)\n            + "-" + c1.get(calendar.month)\n            + "-" + c1.get(calendar.date));\n    c1.set(2017, 1, 0);\n    system.out.println(c1.get(calendar.year)\n            + "-" + c1.get(calendar.month)\n            + "-" + c1.get(calendar.date));\n}\n/*\n输出\n2017-1-1\n2017-0-31\n    /*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可见，将日期设为0以后，月份变成了上个月，但月份可以为0，把月份改为2试试：\n\npublic static void main(string[] args) {\n    calendar c1 = calendar.getinstance();\n    c1.set(2017, 2, 1);\n    system.out.println(c1.get(calendar.year)\n            + "-" + c1.get(calendar.month)\n            + "-" + c1.get(calendar.date));\n    c1.set(2017, 2, 0);\n    system.out.println(c1.get(calendar.year)\n            + "-" + c1.get(calendar.month)\n            + "-" + c1.get(calendar.date));\n}\n/*\n输出\n2017-2-1\n2017-1-28\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可以看到上个月的最后一天是28号，所以calendar.month为1的时候是2月 。\n\n\n# string类\n\n\n# 1、string概述\n\n在api中是这样描述：\n\nstring 类代表字符串。java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。 字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 string 对象是不可变的， 所以可以共享。\n\n【演示：查看string源码】\n\npublic final class string\nimplements java.io.serializable, comparable<string>, charsequence {\n    \n}\n\n\n1\n2\n3\n4\n\n\n【string的成员变量】\n\n//string的属性值\nprivate final char value[];\n\n//数组被使用的开始位置\nprivate final int offset;\n\n//string中元素的个数\nprivate final int count;\n\n//string类型的hash值\nprivate int hash; // default to 0\n\nprivate static final long serialversionuid = -6849794470754667710l;\nprivate static final objectstreamfield[] serialpersistentfields =\nnew objectstreamfield[0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n从源码看出string底层使用一个字符数组来维护的。\n\n成员变量可以知道string类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的 string类型对象，存储string数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始。\n\n【string的构造方法】\n\nstring()\n//初始化一个新创建的 string 对象，使其表示一个空字符序列。\n    \nstring(byte[] bytes)\n//通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 string。\n    \nstring(byte[] bytes, charset charset)\n//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 string。\n    \nstring(byte[] bytes, int offset, int length)\n//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 string。\n    \nstring(byte[] bytes, int offset, int length, charset charset)\n//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 string。\n    \nstring(byte[] bytes, int offset, int length, string charsetname)\n//通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 string。\n    \nstring(byte[] bytes, string charsetname)\n//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 string。\n    \nstring(char[] value)\n//分配一个新的 string，使其表示字符数组参数中当前包含的字符序列。\n    \nstring(char[] value, int offset, int count)\n//分配一个新的 string，它包含取自字符数组参数一个子数组的字符。\n    \nstring(int[] codepoints, int offset, int count)\n//分配一个新的 string，它包含 unicode 代码点数组参数一个子数组的字符。\n    \nstring(string original)\n//初始化一个新创建的 string 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。\n    \nstring(stringbuffer buffer)\n//分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。\n    \nstring(stringbuilder builder)\n//分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2、创建字符串对象方式\n\n直接赋值方式创建对象是在方法区的常量池\n\nstring str="hello";//直接赋值的方式\n\n\n1\n\n\n通过构造方法创建字符串对象是在堆内存\n\nstring str=new string("hello");//实例化的方式\n\n\n1\n\n\n【两种实例化方式的比较】\n\n编写代码比较\n\npublic static void main(string[] args) {\n    string str1 = "lance";\n    string str2 = new string("lance");\n    string str3 = str2; //引用传递，str3直接指向st2的堆内存地址\n    string str4 = "lance";\n    /**\n     * ==:\n     * 基本数据类型：比较的是基本数据类型的值是否相同\n     * 引用数据类型：比较的是引用数据类型的地址值是否相同\n     * 所以在这里的话：string类对象==比较，比较的是地址，而不是内容\n     */\n    system.out.println(str1 == str2);//false\n    system.out.println(str1 == str3);//false\n    system.out.println(str3 == str2);//true\n    system.out.println(str1 == str4);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n内存图分析\n\n\n\n可能这里还是不够明显，构造方法实例化方式的内存图：string str = new string("hello");\n\n\n\n当我们再一次的new一个string对象时：\n\n\n\n【字符串常量池】\n\n在字符串中，如果采用直接赋值的方式（string str="lance"）进行对象的实例化，则会将匿名对象 “lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象，我们可以用对象手工入池；\n\npublic static void main(string args[]){\n    string str = new string("lance").intern();//对匿名对象进行手工入池操作\n    string str1 = "lance";\n    system.out.println(str==str1);//true\n}\n\n\n1\n2\n3\n4\n5\n\n\n【两种实例化方式的区别】\n\n 1. 直接赋值（string str = "hello"）\n    \n    只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。\n\n 2. 构造方法（string str= new string("hello");）\n    \n    会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public string intern();方法进行手工入池。\n\n 3. 在开发的过程中不会采用构造方法进行字符串的实例化。\n\n【避免空指向】\n\n首先了解： == 和public boolean equals()比较字符串的区别\n\n==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中， equals()通过接受参数，可以避免空指向。\n\nstring str = null;\nif(str.equals("hello")){//此时会出现空指向异常\n\n}\n\nif("hello".equals(str)){//此时equals会处理null值，可以避免空指向异常\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nstring类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾\n\n\n\n\n# 3、string常用的方法\n\n\n\n# string的判断\n\n> boolean equals(object obj)：比较字符串的内容是否相同 boolean equalsignorecase(string str)： 比较字符串的内容是否相同,忽略大小写 boolean startswith(string str)： 判断字符串对象是否以指定的str开头 boolean endswith(string str)： 判断字符串对象是否以指定的str结尾\n\n演示：\n\npublic static void main(string[] args) {\n    // 创建字符串对象\n    string s1 = "hello";\n    string s2 = "hello";\n    string s3 = "hello";\n    \n    // boolean equals(object obj):比较字符串的内容是否相同\n    system.out.println(s1.equals(s2)); //true\n    system.out.println(s1.equals(s3)); //false\n    system.out.println("-----------");\n    \n    // boolean equalsignorecase(string str):比较字符串的内容是否相同,忽略大小写\n    system.out.println(s1.equalsignorecase(s2)); //true\n    system.out.println(s1.equalsignorecase(s3)); //true\n    system.out.println("-----------");\n    \n    // boolean startswith(string str):判断字符串对象是否以指定的str开头\n    system.out.println(s1.startswith("he")); //true\n    system.out.println(s1.startswith("ll")); //false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# string的截取\n\n> int length():获取字符串的长度，其实也就是字符个数 char charat(int index):获取指定索引处的字符 int indexof(string str):获取str在字符串对象中第一次出现的索引 string substring(int start):从start开始截取字符串 string substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end\n\n演示\n\npublic static void main(string args[]) {\n    // 创建字符串对象\n    string s = "helloworld";\n    // int length():获取字符串的长度，其实也就是字符个数\n    system.out.println(s.length()); //10\n    system.out.println("--------");\n    // char charat(int index):获取指定索引处的字符\n    system.out.println(s.charat(0)); //h\n    system.out.println(s.charat(1)); //e\n    system.out.println("--------");\n    // int indexof(string str):获取str在字符串对象中第一次出现的索引\n    system.out.println(s.indexof("l")); //2\n    system.out.println(s.indexof("owo")); //4\n    system.out.println(s.indexof("ak")); //-1\n    system.out.println("--------");\n    // string substring(int start):从start开始截取字符串\n    system.out.println(s.substring(0)); //helloworld\n    system.out.println(s.substring(5)); //world\n    system.out.println("--------");\n    // string substring(int start,int end):从start开始，到end结束截取字符串\n    system.out.println(s.substring(0, s.length())); //helloworld\n    system.out.println(s.substring(3, 8)); //lowor\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# string的转换\n\n> char[] tochararray()：把字符串转换为字符数组 string tolowercase()：把字符串转换为小写字符串 string touppercase()：把字符串转换为大写字符串\n\n演示\n\npublic static void main(string args[]) {\n\t// 创建字符串对象\n    string s = "abcde";\n    \n    // char[] tochararray():把字符串转换为字符数组\n    char[] chs = s.tochararray();\n    for (int x = 0; x < chs.length; x++) {\n        system.out.println(chs[x]);\n    }\n    \n    system.out.println("-----------");\n    \n    // string tolowercase():把字符串转换为小写字符串\n    system.out.println("helloworld".tolowercase());\n    // string touppercase():把字符串转换为大写字符串\n    system.out.println("helloworld".touppercase());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 其他方法\n\n> 去除字符串两端空格：string trim()\n> \n> 按照指定符号分割字符串：string[] split(string str)\n\npublic static void main(string args[]) {\n    // 创建字符串对象\n    string s1 = "helloworld";\n    string s2 = " helloworld ";\n    string s3 = " hello world ";\n    system.out.println("---" + s1 + "---");\n    system.out.println("---" + s1.trim() + "---");\n    system.out.println("---" + s2 + "---");\n    system.out.println("---" + s2.trim() + "---");\n    system.out.println("---" + s3 + "---");\n    system.out.println("---" + s3.trim() + "---");\n    system.out.println("-------------------");\n    \n    // string[] split(string str)\n    // 创建字符串对象\n    string s4 = "aa,bb,cc";\n    string[] strarray = s4.split(",");\n    for (int x = 0; x < strarray.length; x++) {\n        system.out.println(strarray[x]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4、string的不可变性\n\n当我们去阅读源代码的时候，会发现有这样的一句话：\n\n> strings are constant; their values cannot be changed after they are created.\n\n意思就是说：string是个常量，从一出生就注定不可变\n\n我想大家应该就知道为什么string不可变了，string类被final修饰，官方注释说明创建后不能被改变，但 是为什么string要使用final修饰呢？\n\n了解一个经典的面试题\n\npublic static void main(string[] args) {\n    string a = "abc";\n    string b = "abc";\n    string c = new string("abc");\n    system.out.println(a==b); //true\n    system.out.println(a.equals(b)); //true\n    system.out.println(a==c); //false\n    system.out.println(a.equals(c)); //true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n因为string太过常用，java类库的设计者在实现时做了个小小的变化，即采用了享元模式，每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。\n\n需要说明一点的是，在object中，equals()是用来比较内存地址的，但是string重写了equals()方 法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。\n\nstring不可变的好处\n\n * 可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。\n * 我们的程序中大量使用了string字符串，有可能是出于安全性考虑。\n * 大家都知道hashmap中key为string类型，如果可变将变的多么可怕。\n * 当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。\n\n\n# 5、字符串常量池\n\n字符串常量池概述：\n\n1、常量池表（constant_pool table）\n\nclass文件中存储所有常量（包括字符串）的table。这是class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是class文件中的字节码指令。\n\n2、运行时常量池（runtime constant pool）\n\njvm内存中方法区的一部分，这是运行时的内容。这部分内容（绝大部分）是随着jvm运行时候，从常量池转化而来，每个class对应一个运行时常量池。上一句中说绝大部分是因为：除了 class中常量池内 容，还可能包括动态生成并加入这里的内容。\n\n3、字符串常量池（string pool）\n\n这部分也在方法区中，但与runtime constant pool不是一个概念，string pool是jvm实例全局共享的，全局只有一个。jvm规范要求进入这里的string实例叫“被驻留的interned string”，各个jvm可以有不同的实现，hotspot是设置了一个哈希表stringtable来引用堆中的字符串实例，被引用就是被驻留。\n\n【亨元模式】\n\n其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - > 共享元素模式 也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素\n\njava中string部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - string pool”\n\n【详细分析】\n\nint x = 10;\nstring y = "hello";\n\n\n1\n2\n\n\n① 首先， 10和 "hello"会在经过javac（或者其他编译器）编译过后变为class文件中 constant_pool table 的内容\n\n② 当我们的程序运行时，也就是说jvm运行时，每个class constant_pool table 中的内容会被加载到jvm内存中的方法区中各自class的 runtime constant pool。\n\n③ 一个没有被string pool包含的runtime constant pool中的字符串（这里是"hello"）会被加入到 string pool中（hosspot使用hashtable引用方式），步骤如下：\n\n 1. 在java heap（堆）中根据"hello"字面量create一个字符串对象\n\n 2. 将字面量"hello"与字符串对象的引用在hashtable中关联起来键 - 值\n    \n    形式是："hello" = 对象的引用地址。\n\n另外来说，当一个新的字符串出现在runtime constant pool中时怎么判断需不需要在java heap中创建 新对象呢？\n\n策略是这样：会先去根据equals来比较runtime constant pool中的这个字符串是否和string pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，就如同上面的第三步。\n\n如此，就实现了享元模式，提高的内存利用效率。\n\n举例：\n\n> 使用string s = new string("hello");会创建几个对象 答：会创建2个对象\n> \n> 首先，出现了字面量"hello"，那么去string pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在java heap中用字面量"hello"首先创建1个string对象。\n> \n> 接着，new string("hello")，关键字new又在java heap中创建了1个对象，然后调用接收string 参数的构造器进行了初始化。最终s的引用是这个string对象.\n\n\n# stringbuilder和stringbuffer\n\n\n# 1、概述\n\n【演示：查看源码及api文档】\n\npublic final class stringbuilder\n    extends abstractstringbuilder\n    implements java.io.serializable, charsequence{\n    \n}\n\n\n1\n2\n3\n4\n5\n\n\nstringbuilder 是一个可变的字符序列。它继承于abstractstringbuilder，实现了charsequence接口。 stringbuffer 也是继承于abstractstringbuilder的子类； 但是，stringbuilder和stringbuffer不同，前者是非线程安全的，后者是线程安全的。\n\nstringbuilder 和 charsequence之间的关系图如下：\n\n\n\n【源码概览】\n\npackage java.lang;\npublic final class stringbuilder\n    extends abstractstringbuilder\n    implements java.io.serializable, charsequence {\n    \n    static final long serialversionuid = 4383685877147921099l;\n    // 构造函数。默认的字符数组大小是16。\n    public stringbuilder() {\n        super(16);\n    }\n    \n    // 构造函数。指定stringbuilder的字符数组大小是capacity。\n        public stringbuilder(int capacity) {\n        super(capacity);\n    }\n    \n    // 构造函数。指定字符数组大小=str长度+15，且将str的值赋值到当前字符数组中。\n    public stringbuilder(string str) {\n        super(str.length() + 16);\n        append(str);\n    }\n    \n    // 构造函数。指定字符数组大小=seq长度+15，且将seq的值赋值到当前字符数组中。\n    public stringbuilder(charsequence seq) {\n        this(seq.length() + 16);\n        append(seq);\n    }\n    \n    // 追加“对象obj对应的字符串”。string.valueof(obj)实际上是调用obj.tostring()\n    public stringbuilder append(object obj) {\n        return append(string.valueof(obj));\n    }\n    \n    // 追加“str”。\n    public stringbuilder append(string str) {\n        super.append(str);\n        return this;\n    }\n    \n      // 追加“sb的内容”。\n    private stringbuilder append(stringbuilder sb) {\n        if (sb == null)\n        \treturn append("null");\n        int len = sb.length();\n        int newcount = count + len;\n        if (newcount > value.length)\n        \texpandcapacity(newcount);\n        sb.getchars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n    \n    // 追加“sb的内容”。\n    public stringbuilder append(stringbuffer sb) {\n        super.append(sb);\n        return this;\n    }\n    \n    // 追加“s的内容”。\n    public stringbuilder append(charsequence s) {\n        if (s == null)\n            s = "null";\n        if (s instanceof string)\n            return this.append((string)s);\n        if (s instanceof stringbuffer)\n            return this.append((stringbuffer)s);\n        if (s instanceof stringbuilder)\n            return this.append((stringbuilder)s);\n        return this.append(s, 0, s.length());\n    }\n\n    // 追加“s从start(包括)到end(不包括)的内容”。\n    public stringbuilder append(charsequence s, int start, int end) {\n        super.append(s, start, end);\n        return this;\n    }\n    \n    // 追加“str字符数组对应的字符串”\n    public stringbuilder append(char[] str) {\n        super.append(str);\n        return this;\n    }\n    \n    // 追加“str从offset开始的内容，内容长度是len”\n    public stringbuilder append(char[] str, int offset, int len) {\n        super.append(str, offset, len);\n        return this;\n    }\n    \n    // 追加“b对应的字符串”\n    public stringbuilder append(boolean b) {\n        super.append(b);\n        return this;\n    }\n    \n    // 追加“c”\n    public stringbuilder append(char c) {\n        super.append(c);\n        return this;\n    }\n    \n    // 追加“i”\n    public stringbuilder append(int i) {\n        super.append(i);\n        return this;\n    }\n    \n    // 追加“lng”\n    public stringbuilder append(long lng) {\n        super.append(lng);\n        return this;\n    }\n    \n    // 追加“f”\n    public stringbuilder append(float f) {\n        super.append(f);\n        return this;\n    }\n    \n    // 追加“d”\n    public stringbuilder append(double d) {\n        super.append(d);\n        return this;\n    }\n    \n    // 追加“codepoint”\n    public stringbuilder appendcodepoint(int codepoint) {\n        super.appendcodepoint(codepoint);\n        return this;\n    }\n    \n    // 删除“从start(包括)到end的内容”\n    public stringbuilder delete(int start, int end) {\n        super.delete(start, end);\n        return this;\n    }\n    \n    // 删除“位置index的内容”\n    public stringbuilder deletecharat(int index) {\n        super.deletecharat(index);\n        return this;\n    }\n    \n    // “用str替换stringbuilder中从start(包括)到end(不包括)的内容”\n    public stringbuilder replace(int start, int end, string str) {\n        super.replace(start, end, str);\n        return this;\n    }\n    \n    // “在stringbuilder的位置index处插入‘str中从offset开始的内容’，插入内容长度是len”\n    public stringbuilder insert(int index, char[] str, int offset,\n    int len)\n    {\n        super.insert(index, str, offset, len);\n        return this;\n    }\n    \n    // “在stringbuilder的位置offset处插入obj对应的字符串”\n    public stringbuilder insert(int offset, object obj) {\n    \treturn insert(offset, string.valueof(obj));\n    }\n    \n    // “在stringbuilder的位置offset处插入str”\n    public stringbuilder insert(int offset, string str) {\n        super.insert(offset, str);\n        return this;\n    }\n    \n    // “在stringbuilder的位置offset处插入str”\n    public stringbuilder insert(int offset, char[] str) {\n        super.insert(offset, str);\n        return this;\n    }\n    \n    // “在stringbuilder的位置dstoffset处插入s”\n    public stringbuilder insert(int dstoffset, charsequence s) {\n        if (s == null)\n       \t \ts = "null";\n        if (s instanceof string)\n        \treturn this.insert(dstoffset, (string)s);\n        return this.insert(dstoffset, s, 0, s.length());\n    }\n    \n    // “在stringbuilder的位置dstoffset处插入\'s中从start到end的内容\'”\n    public stringbuilder insert(int dstoffset, charsequence s,\n    int start, int end)\n    {\n        super.insert(dstoffset, s, start, end);\n        return this;\n    }\n    \n    // “在stringbuilder的位置offset处插入b”\n    public stringbuilder insert(int offset, boolean b) {\n        super.insert(offset, b);\n        return this;\n    }\n    \n    // “在stringbuilder的位置offset处插入c”\n    public stringbuilder insert(int offset, char c) {\n        super.insert(offset, c);\n        return this;\n    }\n    \n    // “在stringbuilder的位置offset处插入i”\n    public stringbuilder insert(int offset, int i) {\n    \treturn insert(offset, string.valueof(i));\n    }\n\n    // “在stringbuilder的位置offset处插入l”\n    public stringbuilder insert(int offset, long l) {\n    \treturn insert(offset, string.valueof(l));\n    }\n    \n    // “在stringbuilder的位置offset处插入f”\n    public stringbuilder insert(int offset, float f) {\n    \treturn insert(offset, string.valueof(f));\n    }\n    \n    // “在stringbuilder的位置offset处插入d”\n    public stringbuilder insert(int offset, double d) {\n   \t\t return insert(offset, string.valueof(d));\n    }\t\n    \n    // 返回“str”在stringbuilder的位置\n    public int indexof(string str) {\n   \t\t return indexof(str, 0);\n    }\n    \n    // 从fromindex开始查找，返回“str”在stringbuilder的位置\n    public int indexof(string str, int fromindex) {\n        return string.indexof(value, 0, count,\n        \tstr.tochararray(), 0, str.length(),fromindex);\n    }\n    \n    // 从后向前查找，返回“str”在stringbuilder的位置\n    public int lastindexof(string str) {\n   \t\t return lastindexof(str, count);\n    }\n    \n    // 从fromindex开始，从后向前查找，返回“str”在stringbuilder的位置\n    public int lastindexof(string str, int fromindex) {\n    return string.lastindexof(value, 0, count,\n    \tstr.tochararray(), 0, str.length(),fromindex);\n    }\n    \n    // 反转stringbuilder\n    public stringbuilder reverse() {\n        super.reverse();\n        return this;\n    }\n    \n    public string tostring() {\n    // create a copy, don\'t share the array\n    \treturn new string(value, 0, count);\n    }\n    \n    // 序列化对应的写入函数\n    private void writeobject(java.io.objectoutputstream s)\n        throws java.io.ioexception {\n            s.defaultwriteobject();\n            s.writeint(count);\n            s.writeobject(value);\n    }\n    \n        // 序列化对应的读取函数\n    private void readobject(java.io.objectinputstream s)\n        throws java.io.ioexception, classnotfoundexception {\n            s.defaultreadobject();\n            count = s.readint();\n            value = (char[]) s.readobject();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n\n\n\n# 2、常用方法\n\n# insert\n\npublic static void main(string[] args) {\n    stringbuilder sbuilder = new stringbuilder();\n    // 在位置0处插入字符数组\n    sbuilder.insert(0, new char[]{\'a\', \'b\', \'c\', \'d\', \'e\'});\n    // 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度\n    sbuilder.insert(0, new char[]{\'a\', \'b\', \'c\', \'d\', \'e\'}, 0, 3);\n    // 在位置0处插入float\n    sbuilder.insert(0, 1.414f);\n    // 在位置0处插入double\n    sbuilder.insert(0, 3.14159d);\n    // 在位置0处插入boolean\n    sbuilder.insert(0, true);\n    // 在位置0处插入char\n    sbuilder.insert(0, \'\\n\');\n    // 在位置0处插入int\n    sbuilder.insert(0, 100);\n    // 在位置0处插入long\n    sbuilder.insert(0, 12345l);\n    // 在位置0处插入stringbuilder对象\n    sbuilder.insert(0, new stringbuilder("stringbuilder"));\n    // 在位置0处插入stringbuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括)\n    sbuilder.insert(0, new stringbuilder("stringbuilder"), 6, 13);\n    // 在位置0处插入stringbuffer对象。\n    sbuilder.insert(0, new stringbuffer("stringbuffer"));\n    // 在位置0处插入stringbuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括)\n    sbuilder.insert(0, new stringbuffer("stringbuffer"), 6, 12);\n    // 在位置0处插入string对象。\n    sbuilder.insert(0, "string");\n    // 在位置0处插入string对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括)\n    sbuilder.insert(0, "0123456789", 1, 6);\n    sbuilder.insert(0, \'\\n\');\n    \n    // 在位置0处插入object对象。此处以hashmap为例\n    hashmap map = new hashmap();\n    map.put("1", "one");\n    map.put("2", "two");\n    map.put("3", "three");\n    \n    sbuilder.insert(0, map);\n    \n    system.out.printf("%s\\n\\n", sbuilder);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# append\n\npublic static void main(string[] args) {\n    stringbuilder sbuilder = new stringbuilder();\n    // 追加字符数组\n    sbuilder.append(new char[]{\'a\', \'b\', \'c\', \'d\', \'e\'});\n    // 追加字符数组。0表示字符数组起始位置，3表示长度\n    sbuilder.append(new char[]{\'a\', \'b\', \'c\', \'d\', \'e\'}, 0, 3);\n    // 追加float\n    sbuilder.append(1.414f);\n    // 追加double\n    sbuilder.append(3.14159d);\n    // 追加boolean\n    sbuilder.append(true);\n    // 追加char\n    sbuilder.append(\'\\n\');\n    // 追加int\n    sbuilder.append(100);\n    // 追加long\n    sbuilder.append(12345l);\n    // 追加stringbuilder对象\n    sbuilder.append(new stringbuilder("stringbuilder"));\n    // 追加stringbuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括)\n    sbuilder.append(new stringbuilder("stringbuilder"), 6, 13);\n    // 追加stringbuffer对象。\n    sbuilder.append(new stringbuffer("stringbuffer"));\n    // 追加stringbuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括)\n    sbuilder.append(new stringbuffer("stringbuffer"), 6, 12);\n    // 追加string对象。\n    sbuilder.append("string");\n    // 追加string对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括)\n    sbuilder.append("0123456789", 1, 6);\n\n    sbuilder.append(\'\\n\');\n\n    // 追加object对象。此处以hashmap为例\n    hashmap map = new hashmap();\n    map.put("1", "one");\n    map.put("2", "two");\n    map.put("3", "three");\n    sbuilder.append(map);\n    sbuilder.append(\'\\n\');\n\n    // 追加unicode编码\n    sbuilder.appendcodepoint(0x5b57); // 0x5b57是“字”的unicode编码\n    sbuilder.appendcodepoint(0x7b26); // 0x7b26是“符”的unicode编码\n    sbuilder.appendcodepoint(0x7f16); // 0x7f16是“编”的unicode编码\n    sbuilder.appendcodepoint(0x7801); // 0x7801是“码”的unicode编码\n\n    system.out.printf("%s\\n\\n", sbuilder);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# replace\n\npublic static void main(string[] args) {\n    stringbuilder sbuilder;\n    \n    sbuilder = new stringbuilder("0123456789");\n    sbuilder.replace(0, 3, "abcde");\n    system.out.printf("sbuilder=%s\\n", sbuilder);\n\n    sbuilder = new stringbuilder("0123456789");\n    sbuilder.reverse();\n    system.out.printf("sbuilder=%s\\n", sbuilder);\n\n    sbuilder = new stringbuilder("0123456789");\n    sbuilder.setcharat(0, \'m\');\n    system.out.printf("sbuilder=%s\\n", sbuilder);\n    system.out.println();\n    /*\n    sbuilder=abcde3456789\n    sbuilder=9876543210\n    sbuilder=m123456789\n*/\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# delete\n\npublic static void main(string[] args) {\n    stringbuilder sbuilder = new stringbuilder("0123456789");\n\n    // 删除位置0的字符，剩余字符是“123456789”。\n    sbuilder.deletecharat(0);\n    // 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。\n    sbuilder.delete(3, 6);\n\n    // 获取sb中从位置1开始的字符串\n    string str1 = sbuilder.substring(1);\n    // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串\n    string str2 = sbuilder.substring(3, 5);\n    // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是charsequence对象，此处转型为string\n    string str3 = (string) sbuilder.subsequence(3, 5);\n    \n    system.out.printf("sbuilder=%s\\nstr1=%s\\nstr2=%s\\nstr3=%s\\n",\n            sbuilder, str1, str2, str3);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# index\n\npublic static void main(string[] args) {\n    stringbuilder sbuilder = new stringbuilder("abcabcabcabcabcabcabcabc");\n    \n    system.out.printf("sbuilder=%s\\n", sbuilder);\n    \n    // 1. 从前往后，找出"bc"第一次出现的位置\n    system.out.printf("%-30s = %d\\n", "sbuilder.indexof(\\"bc\\")", sbuilder.indexof("bc"));\n    \n    // 2. 从位置5开始，从前往后，找出"bc"第一次出现的位置\n    system.out.printf("%-30s = %d\\n", "sbuilder.indexof(\\"bc\\", 5)", sbuilder.indexof("bc", 5));\n    \n    // 3. 从后往前，找出"bc"第一次出现的位置\n    system.out.printf("%-30s = %d\\n", "sbuilder.lastindexof(\\"bc\\")", sbuilder.lastindexof("bc"));\n    \n    // 4. 从位置4开始，从后往前，找出"bc"第一次出现的位置\n    system.out.printf("%-30s = %d\\n", "sbuilder.lastindexof(\\"bc\\", 4)", sbuilder.lastindexof("bc", 4));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 其他api\n\npublic static void main(string[] args) {\n    stringbuilder sbuilder = new stringbuilder("0123456789");\n\n    int cap = sbuilder.capacity();\n    system.out.printf("cap=%d\\n", cap);\n\n    /*\n    capacity()返回的是字符串缓冲区的容量\n    stringbuffer( ); 分配16个字符的缓冲区\n    stringbuffer( int len ); 分配len个字符的缓冲区\n    stringbuffer( string s ); 除了按照s的大小分配空间外,再分配16个 字符的缓冲区\n    你的stringbuffer是用字符构造的，"0123456789"的长度是10另外再分配16个字符，所以一共是26。\n    */\n\n    char c = sbuilder.charat(6);\n    system.out.printf("c=%c\\n", c);\n    \n    char[] carr = new char[4];\n    sbuilder.getchars(3, 7, carr, 0);\n    for (int i = 0; i < carr.length; i++) {\n        system.out.printf("carr[%d]=%c ", i, carr[i]);\n    }\n    system.out.println();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 3、stringbuffer\n\n和stringbulider用法差不多，不过多介绍，主要看一下三者的区别\n\nstringbuffer是线程安全的，推荐在多线程里使用。\n\n\n# 4、小结\n\nstring、stringbuffer、stringbuilder之间的区别\n\n首先需要说明的是：\n\n * string 字符串常量\n * stringbuffer 字符串变量（线程安全）\n * stringbuilder 字符串变量（非线程安全）\n\n在大多数情况下三者在执行速度方面的比较：stringbuilder > stringbuffer > string\n\n解释：\n\nstring 类型和 stringbuffer 类型的主要性能区别其实在于 string 是不可变的对象，因此在每次对 string 类型进行改变的时候其实都等同于生成了一个新的 string 对象，然后将指针指向新的 string 对象，所以经常改变内容的字符串最好不要用 string ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， jvm 的 gc 就会开始工作，那速度是一定会相当慢的。\n\n而如果是使用 stringbuffer 类则结果就不一样了，每次结果都会对 stringbuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 stringbuffer ，特别是字符串对象经常改变的情况下。\n\n为什么是大多数情况呢？\n\n在某些特别情况下， string 对象的字符串拼接其实是被 jvm 解释成了 stringbuffer 对象的拼接， 所以这些时候 string 对象的速度并不会比 stringbuffer 对象慢，而特别是以下的字符串对象生成中， string 效率是远要比 stringbuffer 快的：\n\nstring s1 = “this is only a” + “ simple” + “ test”;\nstringbuffer sb = new stringbuilder(“this is only a”).append(“simple”).append(“ test”);\n\n\n1\n2\n\n\n你会很惊讶的发现，生成 string s1 对象的速度简直太快了，而这个时候 stringbuffer 居然速度上根本 一点都不占优势。其实这是 jvm 的一个把戏，在 jvm 眼里，这个\n\nstring s1 = “this is only a” + “ simple” + “test”;\n\n其实就是：string s1 = “this is only a simple test”;\n\n所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 string 对象 的话，速度就没那么快了，譬如：\n\n> string s2 = “this is only a”; string s3 = “ simple”; string s4 = “ test”;\n\n大部分情况下stringbuilder的速度要大于stringbuffer：\n\njava.lang.stringbuilder一个可变的字符序列是5.0新增的。（大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用stringbuilder而不用stringbuffer的）此类提供一个与 stringbuffer 兼容的 api，但不保证同步。该类被设计用作 stringbuffer 的一个简易替换，用在字符串缓冲区被单个 线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 stringbuffer 要快。两者的方法基本相同。\n\n对于三者使用的总结：\n\n * 如果要操作少量的数据用 ：string\n * 单线程操作字符串缓冲区 下操作大量数据 ：stringbuilder\n * 多线程操作字符串缓冲区 下操作大量数据 ： stringbuffer\n\n\n# 5、面试题的回答\n\nstringbuilder 与stringbuffer的区别，stringbuilder与string的区别。\n\n1）stringbuilder效率高，线程不安全，stringbuffer对比之下没它高，线程安全。\n\n2）string是不可变字符串，stringbuilder是可变字符串。为什么有这样的差异，可以深入源码去解析， 比如string类内的 priver final char value[] 等方法的原因。\n\n3）如果是简单的声明一个字符串没有后续过多的操作，使用string,stringbuilder均可，若后续对字符穿做频繁的添加，删除操作,或者是在循环当中动态的改变字符穿的长度应该用stringbuilder。使用string 会产生多余的字符串，占用内存空间。\n\n\n# file类\n\n\n# 1、file类的基本用法\n\njava.io.file类：文件和目录路径名的抽象表示形式。\n\nfile类的常见构造方法：\n\npublic file(string pathname)\n\n\n1\n\n\n以pathname为路径创建file对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir 中存储。\n\nfile的静态属性string separator存储了当前系统的路径分隔符。\n\n通过file对象可以访问文件的属性。\n\npublic boolean canread()\npublic boolean exists()\npublic boolean isfile()\npublic long lastmodified()\npublic string getname()\npublic boolean canwrite()\npublic boolean isdirectory()\npublic boolean ishidden()\npublic long length()\npublic string getpath()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n通过file对象创建空文件或目录（在该对象所指的文件或目录不存在的情况下）。\n\npublic boolean createnewfile()throws ioexception\npublic boolean delete()\npublic boolean mkdir()， mkdirs()\n\n\n1\n2\n3\n\n\n常见构造器，方法\n\nimport java.io.file;\nimport java.io.ioexception;\npublic class testfile {\n    /**\n    * file文件类 1.代表文件 2.代表目录\n    */\n    public static void main(string[] args) {\n        file f = new file("d:/src3/testobject.java");\n        file f2 = new file("d:/src3");\n        file f3 = new file(f2, "testfile.java");\n        file f4 = new file(f2, "testfile666.java");\n        file f5 = new file("d:/src3/aa/bb/cc/dd");\n        //f5.mkdirs();\n        f5.delete();\n\n        try {\n            f4.createnewfile();\n            system.out.println("文件创建成功！");\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        if (f.isfile()) {\n            system.out.println("是一个文件！");\n        }\n        if (f2.isdirectory()) {\n            system.out.println("是一个目录！");\n        }\n        if (f3.isfile()) {\n            system.out.println("是一个文件奥");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"集合概序",frontmatter:{title:"集合概序",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/synopsis",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01.%E9%9B%86%E5%90%88%E6%A6%82%E5%BA%8F.html",relativePath:"01.Java/05.Java-集合框架/01.集合概序.md",key:"v-79afdc49",path:"/java/se/collection/synopsis/",headers:[{level:2,title:"集合概序",slug:"集合概序",normalizedTitle:"集合概序",charIndex:2},{level:3,title:"1、为什么使用集合框架？",slug:"_1、为什么使用集合框架",normalizedTitle:"1、为什么使用集合框架？",charIndex:11},{level:3,title:"2、集合框架包含的内容",slug:"_2、集合框架包含的内容",normalizedTitle:"2、集合框架包含的内容",charIndex:234}],headersStr:"集合概序 1、为什么使用集合框架？ 2、集合框架包含的内容",content:"# 集合概序\n\n\n# 1、为什么使用集合框架？\n\n假设，一个班级有30个人，我们需要存储学员的信息，是不是我们可以用一个一维数组就解决了？\n\n那换一个问题，一个网站每天要存储的新闻信息，我们知道新闻是可以实时发布的，我们并不知道需要多大的空间去存储，我要是去设置一个很大的数组，要是没有存满，或者不够用，都会影响我们，前者浪费的空间，后者影响了业务！\n\n如果并不知道程序运行时会需要多少对象，或者需要更复杂的方式存储对象，那我们就可以使用Java的集合框架！\n\n\n# 2、集合框架包含的内容\n\nJava集合框架提供了一套性能优良，使用方便的接口和类，他们位于java.util包中。\n\n接口和具体类\n\n\n\n算法\n\nCollections 类提供了对集合进行排序，遍历等多种算法实现！\n\n【重中之重】\n\n * Collection 接口存储一组不唯一，无序的对象\n\n * List 接口存储一组不唯一，有序的对象。\n\n * Set 接口存储一组唯一，无序的对象\n\n * Map 接口存储一组键值对象，提供key到value的映射\n\n * ArrayList实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高\n   \n   \n   \n   \n\n * LinkedList采用链表存储方式。插入、删除元素时效率比较高\n   \n   \n   \n   \n\n * HashSet:采用哈希算法实现的Set\n   \n   HashSet的底层是用HashMap实现的，因此查询效率较高，由于采用hashCode算法直接确定 元素的内存地址，增删效率也挺高的。",normalizedContent:"# 集合概序\n\n\n# 1、为什么使用集合框架？\n\n假设，一个班级有30个人，我们需要存储学员的信息，是不是我们可以用一个一维数组就解决了？\n\n那换一个问题，一个网站每天要存储的新闻信息，我们知道新闻是可以实时发布的，我们并不知道需要多大的空间去存储，我要是去设置一个很大的数组，要是没有存满，或者不够用，都会影响我们，前者浪费的空间，后者影响了业务！\n\n如果并不知道程序运行时会需要多少对象，或者需要更复杂的方式存储对象，那我们就可以使用java的集合框架！\n\n\n# 2、集合框架包含的内容\n\njava集合框架提供了一套性能优良，使用方便的接口和类，他们位于java.util包中。\n\n接口和具体类\n\n\n\n算法\n\ncollections 类提供了对集合进行排序，遍历等多种算法实现！\n\n【重中之重】\n\n * collection 接口存储一组不唯一，无序的对象\n\n * list 接口存储一组不唯一，有序的对象。\n\n * set 接口存储一组唯一，无序的对象\n\n * map 接口存储一组键值对象，提供key到value的映射\n\n * arraylist实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高\n   \n   \n   \n   \n\n * linkedlist采用链表存储方式。插入、删除元素时效率比较高\n   \n   \n   \n   \n\n * hashset:采用哈希算法实现的set\n   \n   hashset的底层是用hashmap实现的，因此查询效率较高，由于采用hashcode算法直接确定 元素的内存地址，增删效率也挺高的。",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ArrayList",frontmatter:{title:"ArrayList",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/ArrayList",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/02.ArrayList.html",relativePath:"01.Java/05.Java-集合框架/02.ArrayList.md",key:"v-2831c459",path:"/java/se/collection/ArrayList/",headers:[{level:2,title:"ArrayList概述",slug:"arraylist概述",normalizedTitle:"arraylist概述",charIndex:16},{level:2,title:"ArrayList的数据结构",slug:"arraylist的数据结构",normalizedTitle:"arraylist的数据结构",charIndex:426},{level:2,title:"ArrayList源码分析",slug:"arraylist源码分析",normalizedTitle:"arraylist源码分析",charIndex:605},{level:3,title:"1、继承结构和层次关系",slug:"_1、继承结构和层次关系",normalizedTitle:"1、继承结构和层次关系",charIndex:623},{level:3,title:"2、类中的属性",slug:"_2、类中的属性",normalizedTitle:"2、类中的属性",charIndex:1815},{level:3,title:"3、构造方法",slug:"_3、构造方法",normalizedTitle:"3、构造方法",charIndex:2478},{level:3,title:"4、核心方法-add",slug:"_4、核心方法-add",normalizedTitle:"4、核心方法-add",charIndex:4792},{level:3,title:"5、核心方法-remove",slug:"_5、核心方法-remove",normalizedTitle:"5、核心方法-remove",charIndex:10215},{level:3,title:"6、其他方法",slug:"_6、其他方法",normalizedTitle:"6、其他方法",charIndex:13701},{level:2,title:"ArrayList实践",slug:"arraylist实践",normalizedTitle:"arraylist实践",charIndex:14838}],headersStr:"ArrayList概述 ArrayList的数据结构 ArrayList源码分析 1、继承结构和层次关系 2、类中的属性 3、构造方法 4、核心方法-add 5、核心方法-remove 6、其他方法 ArrayList实践",content:'# ArrayList\n\n\n# ArrayList概述\n\nArrayList是可以动态增长和缩减的索引序列，它是基于数组实现的List类。\n\n该类封装了一个动态再分配的Object[]数组，每一个类对象都有一个capacity【容量】属性，表示它们所封装的Object[]数组的长度，当向ArrayList中添加元素时，该属性值会自动增加。如果想 ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capacity，可以减少增加重分配的次数提高性能。\n\nArrayList的用法和Vector向类似，但是Vector是一个较老的集合，具有很多缺点，不建议使用。\n\n另外，ArrayList和Vector的区别是：ArrayList是线程不安全的，当多条线程访问同一个ArrayList集合时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。\n\nArrayList和Collection的关系：\n\n\n\n\n# ArrayList的数据结构\n\n分析一个类的时候，数据结构往往是它的灵魂所在，理解底层的数据结构其实就理解了该类的实现思 路，具体的实现细节再具体分析。\n\nArrayList的数据结构是：\n\n\n\n说明：底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对 ArrayList类的实例的所有的操作底层都是基于数组的。\n\n\n# ArrayList源码分析\n\n\n# 1、继承结构和层次关系\n\nIDEA快捷键：Ctrl+H\n\n\n\npublic class ArrayList<E> extends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n    \n}\n\n\n1\n2\n3\n4\n\n\n我们看一下ArrayList的继承结构：\n\nArrayList extends AbstractList AbstractList extends AbstractCollection\n\n所有类都继承Object 所以ArrayList的继承结构就是上图这样。\n\n【分析】\n\n为什么要先继承AbstractList，而让AbstractList先实现List？而不是让ArrayList直接实现List？\n\n这里是有一个思想，接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来，先一起实现了，减少重复代码。所以一般看到 一个类上面还有一个抽象类，应该就是这个作用。\n\nArrayList实现了哪些接口？\n\nList接口：我们会出现这样一个疑问，在查看了ArrayList的父类 AbstractList也实现了List接口，那为什么子类ArrayList还是去实现一遍呢？\n\n这是想不通的地方，查资料显示，有的人说是为了查看代码方便，使观看者一目了然，说法不 一，但每一个让我感觉合理的，但是在stackOverFlow中找到了答案，这里其实很有趣。\n\n开发这个collection 的作者Josh说：\n\n这其实是一个mistake[失误]，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。\n\nRandomAccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取， 有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如ArrayList。而没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了 让我们知道我们用什么样的方式去获取数据性能更好。\n\nCloneable接口：实现了该接口，就可以使用Object.Clone()方法了。\n\nSerializable接口：实现该序列化接口，表明该类可以被序列化，什么是序列化？简单的说，就是能够 从类变成字节流传输，然后还能从字节流变成原来的类。\n\n\n# 2、类中的属性\n\npublic class ArrayList<E> extends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, java.io.Serializable\n    {\n    // 版本号\n    private static final long serialVersionUID = 8683452581122892189L;\n    // 缺省容量\n    private static final int DEFAULT_CAPACITY = 10;\n    // 空对象数组\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n    // 缺省空对象数组\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n    // 元素数组\n    transient Object[] elementData;\n    // 实际元素大小，默认为0\n    private int size;\n    // 最大数组容量\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3、构造方法\n\n\n\n无参构造方法\n\n/*\n    Constructs an empty list with an initial capacity of ten.\n    这里就说明了默认会给10的大小，所以说一开始arrayList的容量是10.\n*/\n//ArrayList中储存数据的其实就是一个数组，这个数组就是elementData.\npublic ArrayList() {\n    super(); //调用父类中的无参构造方法，父类中的是个空的构造方法\n    this.elementData = EMPTY_ELEMENTDATA;\n    //EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有参构造方法1\n\n/*\nConstructs an empty list with the specified initial capacity.\n构造具有指定初始容量的空列表。\n\n@param initialCapacity the initial capacity of the list\n初始容量列表的初始容量\n\n@throws IllegalArgumentException if the specified initial capacity is negative\n如果指定的初始容量为负，则为IllegalArgumentException\n*/\n\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        //将自定义的容量大小当成初始化 initialCapacity 的大小\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA; //等同于无参构造方法\n    } else {\n        //判断如果自定义大小的容量小于0，则报下面这个非法数据异常\n        throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n有参构造方法 2\n\n/*\n    Constructs a list containing the elements of the specified collection,in the order they are returned by the collection\'s iterator.\n    按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表。\n    @param c the collection whose elements are to be placed into this list\n    @throws NullPointerException if the specified collection is null\n*/\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray(); //转换为数组\n    //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。\n    if ((size = elementData.length) != 0) {\n   \t\t // c.toArray might (incorrectly) not return Object[] (see 6260652)\n   \t\t if (elementData.getClass() != Object[].class)\n    \t\t elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n    \tthis.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这个构造方法不常用，举个例子就能明白什么意思\n\n举个例子： Strudent exends Person ， ArrayList、 Person这里就是泛型 ， 我还有一个Collection、 由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection转换为ArrayList ， 这就是这个构造方法的作用 。\n\n【总结】ArrayList的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数 组，在其中就叫elementData。\n\n\n# 4、核心方法-add\n\nalt+7 查看方法列表，ctrl+左键 选中add进去后查看\n\nboolean add(E)\n\n/**\n* Appends the specified element to the end of this list.\n* 添加一个特定的元素到list的末尾。\n* @param e element to be appended to this list\n* @return <tt>true</tt> (as specified by {@link Collection#add})\n*/\npublic boolean add(E e) {\n    //确定内部容量是否够了，size是数组中数据的个数，因为要添加一个元素，所以size+1，先判断size+1的这个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了。\n    ensureCapacityInternal(size + 1); // Increments modCount!!\n    elementData[size++] = e; //在数据中正确的位置上放上元素e，并且size++\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【分析：ensureCapacityInternal(xxx); 确定内部容量的方法】\n\nprivate void ensureCapacityInternal(int minCapacity) {\n\tensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity){\n    //看，判断初始化的elementData是不是空的数组，也就是没有长度\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        //因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存放不了，所以就将minCapacity变成10，也就是默认大小，但是在这里，还没有真正的初始化这个elementData的大小。\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    //确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否够用\n    return minCapacity;\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n    //  overflow-conscious code\n    //minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用，不够用那么就要增加elementData的length。这里有的同学就会模糊minCapacity到底是什么呢，这里给你们分析一下\n    /*\n    第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量ensureCapacityInternal)就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，还没有改变elementData的大小。\n    \n\t第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。\n*/\n    if (minCapacity - elementData.length > 0)\n\t\tgrow(minCapacity);\n}\n//arrayList核心的方法，能扩展数组大小的真正秘密。\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    \n    //将扩充前的elementData大小给oldCapacity\n    int oldCapacity = elementData.length;\n    \n    //newCapacity就是1.5倍的oldCapacity\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    \n    //这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。\n    if (newCapacity - minCapacity < 0)\n\t\tnewCapacity = minCapacity;\n    \n    //如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    //新的容量大小已经确定好了，就copy数组，改变容量大小咯。\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n    \n\n//这个就是上面用到的方法，很简单，就是用来赋最大值\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    \n//如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将MAX_ARRAY_SIZE返回。因为maxCapacity是三倍的minCapacity，可能扩充的太大了，就用minCapacity来判断了。\n\n//Integer.MAX_VALUE:2147483647 MAX_ARRAY_SIZE：2147483639 也就是说最大也就能给到第一个数值。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。    \n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n    MAX_ARRAY_SIZE;\n}\n\n    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\nvoid add(int，E)\n\npublic void add(int index, E element) {\n    //检查index也就是插入的位置是否合理。\n    rangeCheckForAdd(index);\n    \n    ensureCapacityInternal(size + 1); // Increments modCount!!\n    \n    //这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位，\n    System.arraycopy(elementData, index, elementData, index + 1,\n    \t\t\t\t\tsize - index);\n    \n    //在目标位置上存放元素\n    elementData[index] = element;\n    size++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n【分析：rangeCheckForAdd(index)】\n\nprivate void rangeCheckForAdd(int index) {\n    //插入的位置肯定不能大于size 和小于0\n    if (index > size || index < 0)\n        //如果是，就报这个越界异常\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【System.arraycopy(...)：就是将elementData在插入位置后的所有元素，往后面移一位】\n\npublic static void arraycopy(Object src,\n            int srcPos,\n            Object dest,\n            int destPos,\n            int length)\n\n    //src：源对象\n    //srcPos：源对象对象的起始位置\n    //dest：目标对象\n    //destPost：目标对象的起始位置\n    //length：从起始位置往后复制的长度。\n  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注释解读：\n\n这段的大概意思就是解释这个方法的用法，复制src到dest，复制的位置是从src的srcPost开始，到srcPost+length-1的位置结束，复制到destPost上，从destPost开始到destPost+length-1的位置上\n\n\n\n告诉你复制的一种情况，如果A和B是一样的，那么先将A复制到临时数组C，然后通过C复制到B，用了一个第三方参数\n\n\n\n这一大段，就是来说明会出现的一些问题，NullPointerException和IndexOutOfBoundsException 还有ArrayStoreException 这三个异常出现的原因。\n\n\n\n这里描述了一种特殊的情况，就是当A的长度大于B的长度的时候，会复制一部分，而不是完全失败。\n\n\n\n这些是参数列表的解释和异常\n\n\n\n😱读别人源码是件很头疼的事，新手会用就行，原理等以后回来复习的时候再看~\n\n【总结】\n\n正常情况下会扩容1.5倍，特殊情况下（新扩展数组大小已经达到了最大值）则只取最大值。\n\n当我们调用add方法时，实际上的函数调用如下：\n\n\n\n说明：程序调用add，实际上还会进行一系列调用，可能会调用到grow，grow可能会调用hugeCapacity。\n\n【举例】\n\nList<Integer> lists = new ArrayList<Integer>;\nlists.add(8);\n\n\n1\n2\n\n\n说明：初始化lists大小为0，调用的ArrayList()型构造函数，那么在调用lists.add(8)方法时，会经过怎样 的步骤呢？下图给出了该程序执行过程和最初与最后的elementData的大小。\n\n\n\n说明：我们可以看到，在add方法之前开始elementData = {}；调用add方法时会继续调用，直至 grow，最后elementData的大小变为10，之后再返回到add函数，把8放在elementData[0]中。\n\n【举例说明二】\n\nList<Integer> lists = new ArrayList<Integer>(6);\nlists.add(8);\n\n\n1\n2\n\n\n说明：调用的ArrayList(int)型构造函数，那么elementData被初始化为大小为6的Object数组，在调用add(8)方法时，具体的步骤如下：\n\n\n\n说明：我们可以知道，在调用add方法之前，elementData的大小已经为6，之后再进行传递，不会进行 扩容处理。\n\n推荐文章系列： 【集合框架】JDK1.8源码分析之HashMap（一）\n\n\n# 5、核心方法-remove\n\n其实这几个删除方法都是类似的。我们选择几个讲，其中fastRemove(int)方法是private的，是提供给 remove(Object)这个方法用的。\n\nremove(int)：通过删除指定位置上的元素\n\npublic E remove(int index) {\n    rangeCheck(index);//检查index的合理性\n    \n    modCount++;//这个作用很多，比如用来检测快速失败的一种标志。\n    E oldValue = elementData(index);//通过索引直接找到该元素\n    \n    int numMoved = size - index - 1;//计算要移动的位数。\n    if (numMoved > 0)\n    \t//这个方法也已经解释过了，就是用来移动元素的。\n    \tSystem.arraycopy(elementData, index+1, elementData, index,numMoved);\n    //将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。\n    elementData[--size] = null; // clear to let GC do its work\n    //返回删除的元素。\n    return oldValue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nremove(Object)：这个方法可以看出来，arrayList是可以存放null值\n\n//通过元素来删除该元素，就依次遍历，如果有这个元素，就将该元素的索引传给fastRemobe(index)，使用这个方法来删除该元素，\n//fastRemove(index)方法的内部跟remove(index)的实现几乎一样，这里最主要是知道arrayList可以存储null值\npublic boolean remove(Object o) {\n    if (o == null) {\n    \tfor (int index = 0; index < size; index++)\n        \tif (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n    \t\t}\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nclear()：将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear\n\npublic void clear() {\n    modCount++;\n    \n    // clear to let GC do its work\n    for (int i = 0; i < size; i++)\n    \telementData[i] = null;\n    size = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nremoveAll(collection c)\n\npublic boolean removeAll(Collection<?> c) {\n\treturn batchRemove(c, false);//批量删除\n}\n\n\n1\n2\n3\n\n\nbatchRemove(xx,xx)：用于两个方法，一个removeAll()：它只清楚指定集合中的元素，retainAll() 用来测试两个集合是否有交集。\n\n//这个方法，用于两处地方，如果complement为false，则用于removeAll如果为true，则给retainAll()用，retainAll（）是用来检测两个集合是否有交集的。\n\nprivate boolean batchRemove(Collection<?> c, boolean complement) {\n        final Object[] elementData = this.elementData; //将原集合，记名为A\n        int r = 0, w = 0;  //r用来控制循环，w是记录有多少个交集\n        boolean modified = false;\n        try {\n            for (; r < size; r++)\n                //参数中的集合C一次检测集合A中的元素是否有，\n                if (c.contains(elementData[r]) == complement)\n                    //有的话，就给集合A\n                    elementData[w++] = elementData[r];\n        } finally {\n            // Preserve behavioral compatibility with AbstractCollection,\n            // even if c.contains() throws.\n            //如果contains方法使用过程报异常\n            if (r != size) {\n                //将剩下的元素都赋值给集合A，\n                System.arraycopy(elementData, r,\n                                 elementData, w,\n                                 size - r);\n                w += size - r;\n            }\n            if (w != size) {\n                // clear to let GC do its work\n                //这里有两个用途，在removeAll()时，w一直为0，就直接跟clear一样，全是为null。\n                //retainAll()：没有一个交集返回true，有交集但不全交也返回true，而两个集合相等的时候，返回false，所以不能根据返回值来确认两个集合是否有交集，而是通过原集合的大小是否发生改变来判断，如果原集合中还有元素，则代表有交集，而元集合没有元素了，说明两个集合没有交集。\n\n                for (int i = w; i < size; i++)\n                    elementData[i] = null;\n                modCount += size - w;\n                size = w;\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n总结：remove函数，用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单 位，并且会把数组最后一个元素设置为null，这样是为了方便之后将整个数组不被使用时，会被GC，可 以作为小的技巧使用。\n\n\n# 6、其他方法\n\nset()方法\n\n说明：设定指定下标索引的元素值\n\npublic E set(int index, E element) {\n    // 检验索引是否合法\n    rangeCheck(index);\n    // 旧值\n    E oldValue = elementData(index);\n    // 赋新值\n    elementData[index] = element;\n    // 返回旧值\n    return oldValue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nindexOf()方法\n\n说明：从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。\n\n// 从首开始查找数组里面是否存在指定元素\npublic int indexOf(Object o) {\n    if (o == null) { // 查找的元素为空\n        for (int i = 0; i < size; i++) // 遍历数组，找到第一个为空的元素，返回下标\n        \tif (elementData[i]==null)\n        \t\treturn i;\n    } else { // 查找的元素不为空\n        for (int i = 0; i < size; i++) // 遍历数组，找到第一个和指定元素相等的元素，返回下标\n        if (o.equals(elementData[i]))\n        \treturn i;\n    }\n    // 没有找到，返回空\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nget()方法\n\npublic E get(int index) {\n    // 检验索引是否合法\n    rangeCheck(index);\n    return elementData(index);\n}\n\n\n1\n2\n3\n4\n5\n\n\n说明：get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0），值得注意的 是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下：\n\nE elementData(int index) {\n\treturn (E) elementData[index];\n}\n\n\n1\n2\n3\n\n\n说明：返回的值都经过了向下转型（Object -> E），这些是对我们应用程序屏蔽的小细节。\n\n\n# ArrayList实践\n\n问题：我们现在有4只小狗，我们如何存储它的信息，获取总数，并能够逐条打印狗狗信息！\n\n分析：通过List 接口的实现类ArrayList 实现该需求。\n\n * 元素个数不确定\n * 要求获得元素的实际个数\n * 按照存储顺序获取并打印元素信息\n\nclass Dog {\n    private String name;\n    //构造。。。set、get、。。。toString（）\n}\n\n\n1\n2\n3\n4\n\n\npublic class TestArrayList {\n    public static void main(String[] args) {\n        //创建ArrayList对象 , 并存储狗狗\n        List dogs = new ArrayList();\n        \n        dogs.add(new Dog("小狗一号"));\n        dogs.add(new Dog("小狗二号"));\n        dogs.add(new Dog("小狗三号"));\n        dogs.add(2,new Dog("小狗四号"));// 添加到指定位置\n        \n        // .size() ： ArrayList大小\n        System.out.println("共计有" + dogs.size() + "条狗狗。");\n        System.out.println("分别是：");\n        \n        // .get(i) ： 逐个获取个元素\n        for (int i = 0; i < dogs.size(); i++) {\n            Dog dog = (Dog) dogs.get(i);\n            System.out.println(dog.getName());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n问题联想：\n\n * 删除第一个狗狗 ：remove（index）\n * 删除指定位置的狗狗 ：remove（object）\n * 判断集合中是否包含指定狗狗 ： contains（object）\n\n分析：使用List接口提供的remove()、contains()方法\n\n【常用方法】\n\n\n\n\n# 总结\n\n1）arrayList可以存放null。 2）arrayList本质上就是一个elementData数组。 3）arrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。 4）arrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素。 5）arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很 多，有移动很多数据才能达到应有的效果 6）arrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环。',normalizedContent:'# arraylist\n\n\n# arraylist概述\n\narraylist是可以动态增长和缩减的索引序列，它是基于数组实现的list类。\n\n该类封装了一个动态再分配的object[]数组，每一个类对象都有一个capacity【容量】属性，表示它们所封装的object[]数组的长度，当向arraylist中添加元素时，该属性值会自动增加。如果想 arraylist中添加大量元素，可使用ensurecapacity方法一次性增加capacity，可以减少增加重分配的次数提高性能。\n\narraylist的用法和vector向类似，但是vector是一个较老的集合，具有很多缺点，不建议使用。\n\n另外，arraylist和vector的区别是：arraylist是线程不安全的，当多条线程访问同一个arraylist集合时，程序需要手动保证该集合的同步性，而vector则是线程安全的。\n\narraylist和collection的关系：\n\n\n\n\n# arraylist的数据结构\n\n分析一个类的时候，数据结构往往是它的灵魂所在，理解底层的数据结构其实就理解了该类的实现思 路，具体的实现细节再具体分析。\n\narraylist的数据结构是：\n\n\n\n说明：底层的数据结构就是数组，数组元素类型为object类型，即可以存放所有类型数据。我们对 arraylist类的实例的所有的操作底层都是基于数组的。\n\n\n# arraylist源码分析\n\n\n# 1、继承结构和层次关系\n\nidea快捷键：ctrl+h\n\n\n\npublic class arraylist<e> extends abstractlist<e>\nimplements list<e>, randomaccess, cloneable, java.io.serializable{\n    \n}\n\n\n1\n2\n3\n4\n\n\n我们看一下arraylist的继承结构：\n\narraylist extends abstractlist abstractlist extends abstractcollection\n\n所有类都继承object 所以arraylist的继承结构就是上图这样。\n\n【分析】\n\n为什么要先继承abstractlist，而让abstractlist先实现list？而不是让arraylist直接实现list？\n\n这里是有一个思想，接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，让abstractlist是实现接口中一些通用的方法，而具体的类，如arraylist就继承这个abstractlist类，拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来，先一起实现了，减少重复代码。所以一般看到 一个类上面还有一个抽象类，应该就是这个作用。\n\narraylist实现了哪些接口？\n\nlist接口：我们会出现这样一个疑问，在查看了arraylist的父类 abstractlist也实现了list接口，那为什么子类arraylist还是去实现一遍呢？\n\n这是想不通的地方，查资料显示，有的人说是为了查看代码方便，使观看者一目了然，说法不 一，但每一个让我感觉合理的，但是在stackoverflow中找到了答案，这里其实很有趣。\n\n开发这个collection 的作者josh说：\n\n这其实是一个mistake[失误]，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。\n\nrandomaccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取， 有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如arraylist。而没有实现该接口的话，使用iterator来迭代，这样性能更高，例如linkedlist。所以这个标记性只是为了 让我们知道我们用什么样的方式去获取数据性能更好。\n\ncloneable接口：实现了该接口，就可以使用object.clone()方法了。\n\nserializable接口：实现该序列化接口，表明该类可以被序列化，什么是序列化？简单的说，就是能够 从类变成字节流传输，然后还能从字节流变成原来的类。\n\n\n# 2、类中的属性\n\npublic class arraylist<e> extends abstractlist<e>\nimplements list<e>, randomaccess, cloneable, java.io.serializable\n    {\n    // 版本号\n    private static final long serialversionuid = 8683452581122892189l;\n    // 缺省容量\n    private static final int default_capacity = 10;\n    // 空对象数组\n    private static final object[] empty_elementdata = {};\n    // 缺省空对象数组\n    private static final object[] defaultcapacity_empty_elementdata = {};\n    // 元素数组\n    transient object[] elementdata;\n    // 实际元素大小，默认为0\n    private int size;\n    // 最大数组容量\n    private static final int max_array_size = integer.max_value - 8;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3、构造方法\n\n\n\n无参构造方法\n\n/*\n    constructs an empty list with an initial capacity of ten.\n    这里就说明了默认会给10的大小，所以说一开始arraylist的容量是10.\n*/\n//arraylist中储存数据的其实就是一个数组，这个数组就是elementdata.\npublic arraylist() {\n    super(); //调用父类中的无参构造方法，父类中的是个空的构造方法\n    this.elementdata = empty_elementdata;\n    //empty_elementdata：是个空的object[]， 将elementdata初始化，elementdata也是个object[]类型。空的object[]会给默认大小10，等会会解释什么时候赋值的。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有参构造方法1\n\n/*\nconstructs an empty list with the specified initial capacity.\n构造具有指定初始容量的空列表。\n\n@param initialcapacity the initial capacity of the list\n初始容量列表的初始容量\n\n@throws illegalargumentexception if the specified initial capacity is negative\n如果指定的初始容量为负，则为illegalargumentexception\n*/\n\npublic arraylist(int initialcapacity) {\n    if (initialcapacity > 0) {\n        //将自定义的容量大小当成初始化 initialcapacity 的大小\n        this.elementdata = new object[initialcapacity];\n    } else if (initialcapacity == 0) {\n        this.elementdata = empty_elementdata; //等同于无参构造方法\n    } else {\n        //判断如果自定义大小的容量小于0，则报下面这个非法数据异常\n        throw new illegalargumentexception("illegal capacity: "+initialcapacity);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n有参构造方法 2\n\n/*\n    constructs a list containing the elements of the specified collection,in the order they are returned by the collection\'s iterator.\n    按照集合迭代器返回元素的顺序构造包含指定集合的元素的列表。\n    @param c the collection whose elements are to be placed into this list\n    @throws nullpointerexception if the specified collection is null\n*/\npublic arraylist(collection<? extends e> c) {\n    elementdata = c.toarray(); //转换为数组\n    //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是object[].class类型，那么久需要使用arraylist中的方法去改造一下。\n    if ((size = elementdata.length) != 0) {\n   \t\t // c.toarray might (incorrectly) not return object[] (see 6260652)\n   \t\t if (elementdata.getclass() != object[].class)\n    \t\t elementdata = arrays.copyof(elementdata, size, object[].class);\n    } else {\n        // replace with empty array.\n    \tthis.elementdata = empty_elementdata;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这个构造方法不常用，举个例子就能明白什么意思\n\n举个例子： strudent exends person ， arraylist、 person这里就是泛型 ， 我还有一个collection、 由于这个student继承了person，那么根据这个构造方法，我就可以把这个collection转换为arraylist ， 这就是这个构造方法的作用 。\n\n【总结】arraylist的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数 组，在其中就叫elementdata。\n\n\n# 4、核心方法-add\n\nalt+7 查看方法列表，ctrl+左键 选中add进去后查看\n\nboolean add(e)\n\n/**\n* appends the specified element to the end of this list.\n* 添加一个特定的元素到list的末尾。\n* @param e element to be appended to this list\n* @return <tt>true</tt> (as specified by {@link collection#add})\n*/\npublic boolean add(e e) {\n    //确定内部容量是否够了，size是数组中数据的个数，因为要添加一个元素，所以size+1，先判断size+1的这个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了。\n    ensurecapacityinternal(size + 1); // increments modcount!!\n    elementdata[size++] = e; //在数据中正确的位置上放上元素e，并且size++\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【分析：ensurecapacityinternal(xxx); 确定内部容量的方法】\n\nprivate void ensurecapacityinternal(int mincapacity) {\n\tensureexplicitcapacity(calculatecapacity(elementdata, mincapacity));\n}\n\nprivate static int calculatecapacity(object[] elementdata, int mincapacity){\n    //看，判断初始化的elementdata是不是空的数组，也就是没有长度\n    if (elementdata == defaultcapacity_empty_elementdata) {\n        //因为如果是空的话，mincapacity=size+1；其实就是等于1，空的数组没有长度就存放不了，所以就将mincapacity变成10，也就是默认大小，但是在这里，还没有真正的初始化这个elementdata的大小。\n        return math.max(default_capacity, mincapacity);\n    }\n    //确认实际的容量，上面只是将mincapacity=10，这个方法就是真正的判断elementdata是否够用\n    return mincapacity;\n}\n\nprivate void ensureexplicitcapacity(int mincapacity) {\n    modcount++;\n    //  overflow-conscious code\n    //mincapacity如果大于了实际elementdata的长度，那么就说明elementdata数组的长度不够用，不够用那么就要增加elementdata的length。这里有的同学就会模糊mincapacity到底是什么呢，这里给你们分析一下\n    /*\n    第一种情况：由于elementdata初始化时是空的数组，那么第一次add的时候，mincapacity=size+1；也就mincapacity=1，在上一个方法(确定内部容量ensurecapacityinternal)就会判断出是空的数组，就会给将mincapacity=10，到这一步为止，还没有改变elementdata的大小。\n    \n\t第二种情况：elementdata不是空的数组了，那么在add的时候，mincapacity=size+1；也就是mincapacity代表着elementdata中增加之后的实际数据个数，拿着它判断elementdata的length是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。\n*/\n    if (mincapacity - elementdata.length > 0)\n\t\tgrow(mincapacity);\n}\n//arraylist核心的方法，能扩展数组大小的真正秘密。\nprivate void grow(int mincapacity) {\n    // overflow-conscious code\n    \n    //将扩充前的elementdata大小给oldcapacity\n    int oldcapacity = elementdata.length;\n    \n    //newcapacity就是1.5倍的oldcapacity\n    int newcapacity = oldcapacity + (oldcapacity >> 1);\n    \n    //这句话就是适应于elementdata就空数组的时候，length=0，那么oldcapacity=0，newcapacity=0，所以这个判断成立，在这里就是真正的初始化elementdata的大小了，就是为10.前面的工作都是准备工作。\n    if (newcapacity - mincapacity < 0)\n\t\tnewcapacity = mincapacity;\n    \n    //如果newcapacity超过了最大的容量限制，就调用hugecapacity，也就是将能给的最大值给newcapacity\n    if (newcapacity - max_array_size > 0)\n        newcapacity = hugecapacity(mincapacity);\n    // mincapacity is usually close to size, so this is a win:\n    //新的容量大小已经确定好了，就copy数组，改变容量大小咯。\n    elementdata = arrays.copyof(elementdata, newcapacity);\n}\n    \n\n//这个就是上面用到的方法，很简单，就是用来赋最大值\nprivate static int hugecapacity(int mincapacity) {\n    if (mincapacity < 0) // overflow\n        throw new outofmemoryerror();\n    \n//如果mincapacity都大于max_array_size，那么就integer.max_value返回，反之将max_array_size返回。因为maxcapacity是三倍的mincapacity，可能扩充的太大了，就用mincapacity来判断了。\n\n//integer.max_value:2147483647 max_array_size：2147483639 也就是说最大也就能给到第一个数值。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。    \n    return (mincapacity > max_array_size) ?\n        integer.max_value :\n    max_array_size;\n}\n\n    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\nvoid add(int，e)\n\npublic void add(int index, e element) {\n    //检查index也就是插入的位置是否合理。\n    rangecheckforadd(index);\n    \n    ensurecapacityinternal(size + 1); // increments modcount!!\n    \n    //这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位，\n    system.arraycopy(elementdata, index, elementdata, index + 1,\n    \t\t\t\t\tsize - index);\n    \n    //在目标位置上存放元素\n    elementdata[index] = element;\n    size++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n【分析：rangecheckforadd(index)】\n\nprivate void rangecheckforadd(int index) {\n    //插入的位置肯定不能大于size 和小于0\n    if (index > size || index < 0)\n        //如果是，就报这个越界异常\n        throw new indexoutofboundsexception(outofboundsmsg(index));\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【system.arraycopy(...)：就是将elementdata在插入位置后的所有元素，往后面移一位】\n\npublic static void arraycopy(object src,\n            int srcpos,\n            object dest,\n            int destpos,\n            int length)\n\n    //src：源对象\n    //srcpos：源对象对象的起始位置\n    //dest：目标对象\n    //destpost：目标对象的起始位置\n    //length：从起始位置往后复制的长度。\n  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注释解读：\n\n这段的大概意思就是解释这个方法的用法，复制src到dest，复制的位置是从src的srcpost开始，到srcpost+length-1的位置结束，复制到destpost上，从destpost开始到destpost+length-1的位置上\n\n\n\n告诉你复制的一种情况，如果a和b是一样的，那么先将a复制到临时数组c，然后通过c复制到b，用了一个第三方参数\n\n\n\n这一大段，就是来说明会出现的一些问题，nullpointerexception和indexoutofboundsexception 还有arraystoreexception 这三个异常出现的原因。\n\n\n\n这里描述了一种特殊的情况，就是当a的长度大于b的长度的时候，会复制一部分，而不是完全失败。\n\n\n\n这些是参数列表的解释和异常\n\n\n\n😱读别人源码是件很头疼的事，新手会用就行，原理等以后回来复习的时候再看~\n\n【总结】\n\n正常情况下会扩容1.5倍，特殊情况下（新扩展数组大小已经达到了最大值）则只取最大值。\n\n当我们调用add方法时，实际上的函数调用如下：\n\n\n\n说明：程序调用add，实际上还会进行一系列调用，可能会调用到grow，grow可能会调用hugecapacity。\n\n【举例】\n\nlist<integer> lists = new arraylist<integer>;\nlists.add(8);\n\n\n1\n2\n\n\n说明：初始化lists大小为0，调用的arraylist()型构造函数，那么在调用lists.add(8)方法时，会经过怎样 的步骤呢？下图给出了该程序执行过程和最初与最后的elementdata的大小。\n\n\n\n说明：我们可以看到，在add方法之前开始elementdata = {}；调用add方法时会继续调用，直至 grow，最后elementdata的大小变为10，之后再返回到add函数，把8放在elementdata[0]中。\n\n【举例说明二】\n\nlist<integer> lists = new arraylist<integer>(6);\nlists.add(8);\n\n\n1\n2\n\n\n说明：调用的arraylist(int)型构造函数，那么elementdata被初始化为大小为6的object数组，在调用add(8)方法时，具体的步骤如下：\n\n\n\n说明：我们可以知道，在调用add方法之前，elementdata的大小已经为6，之后再进行传递，不会进行 扩容处理。\n\n推荐文章系列： 【集合框架】jdk1.8源码分析之hashmap（一）\n\n\n# 5、核心方法-remove\n\n其实这几个删除方法都是类似的。我们选择几个讲，其中fastremove(int)方法是private的，是提供给 remove(object)这个方法用的。\n\nremove(int)：通过删除指定位置上的元素\n\npublic e remove(int index) {\n    rangecheck(index);//检查index的合理性\n    \n    modcount++;//这个作用很多，比如用来检测快速失败的一种标志。\n    e oldvalue = elementdata(index);//通过索引直接找到该元素\n    \n    int nummoved = size - index - 1;//计算要移动的位数。\n    if (nummoved > 0)\n    \t//这个方法也已经解释过了，就是用来移动元素的。\n    \tsystem.arraycopy(elementdata, index+1, elementdata, index,nummoved);\n    //将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。\n    elementdata[--size] = null; // clear to let gc do its work\n    //返回删除的元素。\n    return oldvalue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nremove(object)：这个方法可以看出来，arraylist是可以存放null值\n\n//通过元素来删除该元素，就依次遍历，如果有这个元素，就将该元素的索引传给fastremobe(index)，使用这个方法来删除该元素，\n//fastremove(index)方法的内部跟remove(index)的实现几乎一样，这里最主要是知道arraylist可以存储null值\npublic boolean remove(object o) {\n    if (o == null) {\n    \tfor (int index = 0; index < size; index++)\n        \tif (elementdata[index] == null) {\n                fastremove(index);\n                return true;\n    \t\t}\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementdata[index])) {\n                fastremove(index);\n                return true;\n            }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nclear()：将elementdata中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear\n\npublic void clear() {\n    modcount++;\n    \n    // clear to let gc do its work\n    for (int i = 0; i < size; i++)\n    \telementdata[i] = null;\n    size = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nremoveall(collection c)\n\npublic boolean removeall(collection<?> c) {\n\treturn batchremove(c, false);//批量删除\n}\n\n\n1\n2\n3\n\n\nbatchremove(xx,xx)：用于两个方法，一个removeall()：它只清楚指定集合中的元素，retainall() 用来测试两个集合是否有交集。\n\n//这个方法，用于两处地方，如果complement为false，则用于removeall如果为true，则给retainall()用，retainall（）是用来检测两个集合是否有交集的。\n\nprivate boolean batchremove(collection<?> c, boolean complement) {\n        final object[] elementdata = this.elementdata; //将原集合，记名为a\n        int r = 0, w = 0;  //r用来控制循环，w是记录有多少个交集\n        boolean modified = false;\n        try {\n            for (; r < size; r++)\n                //参数中的集合c一次检测集合a中的元素是否有，\n                if (c.contains(elementdata[r]) == complement)\n                    //有的话，就给集合a\n                    elementdata[w++] = elementdata[r];\n        } finally {\n            // preserve behavioral compatibility with abstractcollection,\n            // even if c.contains() throws.\n            //如果contains方法使用过程报异常\n            if (r != size) {\n                //将剩下的元素都赋值给集合a，\n                system.arraycopy(elementdata, r,\n                                 elementdata, w,\n                                 size - r);\n                w += size - r;\n            }\n            if (w != size) {\n                // clear to let gc do its work\n                //这里有两个用途，在removeall()时，w一直为0，就直接跟clear一样，全是为null。\n                //retainall()：没有一个交集返回true，有交集但不全交也返回true，而两个集合相等的时候，返回false，所以不能根据返回值来确认两个集合是否有交集，而是通过原集合的大小是否发生改变来判断，如果原集合中还有元素，则代表有交集，而元集合没有元素了，说明两个集合没有交集。\n\n                for (int i = w; i < size; i++)\n                    elementdata[i] = null;\n                modcount += size - w;\n                size = w;\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n总结：remove函数，用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单 位，并且会把数组最后一个元素设置为null，这样是为了方便之后将整个数组不被使用时，会被gc，可 以作为小的技巧使用。\n\n\n# 6、其他方法\n\nset()方法\n\n说明：设定指定下标索引的元素值\n\npublic e set(int index, e element) {\n    // 检验索引是否合法\n    rangecheck(index);\n    // 旧值\n    e oldvalue = elementdata(index);\n    // 赋新值\n    elementdata[index] = element;\n    // 返回旧值\n    return oldvalue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nindexof()方法\n\n说明：从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着arraylist中可以存放null元素的。与此函数对应的lastindexof，表示从尾部开始查找。\n\n// 从首开始查找数组里面是否存在指定元素\npublic int indexof(object o) {\n    if (o == null) { // 查找的元素为空\n        for (int i = 0; i < size; i++) // 遍历数组，找到第一个为空的元素，返回下标\n        \tif (elementdata[i]==null)\n        \t\treturn i;\n    } else { // 查找的元素不为空\n        for (int i = 0; i < size; i++) // 遍历数组，找到第一个和指定元素相等的元素，返回下标\n        if (o.equals(elementdata[i]))\n        \treturn i;\n    }\n    // 没有找到，返回空\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nget()方法\n\npublic e get(int index) {\n    // 检验索引是否合法\n    rangecheck(index);\n    return elementdata(index);\n}\n\n\n1\n2\n3\n4\n5\n\n\n说明：get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0），值得注意的 是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下：\n\ne elementdata(int index) {\n\treturn (e) elementdata[index];\n}\n\n\n1\n2\n3\n\n\n说明：返回的值都经过了向下转型（object -> e），这些是对我们应用程序屏蔽的小细节。\n\n\n# arraylist实践\n\n问题：我们现在有4只小狗，我们如何存储它的信息，获取总数，并能够逐条打印狗狗信息！\n\n分析：通过list 接口的实现类arraylist 实现该需求。\n\n * 元素个数不确定\n * 要求获得元素的实际个数\n * 按照存储顺序获取并打印元素信息\n\nclass dog {\n    private string name;\n    //构造。。。set、get、。。。tostring（）\n}\n\n\n1\n2\n3\n4\n\n\npublic class testarraylist {\n    public static void main(string[] args) {\n        //创建arraylist对象 , 并存储狗狗\n        list dogs = new arraylist();\n        \n        dogs.add(new dog("小狗一号"));\n        dogs.add(new dog("小狗二号"));\n        dogs.add(new dog("小狗三号"));\n        dogs.add(2,new dog("小狗四号"));// 添加到指定位置\n        \n        // .size() ： arraylist大小\n        system.out.println("共计有" + dogs.size() + "条狗狗。");\n        system.out.println("分别是：");\n        \n        // .get(i) ： 逐个获取个元素\n        for (int i = 0; i < dogs.size(); i++) {\n            dog dog = (dog) dogs.get(i);\n            system.out.println(dog.getname());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n问题联想：\n\n * 删除第一个狗狗 ：remove（index）\n * 删除指定位置的狗狗 ：remove（object）\n * 判断集合中是否包含指定狗狗 ： contains（object）\n\n分析：使用list接口提供的remove()、contains()方法\n\n【常用方法】\n\n\n\n\n# 总结\n\n1）arraylist可以存放null。 2）arraylist本质上就是一个elementdata数组。 3）arraylist区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。 4）arraylist中removeall(collection c)和clear()的区别就是removeall可以删除批量指定的元素，而clear是全是删除集合中的元素。 5）arraylist由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很 多，有移动很多数据才能达到应有的效果 6）arraylist实现了randomaccess，所以在遍历它的时候推荐使用for循环。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"LinkedList",frontmatter:{title:"LinkedList",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/LinkedList",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/03.LinkedList.html",relativePath:"01.Java/05.Java-集合框架/03.LinkedList.md",key:"v-053d84f2",path:"/java/se/collection/LinkedList/",headers:[{level:2,title:"引入",slug:"引入",normalizedTitle:"引入",charIndex:17},{level:2,title:"LinkedList概述",slug:"linkedlist概述",normalizedTitle:"linkedlist概述",charIndex:203},{level:2,title:"链表的数据结构",slug:"链表的数据结构",normalizedTitle:"链表的数据结构",charIndex:606},{level:2,title:"LinkedList源码分析",slug:"linkedlist源码分析",normalizedTitle:"linkedlist源码分析",charIndex:1109},{level:3,title:"1、LinkedList的特性",slug:"_1、linkedlist的特性",normalizedTitle:"1、linkedlist的特性",charIndex:1152},{level:3,title:"2、继承结构以及层次关系",slug:"_2、继承结构以及层次关系",normalizedTitle:"2、继承结构以及层次关系",charIndex:2157},{level:3,title:"3、类的属性",slug:"_3、类的属性",normalizedTitle:"3、类的属性",charIndex:4102},{level:3,title:"4、构造方法",slug:"_4、构造方法",normalizedTitle:"4、构造方法",charIndex:4494},{level:3,title:"5、内部类（Node）",slug:"_5、内部类-node",normalizedTitle:"5、内部类（node）",charIndex:4789},{level:3,title:"6、核心方法",slug:"_6、核心方法",normalizedTitle:"6、核心方法",charIndex:5212},{level:4,title:"add()方法",slug:"add-方法",normalizedTitle:"add()方法",charIndex:5222},{level:4,title:"addAll()方法",slug:"addall-方法",normalizedTitle:"addall()方法",charIndex:6150},{level:4,title:"remove(Object o)",slug:"remove-object-o",normalizedTitle:"remove(object o)",charIndex:10345},{level:4,title:"get(index)",slug:"get-index",normalizedTitle:"get(index)",charIndex:12664},{level:4,title:"indexOf(Object o)",slug:"indexof-object-o",normalizedTitle:"indexof(object o)",charIndex:13694},{level:3,title:"7、LinkedList的迭代器",slug:"_7、linkedlist的迭代器",normalizedTitle:"7、linkedlist的迭代器",charIndex:14230},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2012}],headersStr:"引入 LinkedList概述 链表的数据结构 LinkedList源码分析 1、LinkedList的特性 2、继承结构以及层次关系 3、类的属性 4、构造方法 5、内部类（Node） 6、核心方法 add()方法 addAll()方法 remove(Object o) get(index) indexOf(Object o) 7、LinkedList的迭代器 总结",content:'# LinkedList\n\n\n# 引入\n\n问题：在集合的任何位置（头部，中间，尾部）添加，获取，删除狗狗对象！\n\n插入，删除操作频繁时，可使用LinkedList来提高效率\n\nLinkedList提供对头部和尾部元素进行添加和删除操作的方法！\n\n\n\nLinkedList的特殊方法\n\n\n\n集合框架有何好处？ Java集合框架中包含哪些接口和类？ ArrayList和LinkedList有何异同？\n\n\n# LinkedList概述\n\n我们都知道它的底层是由链表实现的，所以我们要明白什么是链表？\n\n\n\nLinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的。\n\nLinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。\n\nLinkedList 实现 List 接口，能对它进行队列操作。\n\nLinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。\n\nLinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。\n\nLinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。\n\nLinkedList 是非同步的。\n\n推荐文章：LinkList详解\n\n\n# 链表的数据结构\n\n单向链表：\n\nelement：用来存放元素\n\nnext：用来指向下一个节点元素\n\n通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。\n\n\n\n单向循环链表：\n\nelement、next 跟前面一样，在单向链表的最后一个节点的next会指向头节点，而不是指向null，这样存成一个环\n\n\n\n双向链表：\n\nelement：存放元素\n\npre：用来指向前一个元素\n\nnext：指向后一个元素\n\n双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。\n\n\n\n双向循环链表：\n\nelement、pre、next 跟前面的一样\n\n第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。\n\n\n\n【LinkedList的数据结构】\n\n\n\n如上图所示，LinkedList底层使用的双向链表结构，有一个头结点和一个尾结点，双向链表意味着我们可以从头开始正向遍历，或者是从尾开始逆向遍历，并且可以针对头部和尾部进行相应的操作。\n\n\n# LinkedList源码分析\n\n接下来又到了大家喜欢的读源码环节**😄**\n\n\n# 1、LinkedList的特性\n\n在我们平常中，我们只知道一些常识性的特点：\n\n1）是通过链表实现的 2）如果在频繁的插入，或者删除数据时，就用linkedList性能会更好。\n\n那我们通过API去查看它的一些特性\n\n> Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).\n> \n> 这告诉我们，linkedList是一个双向链表，并且实现了List和Deque接口中所有的列表操作，并且能存储任何元素，包括null，这里我们可以知道linkedList除了可以当链表使用，还可以当作队列使用，并能进行相应的操作。\n> \n> All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n> \n> 这个告诉我们，linkedList在执行任何操作的时候，都必须先遍历此列表来靠近通过index查找我们所需要的的值。通俗点讲，这就告诉了我们这个是顺序存取，每次操作必须先按开始到结束的顺序遍历，随机存取，就是arrayList，能够通过index。随便访问其中的任意位置的数据，这就是随机列表的意思。\n\n3）api中接下来讲的一大堆，就是说明linkedList是一个非线程安全的(异步)，其中在操作Interator时， 如果改变列表结构(adddelete等)，会发生fail-fast。\n\n通过API再次总结一下LinkedList的特性：\n\n 1. 异步，也就是非线程安全\n\n 2. 双向链表。由于实现了list和Deque接口，能够当作队列来使用。\n    \n    链表：查询效率不高，但是插入和删除这种操作性能好。\n\n 3. 是顺序存取结构（注意和随机存取结构两个概念搞清楚）\n\n\n# 2、继承结构以及层次关系\n\nctrl+h\n\n\n\n我们可以看到，linkedList在最底层，说明他的功能最为强大，并且细心的还会发现，arrayList有四层，这里多了一层AbstractSequentialList的抽象类，为什么呢？\n\n通过API我们会发现：\n\n1）减少实现顺序存取（例如LinkedList）这种类的工作，通俗的讲就是方便，抽象出类似LinkedList这种类的一些共同的方法\n\n2）既然有了上面这句话，那么以后如果自己想实现顺序存取这种特性的类(就是链表形式)，那么就继承这个AbstractSequentialList抽象类，如果想像数组那样的随机存取的类，那么就去实现AbstracList抽象类。\n\n3）这样的分层，就很符合我们抽象的概念，越在高处的类，就越抽象，往在底层的类，就越有自己独特的个性。自己要慢慢领会这种思想。\n\n4）LinkedList的类继承结构很有意思，我们着重要看是Deque接口，Deque接口表示是一个双端队列，那么也意味着LinkedList是双端队列的一种实现，所以，基于双端队列的操作在LinkedList中全部有效。\n\npublic abstract class AbstractSequentialList<E>\nextends AbstractList<E>\n\n\n1\n2\n\n\n\n\n第一段：\n\n> 这里第一段就解释了这个类的作用，这个类为实现list接口提供了一些重要的方法， 尽最大努力去减少实现这个“顺序存取”的特性的数据存储(例如链表)的什么 随机存取数据(例如数组)的类应该优先使用AbstractList 从上面就可以大概知道，AbstractSwquentialList这个类是为了减少LinkedList这种顺序存取的类的代码复杂度而抽象的一个类，\n\n第二段：\n\n> 这一段大概讲的就是这个AbstractSequentialList这个类和AbstractList这个类是完全相反 的。比如get、add这个方法的实现\n\n第三段：\n\n> 这里就是讲一些我们自己要继承该类，该做些什么事情，一些规范。\n\n【接口实现分析】\n\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n    {\n    \n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n 1. List接口：列表，add、set、等一些对列表进行操作的方法\n\n 2. Deque接口：有队列的各种特性，\n\n 3. Cloneable接口：能够复制，使用那个copy方法。\n\n 4. Serializable接口：能够序列化。\n\n 5. 应该注意到没有RandomAccess：那么就推荐使用iterator，在其中就有一个foreach，增强的for循环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator都可以。\n    \n    iterator：\n    \n    public static void method() {\n        List<String> l = new ArrayList<>();\n    \n        l.add("hello");\n        l.add(0, "123");\n        l.add("789");\n        l.set(0, "456");\n        l.remove(0);\n    \n        ListIterator<String> lit = l.listIterator();\n        while (lit.hasNext()) {\n            String next = lit.next();\n    //            l.add("111");\n            lit.add("111");\n            System.out.println(next);\n    \n        }\n        System.out.println(l);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n\n# 3、类的属性\n\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n{\n    // 实际元素个数\n    transient int size = 0;\n    // 头结点\n    transient Node<E> first;\n    // 尾结点\n    transient Node<E> last;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nLinkedList的属性非常简单，一个头结点、一个尾结点、一个表示链表中实际元素个数的变量。注意， 头结点、尾结点都有transient关键字修饰，这也意味着在序列化时该域是不会序列化的。\n\n\n# 4、构造方法\n\n两个构造方法(两个构造方法都是规范规定需要写的）\n\n【空参构造函数】\n\npublic LinkedList() {\n    \n}\n\n\n1\n2\n3\n\n\n【有参构造函数】\n\n//将集合c中的各个元素构建成LinkedList链表。\npublic LinkedList(Collection<? extends E> c) {\n    // 调用无参构造函数\n    this();\n    // 添加集合中所有的元素\n    addAll(c);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n说明：会调用无参构造函数，并且会把集合中所有的元素添加到LinkedList中。\n\n\n# 5、内部类（Node）\n\n//根据前面介绍双向链表就知道这个代表什么了，linkedList的奥秘就在这里。\nprivate static class Node<E> {\n    E item; // 数据域（当前节点的值）\n    Node<E> next; // 后继（指向当前一个节点的后一个节点）\n    Node<E> prev; // 前驱（指向当前节点的前一个节点）\n    \n    // 构造函数，赋值前驱后继\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n说明：内部类Node就是实际的结点，用于存放实际元素的地方。\n\n\n# 6、核心方法\n\n# add()方法\n\npublic boolean add(E e) {\n    // 添加到末尾\n    linkLast(e);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n\n\n说明：add函数用于向LinkedList中添加一个元素，并且添加到链表尾部。具体添加到尾部的逻辑是由 linkLast函数完成的。\n\n【LinkLast(XXXXX)】\n\n/**\n * Links e as last element.\n */\nvoid linkLast(E e) {\n    final Node<E> l = last; //临时节点l(L的小写)保存last，也就是l指向了最后一个节点\n    final Node<E> newNode = new Node<>(l, e, null);////将e封装为节点，并且e.prev指向了最后一个节点\n    last = newNode;//newNode成为了最后一个节点，所以last指向了它\n    if (l == null)//判断是不是一开始链表中就什么都没有，如果没有，则newNode就成为了第一个节点，first和last都要指向它\n        first = newNode;\n    else  //正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的最后一个节点，原先的最后一个节点就变成了倒数第二个节点\n        l.next = newNode;\n    size++; ;//添加一个节点，size自增\n    modCount++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n说明：对于添加一个元素至链表中会调用add方法 -> linkLast方法。\n\n【举例一】\n\nList<Integer> lists = new LinkedList<Integer>();\nlists.add(5);\nlists.add(6);\n\n\n1\n2\n3\n\n\n首先调用无参构造函数，之后添加元素5，之后再添加元素6。具体的示意图如下：\n\n\n\n上图的表明了在执行每一条语句后，链表对应的状态。\n\n# addAll()方法\n\naddAll有两个重载函数，addAll(Collection)型和addAll(int, Collection) 型，我们平时习惯调用的addAll(Collection)型会转化为addAll(int, Collection)型。\n\npublic boolean addAll(Collection<? extends E> c) {\n//继续往下看\nreturn addAll(size, c);\n}\n\n\n1\n2\n3\n4\n\n\naddAll(size，c)：这个方法，能包含三种情况下的添加，我们这里分析的只是构造方法，空链表的情况，看的时候只需要按照不同的情况分析下去就行了。\n\n//真正核心的地方就是这里了，记得我们传过来的是size，c\npublic boolean addAll(int index, Collection<? extends E> c) {\n    //检查index这个是否为合理。这个很简单，自己点进去看下就明白了。\n    checkPositionIndex(index);\n\t//将集合c转换为Object数组 a\n    Object[] a = c.toArray();\n    //数组a的长度numNew，也就是由多少个元素\n    int numNew = a.length;\n    if (numNew == 0)\n        //集合c是个空的，直接返回false，什么也不做。\n        return false;\n\t//集合c是非空的，定义两个节点(内部类)，每个节点都有三个属性，item、next、prev。注意：不要管这两个什么含义，就是用来做临时存储节点的。这个Node看下面一步的源码分析，Node就是linkedList的最核心的实现，可以直接先跳下一个去看Node的分析\n    Node<E> pred, succ;\n    //构造方法中传过来的就是index==size\n    if (index == size) {\n        //linkedList中三个属性：size、first、last。 size：链表中的元素个数。first：头节点 last：尾节点，就两种情况能进来这里\n        //情况一、：构造方法创建的一个空的链表，那么size=0，last、和first都为null。linkedList中是空的。什么节点都没有。succ=null、pred=last=null\n        \n        //情况二、：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到pred临时节点中。\n\n        succ = null;\n        pred = last;\n    } else {\n        //情况三、index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知道index上的节点是谁，保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了\n        //举个简单的例子，有2个位置，1、2、如果想插数据到第二个位置，双向链表中，就需要知道第一个位置是谁，原位置也就是第二个位置上是谁，然后才能将自己插到第二个位置上。如果这里还不明白，先看一下文章开头对于各种链表的删除，add操作是怎么实现的。\n        succ = node(index);\n        pred = succ.prev;\n    }\n\t//前面的准备工作做完了，将遍历数组a中的元素，封装为一个个节点。\n    for (Object o : a) {\n        @SuppressWarnings("unchecked") E e = (E) o;\n        //pred就是之前所构建好的，可能为null、也可能不为null，为null的话就是属于情况一、不为null则可能是情况二、或者情况三\n\n        Node<E> newNode = new Node<>(pred, e, null);\n        //如果pred==null，说明是情况一，构造方法，是刚创建的一个空链表，此时的newNode就当作第一个节点，所以把newNode给first头节点\n        if (pred == null)\n            first = newNode;\n        else\n            //如果pred！=null，说明可能是情况2或者情况3，如果是情况2，pred就是last，那么在最后一个节点之后追加到newNode，如果是情况3，在中间插入，pred为原index节点之前的一个节点，将它的next指向插入的节点，也是对的\n            pred.next = newNode;\n        //然后将pred换成newNode，注意，这个不在else之中，请看清楚了。\n        pred = newNode;\n    }\n\n    if (succ == null) {\n        /*如果succ==null，说明是情况一或者情况二，\n\t\t情况一、构造方法，也就是刚创建的一个空链表，pred已经是newNode了，last=newNode，所以linkedList的first、last都指向第一个节点。\n\t\t情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点\n了，就是newNode。*/\n        last = pred;\n    } else {\n        //如果succ！=null，说明可能是情况三、在中间插入节点，举例说明这几个参数的意义，有1、2两个节点，现在想在第二个位置插入节点newNode，根据前面的代码，pred=newNode，succ=2，并且1.next=newNode，已经构建好了，pred.next=succ，相当于在newNode.next =2； succ.prev = pred，相当于 2.prev = newNode， 这样一来，这种指向关系就完成了。first和last不用变，因为头节点和尾节点没变\n        pred.next = succ;\n        succ.prev = pred;\n    }\n\t//增加了几个元素，就把 size = size +numNew 就可以了\n    size += numNew;\n    modCount++;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n说明：参数中的index表示在索引下标为index的结点（实际上是第index + 1个结点）的前面插入。\n\n在addAll函数中，addAll函数中还会调用到node函数，get函数也会调用到node函数，此函数是根据索引下标找到该结点并返回，具体代码如下：\n\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\t// 判断插入的位置在链表前半段或者是后半段\n    if (index < (size >> 1)) {// 插入位置在前半段\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)// 从头结点开始正向遍历\n            x = x.next;\n        return x;// 返回该结点\n    } else {// 插入位置在后半段\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)// 从尾结点开始反向遍历\n            x = x.prev;\n        return x;// 返回该结点\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n说明：在根据索引查找结点时，会有一个小优化，结点在前半段则从头开始遍历，在后半段则从尾开始遍历，这样就保证了只需要遍历最多一半结点就可以找到指定索引的结点。\n\n举例说明调用addAll函数后的链表状态：\n\nList<Integer> lists = new LinkedList<Integer>();\nlists.add(5);\nlists.addAll(0, Arrays.asList(2, 3, 4, 5));\n\n\n1\n2\n3\n\n\n上述代码内部的链表结构如下：\n\n\n\naddAll()中的一个问题：\n\n在addAll函数中，传入一个集合参数和插入位置，然后将集合转化为数组，然后再遍历数组，挨个添加数组的元素，但是问题来了，为什么要先转化为数组再进行遍历，而不是直接遍历集合呢？\n\n从效果上两者是完全等价的，都可以达到遍历的效果。关于为什么要转化为数组的问题，我的思考如 下：\n\n 1. 如果直接遍历集合的话，那么在遍历过程中需要插入元素，在堆上分配内存空间，修改指针域，这个过程中就会一直占用着这个集合，考虑正确同步的话，其他线程只能一直等待。\n 2. 如果转化为数组，只需要遍历集合，而遍历集合过程中不需要额外的操作，所以占用的时间相对是较短的，这样就利于其他线程尽快的使用这个集合。说白了，就是有利于提高多线程访问该集合的效率，尽可能短时间的阻塞。\n\n# remove(Object o)\n\n/**\n * Removes the first occurrence of the specified element from this list,\n * if it is present.  If this list does not contain the element, it is\n * unchanged.  More formally, removes the element with the lowest index\n * {@code i} such that\n * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n * (if such an element exists).  Returns {@code true} if this list\n * contained the specified element (or equivalently, if this list\n * changed as a result of the call).\n *\n * @param o element to be removed from this list, if present\n * @return {@code true} if this list contained the specified element\n */\n\n///首先通过看上面的注释，我们可以知道，如果我们要移除的值在链表中存在多个一样的值，那么我们会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做。\npublic boolean remove(Object o) {\n    //这里可以看到，linkedList也能存储null\n    if (o == null) {\n        //循环遍历链表，直到找到null值，然后使用unlink移除该值。下面的这个else中也一样\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n【unlink(xxxx)】\n\n// Unlinks non-null node x.\n//不能传一个null值过，注意，看之前要注意之前的next、prev这些都是谁。\nE unlink(Node<E> x) {\n    // assert x != null;\n    //拿到节点x的三个属性\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\t\n    //这里开始往下就进行移除该元素之后的操作，也就是把指向哪个节点搞定。\n    if (prev == null) {\n        //说明移除的节点是头节点，则first头节点应该指向下一个节点\n        first = next;\n    } else {\n        //不是头节点，prev.next=next：有1、2、3，将1.next指向3\n        prev.next = next;\n        //然后解除x节点的前指向。\n        x.prev = null;\n    }\n\n    if (next == null) {\n        //说明移除的节点是尾节点\n        last = prev;\n    } else {\n        //不是尾节点，有1、2、3，将3.prev指向1. 然后将2.next=解除指向。\n        next.prev = prev;\n        x.next = null;\n    }\n\n    //x的前后指向都为null了，也把item为null，让gc回收它\n    x.item = null;\n    size--;//移除一个节点，size自减\n    modCount++;\n    return element;//由于一开始已经保存了x的值到element，所以返回。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# get(index)\n\n【get(index)查询元素的方法】\n\n/**\n    * Returns the element at the specified position in this list.\n    *\n    * @param index index of the element to return\n    * @return the element at the specified position in this list\n    * @throws IndexOutOfBoundsException {@inheritDoc}\n*/\n//这里没有什么，重点还是在node(index)中\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【node(index)】\n\n/**\n* Returns the (non-null) Node at the specified element index.\n*/\n//这里查询使用的是先从中间分一半查找\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n    //"<<":*2的几次方 “>>”:/2的几次方，例如：size<<1：size*2的1次方，\n    //这个if中就是查询前半部分\n    if (index < (size >> 1)) {//index<size/2\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {//前半部分没找到，所以找后半部分\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# indexOf(Object o)\n\n//这个很简单，就是通过实体元素来查找到该元素在链表中的位置。跟remove中的代码类似，只是返回类型不一样。\npublic int indexOf(Object o) {\n    int index = 0;\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null)\n                return index;\n            index++;\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item))\n                return index;\n            index++;\n        }\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 7、LinkedList的迭代器\n\n在LinkedList中除了有一个Node的内部类外，应该还能看到另外两个内部类，那就是ListItr，还有一个是DescendingIterator。\n\n【ListItr内部类】\n\nprivate class ListItr implements ListIterator<E> {\n}\n\n\n1\n2\n\n\n看一下他的继承结构，发现只继承了一个ListIterator，到ListIterator中一看：\n\n\n\n看到方法名之后，就发现不止有向后迭代的方法，还有向前迭代的方法，所以我们就知道了这个ListItr 这个内部类干嘛用的了，就是能让linkedList不光能像后迭代，也能向前迭代。\n\n看一下ListItr中的方法，可以发现，在迭代的过程中，还能移除、修改、添加值得操作。\n\n\n\n【DescendingIterator内部类】\n\nprivate class DescendingIterator implements Iterator<E> {\n    //看一下这个类，还是调用的ListItr，作用是封装一下Itr中几个方法，让使用者以正常的思维去写代码，例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特殊的previous。\n    private final ListItr itr = new ListItr(size());\n    public boolean hasNext() {\n        return itr.hasPrevious();\n    }\n    public E next() {\n        return itr.previous();\n    }\n    public void remove() {\n        itr.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 总结\n\n 1. linkedList本质上是一个双向链表，通过一个Node内部类实现的这种链表结构\n 2. 能存储null值\n 3. 跟arrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查询的性能上好\n 4. . 从源码中看，它不存在容量不足的情况\n 5. . linkedList不光能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值。\n 6. linkedList不光能当链表，还能当队列使用，这个就是因为实现了Deque接口。\n\n代码在 LinkedList源码分析中3、类的属性',normalizedContent:'# linkedlist\n\n\n# 引入\n\n问题：在集合的任何位置（头部，中间，尾部）添加，获取，删除狗狗对象！\n\n插入，删除操作频繁时，可使用linkedlist来提高效率\n\nlinkedlist提供对头部和尾部元素进行添加和删除操作的方法！\n\n\n\nlinkedlist的特殊方法\n\n\n\n集合框架有何好处？ java集合框架中包含哪些接口和类？ arraylist和linkedlist有何异同？\n\n\n# linkedlist概述\n\n我们都知道它的底层是由链表实现的，所以我们要明白什么是链表？\n\n\n\nlinkedlist是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的。\n\nlinkedlist 是一个继承于abstractsequentiallist的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。\n\nlinkedlist 实现 list 接口，能对它进行队列操作。\n\nlinkedlist 实现 deque 接口，即能将linkedlist当作双端队列使用。\n\nlinkedlist 实现了cloneable接口，即覆盖了函数clone()，能克隆。\n\nlinkedlist 实现java.io.serializable接口，这意味着linkedlist支持序列化，能通过序列化去传输。\n\nlinkedlist 是非同步的。\n\n推荐文章：linklist详解\n\n\n# 链表的数据结构\n\n单向链表：\n\nelement：用来存放元素\n\nnext：用来指向下一个节点元素\n\n通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。\n\n\n\n单向循环链表：\n\nelement、next 跟前面一样，在单向链表的最后一个节点的next会指向头节点，而不是指向null，这样存成一个环\n\n\n\n双向链表：\n\nelement：存放元素\n\npre：用来指向前一个元素\n\nnext：指向后一个元素\n\n双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。\n\n\n\n双向循环链表：\n\nelement、pre、next 跟前面的一样\n\n第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。\n\n\n\n【linkedlist的数据结构】\n\n\n\n如上图所示，linkedlist底层使用的双向链表结构，有一个头结点和一个尾结点，双向链表意味着我们可以从头开始正向遍历，或者是从尾开始逆向遍历，并且可以针对头部和尾部进行相应的操作。\n\n\n# linkedlist源码分析\n\n接下来又到了大家喜欢的读源码环节**😄**\n\n\n# 1、linkedlist的特性\n\n在我们平常中，我们只知道一些常识性的特点：\n\n1）是通过链表实现的 2）如果在频繁的插入，或者删除数据时，就用linkedlist性能会更好。\n\n那我们通过api去查看它的一些特性\n\n> doubly-linked list implementation of the list and deque interfaces. implements all optional list operations, and permits all elements (including null).\n> \n> 这告诉我们，linkedlist是一个双向链表，并且实现了list和deque接口中所有的列表操作，并且能存储任何元素，包括null，这里我们可以知道linkedlist除了可以当链表使用，还可以当作队列使用，并能进行相应的操作。\n> \n> all of the operations perform as could be expected for a doubly-linked list. operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n> \n> 这个告诉我们，linkedlist在执行任何操作的时候，都必须先遍历此列表来靠近通过index查找我们所需要的的值。通俗点讲，这就告诉了我们这个是顺序存取，每次操作必须先按开始到结束的顺序遍历，随机存取，就是arraylist，能够通过index。随便访问其中的任意位置的数据，这就是随机列表的意思。\n\n3）api中接下来讲的一大堆，就是说明linkedlist是一个非线程安全的(异步)，其中在操作interator时， 如果改变列表结构(adddelete等)，会发生fail-fast。\n\n通过api再次总结一下linkedlist的特性：\n\n 1. 异步，也就是非线程安全\n\n 2. 双向链表。由于实现了list和deque接口，能够当作队列来使用。\n    \n    链表：查询效率不高，但是插入和删除这种操作性能好。\n\n 3. 是顺序存取结构（注意和随机存取结构两个概念搞清楚）\n\n\n# 2、继承结构以及层次关系\n\nctrl+h\n\n\n\n我们可以看到，linkedlist在最底层，说明他的功能最为强大，并且细心的还会发现，arraylist有四层，这里多了一层abstractsequentiallist的抽象类，为什么呢？\n\n通过api我们会发现：\n\n1）减少实现顺序存取（例如linkedlist）这种类的工作，通俗的讲就是方便，抽象出类似linkedlist这种类的一些共同的方法\n\n2）既然有了上面这句话，那么以后如果自己想实现顺序存取这种特性的类(就是链表形式)，那么就继承这个abstractsequentiallist抽象类，如果想像数组那样的随机存取的类，那么就去实现abstraclist抽象类。\n\n3）这样的分层，就很符合我们抽象的概念，越在高处的类，就越抽象，往在底层的类，就越有自己独特的个性。自己要慢慢领会这种思想。\n\n4）linkedlist的类继承结构很有意思，我们着重要看是deque接口，deque接口表示是一个双端队列，那么也意味着linkedlist是双端队列的一种实现，所以，基于双端队列的操作在linkedlist中全部有效。\n\npublic abstract class abstractsequentiallist<e>\nextends abstractlist<e>\n\n\n1\n2\n\n\n\n\n第一段：\n\n> 这里第一段就解释了这个类的作用，这个类为实现list接口提供了一些重要的方法， 尽最大努力去减少实现这个“顺序存取”的特性的数据存储(例如链表)的什么 随机存取数据(例如数组)的类应该优先使用abstractlist 从上面就可以大概知道，abstractswquentiallist这个类是为了减少linkedlist这种顺序存取的类的代码复杂度而抽象的一个类，\n\n第二段：\n\n> 这一段大概讲的就是这个abstractsequentiallist这个类和abstractlist这个类是完全相反 的。比如get、add这个方法的实现\n\n第三段：\n\n> 这里就是讲一些我们自己要继承该类，该做些什么事情，一些规范。\n\n【接口实现分析】\n\npublic class linkedlist<e>\n    extends abstractsequentiallist<e>\n    implements list<e>, deque<e>, cloneable, java.io.serializable\n    {\n    \n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n 1. list接口：列表，add、set、等一些对列表进行操作的方法\n\n 2. deque接口：有队列的各种特性，\n\n 3. cloneable接口：能够复制，使用那个copy方法。\n\n 4. serializable接口：能够序列化。\n\n 5. 应该注意到没有randomaccess：那么就推荐使用iterator，在其中就有一个foreach，增强的for循环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator都可以。\n    \n    iterator：\n    \n    public static void method() {\n        list<string> l = new arraylist<>();\n    \n        l.add("hello");\n        l.add(0, "123");\n        l.add("789");\n        l.set(0, "456");\n        l.remove(0);\n    \n        listiterator<string> lit = l.listiterator();\n        while (lit.hasnext()) {\n            string next = lit.next();\n    //            l.add("111");\n            lit.add("111");\n            system.out.println(next);\n    \n        }\n        system.out.println(l);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n\n# 3、类的属性\n\npublic class linkedlist<e>\n    extends abstractsequentiallist<e>\n    implements list<e>, deque<e>, cloneable, java.io.serializable\n{\n    // 实际元素个数\n    transient int size = 0;\n    // 头结点\n    transient node<e> first;\n    // 尾结点\n    transient node<e> last;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nlinkedlist的属性非常简单，一个头结点、一个尾结点、一个表示链表中实际元素个数的变量。注意， 头结点、尾结点都有transient关键字修饰，这也意味着在序列化时该域是不会序列化的。\n\n\n# 4、构造方法\n\n两个构造方法(两个构造方法都是规范规定需要写的）\n\n【空参构造函数】\n\npublic linkedlist() {\n    \n}\n\n\n1\n2\n3\n\n\n【有参构造函数】\n\n//将集合c中的各个元素构建成linkedlist链表。\npublic linkedlist(collection<? extends e> c) {\n    // 调用无参构造函数\n    this();\n    // 添加集合中所有的元素\n    addall(c);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n说明：会调用无参构造函数，并且会把集合中所有的元素添加到linkedlist中。\n\n\n# 5、内部类（node）\n\n//根据前面介绍双向链表就知道这个代表什么了，linkedlist的奥秘就在这里。\nprivate static class node<e> {\n    e item; // 数据域（当前节点的值）\n    node<e> next; // 后继（指向当前一个节点的后一个节点）\n    node<e> prev; // 前驱（指向当前节点的前一个节点）\n    \n    // 构造函数，赋值前驱后继\n    node(node<e> prev, e element, node<e> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n说明：内部类node就是实际的结点，用于存放实际元素的地方。\n\n\n# 6、核心方法\n\n# add()方法\n\npublic boolean add(e e) {\n    // 添加到末尾\n    linklast(e);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n\n\n说明：add函数用于向linkedlist中添加一个元素，并且添加到链表尾部。具体添加到尾部的逻辑是由 linklast函数完成的。\n\n【linklast(xxxxx)】\n\n/**\n * links e as last element.\n */\nvoid linklast(e e) {\n    final node<e> l = last; //临时节点l(l的小写)保存last，也就是l指向了最后一个节点\n    final node<e> newnode = new node<>(l, e, null);////将e封装为节点，并且e.prev指向了最后一个节点\n    last = newnode;//newnode成为了最后一个节点，所以last指向了它\n    if (l == null)//判断是不是一开始链表中就什么都没有，如果没有，则newnode就成为了第一个节点，first和last都要指向它\n        first = newnode;\n    else  //正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的最后一个节点，原先的最后一个节点就变成了倒数第二个节点\n        l.next = newnode;\n    size++; ;//添加一个节点，size自增\n    modcount++;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n说明：对于添加一个元素至链表中会调用add方法 -> linklast方法。\n\n【举例一】\n\nlist<integer> lists = new linkedlist<integer>();\nlists.add(5);\nlists.add(6);\n\n\n1\n2\n3\n\n\n首先调用无参构造函数，之后添加元素5，之后再添加元素6。具体的示意图如下：\n\n\n\n上图的表明了在执行每一条语句后，链表对应的状态。\n\n# addall()方法\n\naddall有两个重载函数，addall(collection)型和addall(int, collection) 型，我们平时习惯调用的addall(collection)型会转化为addall(int, collection)型。\n\npublic boolean addall(collection<? extends e> c) {\n//继续往下看\nreturn addall(size, c);\n}\n\n\n1\n2\n3\n4\n\n\naddall(size，c)：这个方法，能包含三种情况下的添加，我们这里分析的只是构造方法，空链表的情况，看的时候只需要按照不同的情况分析下去就行了。\n\n//真正核心的地方就是这里了，记得我们传过来的是size，c\npublic boolean addall(int index, collection<? extends e> c) {\n    //检查index这个是否为合理。这个很简单，自己点进去看下就明白了。\n    checkpositionindex(index);\n\t//将集合c转换为object数组 a\n    object[] a = c.toarray();\n    //数组a的长度numnew，也就是由多少个元素\n    int numnew = a.length;\n    if (numnew == 0)\n        //集合c是个空的，直接返回false，什么也不做。\n        return false;\n\t//集合c是非空的，定义两个节点(内部类)，每个节点都有三个属性，item、next、prev。注意：不要管这两个什么含义，就是用来做临时存储节点的。这个node看下面一步的源码分析，node就是linkedlist的最核心的实现，可以直接先跳下一个去看node的分析\n    node<e> pred, succ;\n    //构造方法中传过来的就是index==size\n    if (index == size) {\n        //linkedlist中三个属性：size、first、last。 size：链表中的元素个数。first：头节点 last：尾节点，就两种情况能进来这里\n        //情况一、：构造方法创建的一个空的链表，那么size=0，last、和first都为null。linkedlist中是空的。什么节点都没有。succ=null、pred=last=null\n        \n        //情况二、：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到pred临时节点中。\n\n        succ = null;\n        pred = last;\n    } else {\n        //情况三、index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知道index上的节点是谁，保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了\n        //举个简单的例子，有2个位置，1、2、如果想插数据到第二个位置，双向链表中，就需要知道第一个位置是谁，原位置也就是第二个位置上是谁，然后才能将自己插到第二个位置上。如果这里还不明白，先看一下文章开头对于各种链表的删除，add操作是怎么实现的。\n        succ = node(index);\n        pred = succ.prev;\n    }\n\t//前面的准备工作做完了，将遍历数组a中的元素，封装为一个个节点。\n    for (object o : a) {\n        @suppresswarnings("unchecked") e e = (e) o;\n        //pred就是之前所构建好的，可能为null、也可能不为null，为null的话就是属于情况一、不为null则可能是情况二、或者情况三\n\n        node<e> newnode = new node<>(pred, e, null);\n        //如果pred==null，说明是情况一，构造方法，是刚创建的一个空链表，此时的newnode就当作第一个节点，所以把newnode给first头节点\n        if (pred == null)\n            first = newnode;\n        else\n            //如果pred！=null，说明可能是情况2或者情况3，如果是情况2，pred就是last，那么在最后一个节点之后追加到newnode，如果是情况3，在中间插入，pred为原index节点之前的一个节点，将它的next指向插入的节点，也是对的\n            pred.next = newnode;\n        //然后将pred换成newnode，注意，这个不在else之中，请看清楚了。\n        pred = newnode;\n    }\n\n    if (succ == null) {\n        /*如果succ==null，说明是情况一或者情况二，\n\t\t情况一、构造方法，也就是刚创建的一个空链表，pred已经是newnode了，last=newnode，所以linkedlist的first、last都指向第一个节点。\n\t\t情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点\n了，就是newnode。*/\n        last = pred;\n    } else {\n        //如果succ！=null，说明可能是情况三、在中间插入节点，举例说明这几个参数的意义，有1、2两个节点，现在想在第二个位置插入节点newnode，根据前面的代码，pred=newnode，succ=2，并且1.next=newnode，已经构建好了，pred.next=succ，相当于在newnode.next =2； succ.prev = pred，相当于 2.prev = newnode， 这样一来，这种指向关系就完成了。first和last不用变，因为头节点和尾节点没变\n        pred.next = succ;\n        succ.prev = pred;\n    }\n\t//增加了几个元素，就把 size = size +numnew 就可以了\n    size += numnew;\n    modcount++;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n说明：参数中的index表示在索引下标为index的结点（实际上是第index + 1个结点）的前面插入。\n\n在addall函数中，addall函数中还会调用到node函数，get函数也会调用到node函数，此函数是根据索引下标找到该结点并返回，具体代码如下：\n\nnode<e> node(int index) {\n    // assert iselementindex(index);\n\t// 判断插入的位置在链表前半段或者是后半段\n    if (index < (size >> 1)) {// 插入位置在前半段\n        node<e> x = first;\n        for (int i = 0; i < index; i++)// 从头结点开始正向遍历\n            x = x.next;\n        return x;// 返回该结点\n    } else {// 插入位置在后半段\n        node<e> x = last;\n        for (int i = size - 1; i > index; i--)// 从尾结点开始反向遍历\n            x = x.prev;\n        return x;// 返回该结点\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n说明：在根据索引查找结点时，会有一个小优化，结点在前半段则从头开始遍历，在后半段则从尾开始遍历，这样就保证了只需要遍历最多一半结点就可以找到指定索引的结点。\n\n举例说明调用addall函数后的链表状态：\n\nlist<integer> lists = new linkedlist<integer>();\nlists.add(5);\nlists.addall(0, arrays.aslist(2, 3, 4, 5));\n\n\n1\n2\n3\n\n\n上述代码内部的链表结构如下：\n\n\n\naddall()中的一个问题：\n\n在addall函数中，传入一个集合参数和插入位置，然后将集合转化为数组，然后再遍历数组，挨个添加数组的元素，但是问题来了，为什么要先转化为数组再进行遍历，而不是直接遍历集合呢？\n\n从效果上两者是完全等价的，都可以达到遍历的效果。关于为什么要转化为数组的问题，我的思考如 下：\n\n 1. 如果直接遍历集合的话，那么在遍历过程中需要插入元素，在堆上分配内存空间，修改指针域，这个过程中就会一直占用着这个集合，考虑正确同步的话，其他线程只能一直等待。\n 2. 如果转化为数组，只需要遍历集合，而遍历集合过程中不需要额外的操作，所以占用的时间相对是较短的，这样就利于其他线程尽快的使用这个集合。说白了，就是有利于提高多线程访问该集合的效率，尽可能短时间的阻塞。\n\n# remove(object o)\n\n/**\n * removes the first occurrence of the specified element from this list,\n * if it is present.  if this list does not contain the element, it is\n * unchanged.  more formally, removes the element with the lowest index\n * {@code i} such that\n * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n * (if such an element exists).  returns {@code true} if this list\n * contained the specified element (or equivalently, if this list\n * changed as a result of the call).\n *\n * @param o element to be removed from this list, if present\n * @return {@code true} if this list contained the specified element\n */\n\n///首先通过看上面的注释，我们可以知道，如果我们要移除的值在链表中存在多个一样的值，那么我们会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做。\npublic boolean remove(object o) {\n    //这里可以看到，linkedlist也能存储null\n    if (o == null) {\n        //循环遍历链表，直到找到null值，然后使用unlink移除该值。下面的这个else中也一样\n        for (node<e> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (node<e> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n【unlink(xxxx)】\n\n// unlinks non-null node x.\n//不能传一个null值过，注意，看之前要注意之前的next、prev这些都是谁。\ne unlink(node<e> x) {\n    // assert x != null;\n    //拿到节点x的三个属性\n    final e element = x.item;\n    final node<e> next = x.next;\n    final node<e> prev = x.prev;\n\t\n    //这里开始往下就进行移除该元素之后的操作，也就是把指向哪个节点搞定。\n    if (prev == null) {\n        //说明移除的节点是头节点，则first头节点应该指向下一个节点\n        first = next;\n    } else {\n        //不是头节点，prev.next=next：有1、2、3，将1.next指向3\n        prev.next = next;\n        //然后解除x节点的前指向。\n        x.prev = null;\n    }\n\n    if (next == null) {\n        //说明移除的节点是尾节点\n        last = prev;\n    } else {\n        //不是尾节点，有1、2、3，将3.prev指向1. 然后将2.next=解除指向。\n        next.prev = prev;\n        x.next = null;\n    }\n\n    //x的前后指向都为null了，也把item为null，让gc回收它\n    x.item = null;\n    size--;//移除一个节点，size自减\n    modcount++;\n    return element;//由于一开始已经保存了x的值到element，所以返回。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n# get(index)\n\n【get(index)查询元素的方法】\n\n/**\n    * returns the element at the specified position in this list.\n    *\n    * @param index index of the element to return\n    * @return the element at the specified position in this list\n    * @throws indexoutofboundsexception {@inheritdoc}\n*/\n//这里没有什么，重点还是在node(index)中\npublic e get(int index) {\n    checkelementindex(index);\n    return node(index).item;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【node(index)】\n\n/**\n* returns the (non-null) node at the specified element index.\n*/\n//这里查询使用的是先从中间分一半查找\nnode<e> node(int index) {\n    // assert iselementindex(index);\n    //"<<":*2的几次方 “>>”:/2的几次方，例如：size<<1：size*2的1次方，\n    //这个if中就是查询前半部分\n    if (index < (size >> 1)) {//index<size/2\n        node<e> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {//前半部分没找到，所以找后半部分\n        node<e> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# indexof(object o)\n\n//这个很简单，就是通过实体元素来查找到该元素在链表中的位置。跟remove中的代码类似，只是返回类型不一样。\npublic int indexof(object o) {\n    int index = 0;\n    if (o == null) {\n        for (node<e> x = first; x != null; x = x.next) {\n            if (x.item == null)\n                return index;\n            index++;\n        }\n    } else {\n        for (node<e> x = first; x != null; x = x.next) {\n            if (o.equals(x.item))\n                return index;\n            index++;\n        }\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 7、linkedlist的迭代器\n\n在linkedlist中除了有一个node的内部类外，应该还能看到另外两个内部类，那就是listitr，还有一个是descendingiterator。\n\n【listitr内部类】\n\nprivate class listitr implements listiterator<e> {\n}\n\n\n1\n2\n\n\n看一下他的继承结构，发现只继承了一个listiterator，到listiterator中一看：\n\n\n\n看到方法名之后，就发现不止有向后迭代的方法，还有向前迭代的方法，所以我们就知道了这个listitr 这个内部类干嘛用的了，就是能让linkedlist不光能像后迭代，也能向前迭代。\n\n看一下listitr中的方法，可以发现，在迭代的过程中，还能移除、修改、添加值得操作。\n\n\n\n【descendingiterator内部类】\n\nprivate class descendingiterator implements iterator<e> {\n    //看一下这个类，还是调用的listitr，作用是封装一下itr中几个方法，让使用者以正常的思维去写代码，例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特殊的previous。\n    private final listitr itr = new listitr(size());\n    public boolean hasnext() {\n        return itr.hasprevious();\n    }\n    public e next() {\n        return itr.previous();\n    }\n    public void remove() {\n        itr.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 总结\n\n 1. linkedlist本质上是一个双向链表，通过一个node内部类实现的这种链表结构\n 2. 能存储null值\n 3. 跟arraylist相比较，就真正的知道了，linkedlist在删除和增加等操作上性能好，而arraylist在查询的性能上好\n 4. . 从源码中看，它不存在容量不足的情况\n 5. . linkedlist不光能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值。\n 6. linkedlist不光能当链表，还能当队列使用，这个就是因为实现了deque接口。\n\n代码在 linkedlist源码分析中3、类的属性',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Vevtor和Stack",frontmatter:{title:"Vevtor和Stack",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/Vevtor-Stack/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04.Vevtor%E5%92%8CStack.html",relativePath:"01.Java/05.Java-集合框架/04.Vevtor和Stack.md",key:"v-b2628b0c",path:"/java/se/collection/Vevtor-Stack/",headers:[{level:3,title:"1、Vector概述",slug:"_1、vector概述",normalizedTitle:"1、vector概述",charIndex:560},{level:3,title:"2、Vector源码分析",slug:"_2、vector源码分析",normalizedTitle:"2、vector源码分析",charIndex:1038},{level:4,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:1264},{level:4,title:"核心方法",slug:"核心方法",normalizedTitle:"核心方法",charIndex:3926},{level:3,title:"3、Stack",slug:"_3、stack",normalizedTitle:"3、stack",charIndex:6064},{level:3,title:"4、总结Vector和Stack",slug:"_4、总结vector和stack",normalizedTitle:"4、总结vector和stack",charIndex:6276}],headersStr:"1、Vector概述 2、Vector源码分析 构造方法 核心方法 3、Stack 4、总结Vector和Stack",content:'# Vevtor和Stack\n\n前面写了一篇关于的是LinkedList的除了它的数据结构稍微有一点复杂之外，其他的都很好理解的。这 一篇说的大家在开发中很少去用到，有的时候也可能是会用到的，了解就行。\n\n注意在学习这一篇之前，需要有多线程的知识：\n\n1）锁机制：对象锁、方法锁、类锁\n\n对象锁就是方法锁：就是在一个类中的方法上加上synchronized关键字，这就是给这个方法加锁了。\n\n类锁：锁的是整个类，当有多个线程来声明这个类的对象的时候将会被阻塞，直到拥有这个类锁的对象被销毁或者主动释放了类锁。这个时候在被阻塞住的线程被挑选出一个占有该类锁，声明该类的对象。 其他线程继续被阻塞住。例如：在类A上有关键字synchronized，那么就是给类A加了类锁，线程1第一 个声明此类的实例，则线程1拿到了该类锁，线程2在想声明类A的对象，就会被阻塞。\n\n2）在本文中，使用的是方法锁。\n\n3）每个对象只有一把锁，有线程A，线程B，还有一个集合C类，线程A操作C拿到了集合中的锁（在集合C中有用synchronized关键字修饰的），并且还没有执行完，那么线程A就不会释放锁，当轮到线程B去操作集合C中的方法时 ，发现锁被人拿走了，所以线程B只能等待那个拿到锁的线程使用完，然后才能拿到锁进行相应的操作。\n\n\n# 1、Vector概述\n\n\n\n通过API中可以知道：\n\n 1. Vector是一个可变化长度的数组\n 2. Vector增加长度通过的是capacity和capacityIncrement这两个变量，目前还不知道如何实现自动 扩增的，等会源码分析\n 3. Vector也可以获得iterator和listIterator这两个迭代器，并且他们发生的是fail-fast，而不是failsafe，注意这里，不要觉得这个vector是线程安全就搞错了，具体分析在下面会说\n 4. Vector是一个线程安全的类，如果使用需要线程安全就使用Vector，如果不需要，就使用arrayList\n 5. Vector和ArrayList很类似，就少许的不一样，从它继承的类和实现的接口来看，跟arrayList一模一 样。\n\n注意：java1.5推出的java.uitl.concurrent包，为了解决复杂的并发问题的。所以开发中，不建议用vector，原因在文章的结束会有解释，需要线程安全的集合类直接用java.util.concurrent包下的类。\n\n\n# 2、Vector源码分析\n\npublic class Vector<E>\n    extends AbstractList<E>\n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n    {\n    \n\t}\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们发现Vector的继承关系和层次结构和ArrayList中的一模一样，忘记的可以去ArrayList标题查看！\n\n# 构造方法\n\n一共有四个构造方法。\n\n构造方法作用：\n\n * 初始化存储元素的容器，也就是数组，elementData，\n * 初始化capacityIncrement的大小，默认是0，这个的作用就是扩展数组的时候，增长的大小，为0 则每次扩展2倍\n\nVector()：空构造\n\n/**\n * Constructs an empty vector so that its internal data array\n * has size {@code 10} and its standard capacity increment is\n * zero.\n */\n///看注释，这个是一个空的Vector构造方法，所以让他使用内置的数组，这里还不知道什么是内置的数组，看它调用了自身另外一个带一个参数的构造器\npublic Vector() {\n    this(10);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nVector(int)\n\n/**\n * Constructs an empty vector with the specified initial capacity and\n * with its capacity increment equal to zero.\n *\n * @param   initialCapacity   the initial capacity of the vector\n * @throws IllegalArgumentException if the specified initial capacity\n *         is negative\n */\n//注释说，给空的cector构造器用和带有一个特定初始化容量用的，并且又调用了另外一个带两个参数的构造器，并且给容量增长值(capacityIncrement=0)为0，查看vector中的变量可以发现capacityIncrement是一个成员变量\n\npublic Vector(int initialCapacity) {\n    this(initialCapacity, 0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nector(int，int)\n\n/**\n * Constructs an empty vector with the specified initial capacity and\n * capacity increment.\n *\n * @param   initialCapacity     the initial capacity of the vector\n * @param   capacityIncrement   the amount by which the capacity is\n *                              increased when the vector overflows\n * @throws IllegalArgumentException if the specified initial capacity\n *         is negative\n */\n//构建一个有特定的初始化容量和容量增长值的空的Vector，\npublic Vector(int initialCapacity, int capacityIncrement) {\n    super();//调用父类的构造，是个空构造\n    if (initialCapacity < 0)//小于0，会报非法参数异常：不合法的容量\n        throw new IllegalArgumentException("Illegal Capacity: "+\n                                           initialCapacity);\n    this.elementData = new Object[initialCapacity];//elementData是一个成员变量数组，初始化它，并给它初始化长度。默认就是10，除非自己给值。\n    this.capacityIncrement = capacityIncrement;//capacityIncrement的意思是如果要扩增数组，每次增长该值，如果该值为0，那数组就变为两倍的原长度，这个之后会分析到\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nVector(Collection c)\n\n/**\n * Constructs a vector containing the elements of the specified\n * collection, in the order they are returned by the collection\'s\n * iterator.\n *\n * @param c the collection whose elements are to be placed into this\n *       vector\n * @throws NullPointerException if the specified collection is null\n * @since   1.2\n */\n//将集合c变为Vector，返回Vector的迭代器。\npublic Vector(Collection<? extends E> c) {\n    elementData = c.toArray();\n    elementCount = elementData.length;\n    // c.toArray might (incorrectly) not return Object[] (see 6260652)\n    if (elementData.getClass() != Object[].class)\n        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 核心方法\n\nadd()方法\n\n/**\n * Appends the specified element to the end of this Vector.\n *\n * @param e element to be appended to this Vector\n * @return {@code true} (as specified by {@link Collection#add})\n * @since 1.2\n */\n\n//就是在vector中的末尾追加元素。但是看方法，synchronized，明白了为什么vector是线程安全的，因为在方法前面加了synchronized关键字，给该方法加锁了，哪个线程先调用它，其它线程就得等着，如果不清楚的就去看看多线程的知识，到后面我也会一一总结的。\npublic synchronized boolean add(E e) {\n    modCount++;\n    //通过arrayList的源码分析经验，这个方法应该是在增加元素前，检查容量是否够用\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nensureCapacityHelper(int)\n\n/**\n * This implements the unsynchronized semantics of ensureCapacity.\n * Synchronized methods in this class can internally call this\n * method for ensuring capacity without incurring the cost of an\n * extra synchronization.\n *\n * @see #ensureCapacity(int)\n */\n////这里注释解释，这个方法是异步(也就是能被多个线程同时访问)的，原因是为了让同步方法都能调用到这个检测容量的方法，比如add的同时，另一个线程调用了add的重载方法，那么两个都需要同时查询容量够不够，所以这个就不需要用synchronized修饰了。因为不会发生线程不安全的问题\nprivate void ensureCapacityHelper(int minCapacity) {\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        //容量不够，就扩增，核心方法\n        grow(minCapacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ngrow(int)\n\n//看一下这个方法，其实跟arrayList一样，唯一的不同就是在扩增数组的方式不一样，如果capacityIncrement不为0，那么增长的长度就是capacityIncrement，如果为0，那么扩增为2倍的原容量\n    \nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n只要能看的懂ArrayList，这个就是在每个方法上比arrayList多了一个synchronized，其他都一 样。这里就不再分析了！\n\npublic synchronized E get(int index) {\n    if (index >= elementCount)\n    \tthrow new ArrayIndexOutOfBoundsException(index);\n    \n    return elementData(index);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、Stack\n\n现在来看看Vector的子类Stack，学过数据结构都知道，这个就是栈的意思。那么该类就是跟栈的用法一 样了\n\nclass Stack<E> extends Vector<E> {}\n\n\n1\n\n\n通过查看他的方法，和查看api文档，很容易就能知道他的特性。就几个操作，出栈，入栈等，构造方法也是空的，用的还是数组，父类中的构造，跟父类一样的扩增方式，并且它的方法也是同步的，所以也是线程安全。\n\n\n\n\n# 4、总结Vector和Stack\n\n【Vector总结（通过源码分析）】\n\n 1. Vector线程安全是因为它的方法都加了synchronized关键字\n 2. Vector的本质是一个数组，特点能是能够自动扩增，扩增的方式跟capacityIncrement的值有关\n 3. 它也会fail-fast，还有一个fail-safe两个的区别在下面的list总结中会讲到。\n\n【Stack的总结】\n\n 1. 对栈的一些操作，先进后出\n 2. 底层也是用数组实现的，因为继承了Vector\n 3. 也是线程安全的',normalizedContent:'# vevtor和stack\n\n前面写了一篇关于的是linkedlist的除了它的数据结构稍微有一点复杂之外，其他的都很好理解的。这 一篇说的大家在开发中很少去用到，有的时候也可能是会用到的，了解就行。\n\n注意在学习这一篇之前，需要有多线程的知识：\n\n1）锁机制：对象锁、方法锁、类锁\n\n对象锁就是方法锁：就是在一个类中的方法上加上synchronized关键字，这就是给这个方法加锁了。\n\n类锁：锁的是整个类，当有多个线程来声明这个类的对象的时候将会被阻塞，直到拥有这个类锁的对象被销毁或者主动释放了类锁。这个时候在被阻塞住的线程被挑选出一个占有该类锁，声明该类的对象。 其他线程继续被阻塞住。例如：在类a上有关键字synchronized，那么就是给类a加了类锁，线程1第一 个声明此类的实例，则线程1拿到了该类锁，线程2在想声明类a的对象，就会被阻塞。\n\n2）在本文中，使用的是方法锁。\n\n3）每个对象只有一把锁，有线程a，线程b，还有一个集合c类，线程a操作c拿到了集合中的锁（在集合c中有用synchronized关键字修饰的），并且还没有执行完，那么线程a就不会释放锁，当轮到线程b去操作集合c中的方法时 ，发现锁被人拿走了，所以线程b只能等待那个拿到锁的线程使用完，然后才能拿到锁进行相应的操作。\n\n\n# 1、vector概述\n\n\n\n通过api中可以知道：\n\n 1. vector是一个可变化长度的数组\n 2. vector增加长度通过的是capacity和capacityincrement这两个变量，目前还不知道如何实现自动 扩增的，等会源码分析\n 3. vector也可以获得iterator和listiterator这两个迭代器，并且他们发生的是fail-fast，而不是failsafe，注意这里，不要觉得这个vector是线程安全就搞错了，具体分析在下面会说\n 4. vector是一个线程安全的类，如果使用需要线程安全就使用vector，如果不需要，就使用arraylist\n 5. vector和arraylist很类似，就少许的不一样，从它继承的类和实现的接口来看，跟arraylist一模一 样。\n\n注意：java1.5推出的java.uitl.concurrent包，为了解决复杂的并发问题的。所以开发中，不建议用vector，原因在文章的结束会有解释，需要线程安全的集合类直接用java.util.concurrent包下的类。\n\n\n# 2、vector源码分析\n\npublic class vector<e>\n    extends abstractlist<e>\n    implements list<e>, randomaccess, cloneable, java.io.serializable\n    {\n    \n\t}\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们发现vector的继承关系和层次结构和arraylist中的一模一样，忘记的可以去arraylist标题查看！\n\n# 构造方法\n\n一共有四个构造方法。\n\n构造方法作用：\n\n * 初始化存储元素的容器，也就是数组，elementdata，\n * 初始化capacityincrement的大小，默认是0，这个的作用就是扩展数组的时候，增长的大小，为0 则每次扩展2倍\n\nvector()：空构造\n\n/**\n * constructs an empty vector so that its internal data array\n * has size {@code 10} and its standard capacity increment is\n * zero.\n */\n///看注释，这个是一个空的vector构造方法，所以让他使用内置的数组，这里还不知道什么是内置的数组，看它调用了自身另外一个带一个参数的构造器\npublic vector() {\n    this(10);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nvector(int)\n\n/**\n * constructs an empty vector with the specified initial capacity and\n * with its capacity increment equal to zero.\n *\n * @param   initialcapacity   the initial capacity of the vector\n * @throws illegalargumentexception if the specified initial capacity\n *         is negative\n */\n//注释说，给空的cector构造器用和带有一个特定初始化容量用的，并且又调用了另外一个带两个参数的构造器，并且给容量增长值(capacityincrement=0)为0，查看vector中的变量可以发现capacityincrement是一个成员变量\n\npublic vector(int initialcapacity) {\n    this(initialcapacity, 0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nector(int，int)\n\n/**\n * constructs an empty vector with the specified initial capacity and\n * capacity increment.\n *\n * @param   initialcapacity     the initial capacity of the vector\n * @param   capacityincrement   the amount by which the capacity is\n *                              increased when the vector overflows\n * @throws illegalargumentexception if the specified initial capacity\n *         is negative\n */\n//构建一个有特定的初始化容量和容量增长值的空的vector，\npublic vector(int initialcapacity, int capacityincrement) {\n    super();//调用父类的构造，是个空构造\n    if (initialcapacity < 0)//小于0，会报非法参数异常：不合法的容量\n        throw new illegalargumentexception("illegal capacity: "+\n                                           initialcapacity);\n    this.elementdata = new object[initialcapacity];//elementdata是一个成员变量数组，初始化它，并给它初始化长度。默认就是10，除非自己给值。\n    this.capacityincrement = capacityincrement;//capacityincrement的意思是如果要扩增数组，每次增长该值，如果该值为0，那数组就变为两倍的原长度，这个之后会分析到\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nvector(collection c)\n\n/**\n * constructs a vector containing the elements of the specified\n * collection, in the order they are returned by the collection\'s\n * iterator.\n *\n * @param c the collection whose elements are to be placed into this\n *       vector\n * @throws nullpointerexception if the specified collection is null\n * @since   1.2\n */\n//将集合c变为vector，返回vector的迭代器。\npublic vector(collection<? extends e> c) {\n    elementdata = c.toarray();\n    elementcount = elementdata.length;\n    // c.toarray might (incorrectly) not return object[] (see 6260652)\n    if (elementdata.getclass() != object[].class)\n        elementdata = arrays.copyof(elementdata, elementcount, object[].class);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 核心方法\n\nadd()方法\n\n/**\n * appends the specified element to the end of this vector.\n *\n * @param e element to be appended to this vector\n * @return {@code true} (as specified by {@link collection#add})\n * @since 1.2\n */\n\n//就是在vector中的末尾追加元素。但是看方法，synchronized，明白了为什么vector是线程安全的，因为在方法前面加了synchronized关键字，给该方法加锁了，哪个线程先调用它，其它线程就得等着，如果不清楚的就去看看多线程的知识，到后面我也会一一总结的。\npublic synchronized boolean add(e e) {\n    modcount++;\n    //通过arraylist的源码分析经验，这个方法应该是在增加元素前，检查容量是否够用\n    ensurecapacityhelper(elementcount + 1);\n    elementdata[elementcount++] = e;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nensurecapacityhelper(int)\n\n/**\n * this implements the unsynchronized semantics of ensurecapacity.\n * synchronized methods in this class can internally call this\n * method for ensuring capacity without incurring the cost of an\n * extra synchronization.\n *\n * @see #ensurecapacity(int)\n */\n////这里注释解释，这个方法是异步(也就是能被多个线程同时访问)的，原因是为了让同步方法都能调用到这个检测容量的方法，比如add的同时，另一个线程调用了add的重载方法，那么两个都需要同时查询容量够不够，所以这个就不需要用synchronized修饰了。因为不会发生线程不安全的问题\nprivate void ensurecapacityhelper(int mincapacity) {\n    // overflow-conscious code\n    if (mincapacity - elementdata.length > 0)\n        //容量不够，就扩增，核心方法\n        grow(mincapacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ngrow(int)\n\n//看一下这个方法，其实跟arraylist一样，唯一的不同就是在扩增数组的方式不一样，如果capacityincrement不为0，那么增长的长度就是capacityincrement，如果为0，那么扩增为2倍的原容量\n    \nprivate void grow(int mincapacity) {\n    // overflow-conscious code\n    int oldcapacity = elementdata.length;\n    int newcapacity = oldcapacity + ((capacityincrement > 0) ?\n                                     capacityincrement : oldcapacity);\n    if (newcapacity - mincapacity < 0)\n        newcapacity = mincapacity;\n    if (newcapacity - max_array_size > 0)\n        newcapacity = hugecapacity(mincapacity);\n    elementdata = arrays.copyof(elementdata, newcapacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n只要能看的懂arraylist，这个就是在每个方法上比arraylist多了一个synchronized，其他都一 样。这里就不再分析了！\n\npublic synchronized e get(int index) {\n    if (index >= elementcount)\n    \tthrow new arrayindexoutofboundsexception(index);\n    \n    return elementdata(index);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、stack\n\n现在来看看vector的子类stack，学过数据结构都知道，这个就是栈的意思。那么该类就是跟栈的用法一 样了\n\nclass stack<e> extends vector<e> {}\n\n\n1\n\n\n通过查看他的方法，和查看api文档，很容易就能知道他的特性。就几个操作，出栈，入栈等，构造方法也是空的，用的还是数组，父类中的构造，跟父类一样的扩增方式，并且它的方法也是同步的，所以也是线程安全。\n\n\n\n\n# 4、总结vector和stack\n\n【vector总结（通过源码分析）】\n\n 1. vector线程安全是因为它的方法都加了synchronized关键字\n 2. vector的本质是一个数组，特点能是能够自动扩增，扩增的方式跟capacityincrement的值有关\n 3. 它也会fail-fast，还有一个fail-safe两个的区别在下面的list总结中会讲到。\n\n【stack的总结】\n\n 1. 对栈的一些操作，先进后出\n 2. 底层也是用数组实现的，因为继承了vector\n 3. 也是线程安全的',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"HashMap",frontmatter:{title:"HashMap",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/HashMap/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/06.HashMap.html",relativePath:"01.Java/05.Java-集合框架/06.HashMap.md",key:"v-ba15898e",path:"/java/se/collection/HashMap/",headers:[{level:2,title:"HashMap",slug:"hashmap",normalizedTitle:"hashmap",charIndex:2},{level:3,title:"HashMap引入",slug:"hashmap引入",normalizedTitle:"hashmap引入",charIndex:14},{level:3,title:"HashMa数据结构",slug:"hashma数据结构",normalizedTitle:"hashma数据结构",charIndex:1011},{level:4,title:"HashMap在JDK1.8以前数据结构和存储原理",slug:"hashmap在jdk1-8以前数据结构和存储原理",normalizedTitle:"hashmap在jdk1.8以前数据结构和存储原理",charIndex:2023},{level:4,title:"JDK1.8后HashMap的数据结构",slug:"jdk1-8后hashmap的数据结构",normalizedTitle:"jdk1.8后hashmap的数据结构",charIndex:2826},{level:3,title:"HashMap的属性",slug:"hashmap的属性",normalizedTitle:"hashmap的属性",charIndex:2922},{level:3,title:"HashMap的源码分析",slug:"hashmap的源码分析",normalizedTitle:"hashmap的源码分析",charIndex:4473},{level:4,title:"1、HashMap的层次关系与继承结构",slug:"_1、hashmap的层次关系与继承结构",normalizedTitle:"1、hashmap的层次关系与继承结构",charIndex:4489},{level:4,title:"2、HashMap类的属性",slug:"_2、hashmap类的属性",normalizedTitle:"2、hashmap类的属性",charIndex:4882},{level:4,title:"3、HashMap的构造方法",slug:"_3、hashmap的构造方法",normalizedTitle:"3、hashmap的构造方法",charIndex:5915},{level:4,title:"4、HashMap常用方法",slug:"_4、hashmap常用方法",normalizedTitle:"4、hashmap常用方法",charIndex:8679},{level:4,title:"5、总结",slug:"_5、总结",normalizedTitle:"5、总结",charIndex:16219}],headersStr:"HashMap HashMap引入 HashMa数据结构 HashMap在JDK1.8以前数据结构和存储原理 JDK1.8后HashMap的数据结构 HashMap的属性 HashMap的源码分析 1、HashMap的层次关系与继承结构 2、HashMap类的属性 3、HashMap的构造方法 4、HashMap常用方法 5、总结",content:'# HashMap\n\n\n# HashMap引入\n\n问题：建立学生学号和学生姓名间的键值映射，并通过key对value进行操作，应该如何实现数据的存储和操作呢？\n\nMap接口专门处理键值映射数据的存储，可以根据键实现对值的操作。 最常用的实现类是HashMap。\n\npublic static void main(String[] args) {\n    Map<String,String> map = new HashMap<String,String>();\n    map.put("004","李清照");\n    map.put("001","李白");\n    map.put("003","王羲之");\n    map.put("002","杜甫");\n\n    System.out.println(map.get("003"));\n\n    //获取所有key 值\n    Set<String> keySet = map.keySet();\n    for (String s : keySet){\n        String s1 = map.get(s);\n        System.out.println(s+"    "+s1);\n    }\n\n    //获取所有值\n    Collection<String> values = map.values();\n    for (String s : values){\n        System.out.println(s);\n    }\n    \n    //entrySet() 获取值\n    Set<Map.Entry<String, String>> entrySet = map.entrySet();\n    for (Map.Entry<String, String> m : entrySet){\n        String key = m.getKey();\n        String value = m.getValue();\n        System.out.println(key+","+value);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# HashMa数据结构\n\nHashMap是基于哈希表的Map接口实现的，它存储的是内容是键值对映射。此类不保证映 射的顺序，假定哈希函数将元素适当的分布在各桶之间，可为基本操作(get和put)提供稳定的性能。\n\n在API中给出了相应的定义：\n\n又到了最激动人心的源码分析环节**😄**\n\n\n\n第一段：\n\n\n哈希表基于map接口的实现，这个实现提供了map所有的操作，并且提供了key和value，可以为 null，(HashMap和HashTable大致上是一样的，除了hashmap是异步的，和允许key和value为 null)\n\n这个类不确定map中元素的位置，特别要提的是，这个类也不确定元素的位置随着时间会不会保持不变。\n\n第二段：\n\n\n假设哈希函数将元素合适的分到了每个桶（其实就是指的数组中位置上的链表）中，则这个实现为基本的操作(get、put)提供了稳定的性能，迭代这个集合视图需要的时间跟hashMap实例（key-value映射的数量）的容量（在桶中）成正比，因此，如果迭代的性能很重要的话，就不要将初始容量设置的太高或者 loadfactor设置的太低，【这里的桶，相当于在数组中每个位置上放一个桶装元素】\n\n第三段：\n\n\nHashMap的实例有两个参数影响性能，初始化容量（initialCapacity）和loadFactor加载因子， 在哈希表中这个容量是桶的数量【也就是数组的长度】，一个初始化容量仅仅是在哈希表被创建时容量， 在容量自动增长之前加载因子是衡量哈希表被允许达到的多少的。当entry的数量在哈希表中超过了加载 因子乘以当前的容量，那么哈希表被修改（内部的数据结构会被重新建立）所以哈希表有大约两倍的桶的数量.\n\n第四段：\n\n\n通常来讲，默认的加载因子(0.75)能够在时间和空间上提供一个好的平衡，更高的值会减少空间上的开支但是会增加查询花费的时间（体现在HashMap类中get、put方法上），当设置初始化容量时，应该考虑到map中会存放entry的数量和加载因子，以便最少次数的进行rehash操作，如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n第五段：\n\n\n如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的 容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。\n\n# HashMap在JDK1.8以前数据结构和存储原理\n\n【链表散列】\n\n首先我们要知道什么是链表散列？通过数组和链表结合在一起使用，就叫做链表散列。这其实就是 hashmap存储的原理图。\n\n\n\n【HashMap的数据结构和存储原理】\n\nHashMap的数据结构就是用的链表散列。那HashMap底层是怎么样使用这个数据结构进行数据存取的呢？分成两个部分：\n\n第一步：HashMap内部有一个entry的内部类，其中有四个属性，我们要存储一个值，则需要一个key 和一个value，存到map中就会先将key和value保存在这个Entry类创建的对象中。\n\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key; //就是我们说的map的key\n    V value; //value值，这两个都不陌生\n    Entry<K,V> next;//指向下一个entry对象\n    int hash;//通过key算过来的你hashcode值。\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nEntry的物理模型图：\n\n\n\n第二步：构造好了entry对象，然后将该对象放入数组中，如何存放就是这hashMap的精华所在了。\n\n大概的一个存放过程是：通过entry对象中的hash值来确定将该对象存放在数组中的哪个位置上，如果在这个位置上还有其他元素，则通过链表来存储这个元素。\n\n\n\n【Hash存放元素的过程】\n\n通过key、value封装成一个entry对象，然后通过key的值来计算该entry的hash值，通过entry的hash值和数组的长度length来计算出entry放在数组中的哪个位置上面，\n\n每次存放都是将entry放在第一个位置。在这个过程中，就是通过hash值来确定将该对象存放在数组中 的哪个位置上。\n\n# JDK1.8后HashMap的数据结构\n\n\n\n上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。\n\n\n\n\n# HashMap的属性\n\nHashMap的实例有两个参数影响其性能。\n\n初始容量：哈希表中桶的数量\n\n加载因子：哈希表在其容量自动增加之前可以达到多满，的一种尺度\n\n当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行 rehash操作，将哈希表扩充至两倍的桶数。\n\nJava中默认初始容量为16，加载因子为0.75。\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\n1\n2\n\n\n【loadFactor加载因子】\n\n定义：loadFactor译为装载因子。装载因子用来衡量HashMap满的程度。loadFactor的默认值为 0.75f。计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。\n\nloadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据 (entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，那么数组中存放的数据也就越稀，也就是可能数组中每个位置上就放一个元素。\n\n那有人说，就把loadFactor变为1最好吗，存的数据很多，但是这样会有一个问题，就是我们在通过key拿到我们的value时，是先通过key的hashcode值，找到对应数组中的位置，如果该位置中有很多元素，则需要通过equals来依次比较链表中的元素，拿到我们的value值，这样花费的性能就很高，如果能让数组上的每个位置尽量只有一个元素最好，我们就能直接得到value值了，所以有人又会说，那把loadFactor变得很小不就好了，但是如果变得太小，在数组中的位置就会太稀，也就是分散的太开，浪费很多空间，这样也不好，所以在hashMap 中loadFactor的初始值就是0.75，一般情况下不需要更改它。\n\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\n1\n\n\n【桶】\n\n根据前面画的HashMap存储的数据结构图，你这样想，数组中每一个位置上都放有一个桶，每个桶里 就是装一个链表，链表中可以有很多个元素(entry)，这就是桶的意思。也就相当于把元素都放在桶中。\n\n【capacity】\n\ncapacity译为容量代表的数组的容量，也就是数组的长度，同时也是HashMap中桶的个数。默认值是 16。\n\n一般第一次扩容时会扩容到64，之后好像是2倍。总之，容量都是2的幂。\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n\n1\n\n\n【size的含义】\n\nsize就是在该HashMap的实例中实际存储的元素的个数\n\n【threshold的作用】\n\nint threshold;\n\n\n1\n\n\nthreshold = capacity * loadFactor，当Size>=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是衡量数组是否需要扩增的一个标准。\n\n注意这里说的是考虑，因为实际上要扩增数组，除了这个size>=threshold条件外，还需要另外一个条 件。\n\n什么时候会扩增数组的大小？在put一个元素时先size>=threshold并且还要在对应数组位置上有元素， 这才能扩增数组。\n\n我们通过一张HashMap的数据结构图来分析：\n\n\n\n\n# HashMap的源码分析\n\n# 1、HashMap的层次关系与继承结构\n\n【HashMap继承结构】\n\n\n\n上面就继承了一个abstractMap，也就是用来减轻实现Map接口的编写负担。\n\n【实现接口】\n\npublic class HashMap<K,V> extends AbstractMap<K,V>\nimplements Map<K,V>, Cloneable, Serializable {\n    \n}\n\n\n1\n2\n3\n4\n\n\nMap<K,V>：在AbstractMap抽象类中已经实现过的接口，这里又实现，实际上是多余的。但每个集合都有这样的错误，也没过大影响\n\nCloneable：能够使用Clone()方法，在HashMap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响 被拷贝的对象。\n\nSerializable：能够使之序列化，即可以将HashMap对象保存至本地，之后可以恢复状态。\n\n# 2、HashMap类的属性\n\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>,Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;\n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8;\n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table;\n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;\n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 填充因子\n    final float loadFactor;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 3、HashMap的构造方法\n\n有四个构造方法，构造方法的作用就是记录一下16这个数给threshold（这个数值最终会当作第一次组的长度。）和初始化加载因子。注意，hashMap中table数组一开始就已经是个没有长度的数组了。\n\n构造方法中，并没有初始化数组的大小，数组在一开始就已经被创建了，构造方法只做两件事情，一个 是初始化加载因子，另一个是用threshold记录下数组初始化的大小。注意是记录。\n\n【HashMap()】\n\n//看上面的注释就已经知道，DEFAULT_INITIAL_CAPACITY=16，DEFAULT_LOAD_FACTOR=0.75\n//初始化容量：也就是初始化数组的大小\n//加载因子：数组上的存放数据疏密程度。\n\npublic HashMap() {\n\tthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【HashMap(int)】\n\npublic HashMap(int initialCapacity) {\n\tthis(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n\n1\n2\n3\n\n\n【HashMap(int,float)】\n\npublic HashMap(int initialCapacity, float loadFactor) {\n    // 初始容量不能小于0，否则报错\n    if (initialCapacity < 0)\n    throw new IllegalArgumentException("Illegal initial capacity: " +\n    \t\t\t\t\t\t\t\t\t\tinitialCapacity);\n    // 初始容量不能大于最大值，否则为最大值\n    if (initialCapacity > MAXIMUM_CAPACITY)\n    initialCapacity = MAXIMUM_CAPACITY;\n    // 填充因子不能小于或等于0，不能为非数字\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n    throw new IllegalArgumentException("Illegal load factor: " +\n    \t\t\t\t\t\t\t\t\t\tloadFactor);\n    // 初始化填充因子\n    this.loadFactor = loadFactor;\n    // 初始化threshold大小\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n【HashMap(Map<? extends K, ? extends V> m) 】\n\npublic HashMap(Map<? extends K, ? extends V> m) {\n    // 初始化填充因子\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    // 将m中的所有元素添加至HashMap中\n    putMapEntries(m, false);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【putMapEntries(Map<? extends K, ? extends V> m, boolean evict)函数将m的所有元素存入本 HashMap实例中】\n\n\n    /**\n     * Implements Map.putAll and Map constructor.\n     *\n     * @param m the map\n     * @param evict false when initially constructing this map, else\n     * true (relayed to method afterNodeInsertion).\n     */\n    final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n        int s = m.size();\n        if (s > 0) {\n            // 判断table是否已经初始化\n            if (table == null) { // pre-size\n                // 未初始化，s为m的实际元素个数\n                float ft = ((float)s / loadFactor) + 1.0F;\n                int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                         (int)ft : MAXIMUM_CAPACITY);\n                // 计算得到的t大于阈值，则初始化阈值\n                if (t > threshold)\n                    threshold = tableSizeFor(t);\n            }\n            // 已初始化，并且m元素个数大于阈值，进行扩容处理\n            else if (s > threshold)\n                resize();\n            // 将m中的所有元素添加至HashMap中\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n                K key = e.getKey();\n                V value = e.getValue();\n                putVal(hash(key), key, value, false, evict);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 4、HashMap常用方法\n\n【put(K key, V value)】\n\npublic V put(K key, V value) {\nreturn putVal(hash(key), key, value, false, true);\n}\n\n\n1\n2\n3\n\n\n【putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)】\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            // 将第一个元素赋值给e，用e来记录\n            e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值，转化为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { // existing mapping for key\n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\nHashMap并没有直接提供putVal接口给用户调用，而是提供的put函数，而put函数就是通过putVal来插入元素的。\n\n【get(Object key)】\n\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\n\n1\n2\n3\n4\n\n\n【getNode(int hash,Pbject key)】\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    // table已经初始化，长度大于0，根据hash寻找table中的项也不为空\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 桶中第一项(数组元素)相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个结点\n        if ((e = first.next) != null) {\n            // 为红黑树结点\n            if (first instanceof TreeNode)\n                // 在红黑树中查找\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 否则，在链表中查找\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nHashMap并没有直接提供getNode接口给用户调用，而是提供的get函数，而get函数就是通过 getNode来取得元素的。\n\n【resize方法】\n\nfinal Node<K,V>[] resize() {\n    // 当前table保存\n    Node<K,V>[] oldTab = table;\n    // 保存table大小\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    // 保存当前阈值\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    // 之前table大小大于0\n    if (oldCap > 0) {\n        // 之前table大于最大容量\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            // 阈值为最大整形\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 容量翻倍，使用左移，效率更高\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // 阈值翻倍\n            newThr = oldThr << 1; // double threshold\n    }\n    // 之前阈值大于0\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    // oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步）\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 新阈值为0\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({"rawtypes","unchecked"})\n    // 初始化table\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    // 之前的table已经初始化过\n    if (oldTab != null) {\n        // 复制元素，重新进行hash\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    // 将同一桶中的元素根据(e.hash & oldCap)是否为0进行分割，分成两个不同的链表，完成rehash\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\n\n在resize前和resize后的元素布局如下:\n\n\n\n上图只是针对了数组下标为2的桶中的各个元素在扩容后的分配布局，其他各个桶中的元素布局可以以此类推。\n\n# 5、总结\n\n【关于数组扩容】\n\n从putVal源代码中我们可以知道，当插入一个元素的时候size就加1，若size大于threshold的时候，就会进行扩容。假设我们的capacity大小为32，loadFator为0.75，则threshold为24 = 32 * 0.75，\n\n此时，插入了25个元素，并且插入的这25个元素都在同一个桶中，桶中的数据结构为红黑树，则还 有31个桶是空的，也会进行扩容处理，其实，此时，还有31个桶是空的，好像似乎不需要进行扩容处 理，但是是需要扩容处理的，因为此时我们的capacity大小可能不适当。我们前面知道，扩容处理会遍 历所有的元素，时间复杂度很高；前面我们还知道，经过一次扩容处理后，元素会更加均匀的分布在各 个桶中，会提升访问效率。所以，说尽量避免进行扩容处理，也就意味着，遍历元素所带来的坏处大于 元素在桶中均匀分布所带来的好处。\n\n【总结】\n\n 1. 要知道hashMap在JDK1.8以前是一个链表散列这样一个数据结构，而在JDK1.8以后是一个数组加 链表加红黑树的数据结构。\n 2. 通过源码的学习，hashMap是一个能快速通过key获取到value值得一个集合，原因是内部使用的 是hash查找值得方法。',normalizedContent:'# hashmap\n\n\n# hashmap引入\n\n问题：建立学生学号和学生姓名间的键值映射，并通过key对value进行操作，应该如何实现数据的存储和操作呢？\n\nmap接口专门处理键值映射数据的存储，可以根据键实现对值的操作。 最常用的实现类是hashmap。\n\npublic static void main(string[] args) {\n    map<string,string> map = new hashmap<string,string>();\n    map.put("004","李清照");\n    map.put("001","李白");\n    map.put("003","王羲之");\n    map.put("002","杜甫");\n\n    system.out.println(map.get("003"));\n\n    //获取所有key 值\n    set<string> keyset = map.keyset();\n    for (string s : keyset){\n        string s1 = map.get(s);\n        system.out.println(s+"    "+s1);\n    }\n\n    //获取所有值\n    collection<string> values = map.values();\n    for (string s : values){\n        system.out.println(s);\n    }\n    \n    //entryset() 获取值\n    set<map.entry<string, string>> entryset = map.entryset();\n    for (map.entry<string, string> m : entryset){\n        string key = m.getkey();\n        string value = m.getvalue();\n        system.out.println(key+","+value);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# hashma数据结构\n\nhashmap是基于哈希表的map接口实现的，它存储的是内容是键值对映射。此类不保证映 射的顺序，假定哈希函数将元素适当的分布在各桶之间，可为基本操作(get和put)提供稳定的性能。\n\n在api中给出了相应的定义：\n\n又到了最激动人心的源码分析环节**😄**\n\n\n\n第一段：\n\n\n哈希表基于map接口的实现，这个实现提供了map所有的操作，并且提供了key和value，可以为 null，(hashmap和hashtable大致上是一样的，除了hashmap是异步的，和允许key和value为 null)\n\n这个类不确定map中元素的位置，特别要提的是，这个类也不确定元素的位置随着时间会不会保持不变。\n\n第二段：\n\n\n假设哈希函数将元素合适的分到了每个桶（其实就是指的数组中位置上的链表）中，则这个实现为基本的操作(get、put)提供了稳定的性能，迭代这个集合视图需要的时间跟hashmap实例（key-value映射的数量）的容量（在桶中）成正比，因此，如果迭代的性能很重要的话，就不要将初始容量设置的太高或者 loadfactor设置的太低，【这里的桶，相当于在数组中每个位置上放一个桶装元素】\n\n第三段：\n\n\nhashmap的实例有两个参数影响性能，初始化容量（initialcapacity）和loadfactor加载因子， 在哈希表中这个容量是桶的数量【也就是数组的长度】，一个初始化容量仅仅是在哈希表被创建时容量， 在容量自动增长之前加载因子是衡量哈希表被允许达到的多少的。当entry的数量在哈希表中超过了加载 因子乘以当前的容量，那么哈希表被修改（内部的数据结构会被重新建立）所以哈希表有大约两倍的桶的数量.\n\n第四段：\n\n\n通常来讲，默认的加载因子(0.75)能够在时间和空间上提供一个好的平衡，更高的值会减少空间上的开支但是会增加查询花费的时间（体现在hashmap类中get、put方法上），当设置初始化容量时，应该考虑到map中会存放entry的数量和加载因子，以便最少次数的进行rehash操作，如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n第五段：\n\n\n如果很多映射关系要存储在 hashmap 实例中，则相对于按需执行自动的 rehash 操作以增大表的 容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。\n\n# hashmap在jdk1.8以前数据结构和存储原理\n\n【链表散列】\n\n首先我们要知道什么是链表散列？通过数组和链表结合在一起使用，就叫做链表散列。这其实就是 hashmap存储的原理图。\n\n\n\n【hashmap的数据结构和存储原理】\n\nhashmap的数据结构就是用的链表散列。那hashmap底层是怎么样使用这个数据结构进行数据存取的呢？分成两个部分：\n\n第一步：hashmap内部有一个entry的内部类，其中有四个属性，我们要存储一个值，则需要一个key 和一个value，存到map中就会先将key和value保存在这个entry类创建的对象中。\n\nstatic class entry<k,v> implements map.entry<k,v> {\n    final k key; //就是我们说的map的key\n    v value; //value值，这两个都不陌生\n    entry<k,v> next;//指向下一个entry对象\n    int hash;//通过key算过来的你hashcode值。\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nentry的物理模型图：\n\n\n\n第二步：构造好了entry对象，然后将该对象放入数组中，如何存放就是这hashmap的精华所在了。\n\n大概的一个存放过程是：通过entry对象中的hash值来确定将该对象存放在数组中的哪个位置上，如果在这个位置上还有其他元素，则通过链表来存储这个元素。\n\n\n\n【hash存放元素的过程】\n\n通过key、value封装成一个entry对象，然后通过key的值来计算该entry的hash值，通过entry的hash值和数组的长度length来计算出entry放在数组中的哪个位置上面，\n\n每次存放都是将entry放在第一个位置。在这个过程中，就是通过hash值来确定将该对象存放在数组中 的哪个位置上。\n\n# jdk1.8后hashmap的数据结构\n\n\n\n上图很形象的展示了hashmap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。\n\n\n\n\n# hashmap的属性\n\nhashmap的实例有两个参数影响其性能。\n\n初始容量：哈希表中桶的数量\n\n加载因子：哈希表在其容量自动增加之前可以达到多满，的一种尺度\n\n当哈希表中条目数超出了当前容量*加载因子(其实就是hashmap的实际容量)时，则对该哈希表进行 rehash操作，将哈希表扩充至两倍的桶数。\n\njava中默认初始容量为16，加载因子为0.75。\n\nstatic final int default_initial_capacity = 1 << 4; // aka 16\nstatic final float default_load_factor = 0.75f;\n\n\n1\n2\n\n\n【loadfactor加载因子】\n\n定义：loadfactor译为装载因子。装载因子用来衡量hashmap满的程度。loadfactor的默认值为 0.75f。计算hashmap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。\n\nloadfactor加载因子是控制数组存放数据的疏密程度，loadfactor越趋近于1，那么数组中存放的数据 (entry)也就越多，也就越密，也就是会让链表的长度增加，loadfactor越小，也就是趋近于0，那么数组中存放的数据也就越稀，也就是可能数组中每个位置上就放一个元素。\n\n那有人说，就把loadfactor变为1最好吗，存的数据很多，但是这样会有一个问题，就是我们在通过key拿到我们的value时，是先通过key的hashcode值，找到对应数组中的位置，如果该位置中有很多元素，则需要通过equals来依次比较链表中的元素，拿到我们的value值，这样花费的性能就很高，如果能让数组上的每个位置尽量只有一个元素最好，我们就能直接得到value值了，所以有人又会说，那把loadfactor变得很小不就好了，但是如果变得太小，在数组中的位置就会太稀，也就是分散的太开，浪费很多空间，这样也不好，所以在hashmap 中loadfactor的初始值就是0.75，一般情况下不需要更改它。\n\nstatic final float default_load_factor = 0.75f;\n\n\n1\n\n\n【桶】\n\n根据前面画的hashmap存储的数据结构图，你这样想，数组中每一个位置上都放有一个桶，每个桶里 就是装一个链表，链表中可以有很多个元素(entry)，这就是桶的意思。也就相当于把元素都放在桶中。\n\n【capacity】\n\ncapacity译为容量代表的数组的容量，也就是数组的长度，同时也是hashmap中桶的个数。默认值是 16。\n\n一般第一次扩容时会扩容到64，之后好像是2倍。总之，容量都是2的幂。\n\nstatic final int default_initial_capacity = 1 << 4; // aka 16\n\n\n1\n\n\n【size的含义】\n\nsize就是在该hashmap的实例中实际存储的元素的个数\n\n【threshold的作用】\n\nint threshold;\n\n\n1\n\n\nthreshold = capacity * loadfactor，当size>=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是衡量数组是否需要扩增的一个标准。\n\n注意这里说的是考虑，因为实际上要扩增数组，除了这个size>=threshold条件外，还需要另外一个条 件。\n\n什么时候会扩增数组的大小？在put一个元素时先size>=threshold并且还要在对应数组位置上有元素， 这才能扩增数组。\n\n我们通过一张hashmap的数据结构图来分析：\n\n\n\n\n# hashmap的源码分析\n\n# 1、hashmap的层次关系与继承结构\n\n【hashmap继承结构】\n\n\n\n上面就继承了一个abstractmap，也就是用来减轻实现map接口的编写负担。\n\n【实现接口】\n\npublic class hashmap<k,v> extends abstractmap<k,v>\nimplements map<k,v>, cloneable, serializable {\n    \n}\n\n\n1\n2\n3\n4\n\n\nmap<k,v>：在abstractmap抽象类中已经实现过的接口，这里又实现，实际上是多余的。但每个集合都有这样的错误，也没过大影响\n\ncloneable：能够使用clone()方法，在hashmap中，实现的是浅层次拷贝，即对拷贝对象的改变会影响 被拷贝的对象。\n\nserializable：能够使之序列化，即可以将hashmap对象保存至本地，之后可以恢复状态。\n\n# 2、hashmap类的属性\n\npublic class hashmap<k,v> extends abstractmap<k,v> implements map<k,v>,cloneable, serializable {\n    // 序列号\n    private static final long serialversionuid = 362498820763181265l;\n    // 默认的初始容量是16\n    static final int default_initial_capacity = 1 << 4;\n    // 最大容量\n    static final int maximum_capacity = 1 << 30;\n    // 默认的填充因子\n    static final float default_load_factor = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int treeify_threshold = 8;\n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int untreeify_threshold = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int min_treeify_capacity = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient node<k,v>[] table;\n    // 存放具体元素的集\n    transient set<map.entry<k,v>> entryset;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modcount;\n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 填充因子\n    final float loadfactor;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 3、hashmap的构造方法\n\n有四个构造方法，构造方法的作用就是记录一下16这个数给threshold（这个数值最终会当作第一次组的长度。）和初始化加载因子。注意，hashmap中table数组一开始就已经是个没有长度的数组了。\n\n构造方法中，并没有初始化数组的大小，数组在一开始就已经被创建了，构造方法只做两件事情，一个 是初始化加载因子，另一个是用threshold记录下数组初始化的大小。注意是记录。\n\n【hashmap()】\n\n//看上面的注释就已经知道，default_initial_capacity=16，default_load_factor=0.75\n//初始化容量：也就是初始化数组的大小\n//加载因子：数组上的存放数据疏密程度。\n\npublic hashmap() {\n\tthis(default_initial_capacity, default_load_factor);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【hashmap(int)】\n\npublic hashmap(int initialcapacity) {\n\tthis(initialcapacity, default_load_factor);\n}\n\n\n1\n2\n3\n\n\n【hashmap(int,float)】\n\npublic hashmap(int initialcapacity, float loadfactor) {\n    // 初始容量不能小于0，否则报错\n    if (initialcapacity < 0)\n    throw new illegalargumentexception("illegal initial capacity: " +\n    \t\t\t\t\t\t\t\t\t\tinitialcapacity);\n    // 初始容量不能大于最大值，否则为最大值\n    if (initialcapacity > maximum_capacity)\n    initialcapacity = maximum_capacity;\n    // 填充因子不能小于或等于0，不能为非数字\n    if (loadfactor <= 0 || float.isnan(loadfactor))\n    throw new illegalargumentexception("illegal load factor: " +\n    \t\t\t\t\t\t\t\t\t\tloadfactor);\n    // 初始化填充因子\n    this.loadfactor = loadfactor;\n    // 初始化threshold大小\n    this.threshold = tablesizefor(initialcapacity);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n【hashmap(map<? extends k, ? extends v> m) 】\n\npublic hashmap(map<? extends k, ? extends v> m) {\n    // 初始化填充因子\n    this.loadfactor = default_load_factor;\n    // 将m中的所有元素添加至hashmap中\n    putmapentries(m, false);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n【putmapentries(map<? extends k, ? extends v> m, boolean evict)函数将m的所有元素存入本 hashmap实例中】\n\n\n    /**\n     * implements map.putall and map constructor.\n     *\n     * @param m the map\n     * @param evict false when initially constructing this map, else\n     * true (relayed to method afternodeinsertion).\n     */\n    final void putmapentries(map<? extends k, ? extends v> m, boolean evict) {\n        int s = m.size();\n        if (s > 0) {\n            // 判断table是否已经初始化\n            if (table == null) { // pre-size\n                // 未初始化，s为m的实际元素个数\n                float ft = ((float)s / loadfactor) + 1.0f;\n                int t = ((ft < (float)maximum_capacity) ?\n                         (int)ft : maximum_capacity);\n                // 计算得到的t大于阈值，则初始化阈值\n                if (t > threshold)\n                    threshold = tablesizefor(t);\n            }\n            // 已初始化，并且m元素个数大于阈值，进行扩容处理\n            else if (s > threshold)\n                resize();\n            // 将m中的所有元素添加至hashmap中\n            for (map.entry<? extends k, ? extends v> e : m.entryset()) {\n                k key = e.getkey();\n                v value = e.getvalue();\n                putval(hash(key), key, value, false, evict);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 4、hashmap常用方法\n\n【put(k key, v value)】\n\npublic v put(k key, v value) {\nreturn putval(hash(key), key, value, false, true);\n}\n\n\n1\n2\n3\n\n\n【putval(int hash, k key, v value, boolean onlyifabsent,boolean evict)】\n\nfinal v putval(int hash, k key, v value, boolean onlyifabsent,\n               boolean evict) {\n    node<k,v>[] tab; node<k,v> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newnode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        node<k,v> e; k k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            // 将第一个元素赋值给e，用e来记录\n            e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof treenode)\n            // 放入树中\n            e = ((treenode<k,v>)p).puttreeval(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int bincount = 0; ; ++bincount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newnode(hash, key, value, null);\n                    // 结点数量达到阈值，转化为红黑树\n                    if (bincount >= treeify_threshold - 1) // -1 for 1st\n                        treeifybin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { // existing mapping for key\n            // 记录e的value\n            v oldvalue = e.value;\n            // onlyifabsent为false或者旧值为null\n            if (!onlyifabsent || oldvalue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afternodeaccess(e);\n            // 返回旧值\n            return oldvalue;\n        }\n    }\n    // 结构性修改\n    ++modcount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afternodeinsertion(evict);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\nhashmap并没有直接提供putval接口给用户调用，而是提供的put函数，而put函数就是通过putval来插入元素的。\n\n【get(object key)】\n\npublic v get(object key) {\n    node<k,v> e;\n    return (e = getnode(hash(key), key)) == null ? null : e.value;\n}\n\n\n1\n2\n3\n4\n\n\n【getnode(int hash,pbject key)】\n\nfinal node<k,v> getnode(int hash, object key) {\n    node<k,v>[] tab; node<k,v> first, e; int n; k k;\n    // table已经初始化，长度大于0，根据hash寻找table中的项也不为空\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 桶中第一项(数组元素)相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个结点\n        if ((e = first.next) != null) {\n            // 为红黑树结点\n            if (first instanceof treenode)\n                // 在红黑树中查找\n                return ((treenode<k,v>)first).gettreenode(hash, key);\n            // 否则，在链表中查找\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nhashmap并没有直接提供getnode接口给用户调用，而是提供的get函数，而get函数就是通过 getnode来取得元素的。\n\n【resize方法】\n\nfinal node<k,v>[] resize() {\n    // 当前table保存\n    node<k,v>[] oldtab = table;\n    // 保存table大小\n    int oldcap = (oldtab == null) ? 0 : oldtab.length;\n    // 保存当前阈值\n    int oldthr = threshold;\n    int newcap, newthr = 0;\n    // 之前table大小大于0\n    if (oldcap > 0) {\n        // 之前table大于最大容量\n        if (oldcap >= maximum_capacity) {\n            // 阈值为最大整形\n            threshold = integer.max_value;\n            return oldtab;\n        }\n        // 容量翻倍，使用左移，效率更高\n        else if ((newcap = oldcap << 1) < maximum_capacity &&\n                 oldcap >= default_initial_capacity)\n            // 阈值翻倍\n            newthr = oldthr << 1; // double threshold\n    }\n    // 之前阈值大于0\n    else if (oldthr > 0) // initial capacity was placed in threshold\n        newcap = oldthr;\n    // oldcap = 0并且oldthr = 0，使用缺省值（如使用hashmap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步）\n    else {               // zero initial threshold signifies using defaults\n        newcap = default_initial_capacity;\n        newthr = (int)(default_load_factor * default_initial_capacity);\n    }\n    // 新阈值为0\n    if (newthr == 0) {\n        float ft = (float)newcap * loadfactor;\n        newthr = (newcap < maximum_capacity && ft < (float)maximum_capacity ?\n                  (int)ft : integer.max_value);\n    }\n    threshold = newthr;\n    @suppresswarnings({"rawtypes","unchecked"})\n    // 初始化table\n    node<k,v>[] newtab = (node<k,v>[])new node[newcap];\n    table = newtab;\n    // 之前的table已经初始化过\n    if (oldtab != null) {\n        // 复制元素，重新进行hash\n        for (int j = 0; j < oldcap; ++j) {\n            node<k,v> e;\n            if ((e = oldtab[j]) != null) {\n                oldtab[j] = null;\n                if (e.next == null)\n                    newtab[e.hash & (newcap - 1)] = e;\n                else if (e instanceof treenode)\n                    ((treenode<k,v>)e).split(this, newtab, j, oldcap);\n                else { // preserve order\n                    node<k,v> lohead = null, lotail = null;\n                    node<k,v> hihead = null, hitail = null;\n                    node<k,v> next;\n                    // 将同一桶中的元素根据(e.hash & oldcap)是否为0进行分割，分成两个不同的链表，完成rehash\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldcap) == 0) {\n                            if (lotail == null)\n                                lohead = e;\n                            else\n                                lotail.next = e;\n                            lotail = e;\n                        }\n                        else {\n                            if (hitail == null)\n                                hihead = e;\n                            else\n                                hitail.next = e;\n                            hitail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (lotail != null) {\n                        lotail.next = null;\n                        newtab[j] = lohead;\n                    }\n                    if (hitail != null) {\n                        hitail.next = null;\n                        newtab[j + oldcap] = hihead;\n                    }\n                }\n            }\n        }\n    }\n    return newtab;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\n\n在resize前和resize后的元素布局如下:\n\n\n\n上图只是针对了数组下标为2的桶中的各个元素在扩容后的分配布局，其他各个桶中的元素布局可以以此类推。\n\n# 5、总结\n\n【关于数组扩容】\n\n从putval源代码中我们可以知道，当插入一个元素的时候size就加1，若size大于threshold的时候，就会进行扩容。假设我们的capacity大小为32，loadfator为0.75，则threshold为24 = 32 * 0.75，\n\n此时，插入了25个元素，并且插入的这25个元素都在同一个桶中，桶中的数据结构为红黑树，则还 有31个桶是空的，也会进行扩容处理，其实，此时，还有31个桶是空的，好像似乎不需要进行扩容处 理，但是是需要扩容处理的，因为此时我们的capacity大小可能不适当。我们前面知道，扩容处理会遍 历所有的元素，时间复杂度很高；前面我们还知道，经过一次扩容处理后，元素会更加均匀的分布在各 个桶中，会提升访问效率。所以，说尽量避免进行扩容处理，也就意味着，遍历元素所带来的坏处大于 元素在桶中均匀分布所带来的好处。\n\n【总结】\n\n 1. 要知道hashmap在jdk1.8以前是一个链表散列这样一个数据结构，而在jdk1.8以后是一个数组加 链表加红黑树的数据结构。\n 2. 通过源码的学习，hashmap是一个能快速通过key获取到value值得一个集合，原因是内部使用的 是hash查找值得方法。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"List总结",frontmatter:{title:"List总结",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/List-summary/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/05.List%E6%80%BB%E7%BB%93.html",relativePath:"01.Java/05.Java-集合框架/05.List总结.md",key:"v-797fe2d2",path:"/java/se/collection/List-summary/",headers:[{level:2,title:"List总结",slug:"list总结",normalizedTitle:"list总结",charIndex:2}],headersStr:"List总结",content:"# List总结\n\narrayList和LinkedList区别\n\n\tarrayList底层是用数组实现的顺序表，是随机存取类型，可自动扩增，并且在初始化时，数组的长度是0，只有在增加元素时，长度才会增加。默认是10，不能无限扩增，有上限，在查询操作的时候性能更好\n\n\tLinkedList底层是用链表来实现的，是一个双向链表，注意这里不是双向循环链表，顺序存取类型。 在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性能更好。\n\n\n两个都是线程不安全的，在iterator时，会发生fail-fast：快速失效。\n\narrayList和Vector的区别\n\n\tarrayList线程不安全，在用iterator，会发生fail-fast\n\n\tVector线程安全，因为在方法前加了Synchronized关键字。也会发生fail-fast\n\n\nfail-fast和fail-safe区别和什么情况下会发生\n\n\t简单的来说：在java.util下的集合都是发生fail-fast，而在java.util.concurrent下的发生的都是failsafe。\n\n\t1）fail-fast\n\n\n快速失败，例如在arrayList中使用迭代器遍历时，有另外的线程对arrayList的存储数组进行了改变，比如add、delete、等使之发生了结构上的改变，所以Iterator就会快速报一个 java.util.ConcurrentModificationException 异常（并发修改异常），这就是快速失败。\n\n\t2）fail-safe\n\n\n安全失败，在java.util.concurrent下的类，都是线程安全的类，他们在迭代的过程中，如果有线程进行结构的改变，不会报异常，而是正常遍历，这就是安全失败。\n\n\t3）为什么在java.util.concurrent包下对集合有结构的改变，却不会报异常？\n\n\n在concurrent下的集合类增加元素的时候使用Arrays.copyOf()来拷贝副本，在副本上增加元素，如果有其他线程在此改变了集合的结构，那也是在副本上的改变，而不是影响到原集合，迭代器还是照常遍 历，遍历完之后，改变原引用指向副本，所以总的一句话就是如果在此包下的类进行增加删除，就会出现一个副本。所以能防止fail-fast，这种机制并不会出错，所以我们叫这种现象为fail-safe。\n\n\t4）vector也是线程安全的，为什么是fail-fast呢？\n\n\n这里搞清楚一个问题，并不是说线程安全的集合就不会报fail-fast，而是报fail-safe，你得搞清楚前面所说答案的原理，出现fail-safe是因为他们在实现增删的底层机制不一样，就像上面说的，会有一个副本，而像arrayList、linekdList、verctor等，他们底层就是对着真正的引用进行操作，所以才会发生异常。\n\n\t5）既然是线程安全的，为什么在迭代的时候，还会有别的线程来改变其集合的结构呢(也就是对其删除和增加等操作)？\n\n\n首先，我们迭代的时候，根本就没用到集合中的删除、增加，查询的操作，就拿vector来说，我们都没有用那些加锁的方法，也就是方法锁放在那没人拿，在迭代的过程中，有人拿了那把锁，我们也没有办法，因为那把锁就放在那边。\n\n【举例说明fail-fast和fail-safe的区别】\n\n * fail-fast\n\n\n\n * fail-safe\n\n通过CopyOnWriteArrayList这个类来做实验，不用管这个类的作用，但是他确实没有报异常， 并且还通过第二次打印，来验证了上面我们说创建了副本的事情。\n\n原理是在添加操作时会创建副本，在副本上进行添加操作，等迭代器遍历结束后，会将原引用 改为副本引用，所以我们在创建了一个list的迭代器，结果打印的就是123444了，\n\n证明了确实改变成为了副本引用，后面为什么是三个4，原因是我们循环了3次，不就添加了3 个4吗。如果还感觉不爽的话，看下add的源码。\n\n\n\n\n\n【为什么现在都不提倡使用vector了】\n\n1）vector实现线程安全的方法是在每个操作方法上加锁，这些锁并不是必须要的，在实际开发中， 一般都是通过锁一系列的操作来实现线程安全，也就是说将需要同步的资源放一起加锁来保证线程安全。\n\n2）如果多个Thread并发执行一个已经加锁的方法，但是在该方法中，又有vector的存在，vector本身实现中已经加锁了，那么相当于锁上又加锁，会造成额外的开销。\n\n3）就如上面第三个问题所说的，vector还有fail-fast的问题，也就是说它也无法保证遍历安全，在遍历时又得额外加锁，又是额外的开销，还不如直接用arrayList，然后再加锁呢。\n\n总结：Vector在你不需要进行线程安全的时候，也会给你加锁，也就导致了额外开销，所以在 jdk1.5之后就被弃用了，现在如果要用到线程安全的集合，都是从java.util.concurrent包下去拿相应的类。",normalizedContent:"# list总结\n\narraylist和linkedlist区别\n\n\tarraylist底层是用数组实现的顺序表，是随机存取类型，可自动扩增，并且在初始化时，数组的长度是0，只有在增加元素时，长度才会增加。默认是10，不能无限扩增，有上限，在查询操作的时候性能更好\n\n\tlinkedlist底层是用链表来实现的，是一个双向链表，注意这里不是双向循环链表，顺序存取类型。 在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性能更好。\n\n\n两个都是线程不安全的，在iterator时，会发生fail-fast：快速失效。\n\narraylist和vector的区别\n\n\tarraylist线程不安全，在用iterator，会发生fail-fast\n\n\tvector线程安全，因为在方法前加了synchronized关键字。也会发生fail-fast\n\n\nfail-fast和fail-safe区别和什么情况下会发生\n\n\t简单的来说：在java.util下的集合都是发生fail-fast，而在java.util.concurrent下的发生的都是failsafe。\n\n\t1）fail-fast\n\n\n快速失败，例如在arraylist中使用迭代器遍历时，有另外的线程对arraylist的存储数组进行了改变，比如add、delete、等使之发生了结构上的改变，所以iterator就会快速报一个 java.util.concurrentmodificationexception 异常（并发修改异常），这就是快速失败。\n\n\t2）fail-safe\n\n\n安全失败，在java.util.concurrent下的类，都是线程安全的类，他们在迭代的过程中，如果有线程进行结构的改变，不会报异常，而是正常遍历，这就是安全失败。\n\n\t3）为什么在java.util.concurrent包下对集合有结构的改变，却不会报异常？\n\n\n在concurrent下的集合类增加元素的时候使用arrays.copyof()来拷贝副本，在副本上增加元素，如果有其他线程在此改变了集合的结构，那也是在副本上的改变，而不是影响到原集合，迭代器还是照常遍 历，遍历完之后，改变原引用指向副本，所以总的一句话就是如果在此包下的类进行增加删除，就会出现一个副本。所以能防止fail-fast，这种机制并不会出错，所以我们叫这种现象为fail-safe。\n\n\t4）vector也是线程安全的，为什么是fail-fast呢？\n\n\n这里搞清楚一个问题，并不是说线程安全的集合就不会报fail-fast，而是报fail-safe，你得搞清楚前面所说答案的原理，出现fail-safe是因为他们在实现增删的底层机制不一样，就像上面说的，会有一个副本，而像arraylist、linekdlist、verctor等，他们底层就是对着真正的引用进行操作，所以才会发生异常。\n\n\t5）既然是线程安全的，为什么在迭代的时候，还会有别的线程来改变其集合的结构呢(也就是对其删除和增加等操作)？\n\n\n首先，我们迭代的时候，根本就没用到集合中的删除、增加，查询的操作，就拿vector来说，我们都没有用那些加锁的方法，也就是方法锁放在那没人拿，在迭代的过程中，有人拿了那把锁，我们也没有办法，因为那把锁就放在那边。\n\n【举例说明fail-fast和fail-safe的区别】\n\n * fail-fast\n\n\n\n * fail-safe\n\n通过copyonwritearraylist这个类来做实验，不用管这个类的作用，但是他确实没有报异常， 并且还通过第二次打印，来验证了上面我们说创建了副本的事情。\n\n原理是在添加操作时会创建副本，在副本上进行添加操作，等迭代器遍历结束后，会将原引用 改为副本引用，所以我们在创建了一个list的迭代器，结果打印的就是123444了，\n\n证明了确实改变成为了副本引用，后面为什么是三个4，原因是我们循环了3次，不就添加了3 个4吗。如果还感觉不爽的话，看下add的源码。\n\n\n\n\n\n【为什么现在都不提倡使用vector了】\n\n1）vector实现线程安全的方法是在每个操作方法上加锁，这些锁并不是必须要的，在实际开发中， 一般都是通过锁一系列的操作来实现线程安全，也就是说将需要同步的资源放一起加锁来保证线程安全。\n\n2）如果多个thread并发执行一个已经加锁的方法，但是在该方法中，又有vector的存在，vector本身实现中已经加锁了，那么相当于锁上又加锁，会造成额外的开销。\n\n3）就如上面第三个问题所说的，vector还有fail-fast的问题，也就是说它也无法保证遍历安全，在遍历时又得额外加锁，又是额外的开销，还不如直接用arraylist，然后再加锁呢。\n\n总结：vector在你不需要进行线程安全的时候，也会给你加锁，也就导致了额外开销，所以在 jdk1.5之后就被弃用了，现在如果要用到线程安全的集合，都是从java.util.concurrent包下去拿相应的类。",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"set",frontmatter:{title:"set",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/set/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/07.Set.html",relativePath:"01.Java/05.Java-集合框架/07.Set.md",key:"v-0210a959",path:"/java/se/collection/set/",headers:[{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:2}],headersStr:"Set",content:'# Set\n\nSet注重独一无二的性质，该体系集合可以知道某物是否已经存在于集合中，不会存储重复的元素，用于存储无序**（存入和取出的顺序不一定相同）**元素，值不能重复\n\n对象的相等性： 引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashcode方法，会得到相同的结果，如果对象所属的类没有覆盖object的hashcode方法的话，hashcode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashcode值是不可能相等的。\n\n如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继承下来的hashcode方法和equals方法，因为Object hashcode返回的是该对象的内存地址，所以必须重写hashcode方法，才能保证两个不同的对象具有相同的hashcode，同时也需要两个不同对象比较equals方法返回true。\n\n该集合中没有特有的方法，直接继承自Collection\n\n/**\n * Collection\n *      \\--List\n *          有序（存储顺序和取出顺序一致），可重复\n *      \\--Set\n *          无序（存储顺序和取出顺序不一致），唯一\n * HashSet:它不保证set的迭代顺序；特别是它不保证该顺序恒久不变\n * 注意：虽然set集合的元素无序，但是，作为集合来说，它肯定有它自己的存储顺序，\n * 而你的顺序恰巧和它的存储顺序一致，这代表不了有序，你可以多存储一些数据就能看到效果\n **/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n案例：set集合添加元素并使用增强for循环遍历\n\npublic static void method1() {\n    Set<String> set = new HashSet<>();\n    set.add("1");\n    set.add("5");\n    set.add("2");\n\n    set.add("5");//重复的不会添加进去\n    for (String s : set) {\n        System.out.println(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后输出顺序是： 1、2、5',normalizedContent:'# set\n\nset注重独一无二的性质，该体系集合可以知道某物是否已经存在于集合中，不会存储重复的元素，用于存储无序**（存入和取出的顺序不一定相同）**元素，值不能重复\n\n对象的相等性： 引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashcode方法，会得到相同的结果，如果对象所属的类没有覆盖object的hashcode方法的话，hashcode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashcode值是不可能相等的。\n\n如果想要让两个不同的person对象视为相等的，就必须覆盖object继承下来的hashcode方法和equals方法，因为object hashcode返回的是该对象的内存地址，所以必须重写hashcode方法，才能保证两个不同的对象具有相同的hashcode，同时也需要两个不同对象比较equals方法返回true。\n\n该集合中没有特有的方法，直接继承自collection\n\n/**\n * collection\n *      \\--list\n *          有序（存储顺序和取出顺序一致），可重复\n *      \\--set\n *          无序（存储顺序和取出顺序不一致），唯一\n * hashset:它不保证set的迭代顺序；特别是它不保证该顺序恒久不变\n * 注意：虽然set集合的元素无序，但是，作为集合来说，它肯定有它自己的存储顺序，\n * 而你的顺序恰巧和它的存储顺序一致，这代表不了有序，你可以多存储一些数据就能看到效果\n **/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n案例：set集合添加元素并使用增强for循环遍历\n\npublic static void method1() {\n    set<string> set = new hashset<>();\n    set.add("1");\n    set.add("5");\n    set.add("2");\n\n    set.add("5");//重复的不会添加进去\n    for (string s : set) {\n        system.out.println(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后输出顺序是： 1、2、5',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"HashSet",frontmatter:{title:"HashSet",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/HashSet/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/08.HashSet.html",relativePath:"01.Java/05.Java-集合框架/08.HashSet.md",key:"v-2d5f5839",path:"/java/se/collection/HashSet/",headers:[{level:2,title:"HashSet",slug:"hashset",normalizedTitle:"hashset",charIndex:2},{level:3,title:"存储规则",slug:"存储规则",normalizedTitle:"存储规则",charIndex:288},{level:3,title:"HashSet用处",slug:"hashset用处",normalizedTitle:"hashset用处",charIndex:1084},{level:3,title:"LinkedHashSet",slug:"linkedhashset",normalizedTitle:"linkedhashset",charIndex:2625}],headersStr:"HashSet 存储规则 HashSet用处 LinkedHashSet",content:'# HashSet\n\nHashSet是一个没有重复元素的集合，它其实是由HashMap实现的，HashMap保存的是建值对，然而我们只能向HashSet中添加Key，原因在于HashSet的Value其实都是同一个对象，这是HashSet添加元素的方法，可以看到辅助实现HashSet的map中的value其实都是Object类的同一个对象。\n\n特点：\n\n * 底层数据结构是哈希表\n * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n * 没有带索引的方法，所以不能使用普通for循环遍历\n * 由于是Set集合，所以是不包含重复元素的集合\n\n\n# 存储规则\n\n**哈希表边存放的是哈希值。**HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。\n\nHashSet不存入重复元素的规则.使用hashcode和equals\n\n由于Set集合是不能存入重复元素的集合。那么HashSet也是具备这一特性的。HashSet如何检查重复？HashSet会通过元素的hashcode（）和equals方法进行判断元素师否重复。\n\n当你试图把对象加入HashSet时，HashSet会使用对象的hashCode来判断对象加入的位置。同时也会与其他已经加入的对象的hashCode进行比较，如果没有相等的hashCode，HashSet就会假设对象没有重复出现。\n\n简单一句话，如果对象的hashCode值是不同的，那么HashSet会认为对象是不可能相等的。\n\n因此我们自定义类的时候需要重写hashCode，来确保对象具有相同的hashCode值。\n\n如果元素(对象)的hashCode值相同，是不是就无法存入HashSet中了？当然不是，会继续使用equals 进行比较。如果 equals为true 那么HashSet认为新加入的对象重复了，所以加入失败。如果equals 为false那么HashSet 认为新加入的对象没有重复，新元素可以存入。\n\n总结：\n\n元素的哈希值是通过元素的hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法 如果 equls结果为true ，HashSet就视为同一个元素。如果equals 为false就不是同一个元素。\n\n哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。\n\n\n# HashSet用处\n\n问题：现在有一批数据，要求不能重复存储元素，而且要排序。ArrayList 、 LinkedList不能去除重复数据。HashSet可以去除重复，但是是无序。\n\n所以这时候就要使用TreeSet了\n\n案例：创建一个学生类，并重写equals和hashcode\n\nimport java.util.Objects;\n\npublic class HashSetStudent {\n    public String name;\n    public int age;\n\n    public HashSetStudent(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        HashSetStudent that = (HashSetStudent) o;\n        return age == that.age && Objects.equals(name, that.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n代码：\n\npublic class HashSetTest {\n    public static void main(String[] args) {\n        HashSetStudent s1 = new HashSetStudent("李白1",15);\n        HashSetStudent s2 = new HashSetStudent("李白2",16);\n\n        HashSetStudent s3 = new HashSetStudent("李白1",15);//重复值不插入\n        \n        HashSetStudent s4 = new HashSetStudent("李白1",10);\n        HashSetStudent s5 = new HashSetStudent("李白2",10);\n\n        HashSet<HashSetStudent> hs = new HashSet<>();\n        hs.add(s1);\n        hs.add(s2);\n        hs.add(s3);\n        hs.add(s4);\n        hs.add(s5);\n\n        for(HashSetStudent S:hs){\n            System.out.println(S.name+"--"+S.age);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n最后输出：\n\n> 李白2--10 李白1--10 李白1--15 李白2--16\n\n\n# LinkedHashSet\n\n特点：\n\n * 哈希表和链表实现的Set接口，具有可预测的迭代次序\n * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n待补充......',normalizedContent:'# hashset\n\nhashset是一个没有重复元素的集合，它其实是由hashmap实现的，hashmap保存的是建值对，然而我们只能向hashset中添加key，原因在于hashset的value其实都是同一个对象，这是hashset添加元素的方法，可以看到辅助实现hashset的map中的value其实都是object类的同一个对象。\n\n特点：\n\n * 底层数据结构是哈希表\n * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n * 没有带索引的方法，所以不能使用普通for循环遍历\n * 由于是set集合，所以是不包含重复元素的集合\n\n\n# 存储规则\n\n**哈希表边存放的是哈希值。**hashset存储元素的顺序并不是按照存入时的顺序（和list显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。\n\nhashset不存入重复元素的规则.使用hashcode和equals\n\n由于set集合是不能存入重复元素的集合。那么hashset也是具备这一特性的。hashset如何检查重复？hashset会通过元素的hashcode（）和equals方法进行判断元素师否重复。\n\n当你试图把对象加入hashset时，hashset会使用对象的hashcode来判断对象加入的位置。同时也会与其他已经加入的对象的hashcode进行比较，如果没有相等的hashcode，hashset就会假设对象没有重复出现。\n\n简单一句话，如果对象的hashcode值是不同的，那么hashset会认为对象是不可能相等的。\n\n因此我们自定义类的时候需要重写hashcode，来确保对象具有相同的hashcode值。\n\n如果元素(对象)的hashcode值相同，是不是就无法存入hashset中了？当然不是，会继续使用equals 进行比较。如果 equals为true 那么hashset认为新加入的对象重复了，所以加入失败。如果equals 为false那么hashset 认为新加入的对象没有重复，新元素可以存入。\n\n总结：\n\n元素的哈希值是通过元素的hashcode方法来获取的, hashset首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法 如果 equls结果为true ，hashset就视为同一个元素。如果equals 为false就不是同一个元素。\n\n哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。\n\n\n# hashset用处\n\n问题：现在有一批数据，要求不能重复存储元素，而且要排序。arraylist 、 linkedlist不能去除重复数据。hashset可以去除重复，但是是无序。\n\n所以这时候就要使用treeset了\n\n案例：创建一个学生类，并重写equals和hashcode\n\nimport java.util.objects;\n\npublic class hashsetstudent {\n    public string name;\n    public int age;\n\n    public hashsetstudent(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @override\n    public boolean equals(object o) {\n        if (this == o) return true;\n        if (o == null || getclass() != o.getclass()) return false;\n        hashsetstudent that = (hashsetstudent) o;\n        return age == that.age && objects.equals(name, that.name);\n    }\n\n    @override\n    public int hashcode() {\n        return objects.hash(name, age);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n代码：\n\npublic class hashsettest {\n    public static void main(string[] args) {\n        hashsetstudent s1 = new hashsetstudent("李白1",15);\n        hashsetstudent s2 = new hashsetstudent("李白2",16);\n\n        hashsetstudent s3 = new hashsetstudent("李白1",15);//重复值不插入\n        \n        hashsetstudent s4 = new hashsetstudent("李白1",10);\n        hashsetstudent s5 = new hashsetstudent("李白2",10);\n\n        hashset<hashsetstudent> hs = new hashset<>();\n        hs.add(s1);\n        hs.add(s2);\n        hs.add(s3);\n        hs.add(s4);\n        hs.add(s5);\n\n        for(hashsetstudent s:hs){\n            system.out.println(s.name+"--"+s.age);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n最后输出：\n\n> 李白2--10 李白1--10 李白1--15 李白2--16\n\n\n# linkedhashset\n\n特点：\n\n * 哈希表和链表实现的set接口，具有可预测的迭代次序\n * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n待补充......',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"迭代器",frontmatter:{title:"迭代器",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/iterator/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/10.%E8%BF%AD%E4%BB%A3%E5%99%A8.html",relativePath:"01.Java/05.Java-集合框架/10.迭代器.md",key:"v-417db3ae",path:"/java/se/collection/iterator/",headers:[{level:2,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:2}],headersStr:"迭代器",content:'# 迭代器\n\n所有实现了Collection接口的容器类都有一个iterator方法用以返回一个实现Iterator接口的对象\n\nIterator对象称作为迭代器，用以方便的对容器内元素的遍历操作，Iterator接口定义了如下方法：\n\n * boolean hashNext();//判断是否有元素没有被遍历\n * Object next();//返回游标当前位置的元素并将游标移动到下一个位置\n * void remove();//删除游标左边的元素，在执行完next之后该操作只能执行一次\n\n问题：如何遍历Map集合呢？\n\n方法1：通过迭代器Iterator实现遍历\n\n获取Iterator ：Collection 接口的iterator()方法\n\nIterator的方法：\n\n * boolean hasNext(): 判断是否存在另一个可访问的元素\n * Object next(): 返回要访问的下一个元素\n\nSet keys = dogMap.keySet(); //取出所有key的集合\nIterator it = keys.iterator(); //获取Iterator对象\nwhile (it.hasNext()) {\n    String key = (String) it.next(); //取出key\n    Dog dog = (Dog) dogMap.get(key); //根据key取出对应的值\n    System.out.println(key + "\\t" + dog.getStrain());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n方法2：增强for循环\n\nfor(元素类型t 元素变量x : 数组或集合对象){\n\t引用了x的java语句\n}\n\n\n1\n2\n3\n',normalizedContent:'# 迭代器\n\n所有实现了collection接口的容器类都有一个iterator方法用以返回一个实现iterator接口的对象\n\niterator对象称作为迭代器，用以方便的对容器内元素的遍历操作，iterator接口定义了如下方法：\n\n * boolean hashnext();//判断是否有元素没有被遍历\n * object next();//返回游标当前位置的元素并将游标移动到下一个位置\n * void remove();//删除游标左边的元素，在执行完next之后该操作只能执行一次\n\n问题：如何遍历map集合呢？\n\n方法1：通过迭代器iterator实现遍历\n\n获取iterator ：collection 接口的iterator()方法\n\niterator的方法：\n\n * boolean hasnext(): 判断是否存在另一个可访问的元素\n * object next(): 返回要访问的下一个元素\n\nset keys = dogmap.keyset(); //取出所有key的集合\niterator it = keys.iterator(); //获取iterator对象\nwhile (it.hasnext()) {\n    string key = (string) it.next(); //取出key\n    dog dog = (dog) dogmap.get(key); //根据key取出对应的值\n    system.out.println(key + "\\t" + dog.getstrain());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n方法2：增强for循环\n\nfor(元素类型t 元素变量x : 数组或集合对象){\n\t引用了x的java语句\n}\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"TreeSet",frontmatter:{title:"TreeSet",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/TreeSet/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/09.TreeSet.html",relativePath:"01.Java/05.Java-集合框架/09.TreeSet.md",key:"v-43d92dd9",path:"/java/se/collection/TreeSet/",headers:[{level:2,title:"TreeSet",slug:"treeset",normalizedTitle:"treeset",charIndex:2},{level:3,title:"TreeSet自然顺序",slug:"treeset自然顺序",normalizedTitle:"treeset自然顺序",charIndex:737},{level:3,title:"TreeSet自定义排序",slug:"treeset自定义排序",normalizedTitle:"treeset自定义排序",charIndex:1016}],headersStr:"TreeSet TreeSet自然顺序 TreeSet自定义排序",content:'# TreeSet\n\nTreeSet简介\n\n红-黑树的数据结构，默认对元素进行自然排序\n\nTreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet, Cloneable, java.io.Serializable接口。\n\nTreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。\n\nTreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。\n\nTreeSet 实现了Cloneable接口，意味着它能被克隆。\n\nTreeSet 实现了java.io.Serializable接口，意味着它支持序列化。\n\nTreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。\n\nTreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。 另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。\n\n特点：\n\n * 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法\n   \n   TreeSet():根据其元素的自然非序进行排序\n   \n   TreeSet(Comparator comparator):根据指定的比较器进行排序\n\n * 没有带索引的方法，所以不能使用普通for循环遍历\n\n * 由于是Set集合，所以不包含重复元素的集合\n\n\n# TreeSet自然顺序\n\n即类要实现Comparable接口，并重写compareTo()方法，TreeSet对象调用add()方法时，会将存入的对象提升为Comparable类型，然后调用对象中的compareTo()方法进行比较，根据比较的返回值进行存储。\n\n因为TreeSet底层是二叉树，当compareTo方法返回0时，不存储；当compareTo方法返回正数时，存入二叉树的右子树；当compareTo方法返回负数时，存入二叉树的左子树。如果一个类没有实现Comparable接口就将该类对象存入TreeSet集合，会发生类型转换异常。\n\n\n# TreeSet自定义排序\n\n方式一：元素自身具备比较性\n\n元素自身具备比较性，需要元素实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。\n\n让元素自身具备比较性\n\n也就是元素需要实现Comparable接口，覆盖compareTo 方法。\n\n案例：创建Student类，有姓名，年龄。存入集合后，先根据年龄大小，再根据姓名来进行排序插入集合中\n\npublic class Student implements Comparable<Student> {\n    public String name;\n    public int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public int compareTo(Student o) {\n        int i = this.age-o.age;\n        int n = i==0?this.name.compareTo(o.name):i;\n        return n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n重写compareTo()方法，返回值有三种情况\n\n 1. 返回值为0：不插入集合\n 2. 返回值为1：往后插入集合\n 3. 返回值为-1：往前插入集合\n\npublic class Demo {\n    public static void main(String[] args) {\n        Student s1 = new Student("xishi",25);\n        Student s2 = new Student("yangyuhuan",29);\n        Student s3 = new Student("diaochan",28);\n        Student s4 = new Student("wangzhaojun",30);\n        Student s5 = new Student("libai",30);\n        Student s6 = new Student("libai",30);\n\n        TreeSet<Student> ts = new TreeSet<>();\n\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n\n        for(Student s : ts){\n            System.out.println(s.name+"---"+s.age);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n让容器自身具备比较性，自定义比较器。\n\n需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。\n\n那么这时只能让容器自身具备。\n\n定义一个类实现Comparator 接口，覆盖compare方法。\n\n并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。\n\n当Comparable比较方式，及Comparator比较方式同时存在，以Comparator比较方式为主。\n\npublic class Demo5 {\n\tpublic static void main(String[] args) {\n\t\tTreeSet ts = new TreeSet(new MyComparator());\n\t\tts.add(new Book("think in java", 100));\n\t\tts.add(new Book("java 核心技术", 75));\n\t\tts.add(new Book("现代操作系统", 50));\n\t\tts.add(new Book("java就业教程", 35));\n\t\tts.add(new Book("think in java", 100));\n\t\tts.add(new Book("ccc in java", 100));\n \n\t\tSystem.out.println(ts); \n\t}\n}\n \nclass MyComparator implements Comparator {\n \n\tpublic int compare(Object o1, Object o2) {\n\t\tBook b1 = (Book) o1;\n\t\tBook b2 = (Book) o2;\n\t\tSystem.out.println(b1+" comparator "+b2);\n\t\tif (b1.getPrice() > b2.getPrice()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b1.getPrice() < b2.getPrice()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn b1.getName().compareTo(b2.getName());\n\t}\n \n}\n \nclass Book {\n\tprivate String name;\n\tprivate double price;\n \n\tpublic Book() {\n \n\t}\n \n\tpublic String getName() {\n\t\treturn name;\n\t}\n \n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n \n\tpublic double getPrice() {\n\t\treturn price;\n\t}\n \n\tpublic void setPrice(double price) {\n\t\tthis.price = price;\n\t}\n \n\tpublic Book(String name, double price) {\n \n\t\tthis.name = name;\n\t\tthis.price = price;\n\t}\n \n\t@Override\n\tpublic String toString() {\n\t\treturn "Book [name=" + name + ", price=" + price + "]";\n\t}\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n',normalizedContent:'# treeset\n\ntreeset简介\n\n红-黑树的数据结构，默认对元素进行自然排序\n\ntreeset 是一个有序的集合，它的作用是提供有序的set集合。它继承于abstractset抽象类，实现了navigableset, cloneable, java.io.serializable接口。\n\ntreeset 继承于abstractset，所以它是一个set集合，具有set的属性和方法。\n\ntreeset 实现了navigableset接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。\n\ntreeset 实现了cloneable接口，意味着它能被克隆。\n\ntreeset 实现了java.io.serializable接口，意味着它支持序列化。\n\ntreeset是基于treemap实现的。treeset中的元素支持2种排序方式：自然排序 或者 根据创建treeset 时提供的 comparator 进行排序。这取决于使用的构造方法。\n\ntreeset为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。 另外，treeset是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。\n\n特点：\n\n * 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法\n   \n   treeset():根据其元素的自然非序进行排序\n   \n   treeset(comparator comparator):根据指定的比较器进行排序\n\n * 没有带索引的方法，所以不能使用普通for循环遍历\n\n * 由于是set集合，所以不包含重复元素的集合\n\n\n# treeset自然顺序\n\n即类要实现comparable接口，并重写compareto()方法，treeset对象调用add()方法时，会将存入的对象提升为comparable类型，然后调用对象中的compareto()方法进行比较，根据比较的返回值进行存储。\n\n因为treeset底层是二叉树，当compareto方法返回0时，不存储；当compareto方法返回正数时，存入二叉树的右子树；当compareto方法返回负数时，存入二叉树的左子树。如果一个类没有实现comparable接口就将该类对象存入treeset集合，会发生类型转换异常。\n\n\n# treeset自定义排序\n\n方式一：元素自身具备比较性\n\n元素自身具备比较性，需要元素实现comparable接口，重写compareto方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。\n\n让元素自身具备比较性\n\n也就是元素需要实现comparable接口，覆盖compareto 方法。\n\n案例：创建student类，有姓名，年龄。存入集合后，先根据年龄大小，再根据姓名来进行排序插入集合中\n\npublic class student implements comparable<student> {\n    public string name;\n    public int age;\n\n    public student(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @override\n    public int compareto(student o) {\n        int i = this.age-o.age;\n        int n = i==0?this.name.compareto(o.name):i;\n        return n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n重写compareto()方法，返回值有三种情况\n\n 1. 返回值为0：不插入集合\n 2. 返回值为1：往后插入集合\n 3. 返回值为-1：往前插入集合\n\npublic class demo {\n    public static void main(string[] args) {\n        student s1 = new student("xishi",25);\n        student s2 = new student("yangyuhuan",29);\n        student s3 = new student("diaochan",28);\n        student s4 = new student("wangzhaojun",30);\n        student s5 = new student("libai",30);\n        student s6 = new student("libai",30);\n\n        treeset<student> ts = new treeset<>();\n\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n\n        for(student s : ts){\n            system.out.println(s.name+"---"+s.age);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n让容器自身具备比较性，自定义比较器。\n\n需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。\n\n那么这时只能让容器自身具备。\n\n定义一个类实现comparator 接口，覆盖compare方法。\n\n并将该接口的子类对象作为参数传递给treeset集合的构造函数。\n\n当comparable比较方式，及comparator比较方式同时存在，以comparator比较方式为主。\n\npublic class demo5 {\n\tpublic static void main(string[] args) {\n\t\ttreeset ts = new treeset(new mycomparator());\n\t\tts.add(new book("think in java", 100));\n\t\tts.add(new book("java 核心技术", 75));\n\t\tts.add(new book("现代操作系统", 50));\n\t\tts.add(new book("java就业教程", 35));\n\t\tts.add(new book("think in java", 100));\n\t\tts.add(new book("ccc in java", 100));\n \n\t\tsystem.out.println(ts); \n\t}\n}\n \nclass mycomparator implements comparator {\n \n\tpublic int compare(object o1, object o2) {\n\t\tbook b1 = (book) o1;\n\t\tbook b2 = (book) o2;\n\t\tsystem.out.println(b1+" comparator "+b2);\n\t\tif (b1.getprice() > b2.getprice()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b1.getprice() < b2.getprice()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn b1.getname().compareto(b2.getname());\n\t}\n \n}\n \nclass book {\n\tprivate string name;\n\tprivate double price;\n \n\tpublic book() {\n \n\t}\n \n\tpublic string getname() {\n\t\treturn name;\n\t}\n \n\tpublic void setname(string name) {\n\t\tthis.name = name;\n\t}\n \n\tpublic double getprice() {\n\t\treturn price;\n\t}\n \n\tpublic void setprice(double price) {\n\t\tthis.price = price;\n\t}\n \n\tpublic book(string name, double price) {\n \n\t\tthis.name = name;\n\t\tthis.price = price;\n\t}\n \n\t@override\n\tpublic string tostring() {\n\t\treturn "book [name=" + name + ", price=" + price + "]";\n\t}\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n',charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"泛型",frontmatter:{title:"泛型",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/generic-paradigm/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/11.%E6%B3%9B%E5%9E%8B.html",relativePath:"01.Java/05.Java-集合框架/11.泛型.md",key:"v-28e9210c",path:"/java/se/collection/generic-paradigm/",headers:[{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:2}],headersStr:"泛型",content:"# 泛型\n\nJava 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许 程序员在编译时检测到非法的类型。\n\n泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n\n如何解决以下强制类型转换时容易出现的异常问题?\n\nList的get(int index)方法获取元素 Map的get(Object key)方法获取元素 Iterator的next()方法获取元素\n\n分析：通过泛型 ， JDK1.5使用泛型改写了集合框架中的所有接口和类\n\n\n\n\n\n？ 通配符： < ? >",normalizedContent:"# 泛型\n\njava 泛型（generics）是 jdk 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许 程序员在编译时检测到非法的类型。\n\n泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n\n如何解决以下强制类型转换时容易出现的异常问题?\n\nlist的get(int index)方法获取元素 map的get(object key)方法获取元素 iterator的next()方法获取元素\n\n分析：通过泛型 ， jdk1.5使用泛型改写了集合框架中的所有接口和类\n\n\n\n\n\n？ 通配符： < ? >",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Collections工具类",frontmatter:{title:"Collections工具类",date:"2021-04-16T16:19:25.000Z",permalink:"/java/se/collection/collections/",categories:["java","java-se","集合框架"]},regularPath:"/01.Java/05.Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/12.Collections%E5%B7%A5%E5%85%B7%E7%B1%BB.html",relativePath:"01.Java/05.Java-集合框架/12.Collections工具类.md",key:"v-5dded6fa",path:"/java/se/collection/collections/",headers:[{level:2,title:"Collections工具类",slug:"collections工具类",normalizedTitle:"collections工具类",charIndex:2},{level:3,title:"1、Collectios概述",slug:"_1、collectios概述",normalizedTitle:"1、collectios概述",charIndex:156},{level:3,title:"2、排序操作",slug:"_2、排序操作",normalizedTitle:"2、排序操作",charIndex:370},{level:3,title:"3、查找、替换操作",slug:"_3、查找、替换操作",normalizedTitle:"3、查找、替换操作",charIndex:2822},{level:3,title:"4、同步控制",slug:"_4、同步控制",normalizedTitle:"4、同步控制",charIndex:4834},{level:3,title:"5、Collesction设置不可变集合",slug:"_5、collesction设置不可变集合",normalizedTitle:"5、collesction设置不可变集合",charIndex:5741},{level:3,title:"总结和测试",slug:"总结和测试",normalizedTitle:"总结和测试",charIndex:6858},{level:3,title:"斗地主案例",slug:"斗地主案例",normalizedTitle:"斗地主案例",charIndex:8677}],headersStr:"Collections工具类 1、Collectios概述 2、排序操作 3、查找、替换操作 4、同步控制 5、Collesction设置不可变集合 总结和测试 斗地主案例",content:'# Collections工具类\n\n【前言】\n\nJava提供了一个操作Set、List和Map等集合的工具类：Collections，该工具类提供了大量方法对集合进 行排序、查询和修改等操作，还提供了将集合对象置为不可变、对集合对象实现同步控制等方法。\n\n这个类不需要创建对象，内部提供的都是静态方法。\n\n\n# 1、Collectios概述\n\n\n\n此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。如果为 此类的方法所提供的 collection 或类对象为 null，则这些方法都将抛出 NullPointerException 。\n\n\n# 2、排序操作\n\nstatic void reverse(List<?> list)//反转列表中元素的顺序。\n\nstatic void shuffle(List<?> list) //对List集合元素进行随机排序。\n\nstatic void sort(List<T> list) //根据元素的自然顺序 对指定列表按升序进行排序\n\nstatic <T> void sort(List<T> list, Comparator<? super T> c) //根据指定比较器产生的顺序对指定列表进行排序。\n    \nstatic void swap(List<?> list, int i, int j)   //在指定List的指定位置i,j处交换元素。\n\nstatic void rotate(List<?> list, int distance)\n //当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【演示】\n\npublic static void main(String[] args) {\n    ArrayList list = new ArrayList();\n    list.add(3);\n    list.add(-2);\n    list.add(9);\n    list.add(5);\n    list.add(-1);\n    list.add(6);\n\n    //输出：[3, -2, 9, 5, -1, 6]\n    System.out.println(list);\n    //集合元素的次序反转\n    Collections.reverse(list);\n    //输出：[6, -1, 5, 9, -2, 3]\n    System.out.println(list);\n    //排序：按照升序排序\n    Collections.sort(list);\n    //[-2, -1, 3, 5, 6, 9]\n    System.out.println(list);\n    //根据下标进行交换\n    Collections.swap(list, 2, 5);\n    //输出：[-2, -1, 9, 5, 6, 3]\n    System.out.println(list);\n    \n    /*//随机排序\n    Collections.shuffle(list);\n    //每次输出的次序不固定\n    System.out.println(list);*/\n    \n    //后两个整体移动到前边\n    Collections.rotate(list, 2);\n    //输出：[6, 9, -2, -1, 3, 5]\n    System.out.println(list);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n【演示】\n\n创建学生集合，加入数据，并自定义排序，先根据年龄，再根据首字母\n\npojo类\n\npublic class Student {\n    public String name;\n    public int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntest代码\n\npublic static void main(String[] args) {\n    ArrayList<Student> array = new ArrayList<>();\n    Student s1 = new Student("lingqingxia",20);\n    Student s2 = new Student("wangxizhi",30);\n    Student s3 = new Student("libai",25);\n    Student s4 = new Student("dufu",25);\n\t//Student s5 = new Student("dufu",25);\n\n    array.add(s1);\n    array.add(s2);\n    array.add(s3);\n    array.add(s4);\n\t//array.add(s5);\n    Collections.sort(array, new Comparator<Student>() {\n        @Override\n        public int compare(Student o1, Student o2) {\n            int i = o1.age-o2.age;\n            int n = i==0?o1.name.compareTo(o2.name):i;\n            return n;\n        }\n    });\n\n    for (Student s:array){\n        System.out.println(s.name+","+s.age);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3、查找、替换操作\n\n【方法】\n\n//使用二分搜索法搜索指定列表，以获得指定对象在List集合中的索引。\n//注意：此前必须保证List集合中的元素已经处于有序状态。\nstatic <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)\n\n//根据元素的自然顺序，返回给定collection 的最大元素。\nstatic Object max(Collection coll)\n\n   \t//根据指定比较器产生的顺序，返回给定 collection 的最大元素。\n    static Object max(Collection coll,Comparator comp)\n\n    //根据元素的自然顺序，返回给定collection 的最小元素。\n    static Object min(Collection coll)\n    \n    //根据指定比较器产生的顺序，返回给定 collection 的最小元素。\n    static Object min(Collection coll,Comparator comp)\n    \n    使用指定元素替换指定列表中的所有元素。\n    static <T> void fill(List<? super T> list, T obj)\n    \n    //返回指定 collection 中等于指定对象的出现次数。\n    static int frequency(Collection<?> c, Object o)\n    \n    //返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1。\n    static int indexOfSubList(List<?> source, List<?> target) \n    \n    //返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1。\n    static int lastIndexOfSubList(List<?> source, List<?> target)\n    \n    //使用一个新值替换List对象的所有旧值oldVal\n    static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n【演示：实例使用查找、替换操作】\n\npublic static void main(String[] args) {\n    ArrayList list = new ArrayList();\n    list.add(3);\n    list.add(-2);\n    list.add(9);\n    list.add(5);\n    list.add(-1);\n    list.add(6);\n    //[3, -2, 9, 5, -1, 6]\n    System.out.println(list);\n    //输出最大元素9\n    System.out.println(Collections.max(list));\n    //输出最小元素：-2\n    System.out.println(Collections.min(list));\n    //将list中的-2用1来代替\n    System.out.println(Collections.replaceAll(list, -2, 1));\n    //[3, 1, 9, 5, -1, 6]\n    System.out.println(list);\n    list.add(9);\n    //判断9在集合中出现的次数，返回2\n    System.out.println(Collections.frequency(list, 9));\n    //对集合进行排序\n    Collections.sort(list);\n    //[-1, 1, 3, 5, 6, 9, 9]\n    System.out.println(list);\n    //只有排序后的List集合才可用二分法查询，输出2\n    System.out.println(Collections.binarySearch(list, 3));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 4、同步控制\n\nCollectons提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从 而解决多线程并发访问集合时的线程安全问题。\n\n正如前面介绍的HashSet，TreeSet，arrayList,LinkedList,HashMap,TreeMap都是线程不安全的。 Collections提供了多个静态方法可以把他们包装成线程同步的集合。\n\n【方法】\n\n//返回指定 collection 支持的同步（线程安全的）collection。\nstatic <T> Collection<T> synchronizedCollection(Collection<T> c)\n    \n//返回指定列表支持的同步（线程安全的）列表。\nstatic <T> List<T> synchronizedList(List<T> list)\n\n//返回由指定映射支持的同步（线程安全的）映射。\nstatic <K,V> Map<K,V> synchronizedMap(Map<K,V> m)\n\n//返回指定 set 支持的同步（线程安全的）set\nstatic <T> Set<T> synchronizedSet(Set<T> s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n【实例】\n\npublic static void main(String[] args) {\n    //下面程序创建了四个同步的集合对象\n    Collection c = Collections.synchronizedCollection(new ArrayList());\n    List list = Collections.synchronizedList(new ArrayList());\n    Set s = Collections.synchronizedSet(new HashSet());\n    Map m = Collections.synchronizedMap(new HashMap());\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5、Collesction设置不可变集合\n\n【方法】\n\n//返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。\nemptyXxx()\n\n//返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。\nsingletonXxx()\n    \n//返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。\nunmodifiableXxx():\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。\n\n【实例】\n\npublic static void main(String[] args) {\n    //创建一个空的、不可改变的List对象\n    List<String> unmodifiableList = Collections.emptyList();\n    //unmodifiableList.add("java");\n    //添加出现异常：java.lang.UnsupportedOperationException\n    System.out.println(unmodifiableList);// []\n    //创建一个只有一个元素，且不可改变的Set对象\n    Set unmodifiableSet = Collections.singleton("Struts2权威指南");\n    //[Struts2权威指南]\n    System.out.println(unmodifiableSet);\n    //创建一个普通Map对象\n    Map scores = new HashMap();\n    scores.put("语文", 80);\n    scores.put("Java", 82);\n    //返回普通Map对象对应的不可变版本\n    Map unmodifiableMap = Collections.unmodifiableMap(scores);\n    //下面任意一行代码都将引发UnsupportedOperationException异常\n    unmodifiableList.add("测试元素");\n    unmodifiableSet.add("测试元素");\n    unmodifiableMap.put("语文", 90);\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 总结和测试\n\n实体类：Pojo\n\nimport java.util.*;\n\n\npublic class CollectionsTest {\n    public static void main(String[] args) {\n        //创建一个空的、不可改变的List对象\n        List<String> unmodifiableList = Collections.emptyList();\n        //unmodifiableList.add("java");\n        //添加出现异常：java.lang.UnsupportedOperationException\n        System.out.println(unmodifiableList);// []\n        //创建一个只有一个元素，且不可改变的Set对象\n        Set unmodifiableSet = Collections.singleton("Struts2权威指南");\n        //[Struts2权威指南]\n        System.out.println(unmodifiableSet);\n        //创建一个普通Map对象\n        Map scores = new HashMap();\n        scores.put("语文", 80);\n        scores.put("Java", 82);\n        //返回普通Map对象对应的不可变版本\n        Map unmodifiableMap = Collections.unmodifiableMap(scores);\n        //下面任意一行代码都将引发UnsupportedOperationException异常\n        unmodifiableList.add("测试元素");\n        unmodifiableSet.add("测试元素");\n        unmodifiableMap.put("语文", 90);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n测试类代码如下\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test01 {\n    public static void main(String[] args) throws Exception {\n        //一个对象对应了一行记录！\n        Employee e1 = new Employee(0301, "狂神", 3000, "项目部", "2017-10");\n        Employee e2 = new Employee(0302, "小明", 3500, "教学部", "2016-10");\n        Employee e3 = new Employee(0303, "小红", 3550, "教学部", "2016-10");\n        List<Employee> list = new ArrayList<Employee>();\n        list.add(e1);\n        list.add(e2);\n        list.add(e3);\n        printEmpName(list);\n    }\n\n    public static void printEmpName(List<Employee> list) {\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i).getName() + "-" + list.get(i).getHireDate());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 斗地主案例\n\n简易版本\n\npublic static void main(String[] args) {\n    ArrayList<String> array = new ArrayList<>();\n\n    String[] colors = {"方片", "梅花", "黑桃", "红桃"};\n    String[] numbers = {"1","2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"};\n\n    for (String c : colors) {\n        for (String n : numbers) {\n            array.add(c + n);\n        }\n    }\n    array.add("小王");\n    array.add("大王");\n    Collections.shuffle(array);//洗牌\n\n    //发牌\n    ArrayList<String> wj1 = new ArrayList<>();//玩家1\n    ArrayList<String> wj2 = new ArrayList<>();\n    ArrayList<String> wj3 = new ArrayList<>();\n    ArrayList<String> dp = new ArrayList<>();//底牌\n\n\n    for (int i = 0; i < array.size(); i++) {\n        String s = array.get(i);\n        if (i >= array.size() - 3) {\n            dp.add(s);\n        }else{\n            int i1 = i % 3;\n            switch (i1){\n                case 0:\n                    wj1.add(s);\n                    break;\n                case 1:\n                    wj2.add(s);\n                    break;\n                case 2:\n                    wj3.add(s);\n                    break;\n            }\n        }\n    }\n    //看牌\n    System.out.println("底牌："+dp);\n    System.out.println("玩家1的牌"+wj1);\n    System.out.println("玩家2的牌"+wj2);\n    System.out.println("玩家3的牌"+wj3);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n> 底牌：[梅花1, 黑桃2, 红桃Q]\n> \n> 玩家1的牌[黑桃10, 大王, 方片7, 梅花5, 方片9, 方片3, 黑桃4, 红桃8, 梅花4, 红桃9, 红桃2, 红桃4, 小王, 方片K, 红桃6, 黑桃6, 红桃K]\n> \n> 玩家2的牌[红桃1, 红桃7, 黑桃7, 方片J, 红桃J, 梅花3, 梅花7, 梅花8, 梅花9, 梅花2, 梅花J, 红桃10, 方片10, 黑桃5, 方片1, 黑桃K, 黑桃Q]\n> \n> 玩家3的牌[方片5, 方片4, 黑桃9, 方片8, 黑桃3, 方片Q, 方片6, 红桃5, 梅花6, 黑桃8, 黑桃1, 梅花Q, 红桃3, 梅花10, 方片2, 梅花K, 黑桃J]\n\n可以看到，能实现洗牌，发牌，看牌\n\n但是牌的顺序不是从小到大的，我们来改进一下\n\n\n\n 1. 用HashMap键值对从0到53序号，存储牌\n 2. 用ArrayList存牌的序号\n 3. 用TreeSet存玩家的牌的序号，TreeSet可以自动排序\n 4. 通过TreeSet的序号，从HashMap中查取牌\n\npublic class Poker {\n    public static void main(String[] args) {\n        //编号，牌\n        HashMap<Integer,String> hm = new HashMap<>();\n        //储存编号\n        ArrayList<Integer> array = new ArrayList<>();\n\n        String[] colors = {"方片", "梅花", "黑桃", "红桃"};\n        String[] numbers = { "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K","A","2"};\n        int index=0;\n        for (String c:colors){\n            for (String n:numbers){\n                hm.put(index,c+n);\n                array.add(index);\n                index++;\n            }\n        }\n        hm.put(index,"小王");\n        array.add(index);\n        index++;\n        hm.put(index,"大王");\n        array.add(index);\n\n        Collections.shuffle(array);//洗牌\n        //发牌\n        TreeSet<Integer> wj1 = new TreeSet<>();//玩家1\n        TreeSet<Integer> wj2 = new TreeSet<>();\n        TreeSet<Integer> wj3 = new TreeSet<>();\n        TreeSet<Integer> dp  = new TreeSet<>();//底牌\n\n        for (int i = 0; i < array.size(); i++) {\n            Integer s = array.get(i);\n            if (i >= array.size() - 3) {\n                dp.add(s);\n            }else{\n                int i1 = i % 3;\n                switch (i1){\n                    case 0:\n                        wj1.add(s);\n                        break;\n                    case 1:\n                        wj2.add(s);\n                        break;\n                    case 2:\n                        wj3.add(s);\n                        break;\n                }\n            }\n        }\n        lookpoke("玩家1",wj1 ,hm);\n        lookpoke("玩家2",wj2 ,hm);\n        lookpoke("玩家3",wj3 ,hm);\n        lookpoke("底牌",dp ,hm);\n\n    }\n    public  static void lookpoke(String name,TreeSet<Integer> ts,HashMap<Integer,String> hm){\n        System.out.print(name+"的牌：   ");\n        for (Integer t:ts){\n            System.out.print(hm.get(t)+" ");\n        }\n        System.out.println();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n',normalizedContent:'# collections工具类\n\n【前言】\n\njava提供了一个操作set、list和map等集合的工具类：collections，该工具类提供了大量方法对集合进 行排序、查询和修改等操作，还提供了将集合对象置为不可变、对集合对象实现同步控制等方法。\n\n这个类不需要创建对象，内部提供的都是静态方法。\n\n\n# 1、collectios概述\n\n\n\n此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。如果为 此类的方法所提供的 collection 或类对象为 null，则这些方法都将抛出 nullpointerexception 。\n\n\n# 2、排序操作\n\nstatic void reverse(list<?> list)//反转列表中元素的顺序。\n\nstatic void shuffle(list<?> list) //对list集合元素进行随机排序。\n\nstatic void sort(list<t> list) //根据元素的自然顺序 对指定列表按升序进行排序\n\nstatic <t> void sort(list<t> list, comparator<? super t> c) //根据指定比较器产生的顺序对指定列表进行排序。\n    \nstatic void swap(list<?> list, int i, int j)   //在指定list的指定位置i,j处交换元素。\n\nstatic void rotate(list<?> list, int distance)\n //当distance为正数时，将list集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n【演示】\n\npublic static void main(string[] args) {\n    arraylist list = new arraylist();\n    list.add(3);\n    list.add(-2);\n    list.add(9);\n    list.add(5);\n    list.add(-1);\n    list.add(6);\n\n    //输出：[3, -2, 9, 5, -1, 6]\n    system.out.println(list);\n    //集合元素的次序反转\n    collections.reverse(list);\n    //输出：[6, -1, 5, 9, -2, 3]\n    system.out.println(list);\n    //排序：按照升序排序\n    collections.sort(list);\n    //[-2, -1, 3, 5, 6, 9]\n    system.out.println(list);\n    //根据下标进行交换\n    collections.swap(list, 2, 5);\n    //输出：[-2, -1, 9, 5, 6, 3]\n    system.out.println(list);\n    \n    /*//随机排序\n    collections.shuffle(list);\n    //每次输出的次序不固定\n    system.out.println(list);*/\n    \n    //后两个整体移动到前边\n    collections.rotate(list, 2);\n    //输出：[6, 9, -2, -1, 3, 5]\n    system.out.println(list);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n【演示】\n\n创建学生集合，加入数据，并自定义排序，先根据年龄，再根据首字母\n\npojo类\n\npublic class student {\n    public string name;\n    public int age;\n\n    public student(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntest代码\n\npublic static void main(string[] args) {\n    arraylist<student> array = new arraylist<>();\n    student s1 = new student("lingqingxia",20);\n    student s2 = new student("wangxizhi",30);\n    student s3 = new student("libai",25);\n    student s4 = new student("dufu",25);\n\t//student s5 = new student("dufu",25);\n\n    array.add(s1);\n    array.add(s2);\n    array.add(s3);\n    array.add(s4);\n\t//array.add(s5);\n    collections.sort(array, new comparator<student>() {\n        @override\n        public int compare(student o1, student o2) {\n            int i = o1.age-o2.age;\n            int n = i==0?o1.name.compareto(o2.name):i;\n            return n;\n        }\n    });\n\n    for (student s:array){\n        system.out.println(s.name+","+s.age);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 3、查找、替换操作\n\n【方法】\n\n//使用二分搜索法搜索指定列表，以获得指定对象在list集合中的索引。\n//注意：此前必须保证list集合中的元素已经处于有序状态。\nstatic <t> int binarysearch(list<? extends comparable<? super t>> list, t key)\n\n//根据元素的自然顺序，返回给定collection 的最大元素。\nstatic object max(collection coll)\n\n   \t//根据指定比较器产生的顺序，返回给定 collection 的最大元素。\n    static object max(collection coll,comparator comp)\n\n    //根据元素的自然顺序，返回给定collection 的最小元素。\n    static object min(collection coll)\n    \n    //根据指定比较器产生的顺序，返回给定 collection 的最小元素。\n    static object min(collection coll,comparator comp)\n    \n    使用指定元素替换指定列表中的所有元素。\n    static <t> void fill(list<? super t> list, t obj)\n    \n    //返回指定 collection 中等于指定对象的出现次数。\n    static int frequency(collection<?> c, object o)\n    \n    //返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1。\n    static int indexofsublist(list<?> source, list<?> target) \n    \n    //返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1。\n    static int lastindexofsublist(list<?> source, list<?> target)\n    \n    //使用一个新值替换list对象的所有旧值oldval\n    static <t> boolean replaceall(list<t> list, t oldval, t newval)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n【演示：实例使用查找、替换操作】\n\npublic static void main(string[] args) {\n    arraylist list = new arraylist();\n    list.add(3);\n    list.add(-2);\n    list.add(9);\n    list.add(5);\n    list.add(-1);\n    list.add(6);\n    //[3, -2, 9, 5, -1, 6]\n    system.out.println(list);\n    //输出最大元素9\n    system.out.println(collections.max(list));\n    //输出最小元素：-2\n    system.out.println(collections.min(list));\n    //将list中的-2用1来代替\n    system.out.println(collections.replaceall(list, -2, 1));\n    //[3, 1, 9, 5, -1, 6]\n    system.out.println(list);\n    list.add(9);\n    //判断9在集合中出现的次数，返回2\n    system.out.println(collections.frequency(list, 9));\n    //对集合进行排序\n    collections.sort(list);\n    //[-1, 1, 3, 5, 6, 9, 9]\n    system.out.println(list);\n    //只有排序后的list集合才可用二分法查询，输出2\n    system.out.println(collections.binarysearch(list, 3));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 4、同步控制\n\ncollectons提供了多个synchronizedxxx()方法，该方法可以将指定集合包装成线程同步的集合，从 而解决多线程并发访问集合时的线程安全问题。\n\n正如前面介绍的hashset，treeset，arraylist,linkedlist,hashmap,treemap都是线程不安全的。 collections提供了多个静态方法可以把他们包装成线程同步的集合。\n\n【方法】\n\n//返回指定 collection 支持的同步（线程安全的）collection。\nstatic <t> collection<t> synchronizedcollection(collection<t> c)\n    \n//返回指定列表支持的同步（线程安全的）列表。\nstatic <t> list<t> synchronizedlist(list<t> list)\n\n//返回由指定映射支持的同步（线程安全的）映射。\nstatic <k,v> map<k,v> synchronizedmap(map<k,v> m)\n\n//返回指定 set 支持的同步（线程安全的）set\nstatic <t> set<t> synchronizedset(set<t> s)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n【实例】\n\npublic static void main(string[] args) {\n    //下面程序创建了四个同步的集合对象\n    collection c = collections.synchronizedcollection(new arraylist());\n    list list = collections.synchronizedlist(new arraylist());\n    set s = collections.synchronizedset(new hashset());\n    map m = collections.synchronizedmap(new hashmap());\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5、collesction设置不可变集合\n\n【方法】\n\n//返回一个空的、不可变的集合对象，此处的集合既可以是list，也可以是set，还可以是map。\nemptyxxx()\n\n//返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：list，set，map。\nsingletonxxx()\n    \n//返回指定集合对象的不可变视图，此处的集合可以是：list，set，map。\nunmodifiablexxx():\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。\n\n【实例】\n\npublic static void main(string[] args) {\n    //创建一个空的、不可改变的list对象\n    list<string> unmodifiablelist = collections.emptylist();\n    //unmodifiablelist.add("java");\n    //添加出现异常：java.lang.unsupportedoperationexception\n    system.out.println(unmodifiablelist);// []\n    //创建一个只有一个元素，且不可改变的set对象\n    set unmodifiableset = collections.singleton("struts2权威指南");\n    //[struts2权威指南]\n    system.out.println(unmodifiableset);\n    //创建一个普通map对象\n    map scores = new hashmap();\n    scores.put("语文", 80);\n    scores.put("java", 82);\n    //返回普通map对象对应的不可变版本\n    map unmodifiablemap = collections.unmodifiablemap(scores);\n    //下面任意一行代码都将引发unsupportedoperationexception异常\n    unmodifiablelist.add("测试元素");\n    unmodifiableset.add("测试元素");\n    unmodifiablemap.put("语文", 90);\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 总结和测试\n\n实体类：pojo\n\nimport java.util.*;\n\n\npublic class collectionstest {\n    public static void main(string[] args) {\n        //创建一个空的、不可改变的list对象\n        list<string> unmodifiablelist = collections.emptylist();\n        //unmodifiablelist.add("java");\n        //添加出现异常：java.lang.unsupportedoperationexception\n        system.out.println(unmodifiablelist);// []\n        //创建一个只有一个元素，且不可改变的set对象\n        set unmodifiableset = collections.singleton("struts2权威指南");\n        //[struts2权威指南]\n        system.out.println(unmodifiableset);\n        //创建一个普通map对象\n        map scores = new hashmap();\n        scores.put("语文", 80);\n        scores.put("java", 82);\n        //返回普通map对象对应的不可变版本\n        map unmodifiablemap = collections.unmodifiablemap(scores);\n        //下面任意一行代码都将引发unsupportedoperationexception异常\n        unmodifiablelist.add("测试元素");\n        unmodifiableset.add("测试元素");\n        unmodifiablemap.put("语文", 90);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n测试类代码如下\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class test01 {\n    public static void main(string[] args) throws exception {\n        //一个对象对应了一行记录！\n        employee e1 = new employee(0301, "狂神", 3000, "项目部", "2017-10");\n        employee e2 = new employee(0302, "小明", 3500, "教学部", "2016-10");\n        employee e3 = new employee(0303, "小红", 3550, "教学部", "2016-10");\n        list<employee> list = new arraylist<employee>();\n        list.add(e1);\n        list.add(e2);\n        list.add(e3);\n        printempname(list);\n    }\n\n    public static void printempname(list<employee> list) {\n        for (int i = 0; i < list.size(); i++) {\n            system.out.println(list.get(i).getname() + "-" + list.get(i).gethiredate());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 斗地主案例\n\n简易版本\n\npublic static void main(string[] args) {\n    arraylist<string> array = new arraylist<>();\n\n    string[] colors = {"方片", "梅花", "黑桃", "红桃"};\n    string[] numbers = {"1","2", "3", "4", "5", "6", "7", "8", "9", "10", "j", "q", "k"};\n\n    for (string c : colors) {\n        for (string n : numbers) {\n            array.add(c + n);\n        }\n    }\n    array.add("小王");\n    array.add("大王");\n    collections.shuffle(array);//洗牌\n\n    //发牌\n    arraylist<string> wj1 = new arraylist<>();//玩家1\n    arraylist<string> wj2 = new arraylist<>();\n    arraylist<string> wj3 = new arraylist<>();\n    arraylist<string> dp = new arraylist<>();//底牌\n\n\n    for (int i = 0; i < array.size(); i++) {\n        string s = array.get(i);\n        if (i >= array.size() - 3) {\n            dp.add(s);\n        }else{\n            int i1 = i % 3;\n            switch (i1){\n                case 0:\n                    wj1.add(s);\n                    break;\n                case 1:\n                    wj2.add(s);\n                    break;\n                case 2:\n                    wj3.add(s);\n                    break;\n            }\n        }\n    }\n    //看牌\n    system.out.println("底牌："+dp);\n    system.out.println("玩家1的牌"+wj1);\n    system.out.println("玩家2的牌"+wj2);\n    system.out.println("玩家3的牌"+wj3);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n> 底牌：[梅花1, 黑桃2, 红桃q]\n> \n> 玩家1的牌[黑桃10, 大王, 方片7, 梅花5, 方片9, 方片3, 黑桃4, 红桃8, 梅花4, 红桃9, 红桃2, 红桃4, 小王, 方片k, 红桃6, 黑桃6, 红桃k]\n> \n> 玩家2的牌[红桃1, 红桃7, 黑桃7, 方片j, 红桃j, 梅花3, 梅花7, 梅花8, 梅花9, 梅花2, 梅花j, 红桃10, 方片10, 黑桃5, 方片1, 黑桃k, 黑桃q]\n> \n> 玩家3的牌[方片5, 方片4, 黑桃9, 方片8, 黑桃3, 方片q, 方片6, 红桃5, 梅花6, 黑桃8, 黑桃1, 梅花q, 红桃3, 梅花10, 方片2, 梅花k, 黑桃j]\n\n可以看到，能实现洗牌，发牌，看牌\n\n但是牌的顺序不是从小到大的，我们来改进一下\n\n\n\n 1. 用hashmap键值对从0到53序号，存储牌\n 2. 用arraylist存牌的序号\n 3. 用treeset存玩家的牌的序号，treeset可以自动排序\n 4. 通过treeset的序号，从hashmap中查取牌\n\npublic class poker {\n    public static void main(string[] args) {\n        //编号，牌\n        hashmap<integer,string> hm = new hashmap<>();\n        //储存编号\n        arraylist<integer> array = new arraylist<>();\n\n        string[] colors = {"方片", "梅花", "黑桃", "红桃"};\n        string[] numbers = { "3", "4", "5", "6", "7", "8", "9", "10", "j", "q", "k","a","2"};\n        int index=0;\n        for (string c:colors){\n            for (string n:numbers){\n                hm.put(index,c+n);\n                array.add(index);\n                index++;\n            }\n        }\n        hm.put(index,"小王");\n        array.add(index);\n        index++;\n        hm.put(index,"大王");\n        array.add(index);\n\n        collections.shuffle(array);//洗牌\n        //发牌\n        treeset<integer> wj1 = new treeset<>();//玩家1\n        treeset<integer> wj2 = new treeset<>();\n        treeset<integer> wj3 = new treeset<>();\n        treeset<integer> dp  = new treeset<>();//底牌\n\n        for (int i = 0; i < array.size(); i++) {\n            integer s = array.get(i);\n            if (i >= array.size() - 3) {\n                dp.add(s);\n            }else{\n                int i1 = i % 3;\n                switch (i1){\n                    case 0:\n                        wj1.add(s);\n                        break;\n                    case 1:\n                        wj2.add(s);\n                        break;\n                    case 2:\n                        wj3.add(s);\n                        break;\n                }\n            }\n        }\n        lookpoke("玩家1",wj1 ,hm);\n        lookpoke("玩家2",wj2 ,hm);\n        lookpoke("玩家3",wj3 ,hm);\n        lookpoke("底牌",dp ,hm);\n\n    }\n    public  static void lookpoke(string name,treeset<integer> ts,hashmap<integer,string> hm){\n        system.out.print(name+"的牌：   ");\n        for (integer t:ts){\n            system.out.print(hm.get(t)+" ");\n        }\n        system.out.println();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JUC学习笔记（上）",frontmatter:{title:"JUC学习笔记（上）",permalink:"/java/se/thread/1",date:"2021-05-15T18:09:11.000Z"},regularPath:"/01.Java/07.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/02.JUC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"01.Java/07.Java-多线程/02.JUC学习笔记.md",key:"v-90469700",path:"/java/se/thread/1/",headers:[{level:2,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:3},{level:3,title:"什么是JUC",slug:"什么是juc",normalizedTitle:"什么是juc",charIndex:13},{level:3,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:25},{level:2,title:"2、Lock锁",slug:"_2、lock锁",normalizedTitle:"2、lock锁",charIndex:34},{level:3,title:"synchronized锁",slug:"synchronized锁",normalizedTitle:"synchronized锁",charIndex:47},{level:3,title:"Lock 锁",slug:"lock-锁",normalizedTitle:"lock 锁",charIndex:66},{level:3,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:78},{level:2,title:"3、生产者和消费者",slug:"_3、生产者和消费者",normalizedTitle:"3、生产者和消费者",charIndex:84},{level:3,title:"synchroinzed",slug:"synchroinzed",normalizedTitle:"synchroinzed",charIndex:99},{level:3,title:"lock",slug:"lock",normalizedTitle:"lock",charIndex:117},{level:3,title:"按照线程顺序执行",slug:"按照线程顺序执行",normalizedTitle:"按照线程顺序执行",charIndex:127},{level:2,title:"4、8锁的现象",slug:"_4、8锁的现象",normalizedTitle:"4、8锁的现象",charIndex:139},{level:3,title:"问题一",slug:"问题一",normalizedTitle:"问题一",charIndex:152},{level:3,title:"问题二",slug:"问题二",normalizedTitle:"问题二",charIndex:161},{level:3,title:"问题三",slug:"问题三",normalizedTitle:"问题三",charIndex:170},{level:3,title:"问题四",slug:"问题四",normalizedTitle:"问题四",charIndex:179},{level:3,title:"问题五",slug:"问题五",normalizedTitle:"问题五",charIndex:188},{level:3,title:"问题六",slug:"问题六",normalizedTitle:"问题六",charIndex:197},{level:3,title:"问题七",slug:"问题七",normalizedTitle:"问题七",charIndex:206},{level:3,title:"问题八",slug:"问题八",normalizedTitle:"问题八",charIndex:215},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:224},{level:2,title:"5、多线程下集合类的不安全",slug:"_5、多线程下集合类的不安全",normalizedTitle:"5、多线程下集合类的不安全",charIndex:230},{level:3,title:"list",slug:"list",normalizedTitle:"list",charIndex:249},{level:3,title:"set",slug:"set",normalizedTitle:"set",charIndex:259},{level:3,title:"map",slug:"map",normalizedTitle:"map",charIndex:268},{level:2,title:"6、Callable",slug:"_6、callable",normalizedTitle:"6、callable",charIndex:275},{level:3,title:"基础入门",slug:"基础入门",normalizedTitle:"基础入门",charIndex:291},{level:3,title:"多个线程调用",slug:"多个线程调用",normalizedTitle:"多个线程调用",charIndex:301},{level:3,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:313},{level:2,title:"7、常用辅助类",slug:"_7、常用辅助类",normalizedTitle:"7、常用辅助类",charIndex:321},{level:3,title:"CountDownLatch",slug:"countdownlatch",normalizedTitle:"countdownlatch",charIndex:334},{level:3,title:"CyclicBarrier",slug:"cyclicbarrier",normalizedTitle:"cyclicbarrier",charIndex:354},{level:3,title:"Semaphore",slug:"semaphore",normalizedTitle:"semaphore",charIndex:373},{level:2,title:"8、读写锁",slug:"_8、读写锁",normalizedTitle:"8、读写锁",charIndex:386},{level:2,title:"9、阻塞队列",slug:"_9、阻塞队列",normalizedTitle:"9、阻塞队列",charIndex:395},{level:3,title:"阻塞队列简介",slug:"阻塞队列简介",normalizedTitle:"阻塞队列简介",charIndex:407},{level:3,title:"阻塞队列的用处",slug:"阻塞队列的用处",normalizedTitle:"阻塞队列的用处",charIndex:419},{level:3,title:"接口架构图",slug:"接口架构图",normalizedTitle:"接口架构图",charIndex:432},{level:3,title:"API的使用",slug:"api的使用",normalizedTitle:"api的使用",charIndex:443}],headersStr:"1、简介 什么是JUC 进程和线程 2、Lock锁 synchronized锁 Lock 锁 区别 3、生产者和消费者 synchroinzed lock 按照线程顺序执行 4、8锁的现象 问题一 问题二 问题三 问题四 问题五 问题六 问题七 问题八 小结 5、多线程下集合类的不安全 list set map 6、Callable 基础入门 多个线程调用 参考资料 7、常用辅助类 CountDownLatch CyclicBarrier Semaphore 8、读写锁 9、阻塞队列 阻塞队列简介 阻塞队列的用处 接口架构图 API的使用",content:' * 1、简介\n   * 什么是JUC\n   * 进程和线程\n * 2、Lock锁\n   * synchronized锁\n   * Lock 锁\n   * 区别\n * 3、生产者和消费者\n   * synchroinzed\n   * lock\n   * 按照线程顺序执行\n * 4、8锁的现象\n   * 问题一\n   * 问题二\n   * 问题三\n   * 问题四\n   * 问题五\n   * 问题六\n   * 问题七\n   * 问题八\n   * 小结\n * 5、多线程下集合类的不安全\n   * list\n   * set\n   * map\n * 6、Callable\n   * 基础入门\n   * 多个线程调用\n   * 参考资料\n * 7、常用辅助类\n   * CountDownLatch\n   * CyclicBarrier\n   * Semaphore\n * 8、读写锁\n * 9、阻塞队列\n   * 阻塞队列简介\n   * 阻塞队列的用处\n   * 接口架构图\n   * API的使用\n\n\n\n狂神JUC视频教程：https://www.bilibili.com/video/BV1B7411L7tE\n\n\n# 1、简介\n\n\n# 什么是JUC\n\nJUC是java.util.concurrent 的简写，在并发编程中使用的工具类。\n\n在jdk官方手册中可以看到juc相关的jar包有三个。\n\n用中文概括一下，JUC的意思就是java并发编程工具包\n\n实现多线程有三种方式：Thread、Runnable、Callable，其中Callable就位于concurrent包下\n\n\n# 进程和线程\n\n> 进程 / 线程是什么？\n\n进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。\n\n线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。\n\n白话：\n\n进程：就是操作系统中运行的一个程序，QQ.exe，music.exe，word.exe ，这就是多个进程\n\n线程：每个进程中都存在一个或者多个线程，比如用word写文章时，就会有一个线程默默帮你定时自动保存。\n\n> 并发 / 并行是什么？\n\n做并发编程之前，必须首先理解什么是并发，什么是并行。\n\n并发和并行是两个非常容易混淆的概念。它们都可以表示两个或多个任务一起执行，但是偏重点有点不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。然而并行的偏重点在于”同时执行”。\n\n严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会运行任务一,一会儿又运行任务二，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务是串行并发的，也会造成是多个任务并行执行的错觉。\n\n实际上，如果系统内只有一个CPU，而现在而使用多线程或者多线程任务，那么真实环境中这些任务不可能真实并行的，毕竟一个CPU一次只能执行一条指令，这种情况下多线程或者多线程任务就是并发的，而不是并行，操作系统会不停的切换任务。真正的并发也只能够出现在拥有多个CPU的系统中（多核CPU）。\n\n并发的动机：在计算能力恒定的情况下处理更多的任务, 就像我们的大脑, 计算能力相对恒定, 要在一天中处理更多的问题, 我们就必须具备多任务的能力. 现实工作中有很多事情可能会中断你的当前任务, 处理这种多任务的能力就是你的并发能力。\n\n并行的动机：用更多的CPU核心更快的完成任务. 就像一个团队, 一个脑袋不够用了, 一个团队来一起处理 一个任务。\n\n例子： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 （不一定是 同时的） 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。\n\n> 线程的状态\n\nJava的线程有6种状态：可以分析源码：\n\npublic enum State {\n    //线程刚创建\n    NEW,\n    \n    //在JVM中正在运行的线程\n    RUNNABLE,\n    \n    //线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行\n    BLOCKED,\n    \n    //等待状态\n    WAITING,\n    \n    //调用sleep() join() wait()方法可能导致线程处于等待状态\n    TIMED_WAITING,\n    \n    //线程执行完毕，已经退出\n    TERMINATED;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n> wait / sleep 的区别\n\n1、来自不同的类\n\n这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。\n\nsleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。\n\n2、有没有释放锁(释放资源)\n\n最主要是sleep方法没有释放锁\n\n而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\n\nsleep是线程被调用时，占着cpu去睡觉，其他线程不能占用cpu，os认为该线程正在工作，不会让出系统资源，wait是进入等待池等待，让出系统资源，其他线程可以占用cpu。\n\nsleep(100L)是占用cpu，线程休眠100毫秒，其他进程不能再占用cpu资源，wait（100L）是进入等待池中等待，交出cpu等系统资源供其他进程使用，在这100毫秒中，该线程可以被其他线程notify，但不同的是其他在等待池中的线程不被notify不会出来，但这个线程在等待100毫秒后会自动进入就绪队列等待系统分配资源，换句话说，sleep（100）在100毫秒后肯定会运行，但wait在100毫秒后还有等待os调用分配资源，所以wait100的停止运行时间是不确定的，但至少是100毫秒。 就是说sleep有时间限制的就像闹钟一样到时候就叫了，而wait是无限期的除非用户主动notify。\n\n3、使用范围不同\n\nwait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n\nsynchronized(x){\n    //或者wait()\n    x.notify()\n}\n\n\n1\n2\n3\n4\n\n\n4、是否需要捕获异常\n\nsleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n\n\n# 2、Lock锁\n\n\n# synchronized锁\n\npublic class SaleTicketTest1 {\n    /*\n     * 题目：三个售票员 卖出 30张票\n     * 多线程编程的企业级套路：\n     * 1. 在高内聚低耦合的前提下， 线程 操作(对外暴露的调用方法) 资源类\n     */\n\n    public static void main(String[] args) {\n        Ticket ticket = new Ticket();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 40; i++) {\n                    ticket.saleTicket();\n                }\n            }\n        }, "A").start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <=40; i++) {\n                    ticket.saleTicket();\n                }\n            }\n        }, "B").start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 40; i++) {\n                    ticket.saleTicket();\n                }\n            }\n        }, "C").start();\n\n    }\n    \n}\n\nclass Ticket { // 资源类\n    private int number = 30;\n\n    public synchronized void saleTicket() {\n        if (number > 0) {\n            System.out.println(Thread.currentThread().getName() + "卖出第 " + (number--) + "票,还剩下:" + number);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# Lock 锁\n\npublic class SaleTicketTest2 {\n    public static void main(String[] args) {\n        Ticket2 ticket2 = new Ticket2();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 40; i++) {\n                ticket2.saleTicket();\n            }\n        }, "A").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 40; i++) {\n                ticket2.saleTicket();\n            }\n        }, "B").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 40; i++) {\n                ticket2.saleTicket();\n            }\n        }, "C").start();\n\n    }\n}\n\nclass Ticket2 { // 资源类\n    private Lock lock = new ReentrantLock();\n\n    private int number = 30;\n\n    public void saleTicket() {\n        lock.lock();\n\n        try {\n            if (number > 0) {\n                System.out.println(Thread.currentThread().getName() + "卖出第 " + (number--) + "票,还剩下:" + number);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 区别\n\n 1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\n 2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\n 3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放 锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n 4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1 阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以 不用一直等待就结束了；\n 5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\n 6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n\n# 3、生产者和消费者\n\n\n# synchroinzed\n\n生产者和消费者 synchroinzed 版\n\npublic class ProducerConsumer {\n    /**\n     * 题目：现在两个线程，可以操作初始值为0的一个变量\n     * 实现一个线程对该变量 + 1，一个线程对该变量 -1\n     * 实现交替10次\n     * <p>\n     * 诀窍：\n     * 1. 高内聚低耦合的前提下，线程操作资源类\n     * 2. 判断 、干活、通知\n     */\n\n    public static void main(String[] args) {\n        Data data = new Data();\n\n        //A线程增加\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "A").start();\n\n        //B线程减少\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "B").start();\n    }\n}\n\nclass Data {\n    private int number = 0;\n\n    public synchronized void increment() throws InterruptedException {\n        // 判断该不该这个线程做\n        if (number != 0) {\n            this.wait();\n        }\n        // 干活\n        number++;\n        System.out.println(Thread.currentThread().getName() + "\\t" + number);\n        // 通知\n        this.notifyAll();\n    }\n\n    public synchronized void decrement() throws InterruptedException {\n        // 判断该不该这个线程做\n        if (number == 0) {\n            this.wait();\n        }\n        // 干活\n        number--;\n        System.out.println(Thread.currentThread().getName() + "\\t" + number);\n        // 通知\n        this.notifyAll();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n问题升级：防止虚假唤醒，4个线程，两个加，两个减\n\n【重点】if 和 while\n\npublic class ProducerConsumerPlus {\n    /**\n     * 题目：现在四个线程，可以操作初始值为0的一个变量\n     * 实现两个线程对该变量 + 1，两个线程对该变量 -1\n     * 实现交替10次\n     *\n     * 诀窍：\n     * 1. 高内聚低耦合的前提下，线程操作资源类\n     * 2. 判断 、干活、通知\n     * 3. 多线程交互中，必须要防止多线程的虚假唤醒，即（判断不能用if，只能用while）\n     */\n\n    public static void main(String[] args) {\n        Data2 data = new Data2();\n\n        //A线程增加\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "A").start();\n\n        //B线程减少\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "B").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "C").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "D").start();\n    }\n}\n\nclass Data2 {\n    private int number = 0;\n\n    public synchronized void increment() throws InterruptedException {\n        // 判断该不该这个线程做\n        while (number != 0) {\n            this.wait();\n        }\n        // 干活\n        number++;\n        System.out.println(Thread.currentThread().getName() + "\\t" + number);\n        // 通知\n        this.notifyAll();\n    }\n\n    public synchronized void decrement() throws InterruptedException {\n        // 判断该不该这个线程做\n        while (number == 0) {\n            this.wait();\n        }\n        // 干活\n        number--;\n        System.out.println(Thread.currentThread().getName() + "\\t" + number);\n        // 通知\n        this.notifyAll();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n\n# lock\n\npublic class ProducerConsumerPlus {\n    /**\n     * 题目：现在四个线程，可以操作初始值为0的一个变量\n     * 实现两个线程对该变量 + 1，两个线程对该变量 -1\n     * 实现交替10次\n     * <p>\n     * 诀窍：\n     * 1. 高内聚低耦合的前提下，线程操作资源类\n     * 2. 判断 、干活、通知\n     * 3. 多线程交互中，必须要防止多线程的虚假唤醒，即（判断不能用if，只能用while）\n     */\n\n    public static void main(String[] args) {\n        Data2 data = new Data2();\n\n        //A线程增加\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "A").start();\n\n        //B线程减少\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "B").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "C").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, "D").start();\n    }\n}\n\nclass Data2 {\n    private int number = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    public void increment() throws InterruptedException {\n\n        lock.lock();\n        try {\n            // 判断该不该这个线程做\n            while (number != 0) {\n                condition.await();\n            }\n            // 干活\n            number++;\n            System.out.println(Thread.currentThread().getName() + "\\t" + number);\n            // 通知\n            condition.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void decrement() throws InterruptedException {\n        lock.lock();\n        try {\n            // 判断该不该这个线程做\n            while (number == 0) {\n                condition.await();\n            }\n            // 干活\n            number--;\n            System.out.println(Thread.currentThread().getName() + "\\t" + number);\n            // 通知\n            condition.signalAll();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n\n\n以上写的程序并不会按照ABCD线程顺序，只会按照 “生产” “消费”顺序\n\n\n# 按照线程顺序执行\n\n精确通知顺序访问\n\npublic class c {\n    /**\n     * 题目：多线程之间按顺序调用，实现 A->B->C\n     * 重点：标志位\n     */\n\n    public static void main(String[] args) {\n        Resources resources = new Resources();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                resources.a();\n            }\n\n        }, "A").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                resources.b();\n            }\n\n        }, "B").start();\n\n        new Thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                resources.c();\n            }\n\n        }, "C").start();\n\n    }\n}\n\nclass Resources {\n    private int number = 1; // 1A 2B 3C\n    private Lock lock = new ReentrantLock();\n    private Condition condition1 = lock.newCondition();\n    private Condition condition2 = lock.newCondition();\n    private Condition condition3 = lock.newCondition();\n\n    public void a() {\n        lock.lock();\n        try {\n            // 判断\n            while (number != 1) {\n                condition1.await();\n            }\n            // 干活\n            System.out.println(Thread.currentThread().getName());\n            // 通知,指定的干活！\n            number = 2;\n            condition2.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void b() {\n        lock.lock();\n        try {\n            // 判断\n            while (number != 2) {\n                condition2.await();\n            }\n            // 干活\n            System.out.println(Thread.currentThread().getName() );\n\n            // 通知,指定的干活！\n            number = 3;\n            condition3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void c() {\n        lock.lock();\n        try {\n            // 判断\n            while (number != 3) {\n                condition3.await();\n            }\n            // 干活\n            System.out.println(Thread.currentThread().getName());\n\n            // 通知,指定的干活！\n            number = 1;\n            condition1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n\n# 4、8锁的现象\n\n\n# 问题一\n\n1、标准访问，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class A {\n    /**\n     * 多线程的8锁\n     * 1、标准访问，请问先打印邮件还是短信？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone phone = new Phone();\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        //休眠一秒\n        //Thread.sleep(1000);\n        TimeUnit.SECONDS.sleep(1);\n        \n        new Thread(() -> {\n            try {\n                phone.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone {\n    public synchronized void sendEmail(){\n        System.out.println("sendEmail");\n    }\n\n    public synchronized void sendSMS(){\n        System.out.println("sendSMS");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n答案：sendEmail\n\n结论：被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行。\n\n\n# 问题二\n\n2、邮件方法暂停4秒钟，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class B {\n    /**\n     * 多线程的8锁\n     * 2、邮件方法暂停4秒钟，请问先打印邮件还是短信？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone2 phone = new Phone2();\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone2 {\n    public synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n\n    public synchronized void sendSMS(){\n        System.out.println("sendSMS");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n答案：sendEmail\n\n结论：被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行。\n\n\n# 问题三\n\n3、新增一个普通方法hello()不加锁，请问先打印邮件还是hello？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author zhiyuan\n */\npublic class C {\n    /**\n     * 多线程的8锁\n     * 3、新增一个普通方法hello()不加锁，请问先打印邮件还是hello？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone3 phone = new Phone3();\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone.hello();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone3 {\n    public synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n    \n    // 没有 synchronized，没有 static 就是普通方式\n    public void hello() {\n        System.out.println("Hello");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n答案：Hello\n\n结论：如果一个方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。\n\n\n# 问题四\n\n4、两个手机，一个手机发邮件，另一个发短信，请问先执行sendEmail 还是 sendSMS\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class D {\n    /**\n     * 多线程的8锁\n     * 4、两个手机，请问先执行sendEmail 还是 sendSMS\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone4 phone = new Phone4();\n        Phone4 phone2 = new Phone4();\n\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone2.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone4 {\n    public synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n\n    public synchronized void sendSMS() {\n        System.out.println("sendSMS");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n答案：先执行“sendSMS”\n\n结论：被synchronized修饰的方法，锁的对象是方法的调用者。用了两个对象调用各自的方法，所以两个方法的调用者不是同一个，于是两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。\n\n\n# 问题五\n\n5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class E {\n    /**\n     * 多线程的8锁\n     * 5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone5 phone = new Phone5();\n\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone5 {\n    public static synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n\n    public static synchronized void sendSMS() {\n        System.out.println("sendSMS");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n答案：先执行“sendEmail”\n\n结论：被synchronized和static修饰的方法，锁的对象是类的class模板对象，这个则全局唯一！两个方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法。\n\n\n# 问题六\n\n6、两个静态同步方法，2部手机，一个手机发邮件，另一个发短信，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author zhiyuan\n */\npublic class F {\n    /**\n     * 多线程的8锁\n     * 6、两个静态同步方法，2部手机，一个手机发邮件，另一个发短信，请问先打印邮件还是短信？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone6 phone = new Phone6();\n\n        Phone6 phone2 = new Phone6();\n\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone2.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone6 {\n    public static synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n\n    public static synchronized void sendSMS() {\n        System.out.println("sendSMS");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n答案：先输出“sendEmail”\n\n结论：被synchronized和static修饰的方法，锁的对象就是Class模板对象，这个则全局唯一！所以说这里是同一个\n\n\n# 问题七\n\n7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class G {\n    /**\n     * 多线程的8锁\n     * 7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone7 phone = new Phone7();\n\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone7 {\n    public static synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n\n    public synchronized void sendSMS() {\n        System.out.println("sendSMS");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n答案：先执行“sendSMS”\n\n结论：synchronized 锁的是这个调用的对象。被synchronized和static修饰的方法，锁的是这个类的Class模板 。这里是两个锁！\n\n\n# 问题八\n\n8、一个普通同步方法，一个静态同步方法，2部手机，一个发邮件，一个发短信，请问哪个先执行？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author zhiyuan\n */\npublic class H {\n    /**\n     * 多线程的8锁\n     * 8、一个普通同步方法，一个静态同步方法，2部手机，一个发邮件，一个发短信，请问先打印邮件还是短信？\n     */\n    public static void main(String[] args) throws InterruptedException {\n        Phone8 phone = new Phone8();\n        Phone8 phone2 = new Phone8();\n\n        new Thread(() -> {\n            try {\n                phone.sendEmail();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "A").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            try {\n                phone2.sendSMS();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, "B").start();\n\n    }\n}\n\nclass Phone8 {\n    public static synchronized void sendEmail() throws Exception {\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("sendEmail");\n    }\n\n    public synchronized void sendSMS() {\n        System.out.println("sendSMS");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n答案：sendSMS\n\n结论：被synchronized和static修饰的方法，锁的对象是类的class对象。仅被synchronized修饰的方法，锁的对象是方法的调用者。即便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。\n\n\n# 小结\n\n1、new this 调用的这个对象，是一个具体的对象！\n\n2、static class 唯一的一个模板！\n\n一个对象里面如果有多个synchronized方法，某个时刻内，只要一个线程去调用其中一个synchronized 方法了，其他的线程都要等待，换句话说，在某个时刻内，只能有唯一一个线程去访问这些 synchronized方法，锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的 synchronized方法\n\n加个普通方法后发现和同步锁无关，换成两个对象后，不是同一把锁，情况变化\n\n都换成静态同步方法后，情况又变化了。所有的非静态的同步方法用的都是同一把锁（锁的class模板）\n\n具体的表现为以下三种形式：\n\n * 对于普通同步方法，锁的是当前实例对象\n\n * 对于静态同步方法，锁的是当前的Class对象。\n\n * 对于同步方法块，锁是synchronized括号里面的配置对象\n\n当一个线程试图访问同步代码块时，他首先必须得到锁，退出或者是抛出异常时必须释放锁，也就是说 如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可以是别的实例对象非非静态同步方法因为跟该实例对象的非静态同步方法用 的是不同的锁，所以必须等待该实例对象已经获取锁的非静态同步方法释放锁就可以获取他们自己的 锁。\n\n所有的静态同步方法用的也是同一把锁（类对象本身） ，这两把锁的是两个不同的对象，所以静态的同步方法与非静态的同步方法之间是不会有竞争条件的，但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要他们用一个的是同一个类的实例对象。\n\n\n# 5、多线程下集合类的不安全\n\n\n# list\n\n多线程下\n\npublic class ListTest {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        // 对比3个线程 和 30个线程，看区别\n        for (int i = 1; i <= 30; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行报错：java.util.ConcurrentModificationException\n\n导致原因：add 方法没有加锁\n\n解决方案：\n\n/**\n * 换一个集合类\n *  1、List<String> list = new Vector<>(); JDK1.0 就存在了！\n *  2、List<String> list = Collections.synchronizedList(new ArrayList<>());\n *  3、List<String> list = new CopyOnWriteArrayList<>();\n */\npublic class ListTest {\n    public static void main(String[] args) {\n\n        List<String> list = new CopyOnWriteArrayList<>();\n\n        for (int i = 1; i <= 30; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n写入时复制（CopyOnWrite）思想\n\n写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本 （private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。\n\nCopyOnWriteArrayList为什么并发安全且性能比Vector好\n\nVector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。\n\n\n# set\n\n/**\n * 1、Set<String> set = Collections.synchronizedSet(new HashSet<>());\n * 2、Set<String> set = new CopyOnWriteArraySet();\n */\npublic class SetTest {\n    public static void main(String[] args) {\n\n        Set<String> set = new CopyOnWriteArraySet();\n\n        for (int i = 1; i <= 30; i++) {\n            new Thread(() -> {\n                set.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(set);\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# map\n\nhashMap底层是数组+链表+红黑树\n\nMap<String,String> map = new HashMap<>();\n// 等价于\nMap<String,String> map = new HashMap<>(16,0.75);\n// 工作中，常常会自己根据业务来写参数，提高效率\n\n\n1\n2\n3\n4\n\n\nmap不安全测试：\n\npublic class MapSet {\n    public static void main(String[] args) {\n        Map<String, String> map = new HashMap<>();\n\n        for (int i = 1; i <= 30; i++) {\n            new Thread(() -> {\n                map.put(Thread.currentThread().getName(),\n                        UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(map);\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n解决：\n\nMap<String,String> map = new ConcurrentHashMap<>();\n\n\n1\n\n\n\n# 6、Callable\n\n我们已经知道Java中常用的两种线程实现方式：分别是继承Thread类和实现Runnable接口。\n\n\n\n从上图中，我们可以看到，第三种实现Callable接口的线程，而且还带有返回值的。我们来对比下实现Runnable和实现Callable接口的两种方式不同点：\n\n1：需要实现的方法名称不一样：一个run方法，一个call方法\n\n2：返回值不同：一个void无返回值，一个带有返回值的。其中返回值的类型和泛型V是一致的。\n\n3：异常：一个无需抛出异常，一个需要抛出异常。\n\n\n# 基础入门\n\npublic class CallableDemo {\n    public static void main(String[] args) throws Exception {\n        MyThread myThread = new MyThread();\n        FutureTask futureTask = new FutureTask(myThread); // 适配类\n        Thread t1 = new Thread(futureTask, "A"); // 调用执行\n        t1.start();\n        Integer result = (Integer) futureTask.get(); // 获取返回值\n        System.out.println(result);\n    }\n}\n\nclass MyThread implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println("call 被调用");\n        return 1024;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n\n# 多个线程调用\n\npublic class CallableDemo {\n    public static void main(String[] args) throws Exception {\n        MyThread myThread = new MyThread();\n        FutureTask futureTask = new FutureTask(myThread); // 适配类\n\n        new Thread(futureTask, "A").start(); // 调用执行\n        // 第二次调用执行，在同一个futureTask对象，不输出结果，可理解为“缓存”\n        new Thread(futureTask, "B").start(); \n\n        //get 方法获得返回结果! 一般放在最后一行！否则可能会阻塞\n        Integer result = (Integer) futureTask.get(); // 获取返回值\n        System.out.println(result);\n    }\n}\n\nclass MyThread implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + "\\tcall 被调用");\n        TimeUnit.SECONDS.sleep(2);\n        return 1024;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考资料\n\n * https://baijiahao.baidu.com/s?id=1666820818587296272\n\n\n# 7、常用辅助类\n\n\n# CountDownLatch\n\n“倒计时锁存器”\n\n例如，执行完6个线程输出执行完毕\n\npublic class CountDownLatchDemo {\n    public static void main(String[] args) throws InterruptedException {\n        // 计数器\n        CountDownLatch countDownLatch = new CountDownLatch(6);\n        for (int i = 1; i <= 6; i++) {\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + "\\tStart");\n                countDownLatch.countDown(); // 计数器-1\n            }, String.valueOf(i)).start();\n        }\n        //阻塞等待计数器归零\n        countDownLatch.await();\n        System.out.println(Thread.currentThread().getName() + "\\tEnd");\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nCountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这些线程会阻塞\n\n其他线程调用CountDown()方法会将计数器减1（调用CountDown方法的线程不会阻塞）\n\n当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行\n\n\n# CyclicBarrier\n\n翻译：CyclicBarrier 篱栅\n\n作用：和上面的减法相反，这里是加法，好比集齐7个龙珠召唤神龙，或者人到齐了再开会！\n\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        // CyclicBarrier(int parties, Runnable barrierAction)\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {\n            System.out.println("召唤神龙成功");\n        });\n\n        for (int i = 1; i <= 7; i++) {\n            final int tempInt = i;\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \n                        "收集了第" + tempInt + "颗龙珠");\n\n                try {\n                    cyclicBarrier.await(); // 等待\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Semaphore\n\n翻译：Semaphore 信号量;信号灯;信号\n\n举个“抢车位”的例子\n\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        // 模拟资源类，有3个空车位\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 1; i <= 6; i++) { // 模拟6个车\n            new Thread(() -> {\n                try {\n                    semaphore.acquire(); // acquire 得到\n                    System.out.println(Thread.currentThread().getName() + " 抢到了车位");\n                    TimeUnit.SECONDS.sleep(3); // 停3秒钟\n                    System.out.println(Thread.currentThread().getName() + " 离开了车位");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release(); // 释放这个位置\n                }\n            }, String.valueOf(i)).start();\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在信号量上我们定义两种操作：\n\n * acquire（获取）\n   \n   当一个线程调用 acquire 操作时，他要么通过成功获取信号量（信号量-1）\n   \n   要么一直等下去，直到有线程释放信号量，或超时\n\n * release （释放）\n   \n   会将信号量的值 + 1，然后唤醒等待的线程\n\n信号量主要用于两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\n\n# 8、读写锁\n\nReadWriteLock\n\n独占锁（写锁）：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁。\n\n共享锁（读锁）：该锁可被多个线程所持有。\n\n对于ReentrantReadWriteLock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的。\n\npublic class ReadWriteLockDemo {\n    /**\n     * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。\n     * 但是，如果有一个线程想去写共享资源，就不应该再有其他线程可以对该资源进行读或写。\n     * 1. 读-读 可以共存\n     * 2. 读-写 不能共存\n     * 3. 写-写 不能共存\n     */\n    public static void main(String[] args) {\n        MyCacheLock myCache = new MyCacheLock();\n        // 写\n        for (int i = 1; i <= 5; i++) {\n            final int tempInt = i;\n            new Thread(() -> {\n                myCache.put(tempInt + "", tempInt + "");\n            }, String.valueOf(i)).start();\n        }\n\n        // 读\n        for (int i = 1; i <= 5; i++) {\n            final int tempInt = i;\n            new Thread(() -> {\n                myCache.get(tempInt + "");\n            }, String.valueOf(i)).start();\n        }\n    }\n\n}\n\n// 测试发现问题: 写入的时候，还没写入完成，会存在其他的写入！造成问题\nclass MyCache {\n    private volatile Map<String, Object> map = new HashMap<>();\n\n    public void put(String key, Object value) {\n        System.out.println(Thread.currentThread().getName() + " 写入" + key);\n        map.put(key, value);\n        System.out.println(Thread.currentThread().getName() + " 写入成功!");\n    }\n\n    public void get(String key) {\n        System.out.println(Thread.currentThread().getName() + " 读取" + key);\n        Object result = map.get(key);\n        System.out.println(Thread.currentThread().getName() + " 读取结果：" + result);\n    }\n}\n\n// 加锁\nclass MyCacheLock {\n    private volatile Map<String, Object> map = new HashMap<>();\n    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 读写锁\n\n    public void put(String key, Object value) {\n        // 写锁\n        readWriteLock.writeLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + " 写入" + key);\n            map.put(key, value);\n            System.out.println(Thread.currentThread().getName() + " 写入成功!");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //解锁\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void get(String key) {\n        // 读锁\n        readWriteLock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + " 读取" + key);\n            Object result = map.get(key);\n            System.out.println(Thread.currentThread().getName() + " 读取结果：" + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n\n# 9、阻塞队列\n\nInterface  BlockingQueue<E>\n\n\n1\n\n\n\n# 阻塞队列简介\n\n阻塞：必须要阻塞、不得不阻塞\n\n阻塞队列是一个队列，在数据结构中起的作用如下图：\n\n\n\n当队列是空的，从队列中获取元素的操作将会被阻塞。\n\n当队列是满的，从队列中添加元素的操作将会被阻塞。\n\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。\n\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。\n\n\n# 阻塞队列的用处\n\n在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自 动被唤起。\n\n为什么需要 BlockingQueue？\n\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都 给你一手包办了。\n\n在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。\n\n\n# 接口架构图\n\n\n\n * ArrayBlockingQueue\n   \n   由数组结构组成的有界阻塞队列。\n\n * LinkedBlockingQueue\n   \n   由链表结构组成的有界（默认值为：integer.MAX_VALUE）阻塞队列。\n\n * PriorityBlockingQueue\n   \n   支持优先级排序的无界阻塞队列\n\n * DelayQueue\n   \n   使用优先级队列实现的延迟无界阻塞队列。\n\n * SynchronousQueue\n   \n   不存储元素的阻塞队列，也即单个元素的队列。\n\n * LinkedTransferQueue\n   \n   由链表组成的无界阻塞队列\n\n * LinkedBlockingDeque\n   \n   由链表组成的双向阻塞队列。\n\n\n# API的使用\n\n方法\\处理方式   抛出异常        返回特殊值      一直阻塞     超时退出\n插入方法      add(e)      offer(e)   put(e)   offer(e,time,unit)\n移除方法      remove()    poll()     take()   poll(time,unit)\n检查方法      element()   peek()     不可用      不可用\n\n解释：\n\n * 抛出异常\n\n当阻塞队列满时，再往队列里add插入元素会抛出 IllegalStateException: Queue full\n\n当阻塞队列空时，再往队列里remove移除元素会抛 NoSuchElementException`\n\n * 返回特殊值\n\n插入方法，成功返回true，失败则false\n\n移除方法，成功返回队列元素，队列里没有则返回null\n\n * 一直阻塞\n\n当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或响应中断退出\n\n当阻塞队列空时，消费者线程从队列里take元素，队列会一直阻塞消费者线程直到队列可用\n\n * 超时退出\n\n当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出\n\n抛出异常\n\npackage com.oddfar.bq;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\n/**\n * @author zhiyuan\n */\npublic class BlockingQueueDemo {\n\n    public static void main(String[] args) {\n        // 队列大小\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n        System.out.println(blockingQueue.add("a"));\n        System.out.println(blockingQueue.add("b"));\n        System.out.println(blockingQueue.add("c"));\n\n        //java.lang.IllegalStateException: Queue full\n//        System.out.println(blockingQueue.add("d"));\n\n        System.out.println("首元素：" + blockingQueue.element()); // 检测队列队首元素！\n        // public E remove() 返回值E，就是移除的值\n        System.out.println(blockingQueue.remove()); //a\n        System.out.println(blockingQueue.remove()); //b\n        System.out.println(blockingQueue.remove()); //c\n        // java.util.NoSuchElementException\n//        System.out.println(blockingQueue.remove());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n返回特殊值\n\npublic class BlockingQueueDemo2 {\n    public static void main(String[] args) {\n        // 队列大小\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n\n        System.out.println(blockingQueue.offer("a")); // true\n        System.out.println(blockingQueue.offer("b")); // true\n        System.out.println(blockingQueue.offer("c")); // true\n        //System.out.println(blockingQueue.offer("d")); // false\n\n        System.out.println("首元素：" + blockingQueue.peek()); // 检测队列队首元素！\n\n        // public E poll()\n        System.out.println(blockingQueue.poll()); // a\n        System.out.println(blockingQueue.poll()); // b\n        System.out.println(blockingQueue.poll()); // c\n        System.out.println(blockingQueue.poll()); // null\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n一直阻塞\n\npublic class BlockingQueueDemo3 {\n    public static void main(String[] args) throws InterruptedException {\n        // 队列大小\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n\n        // 一直阻塞\n        blockingQueue.put("a");\n        blockingQueue.put("b");\n        blockingQueue.put("c");\n//         blockingQueue.put("d");\n        System.out.println(blockingQueue.take()); // a\n        System.out.println(blockingQueue.take()); // b\n        System.out.println(blockingQueue.take()); // c\n        System.out.println(blockingQueue.take()); // 阻塞不停止等待\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n超时退出\n\npublic class BlockingQueueDemo4 {\n    public static void main(String[] args) throws InterruptedException {\n        // 队列大小\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n\n        // 一直阻塞\n        blockingQueue.put("a");\n        blockingQueue.put("b");\n        blockingQueue.put("c");\n        blockingQueue.offer("d",2L, TimeUnit.SECONDS); // 等待2秒超时退出\n\n        System.out.println(blockingQueue.take()); // a\n        System.out.println(blockingQueue.take()); // b\n        System.out.println(blockingQueue.take()); // c\n        System.out.println(blockingQueue.take()); // 阻塞不停止等待\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:' * 1、简介\n   * 什么是juc\n   * 进程和线程\n * 2、lock锁\n   * synchronized锁\n   * lock 锁\n   * 区别\n * 3、生产者和消费者\n   * synchroinzed\n   * lock\n   * 按照线程顺序执行\n * 4、8锁的现象\n   * 问题一\n   * 问题二\n   * 问题三\n   * 问题四\n   * 问题五\n   * 问题六\n   * 问题七\n   * 问题八\n   * 小结\n * 5、多线程下集合类的不安全\n   * list\n   * set\n   * map\n * 6、callable\n   * 基础入门\n   * 多个线程调用\n   * 参考资料\n * 7、常用辅助类\n   * countdownlatch\n   * cyclicbarrier\n   * semaphore\n * 8、读写锁\n * 9、阻塞队列\n   * 阻塞队列简介\n   * 阻塞队列的用处\n   * 接口架构图\n   * api的使用\n\n\n\n狂神juc视频教程：https://www.bilibili.com/video/bv1b7411l7te\n\n\n# 1、简介\n\n\n# 什么是juc\n\njuc是java.util.concurrent 的简写，在并发编程中使用的工具类。\n\n在jdk官方手册中可以看到juc相关的jar包有三个。\n\n用中文概括一下，juc的意思就是java并发编程工具包\n\n实现多线程有三种方式：thread、runnable、callable，其中callable就位于concurrent包下\n\n\n# 进程和线程\n\n> 进程 / 线程是什么？\n\n进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。\n\n线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。\n\n白话：\n\n进程：就是操作系统中运行的一个程序，qq.exe，music.exe，word.exe ，这就是多个进程\n\n线程：每个进程中都存在一个或者多个线程，比如用word写文章时，就会有一个线程默默帮你定时自动保存。\n\n> 并发 / 并行是什么？\n\n做并发编程之前，必须首先理解什么是并发，什么是并行。\n\n并发和并行是两个非常容易混淆的概念。它们都可以表示两个或多个任务一起执行，但是偏重点有点不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。然而并行的偏重点在于”同时执行”。\n\n严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会运行任务一,一会儿又运行任务二，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务是串行并发的，也会造成是多个任务并行执行的错觉。\n\n实际上，如果系统内只有一个cpu，而现在而使用多线程或者多线程任务，那么真实环境中这些任务不可能真实并行的，毕竟一个cpu一次只能执行一条指令，这种情况下多线程或者多线程任务就是并发的，而不是并行，操作系统会不停的切换任务。真正的并发也只能够出现在拥有多个cpu的系统中（多核cpu）。\n\n并发的动机：在计算能力恒定的情况下处理更多的任务, 就像我们的大脑, 计算能力相对恒定, 要在一天中处理更多的问题, 我们就必须具备多任务的能力. 现实工作中有很多事情可能会中断你的当前任务, 处理这种多任务的能力就是你的并发能力。\n\n并行的动机：用更多的cpu核心更快的完成任务. 就像一个团队, 一个脑袋不够用了, 一个团队来一起处理 一个任务。\n\n例子： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 （不一定是 同时的） 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。\n\n> 线程的状态\n\njava的线程有6种状态：可以分析源码：\n\npublic enum state {\n    //线程刚创建\n    new,\n    \n    //在jvm中正在运行的线程\n    runnable,\n    \n    //线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行\n    blocked,\n    \n    //等待状态\n    waiting,\n    \n    //调用sleep() join() wait()方法可能导致线程处于等待状态\n    timed_waiting,\n    \n    //线程执行完毕，已经退出\n    terminated;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n> wait / sleep 的区别\n\n1、来自不同的类\n\n这两个方法来自不同的类分别是，sleep来自thread类，和wait来自object类。\n\nsleep是thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。\n\n2、有没有释放锁(释放资源)\n\n最主要是sleep方法没有释放锁\n\n而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\n\nsleep是线程被调用时，占着cpu去睡觉，其他线程不能占用cpu，os认为该线程正在工作，不会让出系统资源，wait是进入等待池等待，让出系统资源，其他线程可以占用cpu。\n\nsleep(100l)是占用cpu，线程休眠100毫秒，其他进程不能再占用cpu资源，wait（100l）是进入等待池中等待，交出cpu等系统资源供其他进程使用，在这100毫秒中，该线程可以被其他线程notify，但不同的是其他在等待池中的线程不被notify不会出来，但这个线程在等待100毫秒后会自动进入就绪队列等待系统分配资源，换句话说，sleep（100）在100毫秒后肯定会运行，但wait在100毫秒后还有等待os调用分配资源，所以wait100的停止运行时间是不确定的，但至少是100毫秒。 就是说sleep有时间限制的就像闹钟一样到时候就叫了，而wait是无限期的除非用户主动notify。\n\n3、使用范围不同\n\nwait，notify和notifyall只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n\nsynchronized(x){\n    //或者wait()\n    x.notify()\n}\n\n\n1\n2\n3\n4\n\n\n4、是否需要捕获异常\n\nsleep必须捕获异常，而wait，notify和notifyall不需要捕获异常\n\n\n# 2、lock锁\n\n\n# synchronized锁\n\npublic class saletickettest1 {\n    /*\n     * 题目：三个售票员 卖出 30张票\n     * 多线程编程的企业级套路：\n     * 1. 在高内聚低耦合的前提下， 线程 操作(对外暴露的调用方法) 资源类\n     */\n\n    public static void main(string[] args) {\n        ticket ticket = new ticket();\n\n        new thread(new runnable() {\n            @override\n            public void run() {\n                for (int i = 1; i <= 40; i++) {\n                    ticket.saleticket();\n                }\n            }\n        }, "a").start();\n\n        new thread(new runnable() {\n            @override\n            public void run() {\n                for (int i = 1; i <=40; i++) {\n                    ticket.saleticket();\n                }\n            }\n        }, "b").start();\n\n        new thread(new runnable() {\n            @override\n            public void run() {\n                for (int i = 1; i <= 40; i++) {\n                    ticket.saleticket();\n                }\n            }\n        }, "c").start();\n\n    }\n    \n}\n\nclass ticket { // 资源类\n    private int number = 30;\n\n    public synchronized void saleticket() {\n        if (number > 0) {\n            system.out.println(thread.currentthread().getname() + "卖出第 " + (number--) + "票,还剩下:" + number);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# lock 锁\n\npublic class saletickettest2 {\n    public static void main(string[] args) {\n        ticket2 ticket2 = new ticket2();\n\n        new thread(() -> {\n            for (int i = 1; i <= 40; i++) {\n                ticket2.saleticket();\n            }\n        }, "a").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 40; i++) {\n                ticket2.saleticket();\n            }\n        }, "b").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 40; i++) {\n                ticket2.saleticket();\n            }\n        }, "c").start();\n\n    }\n}\n\nclass ticket2 { // 资源类\n    private lock lock = new reentrantlock();\n\n    private int number = 30;\n\n    public void saleticket() {\n        lock.lock();\n\n        try {\n            if (number > 0) {\n                system.out.println(thread.currentthread().getname() + "卖出第 " + (number--) + "票,还剩下:" + number);\n            }\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 区别\n\n 1. 首先synchronized是java内置关键字，在jvm层面，lock是个java类；\n 2. synchronized无法判断是否获取锁的状态，lock可以判断是否获取到锁；\n 3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放 锁)，lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n 4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1 阻塞，线程2则会一直等待下去，而lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以 不用一直等待就结束了；\n 5. synchronized的锁可重入、不可中断、非公平，而lock锁可重入、可判断、可公平（两者皆可）\n 6. lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n\n# 3、生产者和消费者\n\n\n# synchroinzed\n\n生产者和消费者 synchroinzed 版\n\npublic class producerconsumer {\n    /**\n     * 题目：现在两个线程，可以操作初始值为0的一个变量\n     * 实现一个线程对该变量 + 1，一个线程对该变量 -1\n     * 实现交替10次\n     * <p>\n     * 诀窍：\n     * 1. 高内聚低耦合的前提下，线程操作资源类\n     * 2. 判断 、干活、通知\n     */\n\n    public static void main(string[] args) {\n        data data = new data();\n\n        //a线程增加\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "a").start();\n\n        //b线程减少\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "b").start();\n    }\n}\n\nclass data {\n    private int number = 0;\n\n    public synchronized void increment() throws interruptedexception {\n        // 判断该不该这个线程做\n        if (number != 0) {\n            this.wait();\n        }\n        // 干活\n        number++;\n        system.out.println(thread.currentthread().getname() + "\\t" + number);\n        // 通知\n        this.notifyall();\n    }\n\n    public synchronized void decrement() throws interruptedexception {\n        // 判断该不该这个线程做\n        if (number == 0) {\n            this.wait();\n        }\n        // 干活\n        number--;\n        system.out.println(thread.currentthread().getname() + "\\t" + number);\n        // 通知\n        this.notifyall();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n问题升级：防止虚假唤醒，4个线程，两个加，两个减\n\n【重点】if 和 while\n\npublic class producerconsumerplus {\n    /**\n     * 题目：现在四个线程，可以操作初始值为0的一个变量\n     * 实现两个线程对该变量 + 1，两个线程对该变量 -1\n     * 实现交替10次\n     *\n     * 诀窍：\n     * 1. 高内聚低耦合的前提下，线程操作资源类\n     * 2. 判断 、干活、通知\n     * 3. 多线程交互中，必须要防止多线程的虚假唤醒，即（判断不能用if，只能用while）\n     */\n\n    public static void main(string[] args) {\n        data2 data = new data2();\n\n        //a线程增加\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "a").start();\n\n        //b线程减少\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "b").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "c").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "d").start();\n    }\n}\n\nclass data2 {\n    private int number = 0;\n\n    public synchronized void increment() throws interruptedexception {\n        // 判断该不该这个线程做\n        while (number != 0) {\n            this.wait();\n        }\n        // 干活\n        number++;\n        system.out.println(thread.currentthread().getname() + "\\t" + number);\n        // 通知\n        this.notifyall();\n    }\n\n    public synchronized void decrement() throws interruptedexception {\n        // 判断该不该这个线程做\n        while (number == 0) {\n            this.wait();\n        }\n        // 干活\n        number--;\n        system.out.println(thread.currentthread().getname() + "\\t" + number);\n        // 通知\n        this.notifyall();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n\n# lock\n\npublic class producerconsumerplus {\n    /**\n     * 题目：现在四个线程，可以操作初始值为0的一个变量\n     * 实现两个线程对该变量 + 1，两个线程对该变量 -1\n     * 实现交替10次\n     * <p>\n     * 诀窍：\n     * 1. 高内聚低耦合的前提下，线程操作资源类\n     * 2. 判断 、干活、通知\n     * 3. 多线程交互中，必须要防止多线程的虚假唤醒，即（判断不能用if，只能用while）\n     */\n\n    public static void main(string[] args) {\n        data2 data = new data2();\n\n        //a线程增加\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "a").start();\n\n        //b线程减少\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "b").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.increment();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "c").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                try {\n                    data.decrement();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }, "d").start();\n    }\n}\n\nclass data2 {\n    private int number = 0;\n    private lock lock = new reentrantlock();\n    private condition condition = lock.newcondition();\n\n    public void increment() throws interruptedexception {\n\n        lock.lock();\n        try {\n            // 判断该不该这个线程做\n            while (number != 0) {\n                condition.await();\n            }\n            // 干活\n            number++;\n            system.out.println(thread.currentthread().getname() + "\\t" + number);\n            // 通知\n            condition.signalall();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void decrement() throws interruptedexception {\n        lock.lock();\n        try {\n            // 判断该不该这个线程做\n            while (number == 0) {\n                condition.await();\n            }\n            // 干活\n            number--;\n            system.out.println(thread.currentthread().getname() + "\\t" + number);\n            // 通知\n            condition.signalall();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n\n\n以上写的程序并不会按照abcd线程顺序，只会按照 “生产” “消费”顺序\n\n\n# 按照线程顺序执行\n\n精确通知顺序访问\n\npublic class c {\n    /**\n     * 题目：多线程之间按顺序调用，实现 a->b->c\n     * 重点：标志位\n     */\n\n    public static void main(string[] args) {\n        resources resources = new resources();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                resources.a();\n            }\n\n        }, "a").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                resources.b();\n            }\n\n        }, "b").start();\n\n        new thread(() -> {\n            for (int i = 1; i <= 10; i++) {\n                resources.c();\n            }\n\n        }, "c").start();\n\n    }\n}\n\nclass resources {\n    private int number = 1; // 1a 2b 3c\n    private lock lock = new reentrantlock();\n    private condition condition1 = lock.newcondition();\n    private condition condition2 = lock.newcondition();\n    private condition condition3 = lock.newcondition();\n\n    public void a() {\n        lock.lock();\n        try {\n            // 判断\n            while (number != 1) {\n                condition1.await();\n            }\n            // 干活\n            system.out.println(thread.currentthread().getname());\n            // 通知,指定的干活！\n            number = 2;\n            condition2.signal();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void b() {\n        lock.lock();\n        try {\n            // 判断\n            while (number != 2) {\n                condition2.await();\n            }\n            // 干活\n            system.out.println(thread.currentthread().getname() );\n\n            // 通知,指定的干活！\n            number = 3;\n            condition3.signal();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void c() {\n        lock.lock();\n        try {\n            // 判断\n            while (number != 3) {\n                condition3.await();\n            }\n            // 干活\n            system.out.println(thread.currentthread().getname());\n\n            // 通知,指定的干活！\n            number = 1;\n            condition1.signal();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n\n# 4、8锁的现象\n\n\n# 问题一\n\n1、标准访问，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\npublic class a {\n    /**\n     * 多线程的8锁\n     * 1、标准访问，请问先打印邮件还是短信？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone phone = new phone();\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        //休眠一秒\n        //thread.sleep(1000);\n        timeunit.seconds.sleep(1);\n        \n        new thread(() -> {\n            try {\n                phone.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone {\n    public synchronized void sendemail(){\n        system.out.println("sendemail");\n    }\n\n    public synchronized void sendsms(){\n        system.out.println("sendsms");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n答案：sendemail\n\n结论：被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行。\n\n\n# 问题二\n\n2、邮件方法暂停4秒钟，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\npublic class b {\n    /**\n     * 多线程的8锁\n     * 2、邮件方法暂停4秒钟，请问先打印邮件还是短信？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone2 phone = new phone2();\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone2 {\n    public synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n\n    public synchronized void sendsms(){\n        system.out.println("sendsms");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n答案：sendemail\n\n结论：被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行。\n\n\n# 问题三\n\n3、新增一个普通方法hello()不加锁，请问先打印邮件还是hello？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * @author zhiyuan\n */\npublic class c {\n    /**\n     * 多线程的8锁\n     * 3、新增一个普通方法hello()不加锁，请问先打印邮件还是hello？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone3 phone = new phone3();\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone.hello();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone3 {\n    public synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n    \n    // 没有 synchronized，没有 static 就是普通方式\n    public void hello() {\n        system.out.println("hello");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n答案：hello\n\n结论：如果一个方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。\n\n\n# 问题四\n\n4、两个手机，一个手机发邮件，另一个发短信，请问先执行sendemail 还是 sendsms\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\npublic class d {\n    /**\n     * 多线程的8锁\n     * 4、两个手机，请问先执行sendemail 还是 sendsms\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone4 phone = new phone4();\n        phone4 phone2 = new phone4();\n\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone2.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone4 {\n    public synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n\n    public synchronized void sendsms() {\n        system.out.println("sendsms");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n答案：先执行“sendsms”\n\n结论：被synchronized修饰的方法，锁的对象是方法的调用者。用了两个对象调用各自的方法，所以两个方法的调用者不是同一个，于是两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。\n\n\n# 问题五\n\n5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\npublic class e {\n    /**\n     * 多线程的8锁\n     * 5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone5 phone = new phone5();\n\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone5 {\n    public static synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n\n    public static synchronized void sendsms() {\n        system.out.println("sendsms");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n答案：先执行“sendemail”\n\n结论：被synchronized和static修饰的方法，锁的对象是类的class模板对象，这个则全局唯一！两个方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法。\n\n\n# 问题六\n\n6、两个静态同步方法，2部手机，一个手机发邮件，另一个发短信，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * @author zhiyuan\n */\npublic class f {\n    /**\n     * 多线程的8锁\n     * 6、两个静态同步方法，2部手机，一个手机发邮件，另一个发短信，请问先打印邮件还是短信？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone6 phone = new phone6();\n\n        phone6 phone2 = new phone6();\n\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone2.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone6 {\n    public static synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n\n    public static synchronized void sendsms() {\n        system.out.println("sendsms");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n答案：先输出“sendemail”\n\n结论：被synchronized和static修饰的方法，锁的对象就是class模板对象，这个则全局唯一！所以说这里是同一个\n\n\n# 问题七\n\n7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\npublic class g {\n    /**\n     * 多线程的8锁\n     * 7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone7 phone = new phone7();\n\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone7 {\n    public static synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n\n    public synchronized void sendsms() {\n        system.out.println("sendsms");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n答案：先执行“sendsms”\n\n结论：synchronized 锁的是这个调用的对象。被synchronized和static修饰的方法，锁的是这个类的class模板 。这里是两个锁！\n\n\n# 问题八\n\n8、一个普通同步方法，一个静态同步方法，2部手机，一个发邮件，一个发短信，请问哪个先执行？\n\npackage com.oddfar.lock8;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * @author zhiyuan\n */\npublic class h {\n    /**\n     * 多线程的8锁\n     * 8、一个普通同步方法，一个静态同步方法，2部手机，一个发邮件，一个发短信，请问先打印邮件还是短信？\n     */\n    public static void main(string[] args) throws interruptedexception {\n        phone8 phone = new phone8();\n        phone8 phone2 = new phone8();\n\n        new thread(() -> {\n            try {\n                phone.sendemail();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "a").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            try {\n                phone2.sendsms();\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n        }, "b").start();\n\n    }\n}\n\nclass phone8 {\n    public static synchronized void sendemail() throws exception {\n        timeunit.seconds.sleep(4);\n        system.out.println("sendemail");\n    }\n\n    public synchronized void sendsms() {\n        system.out.println("sendsms");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n答案：sendsms\n\n结论：被synchronized和static修饰的方法，锁的对象是类的class对象。仅被synchronized修饰的方法，锁的对象是方法的调用者。即便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。\n\n\n# 小结\n\n1、new this 调用的这个对象，是一个具体的对象！\n\n2、static class 唯一的一个模板！\n\n一个对象里面如果有多个synchronized方法，某个时刻内，只要一个线程去调用其中一个synchronized 方法了，其他的线程都要等待，换句话说，在某个时刻内，只能有唯一一个线程去访问这些 synchronized方法，锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的 synchronized方法\n\n加个普通方法后发现和同步锁无关，换成两个对象后，不是同一把锁，情况变化\n\n都换成静态同步方法后，情况又变化了。所有的非静态的同步方法用的都是同一把锁（锁的class模板）\n\n具体的表现为以下三种形式：\n\n * 对于普通同步方法，锁的是当前实例对象\n\n * 对于静态同步方法，锁的是当前的class对象。\n\n * 对于同步方法块，锁是synchronized括号里面的配置对象\n\n当一个线程试图访问同步代码块时，他首先必须得到锁，退出或者是抛出异常时必须释放锁，也就是说 如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可以是别的实例对象非非静态同步方法因为跟该实例对象的非静态同步方法用 的是不同的锁，所以必须等待该实例对象已经获取锁的非静态同步方法释放锁就可以获取他们自己的 锁。\n\n所有的静态同步方法用的也是同一把锁（类对象本身） ，这两把锁的是两个不同的对象，所以静态的同步方法与非静态的同步方法之间是不会有竞争条件的，但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要他们用一个的是同一个类的实例对象。\n\n\n# 5、多线程下集合类的不安全\n\n\n# list\n\n多线程下\n\npublic class listtest {\n    public static void main(string[] args) {\n        list<string> list = new arraylist<>();\n        // 对比3个线程 和 30个线程，看区别\n        for (int i = 1; i <= 30; i++) {\n            new thread(() -> {\n                list.add(uuid.randomuuid().tostring().substring(0, 8));\n                system.out.println(list);\n            }, string.valueof(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行报错：java.util.concurrentmodificationexception\n\n导致原因：add 方法没有加锁\n\n解决方案：\n\n/**\n * 换一个集合类\n *  1、list<string> list = new vector<>(); jdk1.0 就存在了！\n *  2、list<string> list = collections.synchronizedlist(new arraylist<>());\n *  3、list<string> list = new copyonwritearraylist<>();\n */\npublic class listtest {\n    public static void main(string[] args) {\n\n        list<string> list = new copyonwritearraylist<>();\n\n        for (int i = 1; i <= 30; i++) {\n            new thread(() -> {\n                list.add(uuid.randomuuid().tostring().substring(0, 8));\n                system.out.println(list);\n            }, string.valueof(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n写入时复制（copyonwrite）思想\n\n写入时复制（copyonwrite，简称cow）思想是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本 （private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。\n\ncopyonwritearraylist为什么并发安全且性能比vector好\n\nvector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而copyonwritearraylist 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于vector，copyonwritearraylist支持读多写少的并发情况。\n\n\n# set\n\n/**\n * 1、set<string> set = collections.synchronizedset(new hashset<>());\n * 2、set<string> set = new copyonwritearrayset();\n */\npublic class settest {\n    public static void main(string[] args) {\n\n        set<string> set = new copyonwritearrayset();\n\n        for (int i = 1; i <= 30; i++) {\n            new thread(() -> {\n                set.add(uuid.randomuuid().tostring().substring(0, 8));\n                system.out.println(set);\n            }, string.valueof(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# map\n\nhashmap底层是数组+链表+红黑树\n\nmap<string,string> map = new hashmap<>();\n// 等价于\nmap<string,string> map = new hashmap<>(16,0.75);\n// 工作中，常常会自己根据业务来写参数，提高效率\n\n\n1\n2\n3\n4\n\n\nmap不安全测试：\n\npublic class mapset {\n    public static void main(string[] args) {\n        map<string, string> map = new hashmap<>();\n\n        for (int i = 1; i <= 30; i++) {\n            new thread(() -> {\n                map.put(thread.currentthread().getname(),\n                        uuid.randomuuid().tostring().substring(0, 8));\n                system.out.println(map);\n            }, string.valueof(i)).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n解决：\n\nmap<string,string> map = new concurrenthashmap<>();\n\n\n1\n\n\n\n# 6、callable\n\n我们已经知道java中常用的两种线程实现方式：分别是继承thread类和实现runnable接口。\n\n\n\n从上图中，我们可以看到，第三种实现callable接口的线程，而且还带有返回值的。我们来对比下实现runnable和实现callable接口的两种方式不同点：\n\n1：需要实现的方法名称不一样：一个run方法，一个call方法\n\n2：返回值不同：一个void无返回值，一个带有返回值的。其中返回值的类型和泛型v是一致的。\n\n3：异常：一个无需抛出异常，一个需要抛出异常。\n\n\n# 基础入门\n\npublic class callabledemo {\n    public static void main(string[] args) throws exception {\n        mythread mythread = new mythread();\n        futuretask futuretask = new futuretask(mythread); // 适配类\n        thread t1 = new thread(futuretask, "a"); // 调用执行\n        t1.start();\n        integer result = (integer) futuretask.get(); // 获取返回值\n        system.out.println(result);\n    }\n}\n\nclass mythread implements callable<integer> {\n    @override\n    public integer call() throws exception {\n        system.out.println("call 被调用");\n        return 1024;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n\n# 多个线程调用\n\npublic class callabledemo {\n    public static void main(string[] args) throws exception {\n        mythread mythread = new mythread();\n        futuretask futuretask = new futuretask(mythread); // 适配类\n\n        new thread(futuretask, "a").start(); // 调用执行\n        // 第二次调用执行，在同一个futuretask对象，不输出结果，可理解为“缓存”\n        new thread(futuretask, "b").start(); \n\n        //get 方法获得返回结果! 一般放在最后一行！否则可能会阻塞\n        integer result = (integer) futuretask.get(); // 获取返回值\n        system.out.println(result);\n    }\n}\n\nclass mythread implements callable<integer> {\n    @override\n    public integer call() throws exception {\n        system.out.println(thread.currentthread().getname() + "\\tcall 被调用");\n        timeunit.seconds.sleep(2);\n        return 1024;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考资料\n\n * https://baijiahao.baidu.com/s?id=1666820818587296272\n\n\n# 7、常用辅助类\n\n\n# countdownlatch\n\n“倒计时锁存器”\n\n例如，执行完6个线程输出执行完毕\n\npublic class countdownlatchdemo {\n    public static void main(string[] args) throws interruptedexception {\n        // 计数器\n        countdownlatch countdownlatch = new countdownlatch(6);\n        for (int i = 1; i <= 6; i++) {\n            new thread(() -> {\n                system.out.println(thread.currentthread().getname() + "\\tstart");\n                countdownlatch.countdown(); // 计数器-1\n            }, string.valueof(i)).start();\n        }\n        //阻塞等待计数器归零\n        countdownlatch.await();\n        system.out.println(thread.currentthread().getname() + "\\tend");\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ncountdownlatch 主要有两个方法，当一个或多个线程调用 await 方法时，这些线程会阻塞\n\n其他线程调用countdown()方法会将计数器减1（调用countdown方法的线程不会阻塞）\n\n当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行\n\n\n# cyclicbarrier\n\n翻译：cyclicbarrier 篱栅\n\n作用：和上面的减法相反，这里是加法，好比集齐7个龙珠召唤神龙，或者人到齐了再开会！\n\npublic class cyclicbarrierdemo {\n    public static void main(string[] args) {\n        // cyclicbarrier(int parties, runnable barrieraction)\n        cyclicbarrier cyclicbarrier = new cyclicbarrier(7, () -> {\n            system.out.println("召唤神龙成功");\n        });\n\n        for (int i = 1; i <= 7; i++) {\n            final int tempint = i;\n            new thread(() -> {\n                system.out.println(thread.currentthread().getname() + \n                        "收集了第" + tempint + "颗龙珠");\n\n                try {\n                    cyclicbarrier.await(); // 等待\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } catch (brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# semaphore\n\n翻译：semaphore 信号量;信号灯;信号\n\n举个“抢车位”的例子\n\npublic class semaphoredemo {\n    public static void main(string[] args) {\n        // 模拟资源类，有3个空车位\n        semaphore semaphore = new semaphore(3);\n        for (int i = 1; i <= 6; i++) { // 模拟6个车\n            new thread(() -> {\n                try {\n                    semaphore.acquire(); // acquire 得到\n                    system.out.println(thread.currentthread().getname() + " 抢到了车位");\n                    timeunit.seconds.sleep(3); // 停3秒钟\n                    system.out.println(thread.currentthread().getname() + " 离开了车位");\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } finally {\n                    semaphore.release(); // 释放这个位置\n                }\n            }, string.valueof(i)).start();\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在信号量上我们定义两种操作：\n\n * acquire（获取）\n   \n   当一个线程调用 acquire 操作时，他要么通过成功获取信号量（信号量-1）\n   \n   要么一直等下去，直到有线程释放信号量，或超时\n\n * release （释放）\n   \n   会将信号量的值 + 1，然后唤醒等待的线程\n\n信号量主要用于两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\n\n# 8、读写锁\n\nreadwritelock\n\n独占锁（写锁）：指该锁一次只能被一个线程锁持有。对于reentranrlock和 synchronized 而言都是独占锁。\n\n共享锁（读锁）：该锁可被多个线程所持有。\n\n对于reentrantreadwritelock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的。\n\npublic class readwritelockdemo {\n    /**\n     * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。\n     * 但是，如果有一个线程想去写共享资源，就不应该再有其他线程可以对该资源进行读或写。\n     * 1. 读-读 可以共存\n     * 2. 读-写 不能共存\n     * 3. 写-写 不能共存\n     */\n    public static void main(string[] args) {\n        mycachelock mycache = new mycachelock();\n        // 写\n        for (int i = 1; i <= 5; i++) {\n            final int tempint = i;\n            new thread(() -> {\n                mycache.put(tempint + "", tempint + "");\n            }, string.valueof(i)).start();\n        }\n\n        // 读\n        for (int i = 1; i <= 5; i++) {\n            final int tempint = i;\n            new thread(() -> {\n                mycache.get(tempint + "");\n            }, string.valueof(i)).start();\n        }\n    }\n\n}\n\n// 测试发现问题: 写入的时候，还没写入完成，会存在其他的写入！造成问题\nclass mycache {\n    private volatile map<string, object> map = new hashmap<>();\n\n    public void put(string key, object value) {\n        system.out.println(thread.currentthread().getname() + " 写入" + key);\n        map.put(key, value);\n        system.out.println(thread.currentthread().getname() + " 写入成功!");\n    }\n\n    public void get(string key) {\n        system.out.println(thread.currentthread().getname() + " 读取" + key);\n        object result = map.get(key);\n        system.out.println(thread.currentthread().getname() + " 读取结果：" + result);\n    }\n}\n\n// 加锁\nclass mycachelock {\n    private volatile map<string, object> map = new hashmap<>();\n    private readwritelock readwritelock = new reentrantreadwritelock(); // 读写锁\n\n    public void put(string key, object value) {\n        // 写锁\n        readwritelock.writelock().lock();\n        try {\n            system.out.println(thread.currentthread().getname() + " 写入" + key);\n            map.put(key, value);\n            system.out.println(thread.currentthread().getname() + " 写入成功!");\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            //解锁\n            readwritelock.writelock().unlock();\n        }\n    }\n\n    public void get(string key) {\n        // 读锁\n        readwritelock.readlock().lock();\n        try {\n            system.out.println(thread.currentthread().getname() + " 读取" + key);\n            object result = map.get(key);\n            system.out.println(thread.currentthread().getname() + " 读取结果：" + result);\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            readwritelock.readlock().unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\n\n# 9、阻塞队列\n\ninterface  blockingqueue<e>\n\n\n1\n\n\n\n# 阻塞队列简介\n\n阻塞：必须要阻塞、不得不阻塞\n\n阻塞队列是一个队列，在数据结构中起的作用如下图：\n\n\n\n当队列是空的，从队列中获取元素的操作将会被阻塞。\n\n当队列是满的，从队列中添加元素的操作将会被阻塞。\n\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。\n\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。\n\n\n# 阻塞队列的用处\n\n在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自 动被唤起。\n\n为什么需要 blockingqueue？\n\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切blockingqueue 都 给你一手包办了。\n\n在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。\n\n\n# 接口架构图\n\n\n\n * arrayblockingqueue\n   \n   由数组结构组成的有界阻塞队列。\n\n * linkedblockingqueue\n   \n   由链表结构组成的有界（默认值为：integer.max_value）阻塞队列。\n\n * priorityblockingqueue\n   \n   支持优先级排序的无界阻塞队列\n\n * delayqueue\n   \n   使用优先级队列实现的延迟无界阻塞队列。\n\n * synchronousqueue\n   \n   不存储元素的阻塞队列，也即单个元素的队列。\n\n * linkedtransferqueue\n   \n   由链表组成的无界阻塞队列\n\n * linkedblockingdeque\n   \n   由链表组成的双向阻塞队列。\n\n\n# api的使用\n\n方法\\处理方式   抛出异常        返回特殊值      一直阻塞     超时退出\n插入方法      add(e)      offer(e)   put(e)   offer(e,time,unit)\n移除方法      remove()    poll()     take()   poll(time,unit)\n检查方法      element()   peek()     不可用      不可用\n\n解释：\n\n * 抛出异常\n\n当阻塞队列满时，再往队列里add插入元素会抛出 illegalstateexception: queue full\n\n当阻塞队列空时，再往队列里remove移除元素会抛 nosuchelementexception`\n\n * 返回特殊值\n\n插入方法，成功返回true，失败则false\n\n移除方法，成功返回队列元素，队列里没有则返回null\n\n * 一直阻塞\n\n当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或响应中断退出\n\n当阻塞队列空时，消费者线程从队列里take元素，队列会一直阻塞消费者线程直到队列可用\n\n * 超时退出\n\n当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出\n\n抛出异常\n\npackage com.oddfar.bq;\n\nimport java.util.concurrent.arrayblockingqueue;\n\n/**\n * @author zhiyuan\n */\npublic class blockingqueuedemo {\n\n    public static void main(string[] args) {\n        // 队列大小\n        arrayblockingqueue blockingqueue = new arrayblockingqueue<>(3);\n        system.out.println(blockingqueue.add("a"));\n        system.out.println(blockingqueue.add("b"));\n        system.out.println(blockingqueue.add("c"));\n\n        //java.lang.illegalstateexception: queue full\n//        system.out.println(blockingqueue.add("d"));\n\n        system.out.println("首元素：" + blockingqueue.element()); // 检测队列队首元素！\n        // public e remove() 返回值e，就是移除的值\n        system.out.println(blockingqueue.remove()); //a\n        system.out.println(blockingqueue.remove()); //b\n        system.out.println(blockingqueue.remove()); //c\n        // java.util.nosuchelementexception\n//        system.out.println(blockingqueue.remove());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n返回特殊值\n\npublic class blockingqueuedemo2 {\n    public static void main(string[] args) {\n        // 队列大小\n        arrayblockingqueue blockingqueue = new arrayblockingqueue<>(3);\n\n        system.out.println(blockingqueue.offer("a")); // true\n        system.out.println(blockingqueue.offer("b")); // true\n        system.out.println(blockingqueue.offer("c")); // true\n        //system.out.println(blockingqueue.offer("d")); // false\n\n        system.out.println("首元素：" + blockingqueue.peek()); // 检测队列队首元素！\n\n        // public e poll()\n        system.out.println(blockingqueue.poll()); // a\n        system.out.println(blockingqueue.poll()); // b\n        system.out.println(blockingqueue.poll()); // c\n        system.out.println(blockingqueue.poll()); // null\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n一直阻塞\n\npublic class blockingqueuedemo3 {\n    public static void main(string[] args) throws interruptedexception {\n        // 队列大小\n        arrayblockingqueue blockingqueue = new arrayblockingqueue<>(3);\n\n        // 一直阻塞\n        blockingqueue.put("a");\n        blockingqueue.put("b");\n        blockingqueue.put("c");\n//         blockingqueue.put("d");\n        system.out.println(blockingqueue.take()); // a\n        system.out.println(blockingqueue.take()); // b\n        system.out.println(blockingqueue.take()); // c\n        system.out.println(blockingqueue.take()); // 阻塞不停止等待\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n超时退出\n\npublic class blockingqueuedemo4 {\n    public static void main(string[] args) throws interruptedexception {\n        // 队列大小\n        arrayblockingqueue blockingqueue = new arrayblockingqueue<>(3);\n\n        // 一直阻塞\n        blockingqueue.put("a");\n        blockingqueue.put("b");\n        blockingqueue.put("c");\n        blockingqueue.offer("d",2l, timeunit.seconds); // 等待2秒超时退出\n\n        system.out.println(blockingqueue.take()); // a\n        system.out.println(blockingqueue.take()); // b\n        system.out.println(blockingqueue.take()); // c\n        system.out.println(blockingqueue.take()); // 阻塞不停止等待\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JUC学习笔记（下）",frontmatter:{title:"JUC学习笔记（下）",permalink:"/java/se/thread/2",date:"2021-05-17T18:01:25.000Z"},regularPath:"/01.Java/07.Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05.JUC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"01.Java/07.Java-多线程/05.JUC学习笔记.md",key:"v-6079c7fa",path:"/java/se/thread/2/",headers:[{level:2,title:"11、线程池",slug:"_11、线程池",normalizedTitle:"11、线程池",charIndex:3},{level:3,title:"ExecutorService",slug:"executorservice",normalizedTitle:"executorservice",charIndex:15},{level:3,title:"ThreadPoolExecutor",slug:"threadpoolexecutor",normalizedTitle:"threadpoolexecutor",charIndex:36},{level:2,title:"12、四大函数式接口",slug:"_12、四大函数式接口",normalizedTitle:"12、四大函数式接口",charIndex:58},{level:2,title:"13、Stream流式计算",slug:"_13、stream流式计算",normalizedTitle:"13、stream流式计算",charIndex:72},{level:2,title:"14、分支合并",slug:"_14、分支合并",normalizedTitle:"14、分支合并",charIndex:89},{level:2,title:"15、异步回调",slug:"_15、异步回调",normalizedTitle:"15、异步回调",charIndex:100},{level:2,title:"16、JMM",slug:"_16、jmm",normalizedTitle:"16、jmm",charIndex:111},{level:2,title:"17、volatile",slug:"_17、volatile",normalizedTitle:"17、volatile",charIndex:121},{level:2,title:"18、单例模式",slug:"_18、单例模式",normalizedTitle:"18、单例模式",charIndex:136},{level:3,title:"饿汉式",slug:"饿汉式",normalizedTitle:"饿汉式",charIndex:149},{level:3,title:"懒汉式",slug:"懒汉式",normalizedTitle:"懒汉式",charIndex:158},{level:3,title:"静态内部类",slug:"静态内部类",normalizedTitle:"静态内部类",charIndex:167},{level:3,title:"万恶的反射",slug:"万恶的反射",normalizedTitle:"万恶的反射",charIndex:178},{level:3,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:189},{level:2,title:"19、CAS",slug:"_19、cas",normalizedTitle:"19、cas",charIndex:195},{level:2,title:"20、原子引用",slug:"_20、原子引用",normalizedTitle:"20、原子引用",charIndex:205},{level:2,title:"21、Java锁",slug:"_21、java锁",normalizedTitle:"21、java锁",charIndex:216},{level:3,title:"公平锁非公平锁",slug:"公平锁非公平锁",normalizedTitle:"公平锁非公平锁",charIndex:230},{level:3,title:"可重入锁",slug:"可重入锁",normalizedTitle:"可重入锁",charIndex:243},{level:3,title:"自旋锁",slug:"自旋锁",normalizedTitle:"自旋锁",charIndex:253},{level:3,title:"死锁",slug:"死锁",normalizedTitle:"死锁",charIndex:262}],headersStr:"11、线程池 ExecutorService ThreadPoolExecutor 12、四大函数式接口 13、Stream流式计算 14、分支合并 15、异步回调 16、JMM 17、volatile 18、单例模式 饿汉式 懒汉式 静态内部类 万恶的反射 枚举 19、CAS 20、原子引用 21、Java锁 公平锁非公平锁 可重入锁 自旋锁 死锁",content:' * 11、线程池\n   * ExecutorService\n   * ThreadPoolExecutor\n * 12、四大函数式接口\n * 13、Stream流式计算\n * 14、分支合并\n * 15、异步回调\n * 16、JMM\n * 17、volatile\n * 18、单例模式\n   * 饿汉式\n   * 懒汉式\n   * 静态内部类\n   * 万恶的反射\n   * 枚举\n * 19、CAS\n * 20、原子引用\n * 21、Java锁\n   * 公平锁非公平锁\n   * 可重入锁\n   * 自旋锁\n   * 死锁\n\n\n\n\n# 11、线程池\n\n池化技术\n\n程序的运行，其本质上，是对系统资源(CPU、内存、磁盘、网络等等)的使用。如何高效的使用这些资源 是我们编程优化演进的一个方向。今天说的线程池就是一种对CPU利用的优化手段。\n\n通过学习线程池原理，明白所有池化技术的基本设计思路。遇到其他相似问题可以解决。\n\n前面提到一个名词——池化技术，那么到底什么是池化技术呢 ?\n\n池化技术简单点来说，就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化 技术可以大大的提高资源的利用率，提升性能等。\n\n在编程领域，比较典型的池化技术有：线程池、连接池、内存池、对象池等。\n\n我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。可以利用上多核 CPU。当一个任务结束，当前线程就接收。\n\n但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成很大的性能开销。\n\n那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。\n\n这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接获取，避免多次重复创建、销毁带来的开销。\n\n为什么使用线程池\n\n10 年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球 ，CPU 需要来回切换。\n\n现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。\n\n线程池的优势：\n\n线程池做的工作主要是：控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这 些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。\n\n它的主要特点为：线程复用，控制最大并发数，管理线程。\n\n第一：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n\n第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。\n\n第三：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。\n\n\n# ExecutorService\n\n线程池的三大方法\n\nJava中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor ，Executors， ExecutorService，ThreadPoolExecutor 这几个类。\n\n\n\n三大方法说明：\n\n * Executors.newFixedThreadPool(int)\n   \n   执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程。\n\n * Executors.newSingleThreadExecutor()\n   \n   只有一个线程\n\n * Executors.newCachedThreadPool()\n   \n   执行很多短期异步任务，线程池根据需要创建新线程，但在先构建的线程可用时将重用他们。 可扩容，遇强则强\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) {\n        /** 1、池子大小 5 \n         * 模拟有10个顾客过来银行办理业务，池子中只有5个工作人员受理业务\n         */\n//        ExecutorService threadPool = Executors.newFixedThreadPool(5);\n\n\n        /** 2、有且只有一个固定的线程\n         * 模拟有10个顾客过来银行办理业务，池子中只有1个工作人员受理业务\n         */\n//        ExecutorService threadPool =  Executors.newSingleThreadExecutor();\n        \n        /**  3、一池N线程，可扩容伸缩\n         * 模拟有10个顾客过来银行办理业务，池子中N个工作人员受理业务\n         */\n        ExecutorService threadPool = Executors.newCachedThreadPool();\n        \n        try {\n            for (int i = 1; i <= 10; i++) {\n                threadPool.execute(() -> {\n                    System.out.println(Thread.currentThread().getName() + " 办理业务");\n                });\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            threadPool.shutdown(); // 用完记得关闭\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# ThreadPoolExecutor\n\nThreadPoolExecutor 七大参数\n\n查看三大方法的调用源码，发现本质都是调用了 new ThreadPoolExecutor ( 7 大参数 )\n\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1、corePollSize\n\n核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中。\n\n2、maximumPoolSize\n\n最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1。\n\n3、keepAliveTime\n\n空闲的线程保留的时间，达到这个时间后，自动释放\n\n4、TimeUnit\n\n空闲线程的保留时间单位。\n\nTimeUnit.DAYS; //天\nTimeUnit.HOURS; //小时\nTimeUnit.MINUTES; //分钟\nTimeUnit.SECONDS; //秒\nTimeUnit.MILLISECONDS; //毫秒\nTimeUnit.MICROSECONDS; //微妙\nTimeUnit.NANOSECONDS; //纳秒\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n5、BlockingQueue<Runnable> workQueue\n\n阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、 LinkedBlockingQueue、SynchronousQueue可选。\n\n6、ThreadFactory\n\n线程工厂，用来创建线程，一般默认即可\n\n7、RejectedExecutionHandler\n\n队列已满，而且任务量大于最大线程的异常处理策略。有以下取值\n\nThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。\nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务\n\n\n1\n2\n3\n4\n\n\nThreadPoolExecutor层工作原理\n\n\n\n举例：8个人进银行办理业务\n\n1、1~2人被受理（核心大小core）\n\n2、3~5人进入队列（Queue）\n\n3、6~8人到最大线程池（扩容大小max）\n\n4、再有人进来就要被拒绝策略接受了\n\n\n\n1、在创建了线程池后，开始等待请求。\n\n2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：\n\n * 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务\n * 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列\n * 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非 核心线程立刻运行这个任务\n * 如果队列满了且正在运行的线程数量大于或等于1Size，那么线程池会启动饱和拒绝策略来执行。\n\n3、当一个线程完成任务时，它会从队列中取下一个任务来执行\n\n4、 当一个线程无事可做超过一定的时间(keepAliveTime)时，线程会判断：\n\n如果当前运行的线程数大于corePollSize，那么这个线程就被停掉。\n\n所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\n\n线程池用哪个？生产中如何设置合理参数\n\nExecutors 中 JDK 已经给你提供了，为什么不用？\n\n\n\n代码测试：\n\n线程池的拒绝策略：\n\nRejectedExecutionHandler rejected = null;\n\n//默认，队列满了丢任务，抛出异常\nrejected = new ThreadPoolExecutor.AbortPolicy();\n//队列满了丢任务，不抛出异常【如果允许任务丢失这是最好的】\nrejected = new ThreadPoolExecutor.DiscardPolicy();\n//将最早进入队列的任务删，之后再尝试加入队列\nrejected = new ThreadPoolExecutor.DiscardOldestPolicy();\n////如果添加到线程池失败，那么主线程会自己去执行该任务，回退\nrejected = new ThreadPoolExecutor.CallerRunsPolicy();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\npublic class MyThreadPoolDemo2 {\n\n    public static void main(String[] args) {\n\n\n        // 自定义 ThreadPoolExecutor\n        ExecutorService threadPool = new ThreadPoolExecutor(\n                2,\n                Runtime.getRuntime().availableProcessors(),\n                2L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingDeque<>(3),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.DiscardPolicy());\n        try {\n            // 模拟有6,7,8,9,10个顾客过来银行办理业务，观察结果情况\n            // 最大容量为：maximumPoolSize + workQueue = 最大容量数\n            for (int i = 1; i <= 19; i++) {\n                int num = i;\n                threadPool.execute(() -> {\n                    System.out.println(num + " " + Thread.currentThread().getName() + " ok");\n                });\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            threadPool.shutdown(); // 用完记得关闭\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n线程是否越多越好？\n\n一个计算为主的程序（专业一点称为CPU密集型程序）。多线程跑的时候，可以充分利用起所有的 cpu 核心，比如说4个核心的cpu，开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。但是如果线程远远超出cpu核心数量反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。\n\n如果是一个磁盘或网络为主的程序（IO密集型）。一个线程处在IO等待的时候，另一个线程还可以在 CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的。所以开多线程，比 方说多线程网络传输，多线程往不同的目录写文件，等等。此时线程数等于IO任务数是最佳的。\n\n\n# 12、四大函数式接口\n\n在java.util.function包下，Java 内置核心四大函数式接口，可以使用lambda表达式\n\n\n\n函数型接口，有一个输入，有一个输出\n\nFunction\n\npackage com.oddfar.function;\n\nimport java.util.function.Function;\n\n/**\n * @author zhiyuan\n */\npublic class Demo01 {\n    public static void main(String[] args) {\n//        Function<String,Integer> function = new Function<String,Integer>() {\n//            @Override\n//            public Integer apply(String s) {\n//                return s.length();\n//            }\n//        };\n\n        Function<String,Integer> function = (s)->{return  s.length();};\n\n        System.out.println(function.apply("abc"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n断定型接口，有一个输入参数，返回只有布尔值。\n\nPredicate\n\npublic class Demo02 {\n    public static void main(String[] args) {\n//        Predicate<String> predicate = new Predicate<String>() {\n//            @Override\n//            public boolean test(String s) {\n//                return s.isEmpty();\n//            }\n//        };\n        Predicate<String> predicate = (s)->{return s.isEmpty();};\n\n        System.out.println(predicate.test("abc"));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n消费型接口，有一个输入参数，没有返回值\n\nConsumer\n\npublic class Demo03 {\n    public static void main(String[] args) {\n\n//        Consumer<String> consumer = new Consumer<String>() {\n//            @Override\n//            public void accept(String s) {\n//                System.out.println(s);\n//            }\n//        };\n        Consumer<String> consumer = s -> { System.out.println(s); };\n        consumer.accept("abc");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n供给型接口，没有输入参数，只有返回参数\n\nSupplier\n\npublic class Demo04 {\n    public static void main(String[] args) {\n//        Supplier<String> supplier = new Supplier<String>() {\n//            @Override\n//            public String get() {\n//                return null;\n//            }\n//        };\n        Supplier<String> supplier = () -> { return "abc";};\n        System.out.println(supplier.get());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 13、Stream流式计算\n\n流（Stream）到底是什么呢？\n\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n“集合讲的是数据，流讲的是计算！”\n\n特点：\n\n * Stream 自己不会存储元素\n\n * Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream。\n\n * Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。\n\n\n\n代码举例\n\nUser实体类\n\npublic class User {\n    private int id;\n    private String userName;\n    private int age;\n    //get、set、有参/无参构造器、toString\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nStream算法题\n\npackage com.oddfar.stream;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * 题目：请按照给出数据，找出同时满足以下条件的用户\n * 也即以下条件：\n * 1、全部满足偶数ID\n * 2、年龄大于24\n * 3、用户名转为大写\n * 4、用户名字母倒排序\n * 5、只输出一个用户名字 limit\n */\npublic class StreamDemo {\n    public static void main(String[] args) {\n        User u1 = new User(11, "a", 23);\n        User u2 = new User(12, "b", 24);\n        User u3 = new User(13, "c", 22);\n        User u4 = new User(14, "d", 28);\n        User u5 = new User(16, "e", 26);\n        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);\n\n        /**\n         * 1. 首先我们需要将 list 转化为stream流\n         * 2. 然后将用户过滤出来，这里用到一个函数式接口 Predicate<? super T>，我们可以使用lambda表达式简化\n         * 3. 这里面传递的参数，就是Stream流的泛型类型，也就是User，所以，这里可以直接返回用户id为偶数的用户信息;\n         * 4. 通过forEach进行遍历，直接简化输出 System.out::println\n         */\n        list.stream()\n                .filter(u -> {\n                    return u.getId() % 2 == 0;\n                })\n                .filter(u -> {\n                    return u.getAge() > 24;\n                })\n                .map(u -> {\n                    return u.getUserName().toUpperCase();\n                })\n                //.sorted() //默认正排序 自己用 compareTo 比较\n                .sorted((o1, o2) -> {\n                    return o2.compareTo(o1);\n                })\n                .limit(1)\n                .forEach(System.out::println);\n\n\n        // map解释：\n        List<Integer> list2 = Arrays.asList(1, 2, 3);\n        list2 = list2.stream().map(x -> {\n            return x * 2;\n        }).collect(Collectors.toList());\n\n        for (Integer element : list2) {\n            System.out.println(element);\n        }\n        \n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 14、分支合并\n\n什么是ForkJoin\n\n从JDK1.7开始，Java提供 Fork/Join 框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。\n\n这种思想和MapReduce很像（input --\x3e split --\x3e map --\x3e reduce --\x3e output）\n\n主要有两步：\n\n * 第一、任务切分\n * 第二、结果合并\n\n\n\n它的模型大致是这样的：线程池中的每个线程都有自己的工作队列\n\n（PS：这一点和ThreadPoolExecutor 不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务）\n\n当 自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。\n\n工作窃取\n\n另外，forkjoin有一个工作窃取的概念。简单理解，就是一个工作线程下会维护一个包含多个子任务的双端队列。而对于每个工作线程来说，会从头部到尾部依次执行任务。这时，总会有一些线程执行的速度较快，很快就把所有任务消耗完了。那这个时候怎么办呢，总不能空等着吧，多浪费资源啊。\n\n工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：\n\n\n\n那么为什么需要使用工作窃取算法呢？\n\n假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。\n\n工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。\n\n于是，先做完任务的工作线程会从其他未完成任务的线程尾部依次获取任务去执行。这样就可以充分利用CPU的资源。这个非常好理解，就比如有个妹子程序员做任务比较慢，那么其他猿就可以帮她分担一 些任务，这简直是双赢的局面啊，妹子开心了，你也开心了。\n\n核心类\n\n1、ForkJoinPool\n\nWorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。\n\n什么叫线程的任务窃取呢？就是说你和你的一个伙伴一起吃水果，你的那份吃完了，他那份没吃完，那你就偷偷的拿了他的一些水果吃了。存在执行2个任务的子线程，这里要讲成存在A，B两个了。\n\nWorkQueue在执行任务，A的任务执行完了，B的任务没执行完，那么A的WorkQueue就从B的 WorkQueue的ForkJoinTask数组中拿走了一部分尾部的任务来执行，可以合理的提高运行和计算效率。\n\n每个线程都有一个WorkQueue，而WorkQueue中有执行任务的线程（ForkJoinWorkerThread owner），还有这个线程需要处理的任务（ForkJoinTask<?>[] array）。那么这个新提交的任务就是加到array中。\n\n2、ForkJoinTask\n\nForkJoinTask代表运行在ForkJoinPool中的任务。\n\n主要方法：\n\n * fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务\n * join() 当任务完成的时候返回计算结果。\n * invoke() 开始执行任务，如果必要，等待计算完成。\n\n子类： Recursive ：递归\n\n * RecursiveAction 一个递归无结果的ForkJoinTask（没有返回值）\n * RecursiveTask 一个递归有结果的ForkJoinTask（有返回值）\n\n代码测试\n\n核心代码：\n\npackage com.oddfar.forkJoin;\n\nimport java.util.concurrent.RecursiveTask;\n\n/**\n * @author zhiyuan\n */\npublic class ForkJoinWork extends RecursiveTask<Long> {\n\n    private Long start;//起始值\n    private Long end;//结束值\n    public static final Long critical = 10000L;//临界值\n\n    public ForkJoinWork(Long start, Long end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        //判断是否是拆分完毕\n        Long lenth = end - start;\n        if (lenth <= critical) {\n            //如果拆分完毕就相加\n            Long sum = 0L;\n            for (Long i = start; i <= end; i++) {\n                sum += i;\n            }\n            return sum;\n        } else {\n            //没有拆分完毕就开始拆分\n            Long middle = (end + start) / 2;//计算的两个值的中间值\n            ForkJoinWork right = new ForkJoinWork(start, middle);\n            right.fork();//拆分，并压入线程队列\n            ForkJoinWork left = new ForkJoinWork(middle + 1, end);\n            left.fork();//拆分，并压入线程队列\n\n            //合并\n            return right.join() + left.join();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n三种测试：\n\npackage com.oddfar.forkJoin;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.stream.LongStream;\n\n/**\n * @author zhiyuan\n */\npublic class ForkJoinWorkDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        test1();//  15016\n        test2();//  14694\n        test3();//  216\n\n    }\n\n    // forkjoin这个框架针对的是大任务执行，效率才会明显的看出来有提升，于是我把总数调大到20亿。\n    public static void test1() throws ExecutionException, InterruptedException {\n\n        //ForkJoin实现\n        long l = System.currentTimeMillis();\n\n        ForkJoinPool forkJoinPool = new ForkJoinPool();//实现ForkJoin 就必须有ForkJoinPool的支持\n        ForkJoinTask<Long> task = new ForkJoinWork(0L, 2000000000L);//参数为起始值与结束值\n        ForkJoinTask<Long> result = forkJoinPool.submit(task);\n        Long aLong = result.get();\n\n        long l1 = System.currentTimeMillis();\n        System.out.println("invoke = " + aLong + " time: " + (l1 - l));\n\n    }\n\n\n    public static void test2() {\n        //普通线程实现\n        Long x = 0L;\n        Long y = 20_0000_0000L;\n        long start_time = System.currentTimeMillis();\n        for (Long i = 0L; i <= y; i++) {\n            x += i;\n        }\n        long end_time = System.currentTimeMillis();\n        System.out.println("invoke = " + x + " time: " + (end_time - start_time));\n\n    }\n\n    public static void test3() {\n        //Java 8 并行流的实现\n        long l = System.currentTimeMillis();\n\n        long reduce = LongStream.rangeClosed(0, 2000000000L).parallel().reduce(0, Long::sum);\n\n        long l1 = System.currentTimeMillis();\n        System.out.println("invoke = " + reduce + " time: " + (l1 - l));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n打个比方，假设一个酒店有400个房间，一共有4名清洁工，每个工人每天可以打扫100个房间，这样，4 个工人满负荷工作时，400个房间全部打扫完正好需要1天。\n\nFork/Join的工作模式就像这样：首先，工人甲被分配了400个房间的任务，他一看任务太多了自己一个 人不行，所以先把400个房间拆成两个200，然后叫来乙，把其中一个200分给乙。紧接着，甲和乙再发现200也是个大任务，于是甲继续把200分成两个100，并把其中一个100分给丙， 类似的，乙会把其中一个100分给丁，这样，最终4个人每人分到100个房间，并发执行正好是1天。\n\n\n# 15、异步回调\n\n概述\n\nFuture设计的初衷：对将来某个时刻会发生的结果进行建模。\n\n当我们需要调用一个函数方法时。如果这个函数执行很慢，那么我们就要进行等待。但有时候，我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。\n\n它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在 Future 中出发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。\n\n**Future的优点：**比更底层的Thread更易用。要使用Future，通常只需要将耗时的操作封装在一个 Callable对象中，再将它提交给ExecutorService。\n\n为了让程序更加高效，让CPU最大效率的工作，我们会采用异步编程。首先想到的是开启一个新的线程去做某项工作。再进一步，为了让新线程可以返回一个值，告诉主线程事情做完了，于是乎 Future 粉墨登场。然而Future提供的方式是主线程主动问询新线程，要是有个回调函数就爽了。所以，为了满足 Future的某些遗憾，强大的CompletableFuture 随着Java8一起来了。\n\n\n\n实例\n\n没有返回值的 runAsync 异步调用\n\npackage com.oddfar.future;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author zhiyuan\n */\npublic class Demo01 {\n    public static void main(String[] args) throws Exception {\n\n        //没有返回值的 runAsync 异步调用\n        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(\n                () -> {\n                    try {\n                        TimeUnit.SECONDS.sleep(2);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    int i = 1;\n                    System.out.println(Thread.currentThread().getName() + " 没有返回");\n                }\n        );\n\n        System.out.println("111111");\n        completableFuture.get();\n        System.out.println("222222");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n有返回值的 供给型参数接口\n\npublic class Demo02 {\n    public static void main(String[] args) throws Exception {\n        CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\n                    System.out.println(Thread.currentThread().getName() + " 有返回值");\n//                    int i = 10 / 0;\n                    return 1024;\n                }\n        );\n\n        Integer res = completableFuture.whenComplete((t, u) -> {\n            //编译 完成，正常结束输出\n            System.out.println("===t:" + t); //正常结果\n            System.out.println("===u:" + u); //报错的信息\n        }).exceptionally(e -> { //结果异常，非正常结束\n            System.out.println("=======exception:" + e.getMessage());\n            return 555;\n        }).get();\n\n        System.out.println(res);\n    }\n\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 16、JMM\n\n * 请你谈谈你对 volatile 的理解\n\nvolitile 是 Java 虚拟机提供的轻量级的同步机制，三大特性：\n\n1、保证可见性\n\n2、不保证原子性\n\n3、禁止指令重排\n\n什么是JMM\n\nJMM 本身是一种抽象的概念，并不真实存在，它描述的是一组规则或者规范~\n\nJMM 关于同步的规定：\n\n1、线程解锁前，必须把共享变量的值刷新回主内存\n\n2、线程加锁前，必须读取主内存的最新值到自己的工作内存\n\n3、加锁解锁是同一把锁\n\nJMM即为 JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。\n\nJMM规定了内存主要划分为主内存和工作内存两种。此处的主内存和工作内存跟JVM内存划分（堆、 栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。\n\n\n\nJVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因此 JMM 制定了 一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。\n\nJMM的内存模型\n\n\n\n线程A感知不到线程B操作了值的变化！如何能够保证线程间可以同步感知这个问题呢？只需要使用 Volatile关键字即可！volatile 保证线程间变量的可见性，简单地说就是当线程A对变量X进行了修改后， 在线程A后面执行的其他线程能看到变量X的变动，更详细地说是要符合以下两个规则 ：\n\n * 线程对变量进行修改之后，要立刻回写到主内存。\n * 线程对变量读取的时候，要从主内存中读，而不是缓存。\n\n各线程的工作内存间彼此独立，互不可见，在线程启动的时候，虚拟机为每个内存分配一块工作内存， 不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量（非线程内构造的对象）的副本，即，为了提高执行效率。\n\n内存交互操作\n\n内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）\n\n * lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态\n * unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n * read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用\n * load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中\n * use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令\n * assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中\n * store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用\n * write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内 存的变量中\n\nJMM对这八种指令的使用，制定了如下规则：\n\n * 不允许read和load、store和write操作之一单独出现。即：使用了read必须load，使用了store必须 write\n * 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存\n * 不允许一个线程将没有assign的数据从工作内存同步回主内存\n * 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作\n * 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁\n * 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前， 必须重新load或assign操作初始化变量的值\n * 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量\n * 对一个变量进行unlock操作之前，必须把此变量同步回主内存\n\nJMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不 安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分 析。更多的时候，使用java的happen-before规则来进行分析。\n\n * happens-before字面翻译过来就是先行发生，A happens-before B 就是A先行发生于B？\n\n不准确！在Java内存模型中，happens-before 应该翻译成：前一个操作的结果可以被后续的操作获取。 讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。\n\n我们再来看看为什么需要这几条规则？\n\n因为我们现在电脑都是多CPU,并且都有缓存，导致多线程直接的可见性问题。\n\n所以为了解决多线程的可见性问题，就搞出了happens-before原则，让线程之间遵守这些原则。编译器 还会优化我们的语句，所以等于是给了编译器优化的约束。不能让它优化的不知道东南西北了！\n\n * 并发Bug的源头：https://www.jianshu.com/p/e662bb611360\n\n\n# 17、volatile\n\nvolatile是不错的机制，但是也不能保证原子性。\n\n * 代码验证可见性\n\npublic class JMMVolatileDemo01 {\n    /**\n     * Volatile 用来保证数据的同步，也就是可见性\n     * 不加 volatile 就没有可见性，会一直循环\n     */\n    private volatile static int num = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        new Thread(() -> {\n            while (num == 0) {\n            }\n        }).start();\n\n        Thread.sleep(1000);\n\n        num = 1;\n        System.out.println(num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 验证 volatile 不保证原子性\n\n原子性理解：不可分割，完整性，也就是某个线程正在做某个具体的业务的时候，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败。\n\npublic class JMMVolatileDemo02 {\n    private volatile static int num = 0;\n\n    public  static void add() {\n        num++;\n    }\n\n    // 结果应该是 num 为 2万，测试看结果\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 1; i <= 20; i++) {\n            new Thread(() -> {\n                for (int j = 1; j <= 1000; j++) {\n                    add();\n                }\n            }, String.valueOf(i)).start();\n        }\n\n        // 需要等待上面20个线程都全部计算完毕，看最终结果\n        // 默认一个 main线程 一个 gc 线程\n        while (Thread.activeCount() > 2) {\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName() + " " + num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n为我们的 add 方法没有加锁，加了 volatile ，说明 volatile 不能保证原子性；\n\n命令行查看底层字节码代码： javap -c JMMVolatileDemo02.class\n\n\n\nnum++ 在多线程下是非线程安全的，如何不加 synchronized解决？\n\n查看原子包下的类\n\npublic class JMMVolatileDemo02 {\n    private volatile static AtomicInteger num = new AtomicInteger();\n\n    public static void add() {\n        num.getAndIncrement(); // 等价 num++\n    }\n\n    // 结果应该是 num 为 2万，测试看结果\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 1; i <= 20; i++) {\n            new Thread(() -> {\n                for (int j = 1; j <= 1000; j++) {\n                    add();\n                }\n            }, String.valueOf(i)).start();\n        }\n\n        // 需要等待上面20个线程都全部计算完毕，看最终结果\n        // 默认一个 main线程 一个 gc 线程\n        while (Thread.activeCount() > 2) {\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName() + " " + num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n指令重排\n\n计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排\n\n\n\n一般分以下3种问题：\n\n单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。\n\n处理器在进行重排序时必须要考虑指令之间的数据依赖性。\n\n多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。\n\n指令重排是什么\n\n指令队列在CPU执行时不是串行的, 当某条指令执行时消耗较多时间时, CPU资源足够时并不会在此无意义的等待, 而是开启下一个指令. 开启下一条指令是有条件的, 即上一条指令和下一条指令不存在相关性. 例如下面这个例子:\n\na /= 2;   // 指令A\na /= 2;   // 指令B\nc++;      // 指令C\n\n\n1\n2\n3\n\n\n里的指令B是依赖于指令A的执行结果的, 在A处于执行阶段时, B会被阻塞, 直到A执行完成. 而指令C与A/B均没有依赖关系, 所以在A执行或者B执行的过程中, C会同时被执行, 那么C有可能在A+B的执行过程中就执行完毕了, 这样指令队列的实际执行顺序就是 C->A->B 或者 A->C->B.\n\n\n\n指令重排小结：\n\nvolatile 实现了禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象\n\n先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU 指令，它的作用有两个：\n\n1、保证特定操作的执行顺序。\n\n2、保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。\n\n由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条 Memory Barrier 则会告诉编译器和CPU，不管什么指令都不能和这条 Memory Barrier 指令重排序，也就是说，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。\n\n\n\n经过，可见性，原子性，指令重排的话，线程安全性获得保证：\n\n对于指令重排导致的可见性问题 和 有序性问题，可以利用 volatile 关键字解决，因为 volatile 的另外一 个作用就是禁止重排序优化。\n\n\n# 18、单例模式\n\n如何防止反射 破坏单例模式？\n\n推荐阅读：单例模式 | 菜鸟教程\n\n\n# 饿汉式\n\npublic class Hungry {\n    private Hungry() {\n    }\n\n    private final static Hungry hungry = new Hungry();\n\n    public static Hungry getInstance() {\n        return hungry;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n饿汉式是最简单的单例模式的写法，保证了线程的安全\n\n但饿汉式会有一点小问题，看下面的代码：\n\npublic class Hungry {\n    private byte[] data1 = new byte[1024];\n    private byte[] data2 = new byte[1024];\n    private byte[] data3 = new byte[1024];\n    private byte[] data4 = new byte[1024];\n    \n    private Hungry() {\n    }\n\n    private final static Hungry hungry = new Hungry();\n\n    public static Hungry getInstance() {\n        return hungry;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在 Hungry 类中，我定义了四个byte数组，当代码一运行，这四个数组就被初始化，并且放入内存了，如果长时间没有用到getInstance方法，不需要Hungry类的对象，这不是一种浪费吗？我希望的是只有用 到了 getInstance 方法，才会去初始化单例类，才会加载单例类中的数据。所以就有了第二种单例模式：懒汉式\n\n\n# 懒汉式\n\npublic class LazyMan {\n    private LazyMan() {\n        System.out.println(Thread.currentThread().getName() + "Start");\n    }\n\n    private static LazyMan lazyMan;\n\n    public static LazyMan getInstance() {\n        if (lazyMan == null) {\n            lazyMan = new LazyMan();\n        }\n        return lazyMan;\n    }\n\n    // 测试并发环境，发现单例失效\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(() -> {\n                LazyMan.getInstance();\n            }).start();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n多加一层检测可以避免问题，也就是DCL懒汉式！\n\npublic class LazyMan {\n    private LazyMan() {\n    }\n\n    private static LazyMan lazyMan;\n\n    public static LazyMan getInstance() {\n        if (lazyMan == null) {\n            synchronized (LazyMan.class) {\n                if (lazyMan == null) {\n                    lazyMan = new LazyMan();\n                }\n            }\n        }\n        return lazyMan;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nDCL懒汉式的单例，保证了线程的安全性，又符合了懒加载，只有在用到的时候，才会去初始化，调用 效率也比较高，但是这种写法在极端情况还是可能会有一定的问题。\n\n因为 lazyMan = new LazyMan(); 不是原子性操作，至少会经过三个步骤：\n\n 1. 分配对象内存空间\n 2. 执行构造方法初始化对象\n 3. 设置instance指向刚分配的内存地址，此时 instance ！=null；\n\n由于指令重排，导致A线程执行 lazyMan = new LazyMan(); 的时候，可能先执行了第三步（还没执行第 二步），由于线程调度，当线程B进来时，发现 lazyMan 已经不为空了，直接返回了lazyMan，并且后面使用了返回的lazyMan，由于线程A还没有执行第二步，导致此时lazyMan还不完整，可能会有一些意想不到的错误，所以就有了下面一种单例模式。\n\n这种单例模式只是在上面DCL单例模式增加一个volatile关键字来避免指令重排：\n\npublic class LazyMan {\n    private LazyMan() {\n    }\n\n    private volatile static LazyMan lazyMan;\n\n    public static LazyMan getInstance() {\n        if (lazyMan == null) {\n            synchronized (LazyMan.class) {\n                if (lazyMan == null) {\n                    lazyMan = new LazyMan();\n                }\n            }\n        }\n        return lazyMan;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 静态内部类\n\n还有这种方式是第一种饿汉式的改进版本，同样也是在类中定义static变量的对象，并且直接初始化，不 过是移到了静态内部类中，十分巧妙。既保证了线程的安全性，同时又满足了懒加载。\n\npublic class Holder {\n    private Holder() {\n    }\n\n    public static Holder getInstance() {\n        return InnerClass.holder;\n    }\n\n    private static class InnerClass {\n        private static final Holder holder = new Holder();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 万恶的反射\n\n万恶的反射登场了，反射是一个比较霸道的东西，无视private修饰的构造方法，可以直接在外面 newInstance，破坏我们辛辛苦苦写的单例模式。\n\npublic class SingletonPatternDemo {\n    public static void main(String[] args) throws Exception {\n        LazyMan lazyMan1 = LazyMan.getInstance();\n\n        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);\n        declaredConstructor.setAccessible(true);\n        LazyMan lazyMan2 = declaredConstructor.newInstance();\n        \n        System.out.println(lazyMan1.hashCode());\n        System.out.println(lazyMan2.hashCode());\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们分别打印出lazyMan1，lazyMan2的hashcode，发现不相等\n\n那么，怎么解决这种问题呢？\n\n在私有的构造函数中做一个判断，如果lazyMan不为空，说明lazyMan已经被创建过了，如果正常调用 getInstance方法，是不会出现这种事情的，所以直接抛出异常！\n\npublic class LazyMan {\n    private LazyMan() {\n        synchronized (LazyMan.class) {\n            if (lazyMan != null) {\n                throw new RuntimeException("不要试图用反射破坏单例模式");\n            }\n        }\n    }\n\n    private static LazyMan lazyMan;\n\n    public static LazyMan getInstance() {\n        if (lazyMan == null) {\n            synchronized (LazyMan.class) {\n                if (lazyMan == null) {\n                    lazyMan = new LazyMan();\n                }\n            }\n        }\n        return lazyMan;\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n但是这种写法还是有问题：\n\n上面我们是先正常的调用了getInstance方法，创建了LazyMan对象，所以第二次用反射创建对象，私有构造函数里面的判断起作用了，反射破坏单例模式失败。但是如果破坏者干脆不先调用getInstance方 法，一上来就直接用反射创建对象，我们的判断就不生效了：\n\n那么如何防止这种反射破坏呢？\n\npublic class LazyMan {\n    private static boolean flag = false;\n\n    private LazyMan() {\n        synchronized (LazyMan.class) {\n            if (flag == false) {\n                flag = true;\n            } else {\n                throw new RuntimeException("不要试图用反射破坏单例模式");\n            }\n        }\n    }\n\n    private static LazyMan lazyMan;\n\n    public static LazyMan getInstance() {\n        if (lazyMan == null) {\n            synchronized (LazyMan.class) {\n                if (lazyMan == null) {\n                    lazyMan = new LazyMan();\n                }\n            }\n        }\n        return lazyMan;\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在这里，我定义了一个boolean变量flag，初始值是false，私有构造函数里面做了一个判断，如果 flag=false，就把flag改为true，但是如果flag等于true，就说明有问题了，因为正常的调用是不会第二 次跑到私有构造方法的，所以抛出异常。\n\n看起来很美好，但是还是不能完全防止反射破坏单例模式，因为可以利用反射修改flag的值。\n\npublic class SingletonPatternDemo {\n    public static void main(String[] args) throws Exception {\n\n\n        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);\n        Field field = LazyMan.class.getDeclaredField("flag");\n        field.setAccessible(true);\n\n        // 通过反射实例化对象\n        declaredConstructor.setAccessible(true);\n        LazyMan lazyMan1 = declaredConstructor.newInstance();\n        System.out.println(field.get(lazyMan1));\n        System.out.println(lazyMan1.hashCode());\n\n        //通过反射，修改字段的值！\n        field.set(lazyMan1, false);\n        LazyMan lazyMan2 = declaredConstructor.newInstance();\n        System.out.println(field.get(lazyMan2));\n        System.out.println(lazyMan2.hashCode());\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n并没有一个很好的方案去避免反射破坏单例模式，所以轮到我们的枚举登场了。\n\n\n# 枚举\n\n枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类 (class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性 以及便捷性。\n\npublic enum EnumSingleton {\n\n    INSTANCE;\n    public EnumSingleton getInstance(){\n        return INSTANCE;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n枚举是目前最推荐的单例模式的写法，因为足够简单，不需要开发自己保证线程的安全，同时又可以有 效的防止反射破坏我们的单例模式\n\n\n# 19、CAS\n\nCAS（Conmpare And Swap） : 比较和交换\n\nJAVA1.5开始引入了CAS，主要代码都放在JUC的atomic包下\n\npublic class CASDemo {\n    public static void main(String[] args) {\n        //真实值为 5 \n        AtomicInteger atomicInteger = new AtomicInteger(5);\n\n        // 期望的是5，后面改为 2020 ， 所以结果为 true，2020\n        atomicInteger.compareAndSet(5, 2020);\n        System.out.println(atomicInteger.get());\n        // 期望的是5，后面改为 1024 ， 所以结果为 false，2020\n        System.out.println(atomicInteger.compareAndSet(5, 1024) + "=>" + atomicInteger.get());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n真实值和期望值相同，就修改成功，真实值和期望值不同，就修改失败！\n\n分析源码，如何实现的 i++ 安全的问题：atomicInteger.getAndIncrement();\n\npublic final int getAndIncrement() {\n    // this 当前对象\n\t// valueOffset 内存偏移量，内存地址\n\t// 1\t固定写死\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n跳转到 unsafe\n\n\n\n且这个类中的方法大部分都是 native 的方法了！\n\n * 问题：这个UnSafe类到底是什么？\n\n1、UnSafe\n\nUnSafe是 CAS 的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问， UnSafe相当于一个后门，基于该类可以直接操作特定内存的数据，Unsafe类存在于 sun.misc 包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。\n\n2、变量valueOffset\n\n表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的\n\n3、变量 value用volatile修饰，保证了多线程之间的内存可见性\n\n最后解释CAS 是什么\n\nCAS 的全称为 Compare-And-Swap，它是一条CPU并发原语。\n\n它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。\n\nCAS并发原语体现在JAVA语言中就是 sun.misc.Unsafe 类中的各个方法。调用 UnSafe类中的 CAS 方法， JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功 能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条 CPU 的原子指令，不会造成所谓的数据不一致问题。\n\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        // 获取传入对象的地址\n        var5 = this.getIntVolatile(var1, var2);\n        // 比较并交换，如果var1，var2 还是原来的 var5，就执行内存偏移+1； var5 +var4\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n汇编层面理解\n\nUnsafe 类中的 compareAndSwapint，是一个本地方法，该方法的实现位于 unsafe.cpp 中；\n\n\n\n总结\n\nCAS（CompareAndSwap）：\n\n比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。\n\nCAS 应用：\n\nCAS 有3个操作数，内存值V，旧的预期值A，要修改的更新值B。且仅当预期值A 和 内存值 V 相同时， 将内存值 V 修改为B，否则什么都不做。\n\nCAS 的缺点：\n\n1、循环时间长开销很大。\n\n可以看到源码中存在 一个 do...while 操作，如果CAS失败就会一直进行尝试。\n\n2、只能保证一个共享变量的原子操作。\n\n当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作。但是，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这时候就可以用锁来保证原子性\n\n3、CAS实现的过程是先取出内存中某时刻的数据，在下一时刻比较并替换，那么在这个时间差会导致数据的变化，此时就会导致出现“ABA”问题\n\n什么是”ABA”问题？\n\n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。\n\n尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。\n\n\n# 20、原子引用\n\ndemo：\n\npublic class AtomicReferenceDemo {\n    public static void main(String[] args) {\n\n        User zhangsan = new User("zhangsan", 22);\n        User lisi = new User("lisi", 25);\n\n        AtomicReference<User> atomicReference = new AtomicReference<>();\n        atomicReference.set(zhangsan); // 设置\n\n        // 期望的是zhangsan，后面改为 lisi ， 所以结果为 true，\n        System.out.print(atomicReference.compareAndSet(zhangsan, lisi)+"=>");\n        System.out.println(atomicReference.get().toString());\n        // 期望的是zhangsan，后面改为 lisi ， 所以结果为 flase，\n        System.out.print(atomicReference.compareAndSet(zhangsan, lisi));\n        System.out.println(atomicReference.get().toString());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n原子引用 AtomicReference 解决ABA问题\n\n要解决ABA问题，我们就需要加一个版本号\n\n版本号原子引用，类似乐观锁\n\npublic class ABASaveDemo {\n    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 1);\n\n\n    public static void main(String[] args) {\n\n        new Thread(() -> {\n            int stamp = atomicStampedReference.getStamp(); // 获得版本号\n            System.out.println("T1 stamp 01=>" + stamp);\n            // 暂停2秒钟，保证下面线程获得初始版本号\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            atomicStampedReference.compareAndSet(100, 101,\n                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n\n            System.out.println("T1 stamp 02=>" + atomicStampedReference.getStamp());\n\n            atomicStampedReference.compareAndSet(101, 100,\n                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n\n            System.out.println("T1 stamp 03=>" + atomicStampedReference.getStamp());\n        }, "T1").start();\n\n\n        new Thread(() -> {\n            int stamp = atomicStampedReference.getStamp(); // 获得版本号\n            System.out.println("T2 stamp 01=>" + stamp);\n\t\t\t// 暂停3秒钟，保证上面线程先执行\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            boolean result = atomicStampedReference.compareAndSet(100, 2019,\n                    stamp, stamp + 1);\n            System.out.println("T2 是否修改成功 =>" + result);\n            System.out.println("T2 最新stamp =>" + atomicStampedReference.getStamp());\n            System.out.println("T2 当前的最新值  =>" + atomicStampedReference.getReference());\n        }, "T2").start();\n\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 21、Java锁\n\n\n# 公平锁非公平锁\n\n公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。\n\n非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比现申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。\n\n// 无参\npublic ReentrantLock() {\n\tsync = new NonfairSync();\n}\n// 有参\npublic ReentrantLock(boolean fair) {\n\tsync = fair ? new FairSync() : new NonfairSync();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n两者区别\n\n并发包中的 ReentrantLock 的创建可以指定构造函数的 boolean 类型来得到公平锁或者非公平锁，默认是非公平锁！\n\n公平锁：就是很公平，在并发环境中，每个线程在获取到锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。\n\n非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就会采用类似公平锁那种方式。\n\nJava ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在 于吞吐量比公平锁大。\n\n对于Synchronized而言，也是一种非公平锁。\n\n\n# 可重入锁\n\n可重入锁（也叫递归锁）\n\n指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法 获取锁的时候，在进入内层方法会自动获取锁。\n\n也就是说，线程可以进入任何一个它已经拥有的锁，所同步着的代码块。 好比家里进入大门之后，就可以进入里面的房间了；\n\nReentrantLock、Synchronized 就是一个典型的可重入锁；\n\n可重入锁最大的作用就是避免死锁\n\n测试一：Synchronized\n\npublic class ReentrantLockDemo {\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        // T1 线程在外层获取锁时，也会自动获取里面的锁\n        new Thread(() -> {\n            phone.sendSMS();\n        }, "T1").start();\n\n        new Thread(() -> {\n            phone.sendSMS();\n        }, "T2").start();\n\n    }\n}\nclass Phone {\n    public synchronized void sendSMS() {\n        System.out.println(Thread.currentThread().getName() + " sendSMS");\n        sendEmail();\n    }\n\n    public synchronized void sendEmail() {\n        System.out.println(Thread.currentThread().getName() + " sendEmail");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n测试二：ReentrantLock\n\npublic class ReentrantLockDemo {\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        // T1 线程在外层获取锁时，也会自动获取里面的锁\n        new Thread(phone, "T1").start();\n        new Thread(phone, "T2").start();\n\n    }\n}\n\nclass Phone implements Runnable {\n\n    Lock lock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        get();\n    }\n\n    public void get() {\n        lock.lock();\n        // lock.lock(); 锁必须匹配，如果两个锁，只有一个解锁就会失败\n        try {\n            System.out.println(Thread.currentThread().getName() + " get()");\n            set();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n            // lock.lock();\n        }\n\n    }\n\n    public void set() {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + " set()");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 自旋锁\n\n自旋锁（spinlock），是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。\n\npublic class SpinLockDemo {\n    // 原子引用线程, 没写参数，引用类型默认为null\n    AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n    //上锁\n    public void myLock() {\n        Thread thread = Thread.currentThread();\n        System.out.println(Thread.currentThread().getName() + "==>mylock");\n        // 自旋\n        while (!atomicReference.compareAndSet(null, thread)) {\n        }\n    }\n\n    //解锁\n    public void myUnlock() {\n        Thread thread = Thread.currentThread();\n        atomicReference.compareAndSet(thread, null);\n        System.out.println(Thread.currentThread().getName() + "==>myUnlock");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SpinLockDemo spinLockDemo = new SpinLockDemo();\n\n        new Thread(() -> {\n            spinLockDemo.myLock();\n            try {\n                TimeUnit.SECONDS.sleep(4);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            spinLockDemo.myUnlock();\n        }, "T1").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n        new Thread(() -> {\n            spinLockDemo.myLock();\n\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            spinLockDemo.myUnlock();\n        }, "T2").start();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 死锁\n\n死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否者就会因为争夺有限的资源而陷入死锁。\n\n\n\n产生死锁主要原因：\n\n1、系统资源不足\n\n2、进程运行推进的顺序不合适\n\n3、资源分配不当\n\n测试：\n\npublic class DeadLockDemo {\n    public static void main(String[] args) {\n        String lockA = "lockA";\n        String lockB = "lockB";\n        new Thread(new HoldLockThread(lockA, lockB), "T1").start();\n        new Thread(new HoldLockThread(lockB, lockA), "T2").start();\n    }\n}\n\nclass HoldLockThread implements Runnable {\n    private String lockA;\n    private String lockB;\n\n    public HoldLockThread(String lockA, String lockB) {\n        this.lockA = lockA;\n        this.lockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockA) {\n\n            System.out.println(Thread.currentThread().getName() + "lock:" + lockA + "=>get" + lockB);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            synchronized (lockB) {\n                System.out.println(Thread.currentThread().getName() + "lock:" + lockB + "=>get" + lockA);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n解决\n\n1、查看JDK目录的bin目录\n\n2、使用 jps -l 命令定位进程号\n\n3、使用 jstack 进程号 找到死锁查看\n\n',normalizedContent:' * 11、线程池\n   * executorservice\n   * threadpoolexecutor\n * 12、四大函数式接口\n * 13、stream流式计算\n * 14、分支合并\n * 15、异步回调\n * 16、jmm\n * 17、volatile\n * 18、单例模式\n   * 饿汉式\n   * 懒汉式\n   * 静态内部类\n   * 万恶的反射\n   * 枚举\n * 19、cas\n * 20、原子引用\n * 21、java锁\n   * 公平锁非公平锁\n   * 可重入锁\n   * 自旋锁\n   * 死锁\n\n\n\n\n# 11、线程池\n\n池化技术\n\n程序的运行，其本质上，是对系统资源(cpu、内存、磁盘、网络等等)的使用。如何高效的使用这些资源 是我们编程优化演进的一个方向。今天说的线程池就是一种对cpu利用的优化手段。\n\n通过学习线程池原理，明白所有池化技术的基本设计思路。遇到其他相似问题可以解决。\n\n前面提到一个名词——池化技术，那么到底什么是池化技术呢 ?\n\n池化技术简单点来说，就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化 技术可以大大的提高资源的利用率，提升性能等。\n\n在编程领域，比较典型的池化技术有：线程池、连接池、内存池、对象池等。\n\n我们通过创建一个线程对象，并且实现runnable接口就可以实现一个简单的线程。可以利用上多核 cpu。当一个任务结束，当前线程就接收。\n\n但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成很大的性能开销。\n\n那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。\n\n这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接获取，避免多次重复创建、销毁带来的开销。\n\n为什么使用线程池\n\n10 年前单核cpu电脑，假的多线程，像马戏团小丑玩多个球 ，cpu 需要来回切换。\n\n现在是多核电脑，多个线程各自跑在独立的cpu上，不用切换效率高。\n\n线程池的优势：\n\n线程池做的工作主要是：控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这 些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。\n\n它的主要特点为：线程复用，控制最大并发数，管理线程。\n\n第一：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n\n第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。\n\n第三：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。\n\n\n# executorservice\n\n线程池的三大方法\n\njava中的线程池是通过 executor 框架实现的，该框架中用到了 executor ，executors， executorservice，threadpoolexecutor 这几个类。\n\n\n\n三大方法说明：\n\n * executors.newfixedthreadpool(int)\n   \n   执行长期任务性能好，创建一个线程池，一池有n个固定的线程，有固定线程数的线程。\n\n * executors.newsinglethreadexecutor()\n   \n   只有一个线程\n\n * executors.newcachedthreadpool()\n   \n   执行很多短期异步任务，线程池根据需要创建新线程，但在先构建的线程可用时将重用他们。 可扩容，遇强则强\n\npublic class mythreadpooldemo {\n    public static void main(string[] args) {\n        /** 1、池子大小 5 \n         * 模拟有10个顾客过来银行办理业务，池子中只有5个工作人员受理业务\n         */\n//        executorservice threadpool = executors.newfixedthreadpool(5);\n\n\n        /** 2、有且只有一个固定的线程\n         * 模拟有10个顾客过来银行办理业务，池子中只有1个工作人员受理业务\n         */\n//        executorservice threadpool =  executors.newsinglethreadexecutor();\n        \n        /**  3、一池n线程，可扩容伸缩\n         * 模拟有10个顾客过来银行办理业务，池子中n个工作人员受理业务\n         */\n        executorservice threadpool = executors.newcachedthreadpool();\n        \n        try {\n            for (int i = 1; i <= 10; i++) {\n                threadpool.execute(() -> {\n                    system.out.println(thread.currentthread().getname() + " 办理业务");\n                });\n            }\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            threadpool.shutdown(); // 用完记得关闭\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# threadpoolexecutor\n\nthreadpoolexecutor 七大参数\n\n查看三大方法的调用源码，发现本质都是调用了 new threadpoolexecutor ( 7 大参数 )\n\npublic threadpoolexecutor(int corepoolsize,\n                          int maximumpoolsize,\n                          long keepalivetime,\n                          timeunit unit,\n                          blockingqueue<runnable> workqueue,\n                          threadfactory threadfactory,\n                          rejectedexecutionhandler handler) {\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n1、corepollsize\n\n核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corepoolsize 后，就会把到达的任务放到缓存队列当中。\n\n2、maximumpoolsize\n\n最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1。\n\n3、keepalivetime\n\n空闲的线程保留的时间，达到这个时间后，自动释放\n\n4、timeunit\n\n空闲线程的保留时间单位。\n\ntimeunit.days; //天\ntimeunit.hours; //小时\ntimeunit.minutes; //分钟\ntimeunit.seconds; //秒\ntimeunit.milliseconds; //毫秒\ntimeunit.microseconds; //微妙\ntimeunit.nanoseconds; //纳秒\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n5、blockingqueue<runnable> workqueue\n\n阻塞队列，存储等待执行的任务。参数有arrayblockingqueue、 linkedblockingqueue、synchronousqueue可选。\n\n6、threadfactory\n\n线程工厂，用来创建线程，一般默认即可\n\n7、rejectedexecutionhandler\n\n队列已满，而且任务量大于最大线程的异常处理策略。有以下取值\n\nthreadpoolexecutor.abortpolicy:丢弃任务并抛出rejectedexecutionexception异常。\nthreadpoolexecutor.discardpolicy：也是丢弃任务，但是不抛出异常。\nthreadpoolexecutor.discardoldestpolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nthreadpoolexecutor.callerrunspolicy：由调用线程处理该任务\n\n\n1\n2\n3\n4\n\n\nthreadpoolexecutor层工作原理\n\n\n\n举例：8个人进银行办理业务\n\n1、1~2人被受理（核心大小core）\n\n2、3~5人进入队列（queue）\n\n3、6~8人到最大线程池（扩容大小max）\n\n4、再有人进来就要被拒绝策略接受了\n\n\n\n1、在创建了线程池后，开始等待请求。\n\n2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：\n\n * 如果正在运行的线程数量小于corepoolsize，那么马上创建线程运行这个任务\n * 如果正在运行的线程数量大于或等于corepoolsize，那么将这个任务放入队列\n * 如果这个时候队列满了且正在运行的线程数量还小于maximumpoolsize，那么还是要创建非 核心线程立刻运行这个任务\n * 如果队列满了且正在运行的线程数量大于或等于1size，那么线程池会启动饱和拒绝策略来执行。\n\n3、当一个线程完成任务时，它会从队列中取下一个任务来执行\n\n4、 当一个线程无事可做超过一定的时间(keepalivetime)时，线程会判断：\n\n如果当前运行的线程数大于corepollsize，那么这个线程就被停掉。\n\n所以线程池的所有任务完成后，它最终会收缩到 corepoolsize 的大小。\n\n线程池用哪个？生产中如何设置合理参数\n\nexecutors 中 jdk 已经给你提供了，为什么不用？\n\n\n\n代码测试：\n\n线程池的拒绝策略：\n\nrejectedexecutionhandler rejected = null;\n\n//默认，队列满了丢任务，抛出异常\nrejected = new threadpoolexecutor.abortpolicy();\n//队列满了丢任务，不抛出异常【如果允许任务丢失这是最好的】\nrejected = new threadpoolexecutor.discardpolicy();\n//将最早进入队列的任务删，之后再尝试加入队列\nrejected = new threadpoolexecutor.discardoldestpolicy();\n////如果添加到线程池失败，那么主线程会自己去执行该任务，回退\nrejected = new threadpoolexecutor.callerrunspolicy();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\npublic class mythreadpooldemo2 {\n\n    public static void main(string[] args) {\n\n\n        // 自定义 threadpoolexecutor\n        executorservice threadpool = new threadpoolexecutor(\n                2,\n                runtime.getruntime().availableprocessors(),\n                2l,\n                timeunit.seconds,\n                new linkedblockingdeque<>(3),\n                executors.defaultthreadfactory(),\n                new threadpoolexecutor.discardpolicy());\n        try {\n            // 模拟有6,7,8,9,10个顾客过来银行办理业务，观察结果情况\n            // 最大容量为：maximumpoolsize + workqueue = 最大容量数\n            for (int i = 1; i <= 19; i++) {\n                int num = i;\n                threadpool.execute(() -> {\n                    system.out.println(num + " " + thread.currentthread().getname() + " ok");\n                });\n            }\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            threadpool.shutdown(); // 用完记得关闭\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n线程是否越多越好？\n\n一个计算为主的程序（专业一点称为cpu密集型程序）。多线程跑的时候，可以充分利用起所有的 cpu 核心，比如说4个核心的cpu，开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。但是如果线程远远超出cpu核心数量反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。\n\n如果是一个磁盘或网络为主的程序（io密集型）。一个线程处在io等待的时候，另一个线程还可以在 cpu里面跑，有时候cpu闲着没事干，所有的线程都在等着io，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道io的速度比起cpu来是慢到令人发指的。所以开多线程，比 方说多线程网络传输，多线程往不同的目录写文件，等等。此时线程数等于io任务数是最佳的。\n\n\n# 12、四大函数式接口\n\n在java.util.function包下，java 内置核心四大函数式接口，可以使用lambda表达式\n\n\n\n函数型接口，有一个输入，有一个输出\n\nfunction\n\npackage com.oddfar.function;\n\nimport java.util.function.function;\n\n/**\n * @author zhiyuan\n */\npublic class demo01 {\n    public static void main(string[] args) {\n//        function<string,integer> function = new function<string,integer>() {\n//            @override\n//            public integer apply(string s) {\n//                return s.length();\n//            }\n//        };\n\n        function<string,integer> function = (s)->{return  s.length();};\n\n        system.out.println(function.apply("abc"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n断定型接口，有一个输入参数，返回只有布尔值。\n\npredicate\n\npublic class demo02 {\n    public static void main(string[] args) {\n//        predicate<string> predicate = new predicate<string>() {\n//            @override\n//            public boolean test(string s) {\n//                return s.isempty();\n//            }\n//        };\n        predicate<string> predicate = (s)->{return s.isempty();};\n\n        system.out.println(predicate.test("abc"));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n消费型接口，有一个输入参数，没有返回值\n\nconsumer\n\npublic class demo03 {\n    public static void main(string[] args) {\n\n//        consumer<string> consumer = new consumer<string>() {\n//            @override\n//            public void accept(string s) {\n//                system.out.println(s);\n//            }\n//        };\n        consumer<string> consumer = s -> { system.out.println(s); };\n        consumer.accept("abc");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n供给型接口，没有输入参数，只有返回参数\n\nsupplier\n\npublic class demo04 {\n    public static void main(string[] args) {\n//        supplier<string> supplier = new supplier<string>() {\n//            @override\n//            public string get() {\n//                return null;\n//            }\n//        };\n        supplier<string> supplier = () -> { return "abc";};\n        system.out.println(supplier.get());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 13、stream流式计算\n\n流（stream）到底是什么呢？\n\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\n\n“集合讲的是数据，流讲的是计算！”\n\n特点：\n\n * stream 自己不会存储元素\n\n * stream 不会改变源对象，相反，他们会返回一个持有结果的新stream。\n\n * stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。\n\n\n\n代码举例\n\nuser实体类\n\npublic class user {\n    private int id;\n    private string username;\n    private int age;\n    //get、set、有参/无参构造器、tostring\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nstream算法题\n\npackage com.oddfar.stream;\n\nimport java.util.arrays;\nimport java.util.list;\nimport java.util.stream.collectors;\n\n/**\n * 题目：请按照给出数据，找出同时满足以下条件的用户\n * 也即以下条件：\n * 1、全部满足偶数id\n * 2、年龄大于24\n * 3、用户名转为大写\n * 4、用户名字母倒排序\n * 5、只输出一个用户名字 limit\n */\npublic class streamdemo {\n    public static void main(string[] args) {\n        user u1 = new user(11, "a", 23);\n        user u2 = new user(12, "b", 24);\n        user u3 = new user(13, "c", 22);\n        user u4 = new user(14, "d", 28);\n        user u5 = new user(16, "e", 26);\n        list<user> list = arrays.aslist(u1, u2, u3, u4, u5);\n\n        /**\n         * 1. 首先我们需要将 list 转化为stream流\n         * 2. 然后将用户过滤出来，这里用到一个函数式接口 predicate<? super t>，我们可以使用lambda表达式简化\n         * 3. 这里面传递的参数，就是stream流的泛型类型，也就是user，所以，这里可以直接返回用户id为偶数的用户信息;\n         * 4. 通过foreach进行遍历，直接简化输出 system.out::println\n         */\n        list.stream()\n                .filter(u -> {\n                    return u.getid() % 2 == 0;\n                })\n                .filter(u -> {\n                    return u.getage() > 24;\n                })\n                .map(u -> {\n                    return u.getusername().touppercase();\n                })\n                //.sorted() //默认正排序 自己用 compareto 比较\n                .sorted((o1, o2) -> {\n                    return o2.compareto(o1);\n                })\n                .limit(1)\n                .foreach(system.out::println);\n\n\n        // map解释：\n        list<integer> list2 = arrays.aslist(1, 2, 3);\n        list2 = list2.stream().map(x -> {\n            return x * 2;\n        }).collect(collectors.tolist());\n\n        for (integer element : list2) {\n            system.out.println(element);\n        }\n        \n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 14、分支合并\n\n什么是forkjoin\n\n从jdk1.7开始，java提供 fork/join 框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。\n\n这种思想和mapreduce很像（input --\x3e split --\x3e map --\x3e reduce --\x3e output）\n\n主要有两步：\n\n * 第一、任务切分\n * 第二、结果合并\n\n\n\n它的模型大致是这样的：线程池中的每个线程都有自己的工作队列\n\n（ps：这一点和threadpoolexecutor 不同，threadpoolexecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务）\n\n当 自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。\n\n工作窃取\n\n另外，forkjoin有一个工作窃取的概念。简单理解，就是一个工作线程下会维护一个包含多个子任务的双端队列。而对于每个工作线程来说，会从头部到尾部依次执行任务。这时，总会有一些线程执行的速度较快，很快就把所有任务消耗完了。那这个时候怎么办呢，总不能空等着吧，多浪费资源啊。\n\n工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：\n\n\n\n那么为什么需要使用工作窃取算法呢？\n\n假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如a线程负责处理a队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。\n\n工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。\n\n于是，先做完任务的工作线程会从其他未完成任务的线程尾部依次获取任务去执行。这样就可以充分利用cpu的资源。这个非常好理解，就比如有个妹子程序员做任务比较慢，那么其他猿就可以帮她分担一 些任务，这简直是双赢的局面啊，妹子开心了，你也开心了。\n\n核心类\n\n1、forkjoinpool\n\nworkqueue是一个forkjoinpool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。\n\n什么叫线程的任务窃取呢？就是说你和你的一个伙伴一起吃水果，你的那份吃完了，他那份没吃完，那你就偷偷的拿了他的一些水果吃了。存在执行2个任务的子线程，这里要讲成存在a，b两个了。\n\nworkqueue在执行任务，a的任务执行完了，b的任务没执行完，那么a的workqueue就从b的 workqueue的forkjointask数组中拿走了一部分尾部的任务来执行，可以合理的提高运行和计算效率。\n\n每个线程都有一个workqueue，而workqueue中有执行任务的线程（forkjoinworkerthread owner），还有这个线程需要处理的任务（forkjointask<?>[] array）。那么这个新提交的任务就是加到array中。\n\n2、forkjointask\n\nforkjointask代表运行在forkjoinpool中的任务。\n\n主要方法：\n\n * fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务\n * join() 当任务完成的时候返回计算结果。\n * invoke() 开始执行任务，如果必要，等待计算完成。\n\n子类： recursive ：递归\n\n * recursiveaction 一个递归无结果的forkjointask（没有返回值）\n * recursivetask 一个递归有结果的forkjointask（有返回值）\n\n代码测试\n\n核心代码：\n\npackage com.oddfar.forkjoin;\n\nimport java.util.concurrent.recursivetask;\n\n/**\n * @author zhiyuan\n */\npublic class forkjoinwork extends recursivetask<long> {\n\n    private long start;//起始值\n    private long end;//结束值\n    public static final long critical = 10000l;//临界值\n\n    public forkjoinwork(long start, long end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @override\n    protected long compute() {\n        //判断是否是拆分完毕\n        long lenth = end - start;\n        if (lenth <= critical) {\n            //如果拆分完毕就相加\n            long sum = 0l;\n            for (long i = start; i <= end; i++) {\n                sum += i;\n            }\n            return sum;\n        } else {\n            //没有拆分完毕就开始拆分\n            long middle = (end + start) / 2;//计算的两个值的中间值\n            forkjoinwork right = new forkjoinwork(start, middle);\n            right.fork();//拆分，并压入线程队列\n            forkjoinwork left = new forkjoinwork(middle + 1, end);\n            left.fork();//拆分，并压入线程队列\n\n            //合并\n            return right.join() + left.join();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n三种测试：\n\npackage com.oddfar.forkjoin;\n\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.forkjoinpool;\nimport java.util.concurrent.forkjointask;\nimport java.util.stream.longstream;\n\n/**\n * @author zhiyuan\n */\npublic class forkjoinworkdemo {\n    public static void main(string[] args) throws executionexception, interruptedexception {\n        test1();//  15016\n        test2();//  14694\n        test3();//  216\n\n    }\n\n    // forkjoin这个框架针对的是大任务执行，效率才会明显的看出来有提升，于是我把总数调大到20亿。\n    public static void test1() throws executionexception, interruptedexception {\n\n        //forkjoin实现\n        long l = system.currenttimemillis();\n\n        forkjoinpool forkjoinpool = new forkjoinpool();//实现forkjoin 就必须有forkjoinpool的支持\n        forkjointask<long> task = new forkjoinwork(0l, 2000000000l);//参数为起始值与结束值\n        forkjointask<long> result = forkjoinpool.submit(task);\n        long along = result.get();\n\n        long l1 = system.currenttimemillis();\n        system.out.println("invoke = " + along + " time: " + (l1 - l));\n\n    }\n\n\n    public static void test2() {\n        //普通线程实现\n        long x = 0l;\n        long y = 20_0000_0000l;\n        long start_time = system.currenttimemillis();\n        for (long i = 0l; i <= y; i++) {\n            x += i;\n        }\n        long end_time = system.currenttimemillis();\n        system.out.println("invoke = " + x + " time: " + (end_time - start_time));\n\n    }\n\n    public static void test3() {\n        //java 8 并行流的实现\n        long l = system.currenttimemillis();\n\n        long reduce = longstream.rangeclosed(0, 2000000000l).parallel().reduce(0, long::sum);\n\n        long l1 = system.currenttimemillis();\n        system.out.println("invoke = " + reduce + " time: " + (l1 - l));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n打个比方，假设一个酒店有400个房间，一共有4名清洁工，每个工人每天可以打扫100个房间，这样，4 个工人满负荷工作时，400个房间全部打扫完正好需要1天。\n\nfork/join的工作模式就像这样：首先，工人甲被分配了400个房间的任务，他一看任务太多了自己一个 人不行，所以先把400个房间拆成两个200，然后叫来乙，把其中一个200分给乙。紧接着，甲和乙再发现200也是个大任务，于是甲继续把200分成两个100，并把其中一个100分给丙， 类似的，乙会把其中一个100分给丁，这样，最终4个人每人分到100个房间，并发执行正好是1天。\n\n\n# 15、异步回调\n\n概述\n\nfuture设计的初衷：对将来某个时刻会发生的结果进行建模。\n\n当我们需要调用一个函数方法时。如果这个函数执行很慢，那么我们就要进行等待。但有时候，我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。\n\n它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在 future 中出发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。\n\n**future的优点：**比更底层的thread更易用。要使用future，通常只需要将耗时的操作封装在一个 callable对象中，再将它提交给executorservice。\n\n为了让程序更加高效，让cpu最大效率的工作，我们会采用异步编程。首先想到的是开启一个新的线程去做某项工作。再进一步，为了让新线程可以返回一个值，告诉主线程事情做完了，于是乎 future 粉墨登场。然而future提供的方式是主线程主动问询新线程，要是有个回调函数就爽了。所以，为了满足 future的某些遗憾，强大的completablefuture 随着java8一起来了。\n\n\n\n实例\n\n没有返回值的 runasync 异步调用\n\npackage com.oddfar.future;\n\nimport java.util.concurrent.completablefuture;\nimport java.util.concurrent.timeunit;\n\n/**\n * @author zhiyuan\n */\npublic class demo01 {\n    public static void main(string[] args) throws exception {\n\n        //没有返回值的 runasync 异步调用\n        completablefuture<void> completablefuture = completablefuture.runasync(\n                () -> {\n                    try {\n                        timeunit.seconds.sleep(2);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                    int i = 1;\n                    system.out.println(thread.currentthread().getname() + " 没有返回");\n                }\n        );\n\n        system.out.println("111111");\n        completablefuture.get();\n        system.out.println("222222");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n有返回值的 供给型参数接口\n\npublic class demo02 {\n    public static void main(string[] args) throws exception {\n        completablefuture<integer> completablefuture = completablefuture.supplyasync(() -> {\n                    system.out.println(thread.currentthread().getname() + " 有返回值");\n//                    int i = 10 / 0;\n                    return 1024;\n                }\n        );\n\n        integer res = completablefuture.whencomplete((t, u) -> {\n            //编译 完成，正常结束输出\n            system.out.println("===t:" + t); //正常结果\n            system.out.println("===u:" + u); //报错的信息\n        }).exceptionally(e -> { //结果异常，非正常结束\n            system.out.println("=======exception:" + e.getmessage());\n            return 555;\n        }).get();\n\n        system.out.println(res);\n    }\n\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 16、jmm\n\n * 请你谈谈你对 volatile 的理解\n\nvolitile 是 java 虚拟机提供的轻量级的同步机制，三大特性：\n\n1、保证可见性\n\n2、不保证原子性\n\n3、禁止指令重排\n\n什么是jmm\n\njmm 本身是一种抽象的概念，并不真实存在，它描述的是一组规则或者规范~\n\njmm 关于同步的规定：\n\n1、线程解锁前，必须把共享变量的值刷新回主内存\n\n2、线程加锁前，必须读取主内存的最新值到自己的工作内存\n\n3、加锁解锁是同一把锁\n\njmm即为 java 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。jmm从java 5开始的jsr-133发布后，已经成熟和完善起来。\n\njmm规定了内存主要划分为主内存和工作内存两种。此处的主内存和工作内存跟jvm内存划分（堆、 栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。\n\n\n\njvm在设计时候考虑到，如果java线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因此 jmm 制定了 一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。\n\njmm的内存模型\n\n\n\n线程a感知不到线程b操作了值的变化！如何能够保证线程间可以同步感知这个问题呢？只需要使用 volatile关键字即可！volatile 保证线程间变量的可见性，简单地说就是当线程a对变量x进行了修改后， 在线程a后面执行的其他线程能看到变量x的变动，更详细地说是要符合以下两个规则 ：\n\n * 线程对变量进行修改之后，要立刻回写到主内存。\n * 线程对变量读取的时候，要从主内存中读，而不是缓存。\n\n各线程的工作内存间彼此独立，互不可见，在线程启动的时候，虚拟机为每个内存分配一块工作内存， 不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量（非线程内构造的对象）的副本，即，为了提高执行效率。\n\n内存交互操作\n\n内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）\n\n * lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态\n * unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n * read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用\n * load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中\n * use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令\n * assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中\n * store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用\n * write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内 存的变量中\n\njmm对这八种指令的使用，制定了如下规则：\n\n * 不允许read和load、store和write操作之一单独出现。即：使用了read必须load，使用了store必须 write\n * 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存\n * 不允许一个线程将没有assign的数据从工作内存同步回主内存\n * 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作\n * 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁\n * 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前， 必须重新load或assign操作初始化变量的值\n * 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量\n * 对一个变量进行unlock操作之前，必须把此变量同步回主内存\n\njmm对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不 安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分 析。更多的时候，使用java的happen-before规则来进行分析。\n\n * happens-before字面翻译过来就是先行发生，a happens-before b 就是a先行发生于b？\n\n不准确！在java内存模型中，happens-before 应该翻译成：前一个操作的结果可以被后续的操作获取。 讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。\n\n我们再来看看为什么需要这几条规则？\n\n因为我们现在电脑都是多cpu,并且都有缓存，导致多线程直接的可见性问题。\n\n所以为了解决多线程的可见性问题，就搞出了happens-before原则，让线程之间遵守这些原则。编译器 还会优化我们的语句，所以等于是给了编译器优化的约束。不能让它优化的不知道东南西北了！\n\n * 并发bug的源头：https://www.jianshu.com/p/e662bb611360\n\n\n# 17、volatile\n\nvolatile是不错的机制，但是也不能保证原子性。\n\n * 代码验证可见性\n\npublic class jmmvolatiledemo01 {\n    /**\n     * volatile 用来保证数据的同步，也就是可见性\n     * 不加 volatile 就没有可见性，会一直循环\n     */\n    private volatile static int num = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n\n        new thread(() -> {\n            while (num == 0) {\n            }\n        }).start();\n\n        thread.sleep(1000);\n\n        num = 1;\n        system.out.println(num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 验证 volatile 不保证原子性\n\n原子性理解：不可分割，完整性，也就是某个线程正在做某个具体的业务的时候，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败。\n\npublic class jmmvolatiledemo02 {\n    private volatile static int num = 0;\n\n    public  static void add() {\n        num++;\n    }\n\n    // 结果应该是 num 为 2万，测试看结果\n    public static void main(string[] args) throws interruptedexception {\n        for (int i = 1; i <= 20; i++) {\n            new thread(() -> {\n                for (int j = 1; j <= 1000; j++) {\n                    add();\n                }\n            }, string.valueof(i)).start();\n        }\n\n        // 需要等待上面20个线程都全部计算完毕，看最终结果\n        // 默认一个 main线程 一个 gc 线程\n        while (thread.activecount() > 2) {\n            thread.yield();\n        }\n        system.out.println(thread.currentthread().getname() + " " + num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n为我们的 add 方法没有加锁，加了 volatile ，说明 volatile 不能保证原子性；\n\n命令行查看底层字节码代码： javap -c jmmvolatiledemo02.class\n\n\n\nnum++ 在多线程下是非线程安全的，如何不加 synchronized解决？\n\n查看原子包下的类\n\npublic class jmmvolatiledemo02 {\n    private volatile static atomicinteger num = new atomicinteger();\n\n    public static void add() {\n        num.getandincrement(); // 等价 num++\n    }\n\n    // 结果应该是 num 为 2万，测试看结果\n    public static void main(string[] args) throws interruptedexception {\n        for (int i = 1; i <= 20; i++) {\n            new thread(() -> {\n                for (int j = 1; j <= 1000; j++) {\n                    add();\n                }\n            }, string.valueof(i)).start();\n        }\n\n        // 需要等待上面20个线程都全部计算完毕，看最终结果\n        // 默认一个 main线程 一个 gc 线程\n        while (thread.activecount() > 2) {\n            thread.yield();\n        }\n        system.out.println(thread.currentthread().getname() + " " + num);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n指令重排\n\n计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排\n\n\n\n一般分以下3种问题：\n\n单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。\n\n处理器在进行重排序时必须要考虑指令之间的数据依赖性。\n\n多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。\n\n指令重排是什么\n\n指令队列在cpu执行时不是串行的, 当某条指令执行时消耗较多时间时, cpu资源足够时并不会在此无意义的等待, 而是开启下一个指令. 开启下一条指令是有条件的, 即上一条指令和下一条指令不存在相关性. 例如下面这个例子:\n\na /= 2;   // 指令a\na /= 2;   // 指令b\nc++;      // 指令c\n\n\n1\n2\n3\n\n\n里的指令b是依赖于指令a的执行结果的, 在a处于执行阶段时, b会被阻塞, 直到a执行完成. 而指令c与a/b均没有依赖关系, 所以在a执行或者b执行的过程中, c会同时被执行, 那么c有可能在a+b的执行过程中就执行完毕了, 这样指令队列的实际执行顺序就是 c->a->b 或者 a->c->b.\n\n\n\n指令重排小结：\n\nvolatile 实现了禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象\n\n先了解一个概念，内存屏障（memory barrier）又称内存栅栏，是一个cpu 指令，它的作用有两个：\n\n1、保证特定操作的执行顺序。\n\n2、保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。\n\n由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条 memory barrier 则会告诉编译器和cpu，不管什么指令都不能和这条 memory barrier 指令重排序，也就是说，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种cpu的缓存数据，因此任何cpu上的线程都能读取到这些数据的最新版本。\n\n\n\n经过，可见性，原子性，指令重排的话，线程安全性获得保证：\n\n对于指令重排导致的可见性问题 和 有序性问题，可以利用 volatile 关键字解决，因为 volatile 的另外一 个作用就是禁止重排序优化。\n\n\n# 18、单例模式\n\n如何防止反射 破坏单例模式？\n\n推荐阅读：单例模式 | 菜鸟教程\n\n\n# 饿汉式\n\npublic class hungry {\n    private hungry() {\n    }\n\n    private final static hungry hungry = new hungry();\n\n    public static hungry getinstance() {\n        return hungry;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n饿汉式是最简单的单例模式的写法，保证了线程的安全\n\n但饿汉式会有一点小问题，看下面的代码：\n\npublic class hungry {\n    private byte[] data1 = new byte[1024];\n    private byte[] data2 = new byte[1024];\n    private byte[] data3 = new byte[1024];\n    private byte[] data4 = new byte[1024];\n    \n    private hungry() {\n    }\n\n    private final static hungry hungry = new hungry();\n\n    public static hungry getinstance() {\n        return hungry;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在 hungry 类中，我定义了四个byte数组，当代码一运行，这四个数组就被初始化，并且放入内存了，如果长时间没有用到getinstance方法，不需要hungry类的对象，这不是一种浪费吗？我希望的是只有用 到了 getinstance 方法，才会去初始化单例类，才会加载单例类中的数据。所以就有了第二种单例模式：懒汉式\n\n\n# 懒汉式\n\npublic class lazyman {\n    private lazyman() {\n        system.out.println(thread.currentthread().getname() + "start");\n    }\n\n    private static lazyman lazyman;\n\n    public static lazyman getinstance() {\n        if (lazyman == null) {\n            lazyman = new lazyman();\n        }\n        return lazyman;\n    }\n\n    // 测试并发环境，发现单例失效\n    public static void main(string[] args) {\n        for (int i = 0; i < 10; i++) {\n            new thread(() -> {\n                lazyman.getinstance();\n            }).start();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n多加一层检测可以避免问题，也就是dcl懒汉式！\n\npublic class lazyman {\n    private lazyman() {\n    }\n\n    private static lazyman lazyman;\n\n    public static lazyman getinstance() {\n        if (lazyman == null) {\n            synchronized (lazyman.class) {\n                if (lazyman == null) {\n                    lazyman = new lazyman();\n                }\n            }\n        }\n        return lazyman;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ndcl懒汉式的单例，保证了线程的安全性，又符合了懒加载，只有在用到的时候，才会去初始化，调用 效率也比较高，但是这种写法在极端情况还是可能会有一定的问题。\n\n因为 lazyman = new lazyman(); 不是原子性操作，至少会经过三个步骤：\n\n 1. 分配对象内存空间\n 2. 执行构造方法初始化对象\n 3. 设置instance指向刚分配的内存地址，此时 instance ！=null；\n\n由于指令重排，导致a线程执行 lazyman = new lazyman(); 的时候，可能先执行了第三步（还没执行第 二步），由于线程调度，当线程b进来时，发现 lazyman 已经不为空了，直接返回了lazyman，并且后面使用了返回的lazyman，由于线程a还没有执行第二步，导致此时lazyman还不完整，可能会有一些意想不到的错误，所以就有了下面一种单例模式。\n\n这种单例模式只是在上面dcl单例模式增加一个volatile关键字来避免指令重排：\n\npublic class lazyman {\n    private lazyman() {\n    }\n\n    private volatile static lazyman lazyman;\n\n    public static lazyman getinstance() {\n        if (lazyman == null) {\n            synchronized (lazyman.class) {\n                if (lazyman == null) {\n                    lazyman = new lazyman();\n                }\n            }\n        }\n        return lazyman;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 静态内部类\n\n还有这种方式是第一种饿汉式的改进版本，同样也是在类中定义static变量的对象，并且直接初始化，不 过是移到了静态内部类中，十分巧妙。既保证了线程的安全性，同时又满足了懒加载。\n\npublic class holder {\n    private holder() {\n    }\n\n    public static holder getinstance() {\n        return innerclass.holder;\n    }\n\n    private static class innerclass {\n        private static final holder holder = new holder();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 万恶的反射\n\n万恶的反射登场了，反射是一个比较霸道的东西，无视private修饰的构造方法，可以直接在外面 newinstance，破坏我们辛辛苦苦写的单例模式。\n\npublic class singletonpatterndemo {\n    public static void main(string[] args) throws exception {\n        lazyman lazyman1 = lazyman.getinstance();\n\n        constructor<lazyman> declaredconstructor = lazyman.class.getdeclaredconstructor(null);\n        declaredconstructor.setaccessible(true);\n        lazyman lazyman2 = declaredconstructor.newinstance();\n        \n        system.out.println(lazyman1.hashcode());\n        system.out.println(lazyman2.hashcode());\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们分别打印出lazyman1，lazyman2的hashcode，发现不相等\n\n那么，怎么解决这种问题呢？\n\n在私有的构造函数中做一个判断，如果lazyman不为空，说明lazyman已经被创建过了，如果正常调用 getinstance方法，是不会出现这种事情的，所以直接抛出异常！\n\npublic class lazyman {\n    private lazyman() {\n        synchronized (lazyman.class) {\n            if (lazyman != null) {\n                throw new runtimeexception("不要试图用反射破坏单例模式");\n            }\n        }\n    }\n\n    private static lazyman lazyman;\n\n    public static lazyman getinstance() {\n        if (lazyman == null) {\n            synchronized (lazyman.class) {\n                if (lazyman == null) {\n                    lazyman = new lazyman();\n                }\n            }\n        }\n        return lazyman;\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n但是这种写法还是有问题：\n\n上面我们是先正常的调用了getinstance方法，创建了lazyman对象，所以第二次用反射创建对象，私有构造函数里面的判断起作用了，反射破坏单例模式失败。但是如果破坏者干脆不先调用getinstance方 法，一上来就直接用反射创建对象，我们的判断就不生效了：\n\n那么如何防止这种反射破坏呢？\n\npublic class lazyman {\n    private static boolean flag = false;\n\n    private lazyman() {\n        synchronized (lazyman.class) {\n            if (flag == false) {\n                flag = true;\n            } else {\n                throw new runtimeexception("不要试图用反射破坏单例模式");\n            }\n        }\n    }\n\n    private static lazyman lazyman;\n\n    public static lazyman getinstance() {\n        if (lazyman == null) {\n            synchronized (lazyman.class) {\n                if (lazyman == null) {\n                    lazyman = new lazyman();\n                }\n            }\n        }\n        return lazyman;\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在这里，我定义了一个boolean变量flag，初始值是false，私有构造函数里面做了一个判断，如果 flag=false，就把flag改为true，但是如果flag等于true，就说明有问题了，因为正常的调用是不会第二 次跑到私有构造方法的，所以抛出异常。\n\n看起来很美好，但是还是不能完全防止反射破坏单例模式，因为可以利用反射修改flag的值。\n\npublic class singletonpatterndemo {\n    public static void main(string[] args) throws exception {\n\n\n        constructor<lazyman> declaredconstructor = lazyman.class.getdeclaredconstructor(null);\n        field field = lazyman.class.getdeclaredfield("flag");\n        field.setaccessible(true);\n\n        // 通过反射实例化对象\n        declaredconstructor.setaccessible(true);\n        lazyman lazyman1 = declaredconstructor.newinstance();\n        system.out.println(field.get(lazyman1));\n        system.out.println(lazyman1.hashcode());\n\n        //通过反射，修改字段的值！\n        field.set(lazyman1, false);\n        lazyman lazyman2 = declaredconstructor.newinstance();\n        system.out.println(field.get(lazyman2));\n        system.out.println(lazyman2.hashcode());\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n并没有一个很好的方案去避免反射破坏单例模式，所以轮到我们的枚举登场了。\n\n\n# 枚举\n\n枚举类型是java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类 (class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性 以及便捷性。\n\npublic enum enumsingleton {\n\n    instance;\n    public enumsingleton getinstance(){\n        return instance;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n枚举是目前最推荐的单例模式的写法，因为足够简单，不需要开发自己保证线程的安全，同时又可以有 效的防止反射破坏我们的单例模式\n\n\n# 19、cas\n\ncas（conmpare and swap） : 比较和交换\n\njava1.5开始引入了cas，主要代码都放在juc的atomic包下\n\npublic class casdemo {\n    public static void main(string[] args) {\n        //真实值为 5 \n        atomicinteger atomicinteger = new atomicinteger(5);\n\n        // 期望的是5，后面改为 2020 ， 所以结果为 true，2020\n        atomicinteger.compareandset(5, 2020);\n        system.out.println(atomicinteger.get());\n        // 期望的是5，后面改为 1024 ， 所以结果为 false，2020\n        system.out.println(atomicinteger.compareandset(5, 1024) + "=>" + atomicinteger.get());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n真实值和期望值相同，就修改成功，真实值和期望值不同，就修改失败！\n\n分析源码，如何实现的 i++ 安全的问题：atomicinteger.getandincrement();\n\npublic final int getandincrement() {\n    // this 当前对象\n\t// valueoffset 内存偏移量，内存地址\n\t// 1\t固定写死\n    return unsafe.getandaddint(this, valueoffset, 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n跳转到 unsafe\n\n\n\n且这个类中的方法大部分都是 native 的方法了！\n\n * 问题：这个unsafe类到底是什么？\n\n1、unsafe\n\nunsafe是 cas 的核心类，由于java方法无法直接访问底层系统，需要通过本地（native）方法来访问， unsafe相当于一个后门，基于该类可以直接操作特定内存的数据，unsafe类存在于 sun.misc 包中，其内部方法操作可以像c的指针一样直接操作内存，因为java中cas操作的执行依赖于unsafe类的方法。\n\n2、变量valueoffset\n\n表示该变量值在内存中的偏移地址，因为unsafe就是根据内存偏移地址获取数据的\n\n3、变量 value用volatile修饰，保证了多线程之间的内存可见性\n\n最后解释cas 是什么\n\ncas 的全称为 compare-and-swap，它是一条cpu并发原语。\n\n它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。\n\ncas并发原语体现在java语言中就是 sun.misc.unsafe 类中的各个方法。调用 unsafe类中的 cas 方法， jvm会帮我们实现出cas汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于cas是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功 能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说cas是一条 cpu 的原子指令，不会造成所谓的数据不一致问题。\n\npublic final int getandaddint(object var1, long var2, int var4) {\n    int var5;\n    do {\n        // 获取传入对象的地址\n        var5 = this.getintvolatile(var1, var2);\n        // 比较并交换，如果var1，var2 还是原来的 var5，就执行内存偏移+1； var5 +var4\n    } while(!this.compareandswapint(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n汇编层面理解\n\nunsafe 类中的 compareandswapint，是一个本地方法，该方法的实现位于 unsafe.cpp 中；\n\n\n\n总结\n\ncas（compareandswap）：\n\n比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。\n\ncas 应用：\n\ncas 有3个操作数，内存值v，旧的预期值a，要修改的更新值b。且仅当预期值a 和 内存值 v 相同时， 将内存值 v 修改为b，否则什么都不做。\n\ncas 的缺点：\n\n1、循环时间长开销很大。\n\n可以看到源码中存在 一个 do...while 操作，如果cas失败就会一直进行尝试。\n\n2、只能保证一个共享变量的原子操作。\n\n当对一个共享变量执行操作时，我们可以使用循环cas的方式来保证原子操作。但是，对多个共享变量操作时，循环cas就无法保证操作的原子性，这时候就可以用锁来保证原子性\n\n3、cas实现的过程是先取出内存中某时刻的数据，在下一时刻比较并替换，那么在这个时间差会导致数据的变化，此时就会导致出现“aba”问题\n\n什么是”aba”问题？\n\n比如说一个线程one从内存位置v中取出a，这时候另一个线程two也从内存中取出a，并且two进行了一些操作变成了b，然后two又将v位置的数据变成a，这时候线程one进行cas操作发现内存中仍然是a，然后one操作成功。\n\n尽管线程one的cas操作成功，但是不代表这个过程就是没有问题的。\n\n\n# 20、原子引用\n\ndemo：\n\npublic class atomicreferencedemo {\n    public static void main(string[] args) {\n\n        user zhangsan = new user("zhangsan", 22);\n        user lisi = new user("lisi", 25);\n\n        atomicreference<user> atomicreference = new atomicreference<>();\n        atomicreference.set(zhangsan); // 设置\n\n        // 期望的是zhangsan，后面改为 lisi ， 所以结果为 true，\n        system.out.print(atomicreference.compareandset(zhangsan, lisi)+"=>");\n        system.out.println(atomicreference.get().tostring());\n        // 期望的是zhangsan，后面改为 lisi ， 所以结果为 flase，\n        system.out.print(atomicreference.compareandset(zhangsan, lisi));\n        system.out.println(atomicreference.get().tostring());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n原子引用 atomicreference 解决aba问题\n\n要解决aba问题，我们就需要加一个版本号\n\n版本号原子引用，类似乐观锁\n\npublic class abasavedemo {\n    static atomicstampedreference<integer> atomicstampedreference = new atomicstampedreference<>(100, 1);\n\n\n    public static void main(string[] args) {\n\n        new thread(() -> {\n            int stamp = atomicstampedreference.getstamp(); // 获得版本号\n            system.out.println("t1 stamp 01=>" + stamp);\n            // 暂停2秒钟，保证下面线程获得初始版本号\n            try {\n                timeunit.seconds.sleep(1);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n            atomicstampedreference.compareandset(100, 101,\n                    atomicstampedreference.getstamp(), atomicstampedreference.getstamp() + 1);\n\n            system.out.println("t1 stamp 02=>" + atomicstampedreference.getstamp());\n\n            atomicstampedreference.compareandset(101, 100,\n                    atomicstampedreference.getstamp(), atomicstampedreference.getstamp() + 1);\n\n            system.out.println("t1 stamp 03=>" + atomicstampedreference.getstamp());\n        }, "t1").start();\n\n\n        new thread(() -> {\n            int stamp = atomicstampedreference.getstamp(); // 获得版本号\n            system.out.println("t2 stamp 01=>" + stamp);\n\t\t\t// 暂停3秒钟，保证上面线程先执行\n            try {\n                timeunit.seconds.sleep(3);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n            boolean result = atomicstampedreference.compareandset(100, 2019,\n                    stamp, stamp + 1);\n            system.out.println("t2 是否修改成功 =>" + result);\n            system.out.println("t2 最新stamp =>" + atomicstampedreference.getstamp());\n            system.out.println("t2 当前的最新值  =>" + atomicstampedreference.getreference());\n        }, "t2").start();\n\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 21、java锁\n\n\n# 公平锁非公平锁\n\n公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。\n\n非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比现申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。\n\n// 无参\npublic reentrantlock() {\n\tsync = new nonfairsync();\n}\n// 有参\npublic reentrantlock(boolean fair) {\n\tsync = fair ? new fairsync() : new nonfairsync();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n两者区别\n\n并发包中的 reentrantlock 的创建可以指定构造函数的 boolean 类型来得到公平锁或者非公平锁，默认是非公平锁！\n\n公平锁：就是很公平，在并发环境中，每个线程在获取到锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照fifo的规则从队列中取到自己。\n\n非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就会采用类似公平锁那种方式。\n\njava reentrantlock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在 于吞吐量比公平锁大。\n\n对于synchronized而言，也是一种非公平锁。\n\n\n# 可重入锁\n\n可重入锁（也叫递归锁）\n\n指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法 获取锁的时候，在进入内层方法会自动获取锁。\n\n也就是说，线程可以进入任何一个它已经拥有的锁，所同步着的代码块。 好比家里进入大门之后，就可以进入里面的房间了；\n\nreentrantlock、synchronized 就是一个典型的可重入锁；\n\n可重入锁最大的作用就是避免死锁\n\n测试一：synchronized\n\npublic class reentrantlockdemo {\n    public static void main(string[] args) {\n        phone phone = new phone();\n        // t1 线程在外层获取锁时，也会自动获取里面的锁\n        new thread(() -> {\n            phone.sendsms();\n        }, "t1").start();\n\n        new thread(() -> {\n            phone.sendsms();\n        }, "t2").start();\n\n    }\n}\nclass phone {\n    public synchronized void sendsms() {\n        system.out.println(thread.currentthread().getname() + " sendsms");\n        sendemail();\n    }\n\n    public synchronized void sendemail() {\n        system.out.println(thread.currentthread().getname() + " sendemail");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n测试二：reentrantlock\n\npublic class reentrantlockdemo {\n    public static void main(string[] args) {\n        phone phone = new phone();\n        // t1 线程在外层获取锁时，也会自动获取里面的锁\n        new thread(phone, "t1").start();\n        new thread(phone, "t2").start();\n\n    }\n}\n\nclass phone implements runnable {\n\n    lock lock = new reentrantlock();\n\n    @override\n    public void run() {\n        get();\n    }\n\n    public void get() {\n        lock.lock();\n        // lock.lock(); 锁必须匹配，如果两个锁，只有一个解锁就会失败\n        try {\n            system.out.println(thread.currentthread().getname() + " get()");\n            set();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n            // lock.lock();\n        }\n\n    }\n\n    public void set() {\n        lock.lock();\n        try {\n            system.out.println(thread.currentthread().getname() + " set()");\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 自旋锁\n\n自旋锁（spinlock），是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗cpu。\n\npublic class spinlockdemo {\n    // 原子引用线程, 没写参数，引用类型默认为null\n    atomicreference<thread> atomicreference = new atomicreference<>();\n\n    //上锁\n    public void mylock() {\n        thread thread = thread.currentthread();\n        system.out.println(thread.currentthread().getname() + "==>mylock");\n        // 自旋\n        while (!atomicreference.compareandset(null, thread)) {\n        }\n    }\n\n    //解锁\n    public void myunlock() {\n        thread thread = thread.currentthread();\n        atomicreference.compareandset(thread, null);\n        system.out.println(thread.currentthread().getname() + "==>myunlock");\n    }\n\n    public static void main(string[] args) throws interruptedexception {\n        spinlockdemo spinlockdemo = new spinlockdemo();\n\n        new thread(() -> {\n            spinlockdemo.mylock();\n            try {\n                timeunit.seconds.sleep(4);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            spinlockdemo.myunlock();\n        }, "t1").start();\n\n        timeunit.seconds.sleep(1);\n\n        new thread(() -> {\n            spinlockdemo.mylock();\n\n            try {\n                timeunit.seconds.sleep(1);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n            spinlockdemo.myunlock();\n        }, "t2").start();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 死锁\n\n死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否者就会因为争夺有限的资源而陷入死锁。\n\n\n\n产生死锁主要原因：\n\n1、系统资源不足\n\n2、进程运行推进的顺序不合适\n\n3、资源分配不当\n\n测试：\n\npublic class deadlockdemo {\n    public static void main(string[] args) {\n        string locka = "locka";\n        string lockb = "lockb";\n        new thread(new holdlockthread(locka, lockb), "t1").start();\n        new thread(new holdlockthread(lockb, locka), "t2").start();\n    }\n}\n\nclass holdlockthread implements runnable {\n    private string locka;\n    private string lockb;\n\n    public holdlockthread(string locka, string lockb) {\n        this.locka = locka;\n        this.lockb = lockb;\n    }\n\n    @override\n    public void run() {\n        synchronized (locka) {\n\n            system.out.println(thread.currentthread().getname() + "lock:" + locka + "=>get" + lockb);\n            try {\n                timeunit.seconds.sleep(2);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n            synchronized (lockb) {\n                system.out.println(thread.currentthread().getname() + "lock:" + lockb + "=>get" + locka);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n解决\n\n1、查看jdk目录的bin目录\n\n2、使用 jps -l 命令定位进程号\n\n3、使用 jstack 进程号 找到死锁查看\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaWeb - 基本概念",frontmatter:{title:"JavaWeb - 基本概念",categories:["java","java-web"],date:"2021-05-15T18:09:11.000Z",permalink:"/pages/5916e7/"},regularPath:"/01.Java/20.JavaWeb/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"01.Java/20.JavaWeb/01.基本概念.md",key:"v-4bb79bd0",path:"/pages/5916e7/",headers:[{level:2,title:"1、基本概念",slug:"_1、基本概念",normalizedTitle:"1、基本概念",charIndex:29},{level:3,title:"1.1、前言",slug:"_1-1、前言",normalizedTitle:"1.1、前言",charIndex:40},{level:3,title:"1.2、web应用程序",slug:"_1-2、web应用程序",normalizedTitle:"1.2、web应用程序",charIndex:274},{level:3,title:"1.3、静态web",slug:"_1-3、静态web",normalizedTitle:"1.3、静态web",charIndex:611},{level:3,title:"1.4、动态web",slug:"_1-4、动态web",normalizedTitle:"1.4、动态web",charIndex:831},{level:2,title:"2、web服务器",slug:"_2、web服务器",normalizedTitle:"2、web服务器",charIndex:1016},{level:3,title:"2.1、技术讲解",slug:"_2-1、技术讲解",normalizedTitle:"2.1、技术讲解",charIndex:1029},{level:3,title:"2.2、web服务器",slug:"_2-2、web服务器",normalizedTitle:"2.2、web服务器",charIndex:1723}],headersStr:"1、基本概念 1.1、前言 1.2、web应用程序 1.3、静态web 1.4、动态web 2、web服务器 2.1、技术讲解 2.2、web服务器",content:'JavaWeb笔记转载于狂神笔记，稍修改了点内容\n\n\n# 1、基本概念\n\n\n# 1.1、前言\n\nweb开发：\n\n * web，网页的意思 ， www.baidu.com\n * 静态web\n   * html，css\n   * 提供给所有人看的数据始终不会发生变化！\n * 动态web\n   * 淘宝，几乎是所有的网站；\n   * 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！\n   * 技术栈：Servlet/JSP，ASP，PHP\n\n在Java中，动态web资源开发的技术统称为JavaWeb；\n\n\n# 1.2、web应用程序\n\nweb应用程序：可以提供浏览器访问的程序；\n\n * a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；\n * 你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。\n * URL\n * 这个统一的web资源会被放在同一个文件夹下，web应用程序--\x3eTomcat：服务器\n * 一个web应用由多部分组成 （静态web，动态web）\n   * html，css，js\n   * jsp，servlet\n   * Java程序\n   * jar包\n   * 配置文件 （Properties）\n\nweb应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；\n\n\n# 1.3、静态web\n\n * *.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；\n\n\n\n * 静态web存在的缺点\n   * Web页面无法动态更新，所有用户看到都是同一个页面\n     * 轮播图，点击特效：伪动态\n     * JavaScript [实际开发中，它用的最多]\n     * VBScript\n   * 它无法和数据库交互（数据无法持久化，用户无法交互）\n\n\n# 1.4、动态web\n\n页面会动态展示： “Web的页面展示的效果因人而异”；\n\n\n\n缺点：\n\n * 加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序,重新发布；\n   * 停机维护\n\n优点：\n\n * Web页面可以动态更新，所有用户看到都不是同一个页面\n * 它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）\n\n\n\n\n# 2、web服务器\n\n\n# 2.1、技术讲解\n\nASP:\n\n * 微软：国内最早流行的就是ASP；\n\n * 在HTML中嵌入了VB的脚本， ASP + COM；\n\n * 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱\n\n * 维护成本高！\n\n * C#\n\n * IIS\n   \n   <h1>\n       <h1><h1>\n           <h1>\n               <h1>\n                   <h1>\n           <h1>\n               <%\n               System.out.println("hello")\n               %>\n               <h1>\n                   <h1>\n      <h1><h1>\n   <h1>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\nphp：\n\n * PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）\n * 无法承载大访问量的情况（局限性）\n\n**JSP/Servlet : **\n\nB/S：浏览和服务器\n\nC/S: 客户端和服务器\n\n * sun公司主推的B/S架构\n * 基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)\n * 可以承载三高问题带来的影响；\n * 语法像ASP ， ASP--\x3eJSP , 加强市场强度；\n\n.....\n\n\n# 2.2、web服务器\n\n服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；\n\nIIS\n\n微软的； ASP...,Windows中自带的\n\nTomcat\n\n\n\n面向百度编程；\n\nTomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。\n\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择\n\nTomcat 实际上运行JSP 页面和Servlet。\n\n....\n\n工作3-5年之后，可以尝试手写Tomcat服务器；\n\n下载tomcat：\n\n 1. 安装 or 解压\n 2. 了解配置文件及目录结构\n 3. 这个东西的作用',normalizedContent:'javaweb笔记转载于狂神笔记，稍修改了点内容\n\n\n# 1、基本概念\n\n\n# 1.1、前言\n\nweb开发：\n\n * web，网页的意思 ， www.baidu.com\n * 静态web\n   * html，css\n   * 提供给所有人看的数据始终不会发生变化！\n * 动态web\n   * 淘宝，几乎是所有的网站；\n   * 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！\n   * 技术栈：servlet/jsp，asp，php\n\n在java中，动态web资源开发的技术统称为javaweb；\n\n\n# 1.2、web应用程序\n\nweb应用程序：可以提供浏览器访问的程序；\n\n * a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；\n * 你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。\n * url\n * 这个统一的web资源会被放在同一个文件夹下，web应用程序--\x3etomcat：服务器\n * 一个web应用由多部分组成 （静态web，动态web）\n   * html，css，js\n   * jsp，servlet\n   * java程序\n   * jar包\n   * 配置文件 （properties）\n\nweb应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；\n\n\n# 1.3、静态web\n\n * *.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；\n\n\n\n * 静态web存在的缺点\n   * web页面无法动态更新，所有用户看到都是同一个页面\n     * 轮播图，点击特效：伪动态\n     * javascript [实际开发中，它用的最多]\n     * vbscript\n   * 它无法和数据库交互（数据无法持久化，用户无法交互）\n\n\n# 1.4、动态web\n\n页面会动态展示： “web的页面展示的效果因人而异”；\n\n\n\n缺点：\n\n * 加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序,重新发布；\n   * 停机维护\n\n优点：\n\n * web页面可以动态更新，所有用户看到都不是同一个页面\n * 它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）\n\n\n\n\n# 2、web服务器\n\n\n# 2.1、技术讲解\n\nasp:\n\n * 微软：国内最早流行的就是asp；\n\n * 在html中嵌入了vb的脚本， asp + com；\n\n * 在asp开发中，基本一个页面都有几千行的业务代码，页面极其换乱\n\n * 维护成本高！\n\n * c#\n\n * iis\n   \n   <h1>\n       <h1><h1>\n           <h1>\n               <h1>\n                   <h1>\n           <h1>\n               <%\n               system.out.println("hello")\n               %>\n               <h1>\n                   <h1>\n      <h1><h1>\n   <h1>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\nphp：\n\n * php开发速度很快，功能很强大，跨平台，代码很简单 （70% , wp）\n * 无法承载大访问量的情况（局限性）\n\n**jsp/servlet : **\n\nb/s：浏览和服务器\n\nc/s: 客户端和服务器\n\n * sun公司主推的b/s架构\n * 基于java语言的 (所有的大公司，或者一些开源的组件，都是用java写的)\n * 可以承载三高问题带来的影响；\n * 语法像asp ， asp--\x3ejsp , 加强市场强度；\n\n.....\n\n\n# 2.2、web服务器\n\n服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；\n\niis\n\n微软的； asp...,windows中自带的\n\ntomcat\n\n\n\n面向百度编程；\n\ntomcat是apache 软件基金会（apache software foundation）的jakarta 项目中的一个核心项目，最新的servlet 和jsp 规范总是能在tomcat 中得到体现，因为tomcat 技术先进、性能稳定，而且免费，因而深受java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的web 应用服务器。\n\ntomcat 服务器是一个免费的开放源代码的web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试jsp 程序的首选。对于一个java初学web的人来说，它是最佳的选择\n\ntomcat 实际上运行jsp 页面和servlet。\n\n....\n\n工作3-5年之后，可以尝试手写tomcat服务器；\n\n下载tomcat：\n\n 1. 安装 or 解压\n 2. 了解配置文件及目录结构\n 3. 这个东西的作用',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaWeb - Tomcat",frontmatter:{title:"JavaWeb - Tomcat",categories:["java","java-web"],date:"2021-05-09T12:09:00.000Z",permalink:"/pages/1ccdff/"},regularPath:"/01.Java/20.JavaWeb/02.Tomcat.html",relativePath:"01.Java/20.JavaWeb/02.Tomcat.md",key:"v-e2d344f2",path:"/pages/1ccdff/",headers:[{level:2,title:"3.1、 安装tomcat",slug:"_3-1、-安装tomcat",normalizedTitle:"3.1、 安装tomcat",charIndex:15},{level:2,title:"3.2、Tomcat启动和配置",slug:"_3-2、tomcat启动和配置",normalizedTitle:"3.2、tomcat启动和配置",charIndex:73},{level:2,title:"3.3、配置",slug:"_3-3、配置",normalizedTitle:"3.3、配置",charIndex:209},{level:3,title:"高难度面试题：",slug:"高难度面试题",normalizedTitle:"高难度面试题：",charIndex:591},{level:2,title:"3.4、发布一个web网站",slug:"_3-4、发布一个web网站",normalizedTitle:"3.4、发布一个web网站",charIndex:907}],headersStr:"3.1、 安装tomcat 3.2、Tomcat启动和配置 3.3、配置 高难度面试题： 3.4、发布一个web网站",content:'# 3、Tomcat\n\n\n# 3.1、 安装tomcat\n\ntomcat官网：http://tomcat.apache.org/\n\n\n\n\n\n\n# 3.2、Tomcat启动和配置\n\n文件夹作用：\n\n\n\n启动。关闭Tomcat\n\n\n\n访问测试：http://localhost:8080/\n\n可能遇到的问题：\n\n 1. Java环境变量没有配置\n 2. 闪退问题：需要配置兼容性\n 3. 乱码问题：配置文件中设置\n\n\n# 3.3、配置\n\n\n\n可以配置启动的端口号\n\n * tomcat的默认端口号为：8080\n * mysql：3306\n * http：80\n * https：443\n\n<Connector port="8081" protocol="HTTP/1.1"\n           connectionTimeout="20000"\n           redirectPort="8443" />\n\n\n1\n2\n3\n\n\n可以配置主机的名称\n\n * 默认的主机名为：localhost->127.0.0.1\n * 默认网站应用存放的位置为：webapps\n\n  <Host name="www.qinjiang.com"  appBase="webapps"\n        unpackWARs="true" autoDeploy="true">\n\n\n1\n2\n\n\n\n# 高难度面试题：\n\n请你谈谈网站是如何进行访问的！\n\n 1. 输入一个域名；回车\n\n 2. 检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射；\n    \n    1. 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问\n       \n       127.0.0.1       www.qinjiang.com\n       \n       \n       1\n       \n    \n    2. 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；\n    \n    \n\n 3. 可以配置一下环境变量（可选性）\n\n\n# 3.4、发布一个web网站\n\n不会就先模仿\n\n * 将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了\n\n网站应该有的结构\n\n--webapps ：Tomcat服务器的web目录\n\t-ROOT\n\t-kuangstudy ：网站的目录名\n\t\t- WEB-INF\n\t\t\t-classes : java程序\n\t\t\t-lib：web应用所依赖的jar包\n\t\t\t-web.xml ：网站配置文件\n\t\t- index.html 默认的首页\n\t\t- static \n            -css\n            \t-style.css\n            -js\n            -img\n         -.....\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nHTTP协议 ： 面试\n\nMaven：构建工具\n\n * Maven安装包\n\nServlet 入门\n\n * HelloWorld！\n * Servlet配置\n * 原理',normalizedContent:'# 3、tomcat\n\n\n# 3.1、 安装tomcat\n\ntomcat官网：http://tomcat.apache.org/\n\n\n\n\n\n\n# 3.2、tomcat启动和配置\n\n文件夹作用：\n\n\n\n启动。关闭tomcat\n\n\n\n访问测试：http://localhost:8080/\n\n可能遇到的问题：\n\n 1. java环境变量没有配置\n 2. 闪退问题：需要配置兼容性\n 3. 乱码问题：配置文件中设置\n\n\n# 3.3、配置\n\n\n\n可以配置启动的端口号\n\n * tomcat的默认端口号为：8080\n * mysql：3306\n * http：80\n * https：443\n\n<connector port="8081" protocol="http/1.1"\n           connectiontimeout="20000"\n           redirectport="8443" />\n\n\n1\n2\n3\n\n\n可以配置主机的名称\n\n * 默认的主机名为：localhost->127.0.0.1\n * 默认网站应用存放的位置为：webapps\n\n  <host name="www.qinjiang.com"  appbase="webapps"\n        unpackwars="true" autodeploy="true">\n\n\n1\n2\n\n\n\n# 高难度面试题：\n\n请你谈谈网站是如何进行访问的！\n\n 1. 输入一个域名；回车\n\n 2. 检查本机的 c:\\windows\\system32\\drivers\\etc\\hosts配置文件下有没有这个域名映射；\n    \n    1. 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问\n       \n       127.0.0.1       www.qinjiang.com\n       \n       \n       1\n       \n    \n    2. 没有：去dns服务器找，找到的话就返回，找不到就返回找不到；\n    \n    \n\n 3. 可以配置一下环境变量（可选性）\n\n\n# 3.4、发布一个web网站\n\n不会就先模仿\n\n * 将自己写的网站，放到服务器(tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了\n\n网站应该有的结构\n\n--webapps ：tomcat服务器的web目录\n\t-root\n\t-kuangstudy ：网站的目录名\n\t\t- web-inf\n\t\t\t-classes : java程序\n\t\t\t-lib：web应用所依赖的jar包\n\t\t\t-web.xml ：网站配置文件\n\t\t- index.html 默认的首页\n\t\t- static \n            -css\n            \t-style.css\n            -js\n            -img\n         -.....\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nhttp协议 ： 面试\n\nmaven：构建工具\n\n * maven安装包\n\nservlet 入门\n\n * helloworld！\n * servlet配置\n * 原理',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaWeb - Http",frontmatter:{title:"JavaWeb - Http",date:"2021-05-06T14:38:43.000Z",categories:["java","java-web"],permalink:"/pages/7187be/"},regularPath:"/01.Java/20.JavaWeb/03.Http.html",relativePath:"01.Java/20.JavaWeb/03.Http.md",key:"v-5e22edfe",path:"/pages/7187be/",headers:[{level:2,title:"4.1、什么是HTTP",slug:"_4-1、什么是http",normalizedTitle:"4.1、什么是http",charIndex:13},{level:2,title:"4.2、两个时代",slug:"_4-2、两个时代",normalizedTitle:"4.2、两个时代",charIndex:141},{level:2,title:"4.3、Http请求",slug:"_4-3、http请求",normalizedTitle:"4.3、http请求",charIndex:277},{level:3,title:"1、请求行",slug:"_1、请求行",normalizedTitle:"1、请求行",charIndex:632},{level:3,title:"2、消息头",slug:"_2、消息头",normalizedTitle:"2、消息头",charIndex:815},{level:2,title:"4.4、Http响应",slug:"_4-4、http响应",normalizedTitle:"4.4、http响应",charIndex:1015},{level:3,title:"1.响应体",slug:"_1-响应体",normalizedTitle:"1.响应体",charIndex:1182},{level:3,title:"2、响应状态码",slug:"_2、响应状态码",normalizedTitle:"2、响应状态码",charIndex:1426}],headersStr:"4.1、什么是HTTP 4.2、两个时代 4.3、Http请求 1、请求行 2、消息头 4.4、Http响应 1.响应体 2、响应状态码",content:"# 4、Http\n\n\n# 4.1、什么是HTTP\n\nHTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。\n\n * 文本：html，字符串，~ ….\n * 超文本：图片，音乐，视频，定位，地图…….\n * 80\n\nHttps：安全的\n\n * 443\n\n\n# 4.2、两个时代\n\n * http1.0\n   \n   * HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n\n * http2.0\n   \n   * HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘\n\n\n# 4.3、Http请求\n\n * 客户端---发请求（Request）---服务器\n\n百度：\n\nRequest URL:https://www.baidu.com/   请求地址\nRequest Method:GET    get方法/post方法\nStatus Code:200 OK    状态码：200\nRemote（远程） Address:14.215.177.39:443\n\n\n1\n2\n3\n4\n\n\nAccept:text/html  \nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN,zh;q=0.9    语言\nCache-Control:max-age=0\nConnection:keep-alive\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1、请求行\n\n * 请求行中的请求方式：GET\n * 请求方式：Get，Post，HEAD,DELETE,PUT,TRACT…\n   * get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效\n   * post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。\n\n\n# 2、消息头\n\nAccept：告诉浏览器，它所支持的数据类型\nAccept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1\nAccept-Language：告诉浏览器，它的语言环境\nCache-Control：缓存控制\nConnection：告诉浏览器，请求完成是断开还是保持连接\nHOST：主机..../.\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.4、Http响应\n\n * 服务器---响应-----客户端\n\n百度：\n\nCache-Control:private    缓存控制\nConnection:Keep-Alive    连接\nContent-Encoding:gzip    编码\nContent-Type:text/html   类型\n\n\n1\n2\n3\n4\n\n\n\n# 1.响应体\n\nAccept：告诉浏览器，它所支持的数据类型\nAccept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1\nAccept-Language：告诉浏览器，它的语言环境\nCache-Control：缓存控制\nConnection：告诉浏览器，请求完成是断开还是保持连接\nHOST：主机..../.\nRefresh：告诉客户端，多久刷新一次；\nLocation：让网页重新定位；\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2、响应状态码\n\n200：请求响应成功 200\n\n3xx：请求重定向\n\n * 重定向：你重新到我给你新位置去；\n\n4xx：找不到资源 404\n\n * 资源不存在；\n\n5xx：服务器代码错误 500 502:网关错误\n\n常见面试题：\n\n当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？",normalizedContent:"# 4、http\n\n\n# 4.1、什么是http\n\nhttp（超文本传输协议）是一个简单的请求-响应协议，它通常运行在tcp之上。\n\n * 文本：html，字符串，~ ….\n * 超文本：图片，音乐，视频，定位，地图…….\n * 80\n\nhttps：安全的\n\n * 443\n\n\n# 4.2、两个时代\n\n * http1.0\n   \n   * http/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n\n * http2.0\n   \n   * http/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘\n\n\n# 4.3、http请求\n\n * 客户端---发请求（request）---服务器\n\n百度：\n\nrequest url:https://www.baidu.com/   请求地址\nrequest method:get    get方法/post方法\nstatus code:200 ok    状态码：200\nremote（远程） address:14.215.177.39:443\n\n\n1\n2\n3\n4\n\n\naccept:text/html  \naccept-encoding:gzip, deflate, br\naccept-language:zh-cn,zh;q=0.9    语言\ncache-control:max-age=0\nconnection:keep-alive\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1、请求行\n\n * 请求行中的请求方式：get\n * 请求方式：get，post，head,delete,put,tract…\n   * get：请求能够携带的参数比较少，大小有限制，会在浏览器的url地址栏显示数据内容，不安全，但高效\n   * post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的url地址栏显示数据内容，安全，但不高效。\n\n\n# 2、消息头\n\naccept：告诉浏览器，它所支持的数据类型\naccept-encoding：支持哪种编码格式  gbk   utf-8   gb2312  iso8859-1\naccept-language：告诉浏览器，它的语言环境\ncache-control：缓存控制\nconnection：告诉浏览器，请求完成是断开还是保持连接\nhost：主机..../.\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.4、http响应\n\n * 服务器---响应-----客户端\n\n百度：\n\ncache-control:private    缓存控制\nconnection:keep-alive    连接\ncontent-encoding:gzip    编码\ncontent-type:text/html   类型\n\n\n1\n2\n3\n4\n\n\n\n# 1.响应体\n\naccept：告诉浏览器，它所支持的数据类型\naccept-encoding：支持哪种编码格式  gbk   utf-8   gb2312  iso8859-1\naccept-language：告诉浏览器，它的语言环境\ncache-control：缓存控制\nconnection：告诉浏览器，请求完成是断开还是保持连接\nhost：主机..../.\nrefresh：告诉客户端，多久刷新一次；\nlocation：让网页重新定位；\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2、响应状态码\n\n200：请求响应成功 200\n\n3xx：请求重定向\n\n * 重定向：你重新到我给你新位置去；\n\n4xx：找不到资源 404\n\n * 资源不存在；\n\n5xx：服务器代码错误 500 502:网关错误\n\n常见面试题：\n\n当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？",charsets:{cjk:!0},lastUpdated:"2021/09/11, 2:09:00",lastUpdatedTimestamp:1631327124e3},{title:"JavaWeb- 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.Java/20.JavaWeb",imgUrl:"/img/web.png",description:"JavaWeb目录页"}},title:"JavaWeb- 知识体系",permalink:"/javaweb",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2021-08-03T18:04:03.000Z"},regularPath:"/01.Java/20.JavaWeb/00.javaweb.html",relativePath:"01.Java/20.JavaWeb/00.javaweb.md",key:"v-b785b0fe",path:"/javaweb/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/09/11, 2:09:00",lastUpdatedTimestamp:1631327124e3},{title:"JavaWeb - Servlet",frontmatter:{title:"JavaWeb - Servlet",author:{name:"致远",link:"https://oddfar.com"},categories:["java","java-web"],date:"2021-05-07T18:09:11.000Z",permalink:"/pages/e986b8/"},regularPath:"/01.Java/20.JavaWeb/05.servlet.html",relativePath:"01.Java/20.JavaWeb/05.servlet.md",key:"v-e9d086fe",path:"/pages/e986b8/",headers:[{level:2,title:"6、Servlet",slug:"_6、servlet",normalizedTitle:"6、servlet",charIndex:2},{level:3,title:"6.1、Servlet简介",slug:"_6-1、servlet简介",normalizedTitle:"6.1、servlet简介",charIndex:16},{level:3,title:"6.2、HelloServlet",slug:"_6-2、helloservlet",normalizedTitle:"6.2、helloservlet",charIndex:207},{level:3,title:"6.3、Servlet原理",slug:"_6-3、servlet原理",normalizedTitle:"6.3、servlet原理",charIndex:2454},{level:3,title:"6.4、Mapping问题",slug:"_6-4、mapping问题",normalizedTitle:"6.4、mapping问题",charIndex:2513},{level:3,title:"6.5、ServletContext",slug:"_6-5、servletcontext",normalizedTitle:"6.5、servletcontext",charIndex:4840},{level:4,title:"1、共享数据",slug:"_1、共享数据",normalizedTitle:"1、共享数据",charIndex:4924},{level:4,title:"2、获取初始化参数",slug:"_2、获取初始化参数",normalizedTitle:"2、获取初始化参数",charIndex:6802},{level:4,title:"3、请求转发",slug:"_3、请求转发",normalizedTitle:"3、请求转发",charIndex:7268},{level:4,title:"4、读取资源文件",slug:"_4、读取资源文件",normalizedTitle:"4、读取资源文件",charIndex:7733},{level:3,title:"6.6、HttpServletResponse",slug:"_6-6、httpservletresponse",normalizedTitle:"6.6、httpservletresponse",charIndex:8676},{level:4,title:"1、简单分类",slug:"_1、简单分类",normalizedTitle:"1、简单分类",charIndex:8869},{level:4,title:"2、下载文件",slug:"_2、下载文件",normalizedTitle:"2、下载文件",charIndex:11042},{level:4,title:"3、验证码功能",slug:"_3、验证码功能",normalizedTitle:"3、验证码功能",charIndex:12343},{level:4,title:"4、实现重定向",slug:"_4、实现重定向",normalizedTitle:"4、实现重定向",charIndex:14395},{level:4,title:"5、简单实现登录重定向",slug:"_5、简单实现登录重定向",normalizedTitle:"5、简单实现登录重定向",charIndex:14902},{level:3,title:"6.7、HttpServletRequest",slug:"_6-7、httpservletrequest",normalizedTitle:"6.7、httpservletrequest",charIndex:16106},{level:4,title:"获取参数，请求转发",slug:"获取参数-请求转发",normalizedTitle:"获取参数，请求转发",charIndex:16254}],headersStr:"6、Servlet 6.1、Servlet简介 6.2、HelloServlet 6.3、Servlet原理 6.4、Mapping问题 6.5、ServletContext 1、共享数据 2、获取初始化参数 3、请求转发 4、读取资源文件 6.6、HttpServletResponse 1、简单分类 2、下载文件 3、验证码功能 4、实现重定向 5、简单实现登录重定向 6.7、HttpServletRequest 获取参数，请求转发",content:'# 6、Servlet\n\n\n# 6.1、Servlet简介\n\n * Servlet就是sun公司开发动态web的一门技术\n * Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：\n   * 编写一个类，实现Servlet接口\n   * 把开发好的Java类部署到web服务器中。\n\n把实现了Servlet接口的Java程序叫做，Servlet\n\n\n# 6.2、HelloServlet\n\nSerlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet\n\n 1. 构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程；\n\n 2. 关于Maven父子工程的理解：\n    \n    父项目中会有\n    \n        <modules>\n            <module>servlet-01</module>\n        </modules>\n    \n    \n    1\n    2\n    3\n    \n    \n    子项目会有\n    \n        <parent>\n            <artifactId>javaweb-02-servlet</artifactId>\n            <groupId>com.kuang</groupId>\n            <version>1.0-SNAPSHOT</version>\n        </parent>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    父项目中的java子项目可以直接使用\n    \n    son extends father\n    \n    \n    1\n    \n\n 3. Maven环境优化\n    \n    1. 修改web.xml为最新的\n    2. 将maven的结构搭建完整\n\n 4. 编写一个Servlet程序\n    \n    \n    \n    1. 编写一个普通类\n    \n    2. 实现Servlet接口，这里我们直接继承HttpServlet\n       \n       public class HelloServlet extends HttpServlet {\n           \n           //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；\n           @Override\n           protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n               //ServletOutputStream outputStream = resp.getOutputStream();\n               PrintWriter writer = resp.getWriter(); //响应流\n               writer.print("Hello,Serlvet");\n           }\n       \n           @Override\n           protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n               doGet(req, resp);\n           }\n       }\n       \n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       \n\n 5. 编写Servlet的映射\n    \n    为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；\n    \n        \x3c!--注册Servlet--\x3e\n        <servlet>\n            <servlet-name>hello</servlet-name>\n            <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n        </servlet>\n        \x3c!--Servlet的请求路径--\x3e\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello</url-pattern>\n        </servlet-mapping>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 6. 配置Tomcat\n    \n    注意：配置项目发布的路径就可以了\n\n 7. 启动测试，OK！\n\n\n# 6.3、Servlet原理\n\nServlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：\n\n\n\n\n# 6.4、Mapping问题\n\n 1. 一个Servlet可以指定一个映射路径\n    \n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello</url-pattern>\n        </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 一个Servlet可以指定多个映射路径\n    \n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello2</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello3</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello4</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello5</url-pattern>\n        </servlet-mapping>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 3. 一个Servlet可以指定通用映射路径\n    \n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello/*</url-pattern>\n        </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 默认请求路径\n    \n        \x3c!--默认请求路径--\x3e\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/*</url-pattern>\n        </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. 指定一些后缀或者前缀等等….\n    \n    \x3c!--可以自定义后缀实现请求映射\n        注意点，*前面不能加项目映射的路径\n        hello/sajdlkajda.qinjiang\n        --\x3e\n    <servlet-mapping>\n        <servlet-name>hello</servlet-name>\n        <url-pattern>*.qinjiang</url-pattern>\n    </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 6. 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；\n    \n    \x3c!--404--\x3e\n    <servlet>\n        <servlet-name>error</servlet-name>\n        <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>error</servlet-name>\n        <url-pattern>/*</url-pattern>\n    </servlet-mapping>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 6.5、ServletContext\n\nweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；\n\n# 1、共享数据\n\n我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；\n\npublic class HelloServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        \n        //this.getInitParameter()   初始化参数\n        //this.getServletConfig()   Servlet配置\n        //this.getServletContext()  Servlet上下文\n        ServletContext context = this.getServletContext();\n\n        String username = "秦疆"; //数据\n        context.setAttribute("username",username); //将一个数据保存在了ServletContext中，名字为：username 。值 username\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\npublic class GetServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ServletContext context = this.getServletContext();\n        String username = (String) context.getAttribute("username");\n\n        resp.setContentType("text/html");\n        resp.setCharacterEncoding("utf-8");\n        resp.getWriter().print("名字"+username);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n    <servlet>\n        <servlet-name>hello</servlet-name>\n        <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>hello</servlet-name>\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n\n\n    <servlet>\n        <servlet-name>getc</servlet-name>\n        <servlet-class>com.kuang.servlet.GetServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>getc</servlet-name>\n        <url-pattern>/getc</url-pattern>\n    </servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n测试访问结果；\n\n# 2、获取初始化参数\n\n    \x3c!--配置一些web应用初始化参数--\x3e\n    <context-param>\n        <param-name>url</param-name>\n        <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>\n    </context-param>\n\n\n1\n2\n3\n4\n5\n\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    ServletContext context = this.getServletContext();\n    String url = context.getInitParameter("url");\n    resp.getWriter().print(url);\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 3、请求转发\n\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    ServletContext context = this.getServletContext();\n    System.out.println("进入了ServletDemo04");\n    //RequestDispatcher requestDispatcher = context.getRequestDispatcher("/gp"); //转发的请求路径\n    //requestDispatcher.forward(req,resp); //调用forward实现请求转发；\n    context.getRequestDispatcher("/gp").forward(req,resp);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n# 4、读取资源文件\n\nProperties\n\n * 在java目录下新建properties\n * 在resources目录下新建properties\n\n发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:\n\n思路：需要一个文件流；\n\nusername=root12312\npassword=zxczxczxc\n\n\n1\n2\n\n\npublic class ServletDemo05 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        InputStream is = this.getServletContext().getResourceAsStream("/WEB-INF/classes/com/kuang/servlet/aa.properties");\n\n        Properties prop = new Properties();\n        prop.load(is);\n        String user = prop.getProperty("username");\n        String pwd = prop.getProperty("password");\n\n        resp.getWriter().print(user+":"+pwd);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n访问测试即可ok；\n\n\n# 6.6、HttpServletResponse\n\nweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；\n\n * 如果要获取客户端请求过来的参数：找HttpServletRequest\n * 如果要给客户端响应一些信息：找HttpServletResponse\n\n# 1、简单分类\n\n负责向浏览器发送数据的方法\n\nServletOutputStream getOutputStream() throws IOException;\nPrintWriter getWriter() throws IOException;\n\n\n1\n2\n\n\n负责向浏览器发送响应头的方法\n\n    void setCharacterEncoding(String var1);\n\n    void setContentLength(int var1);\n\n    void setContentLengthLong(long var1);\n\n    void setContentType(String var1);\n\n    void setDateHeader(String var1, long var2);\n\n    void addDateHeader(String var1, long var2);\n\n    void setHeader(String var1, String var2);\n\n    void addHeader(String var1, String var2);\n\n    void setIntHeader(String var1, int var2);\n\n    void addIntHeader(String var1, int var2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n响应的状态码\n\n    int SC_CONTINUE = 100;\n    int SC_SWITCHING_PROTOCOLS = 101;\n    int SC_OK = 200;\n    int SC_CREATED = 201;\n    int SC_ACCEPTED = 202;\n    int SC_NON_AUTHORITATIVE_INFORMATION = 203;\n    int SC_NO_CONTENT = 204;\n    int SC_RESET_CONTENT = 205;\n    int SC_PARTIAL_CONTENT = 206;\n    int SC_MULTIPLE_CHOICES = 300;\n    int SC_MOVED_PERMANENTLY = 301;\n    int SC_MOVED_TEMPORARILY = 302;\n    int SC_FOUND = 302;\n    int SC_SEE_OTHER = 303;\n    int SC_NOT_MODIFIED = 304;\n    int SC_USE_PROXY = 305;\n    int SC_TEMPORARY_REDIRECT = 307;\n    int SC_BAD_REQUEST = 400;\n    int SC_UNAUTHORIZED = 401;\n    int SC_PAYMENT_REQUIRED = 402;\n    int SC_FORBIDDEN = 403;\n    int SC_NOT_FOUND = 404;\n    int SC_METHOD_NOT_ALLOWED = 405;\n    int SC_NOT_ACCEPTABLE = 406;\n    int SC_PROXY_AUTHENTICATION_REQUIRED = 407;\n    int SC_REQUEST_TIMEOUT = 408;\n    int SC_CONFLICT = 409;\n    int SC_GONE = 410;\n    int SC_LENGTH_REQUIRED = 411;\n    int SC_PRECONDITION_FAILED = 412;\n    int SC_REQUEST_ENTITY_TOO_LARGE = 413;\n    int SC_REQUEST_URI_TOO_LONG = 414;\n    int SC_UNSUPPORTED_MEDIA_TYPE = 415;\n    int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    int SC_EXPECTATION_FAILED = 417;\n    int SC_INTERNAL_SERVER_ERROR = 500;\n    int SC_NOT_IMPLEMENTED = 501;\n    int SC_BAD_GATEWAY = 502;\n    int SC_SERVICE_UNAVAILABLE = 503;\n    int SC_GATEWAY_TIMEOUT = 504;\n    int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 2、下载文件\n\n 1. 向浏览器输出消息 （一直在讲，就不说了）\n 2. 下载文件\n    1. 要获取下载文件的路径\n    2. 下载的文件名是啥？\n    3. 设置想办法让浏览器能够支持下载我们需要的东西\n    4. 获取下载文件的输入流\n    5. 创建缓冲区\n    6. 获取OutputStream对象\n    7. 将FileOutputStream流写入到buffer缓冲区\n    8. 使用OutputStream将缓冲区中的数据输出到客户端！\n\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 1. 要获取下载文件的路径\n    String realPath = "F:\\\\班级管理\\\\西开【19525】\\\\2、代码\\\\JavaWeb\\\\javaweb-02-servlet\\\\response\\\\target\\\\classes\\\\秦疆.png";\n    System.out.println("下载文件的路径："+realPath);\n    // 2. 下载的文件名是啥？\n    String fileName = realPath.substring(realPath.lastIndexOf("\\\\") + 1);\n    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码\n    resp.setHeader("Content-Disposition","attachment;filename="+URLEncoder.encode(fileName,"UTF-8"));\n    // 4. 获取下载文件的输入流\n    FileInputStream in = new FileInputStream(realPath);\n    // 5. 创建缓冲区\n    int len = 0;\n    byte[] buffer = new byte[1024];\n    // 6. 获取OutputStream对象\n    ServletOutputStream out = resp.getOutputStream();\n    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！\n    while ((len=in.read(buffer))>0){\n        out.write(buffer,0,len);\n    }\n\n    in.close();\n    out.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 3、验证码功能\n\n验证怎么来的？\n\n * 前端实现\n * 后端实现，需要用到 Java 的图片类，生产一个图片\n\npackage com.kuang.servlet;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\npublic class ImageServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        //如何让浏览器3秒自动刷新一次;\n        resp.setHeader("refresh","3");\n        \n        //在内存中创建一个图片\n        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\n        //得到图片\n        Graphics2D g = (Graphics2D) image.getGraphics(); //笔\n        //设置图片的背景颜色\n        g.setColor(Color.white);\n        g.fillRect(0,0,80,20);\n        //给图片写数据\n        g.setColor(Color.BLUE);\n        g.setFont(new Font(null,Font.BOLD,20));\n        g.drawString(makeNum(),0,20);\n\n        //告诉浏览器，这个请求用图片的方式打开\n        resp.setContentType("image/jpeg");\n        //网站存在缓存，不让浏览器缓存\n        resp.setDateHeader("expires",-1);\n        resp.setHeader("Cache-Control","no-cache");\n        resp.setHeader("Pragma","no-cache");\n\n        //把图片写给浏览器\n        ImageIO.write(image,"jpg", resp.getOutputStream());\n\n    }\n\n    //生成随机数\n    private String makeNum(){\n        Random random = new Random();\n        String num = random.nextInt(9999999) + "";\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < 7-num.length() ; i++) {\n            sb.append("0");\n        }\n        num = sb.toString() + num;\n        return num;\n    }\n\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n# 4、实现重定向\n\n\n\nB一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向\n\n常见场景：\n\n * 用户登录\n\nvoid sendRedirect(String var1) throws IOException;\n\n\n1\n\n\n测试：\n\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    /*\n        resp.setHeader("Location","/r/img");\n        resp.setStatus(302);\n         */\n    resp.sendRedirect("/r/img");//重定向\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n面试题：请你聊聊重定向和转发的区别？\n\n相同点\n\n * 页面都会实现跳转\n\n不同点\n\n * 请求转发的时候，url不会产生变化\n * 重定向时候，url地址栏会发生变化；\n\n\n\n# 5、简单实现登录重定向\n\n<%--这里提交的路径，需要寻找到项目的路径--%>\n<%--${pageContext.request.contextPath}代表当前的项目--%>\n\n<form action="${pageContext.request.contextPath}/login" method="get">\n    用户名：<input type="text" name="username"> <br>\n    密码：<input type="password" name="password"> <br>\n    <input type="submit">\n</form>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //处理请求\n        String username = req.getParameter("username");\n        String password = req.getParameter("password");\n\n        System.out.println(username+":"+password);\n\n        //重定向时候一定要注意，路径问题，否则404；\n        resp.sendRedirect("/r/success.jsp");\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n  <servlet>\n    <servlet-name>requset</servlet-name>\n    <servlet-class>com.kuang.servlet.RequestTest</servlet-class>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>requset</servlet-name>\n    <url-pattern>/login</url-pattern>\n  </servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n\n<h1>Success</h1>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 6.7、HttpServletRequest\n\nHttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；\n\n\n\n\n\n# 获取参数，请求转发\n\n\n\n@Override\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n    req.setCharacterEncoding("utf-8");\n    resp.setCharacterEncoding("utf-8");\n\n    String username = req.getParameter("username");\n    String password = req.getParameter("password");\n    String[] hobbys = req.getParameterValues("hobbys");\n    System.out.println("=============================");\n    //后台接收中文乱码问题\n    System.out.println(username);\n    System.out.println(password);\n    System.out.println(Arrays.toString(hobbys));\n    System.out.println("=============================");\n\n\n    System.out.println(req.getContextPath());\n    //通过请求转发\n    //这里的 / 代表当前的web应用\n    req.getRequestDispatcher("/success.jsp").forward(req,resp);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n面试题：请你聊聊重定向和转发的区别？\n\n相同点\n\n * 页面都会实现跳转\n\n不同点\n\n * 请求转发的时候，url不会产生变化 307\n * 重定向时候，url地址栏会发生变化； 302',normalizedContent:'# 6、servlet\n\n\n# 6.1、servlet简介\n\n * servlet就是sun公司开发动态web的一门技术\n * sun在这些api中提供一个接口叫做：servlet，如果你想开发一个servlet程序，只需要完成两个小步骤：\n   * 编写一个类，实现servlet接口\n   * 把开发好的java类部署到web服务器中。\n\n把实现了servlet接口的java程序叫做，servlet\n\n\n# 6.2、helloservlet\n\nserlvet接口sun公司有两个默认的实现类：httpservlet，genericservlet\n\n 1. 构建一个普通的maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立moudel；这个空的工程就是maven主工程；\n\n 2. 关于maven父子工程的理解：\n    \n    父项目中会有\n    \n        <modules>\n            <module>servlet-01</module>\n        </modules>\n    \n    \n    1\n    2\n    3\n    \n    \n    子项目会有\n    \n        <parent>\n            <artifactid>javaweb-02-servlet</artifactid>\n            <groupid>com.kuang</groupid>\n            <version>1.0-snapshot</version>\n        </parent>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    父项目中的java子项目可以直接使用\n    \n    son extends father\n    \n    \n    1\n    \n\n 3. maven环境优化\n    \n    1. 修改web.xml为最新的\n    2. 将maven的结构搭建完整\n\n 4. 编写一个servlet程序\n    \n    \n    \n    1. 编写一个普通类\n    \n    2. 实现servlet接口，这里我们直接继承httpservlet\n       \n       public class helloservlet extends httpservlet {\n           \n           //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；\n           @override\n           protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n               //servletoutputstream outputstream = resp.getoutputstream();\n               printwriter writer = resp.getwriter(); //响应流\n               writer.print("hello,serlvet");\n           }\n       \n           @override\n           protected void dopost(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n               doget(req, resp);\n           }\n       }\n       \n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       \n\n 5. 编写servlet的映射\n    \n    为什么需要映射：我们写的是java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的servlet，还需给他一个浏览器能够访问的路径；\n    \n        \x3c!--注册servlet--\x3e\n        <servlet>\n            <servlet-name>hello</servlet-name>\n            <servlet-class>com.kuang.servlet.helloservlet</servlet-class>\n        </servlet>\n        \x3c!--servlet的请求路径--\x3e\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello</url-pattern>\n        </servlet-mapping>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 6. 配置tomcat\n    \n    注意：配置项目发布的路径就可以了\n\n 7. 启动测试，ok！\n\n\n# 6.3、servlet原理\n\nservlet是由web服务器调用，web服务器在收到浏览器请求之后，会：\n\n\n\n\n# 6.4、mapping问题\n\n 1. 一个servlet可以指定一个映射路径\n    \n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello</url-pattern>\n        </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 一个servlet可以指定多个映射路径\n    \n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello2</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello3</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello4</url-pattern>\n        </servlet-mapping>\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello5</url-pattern>\n        </servlet-mapping>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 3. 一个servlet可以指定通用映射路径\n    \n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/hello/*</url-pattern>\n        </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 默认请求路径\n    \n        \x3c!--默认请求路径--\x3e\n        <servlet-mapping>\n            <servlet-name>hello</servlet-name>\n            <url-pattern>/*</url-pattern>\n        </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. 指定一些后缀或者前缀等等….\n    \n    \x3c!--可以自定义后缀实现请求映射\n        注意点，*前面不能加项目映射的路径\n        hello/sajdlkajda.qinjiang\n        --\x3e\n    <servlet-mapping>\n        <servlet-name>hello</servlet-name>\n        <url-pattern>*.qinjiang</url-pattern>\n    </servlet-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 6. 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；\n    \n    \x3c!--404--\x3e\n    <servlet>\n        <servlet-name>error</servlet-name>\n        <servlet-class>com.kuang.servlet.errorservlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>error</servlet-name>\n        <url-pattern>/*</url-pattern>\n    </servlet-mapping>\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 6.5、servletcontext\n\nweb容器在启动的时候，它会为每个web程序都创建一个对应的servletcontext对象，它代表了当前的web应用；\n\n# 1、共享数据\n\n我在这个servlet中保存的数据，可以在另外一个servlet中拿到；\n\npublic class helloservlet extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        \n        //this.getinitparameter()   初始化参数\n        //this.getservletconfig()   servlet配置\n        //this.getservletcontext()  servlet上下文\n        servletcontext context = this.getservletcontext();\n\n        string username = "秦疆"; //数据\n        context.setattribute("username",username); //将一个数据保存在了servletcontext中，名字为：username 。值 username\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\npublic class getservlet extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        servletcontext context = this.getservletcontext();\n        string username = (string) context.getattribute("username");\n\n        resp.setcontenttype("text/html");\n        resp.setcharacterencoding("utf-8");\n        resp.getwriter().print("名字"+username);\n\n    }\n\n    @override\n    protected void dopost(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        doget(req, resp);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n    <servlet>\n        <servlet-name>hello</servlet-name>\n        <servlet-class>com.kuang.servlet.helloservlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>hello</servlet-name>\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n\n\n    <servlet>\n        <servlet-name>getc</servlet-name>\n        <servlet-class>com.kuang.servlet.getservlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>getc</servlet-name>\n        <url-pattern>/getc</url-pattern>\n    </servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n测试访问结果；\n\n# 2、获取初始化参数\n\n    \x3c!--配置一些web应用初始化参数--\x3e\n    <context-param>\n        <param-name>url</param-name>\n        <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>\n    </context-param>\n\n\n1\n2\n3\n4\n5\n\n\nprotected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n    servletcontext context = this.getservletcontext();\n    string url = context.getinitparameter("url");\n    resp.getwriter().print(url);\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 3、请求转发\n\n@override\nprotected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n    servletcontext context = this.getservletcontext();\n    system.out.println("进入了servletdemo04");\n    //requestdispatcher requestdispatcher = context.getrequestdispatcher("/gp"); //转发的请求路径\n    //requestdispatcher.forward(req,resp); //调用forward实现请求转发；\n    context.getrequestdispatcher("/gp").forward(req,resp);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n# 4、读取资源文件\n\nproperties\n\n * 在java目录下新建properties\n * 在resources目录下新建properties\n\n发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:\n\n思路：需要一个文件流；\n\nusername=root12312\npassword=zxczxczxc\n\n\n1\n2\n\n\npublic class servletdemo05 extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n\n        inputstream is = this.getservletcontext().getresourceasstream("/web-inf/classes/com/kuang/servlet/aa.properties");\n\n        properties prop = new properties();\n        prop.load(is);\n        string user = prop.getproperty("username");\n        string pwd = prop.getproperty("password");\n\n        resp.getwriter().print(user+":"+pwd);\n\n    }\n\n    @override\n    protected void dopost(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        doget(req, resp);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n访问测试即可ok；\n\n\n# 6.6、httpservletresponse\n\nweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的httpservletrequest对象，代表响应的一个httpservletresponse；\n\n * 如果要获取客户端请求过来的参数：找httpservletrequest\n * 如果要给客户端响应一些信息：找httpservletresponse\n\n# 1、简单分类\n\n负责向浏览器发送数据的方法\n\nservletoutputstream getoutputstream() throws ioexception;\nprintwriter getwriter() throws ioexception;\n\n\n1\n2\n\n\n负责向浏览器发送响应头的方法\n\n    void setcharacterencoding(string var1);\n\n    void setcontentlength(int var1);\n\n    void setcontentlengthlong(long var1);\n\n    void setcontenttype(string var1);\n\n    void setdateheader(string var1, long var2);\n\n    void adddateheader(string var1, long var2);\n\n    void setheader(string var1, string var2);\n\n    void addheader(string var1, string var2);\n\n    void setintheader(string var1, int var2);\n\n    void addintheader(string var1, int var2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n响应的状态码\n\n    int sc_continue = 100;\n    int sc_switching_protocols = 101;\n    int sc_ok = 200;\n    int sc_created = 201;\n    int sc_accepted = 202;\n    int sc_non_authoritative_information = 203;\n    int sc_no_content = 204;\n    int sc_reset_content = 205;\n    int sc_partial_content = 206;\n    int sc_multiple_choices = 300;\n    int sc_moved_permanently = 301;\n    int sc_moved_temporarily = 302;\n    int sc_found = 302;\n    int sc_see_other = 303;\n    int sc_not_modified = 304;\n    int sc_use_proxy = 305;\n    int sc_temporary_redirect = 307;\n    int sc_bad_request = 400;\n    int sc_unauthorized = 401;\n    int sc_payment_required = 402;\n    int sc_forbidden = 403;\n    int sc_not_found = 404;\n    int sc_method_not_allowed = 405;\n    int sc_not_acceptable = 406;\n    int sc_proxy_authentication_required = 407;\n    int sc_request_timeout = 408;\n    int sc_conflict = 409;\n    int sc_gone = 410;\n    int sc_length_required = 411;\n    int sc_precondition_failed = 412;\n    int sc_request_entity_too_large = 413;\n    int sc_request_uri_too_long = 414;\n    int sc_unsupported_media_type = 415;\n    int sc_requested_range_not_satisfiable = 416;\n    int sc_expectation_failed = 417;\n    int sc_internal_server_error = 500;\n    int sc_not_implemented = 501;\n    int sc_bad_gateway = 502;\n    int sc_service_unavailable = 503;\n    int sc_gateway_timeout = 504;\n    int sc_http_version_not_supported = 505;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 2、下载文件\n\n 1. 向浏览器输出消息 （一直在讲，就不说了）\n 2. 下载文件\n    1. 要获取下载文件的路径\n    2. 下载的文件名是啥？\n    3. 设置想办法让浏览器能够支持下载我们需要的东西\n    4. 获取下载文件的输入流\n    5. 创建缓冲区\n    6. 获取outputstream对象\n    7. 将fileoutputstream流写入到buffer缓冲区\n    8. 使用outputstream将缓冲区中的数据输出到客户端！\n\n@override\nprotected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n    // 1. 要获取下载文件的路径\n    string realpath = "f:\\\\班级管理\\\\西开【19525】\\\\2、代码\\\\javaweb\\\\javaweb-02-servlet\\\\response\\\\target\\\\classes\\\\秦疆.png";\n    system.out.println("下载文件的路径："+realpath);\n    // 2. 下载的文件名是啥？\n    string filename = realpath.substring(realpath.lastindexof("\\\\") + 1);\n    // 3. 设置想办法让浏览器能够支持(content-disposition)下载我们需要的东西,中文文件名urlencoder.encode编码，否则有可能乱码\n    resp.setheader("content-disposition","attachment;filename="+urlencoder.encode(filename,"utf-8"));\n    // 4. 获取下载文件的输入流\n    fileinputstream in = new fileinputstream(realpath);\n    // 5. 创建缓冲区\n    int len = 0;\n    byte[] buffer = new byte[1024];\n    // 6. 获取outputstream对象\n    servletoutputstream out = resp.getoutputstream();\n    // 7. 将fileoutputstream流写入到buffer缓冲区,使用outputstream将缓冲区中的数据输出到客户端！\n    while ((len=in.read(buffer))>0){\n        out.write(buffer,0,len);\n    }\n\n    in.close();\n    out.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 3、验证码功能\n\n验证怎么来的？\n\n * 前端实现\n * 后端实现，需要用到 java 的图片类，生产一个图片\n\npackage com.kuang.servlet;\n\nimport javax.imageio.imageio;\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.awt.*;\nimport java.awt.image.bufferedimage;\nimport java.io.ioexception;\nimport java.util.random;\n\npublic class imageservlet extends httpservlet {\n\n    @override\n    protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n\n        //如何让浏览器3秒自动刷新一次;\n        resp.setheader("refresh","3");\n        \n        //在内存中创建一个图片\n        bufferedimage image = new bufferedimage(80,20,bufferedimage.type_int_rgb);\n        //得到图片\n        graphics2d g = (graphics2d) image.getgraphics(); //笔\n        //设置图片的背景颜色\n        g.setcolor(color.white);\n        g.fillrect(0,0,80,20);\n        //给图片写数据\n        g.setcolor(color.blue);\n        g.setfont(new font(null,font.bold,20));\n        g.drawstring(makenum(),0,20);\n\n        //告诉浏览器，这个请求用图片的方式打开\n        resp.setcontenttype("image/jpeg");\n        //网站存在缓存，不让浏览器缓存\n        resp.setdateheader("expires",-1);\n        resp.setheader("cache-control","no-cache");\n        resp.setheader("pragma","no-cache");\n\n        //把图片写给浏览器\n        imageio.write(image,"jpg", resp.getoutputstream());\n\n    }\n\n    //生成随机数\n    private string makenum(){\n        random random = new random();\n        string num = random.nextint(9999999) + "";\n        stringbuffer sb = new stringbuffer();\n        for (int i = 0; i < 7-num.length() ; i++) {\n            sb.append("0");\n        }\n        num = sb.tostring() + num;\n        return num;\n    }\n\n\n    @override\n    protected void dopost(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        doget(req, resp);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n# 4、实现重定向\n\n\n\nb一个web资源收到客户端a请求后，b他会通知a客户端去访问另外一个web资源c，这个过程叫重定向\n\n常见场景：\n\n * 用户登录\n\nvoid sendredirect(string var1) throws ioexception;\n\n\n1\n\n\n测试：\n\n@override\nprotected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n\n    /*\n        resp.setheader("location","/r/img");\n        resp.setstatus(302);\n         */\n    resp.sendredirect("/r/img");//重定向\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n面试题：请你聊聊重定向和转发的区别？\n\n相同点\n\n * 页面都会实现跳转\n\n不同点\n\n * 请求转发的时候，url不会产生变化\n * 重定向时候，url地址栏会发生变化；\n\n\n\n# 5、简单实现登录重定向\n\n<%--这里提交的路径，需要寻找到项目的路径--%>\n<%--${pagecontext.request.contextpath}代表当前的项目--%>\n\n<form action="${pagecontext.request.contextpath}/login" method="get">\n    用户名：<input type="text" name="username"> <br>\n    密码：<input type="password" name="password"> <br>\n    <input type="submit">\n</form>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    @override\n    protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        //处理请求\n        string username = req.getparameter("username");\n        string password = req.getparameter("password");\n\n        system.out.println(username+":"+password);\n\n        //重定向时候一定要注意，路径问题，否则404；\n        resp.sendredirect("/r/success.jsp");\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n  <servlet>\n    <servlet-name>requset</servlet-name>\n    <servlet-class>com.kuang.servlet.requesttest</servlet-class>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>requset</servlet-name>\n    <url-pattern>/login</url-pattern>\n  </servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>title</title>\n</head>\n<body>\n\n<h1>success</h1>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 6.7、httpservletrequest\n\nhttpservletrequest代表客户端的请求，用户通过http协议访问服务器，http请求中的所有信息会被封装到httpservletrequest，通过这个httpservletrequest的方法，获得客户端的所有信息；\n\n\n\n\n\n# 获取参数，请求转发\n\n\n\n@override\nprotected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n\n    req.setcharacterencoding("utf-8");\n    resp.setcharacterencoding("utf-8");\n\n    string username = req.getparameter("username");\n    string password = req.getparameter("password");\n    string[] hobbys = req.getparametervalues("hobbys");\n    system.out.println("=============================");\n    //后台接收中文乱码问题\n    system.out.println(username);\n    system.out.println(password);\n    system.out.println(arrays.tostring(hobbys));\n    system.out.println("=============================");\n\n\n    system.out.println(req.getcontextpath());\n    //通过请求转发\n    //这里的 / 代表当前的web应用\n    req.getrequestdispatcher("/success.jsp").forward(req,resp);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n面试题：请你聊聊重定向和转发的区别？\n\n相同点\n\n * 页面都会实现跳转\n\n不同点\n\n * 请求转发的时候，url不会产生变化 307\n * 重定向时候，url地址栏会发生变化； 302',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaWeb - Cookie和Session",frontmatter:{title:"JavaWeb - Cookie和Session",author:{name:"致远",link:"https://oddfar.com"},categories:["java","java-web"],date:"2021-05-07T18:09:11.000Z",permalink:"/pages/d20044/"},regularPath:"/01.Java/20.JavaWeb/06.cookie%E5%92%8Csession.html",relativePath:"01.Java/20.JavaWeb/06.cookie和session.md",key:"v-fa5b3454",path:"/pages/d20044/",headers:[{level:2,title:"7、Cookie、Session",slug:"_7、cookie、session",normalizedTitle:"7、cookie、session",charIndex:2},{level:3,title:"7.1、会话",slug:"_7-1、会话",normalizedTitle:"7.1、会话",charIndex:23},{level:3,title:"7.2、保存会话的两种技术",slug:"_7-2、保存会话的两种技术",normalizedTitle:"7.2、保存会话的两种技术",charIndex:294},{level:3,title:"7.3、Cookie",slug:"_7-3、cookie",normalizedTitle:"7.3、cookie",charIndex:436},{level:3,title:"7.4、Session（重点）",slug:"_7-4、session-重点",normalizedTitle:"7.4、session（重点）",charIndex:1087}],headersStr:"7、Cookie、Session 7.1、会话 7.2、保存会话的两种技术 7.3、Cookie 7.4、Session（重点）",content:'# 7、Cookie、Session\n\n\n# 7.1、会话\n\n会话：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；\n\n有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；\n\n你能怎么证明你是西开的学生？\n\n你 西开\n\n 1. 发票 西开给你发票\n 2. 学校登记 西开标记你来过了\n\n一个网站，怎么证明你来过？\n\n客户端 服务端\n\n 1. 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie\n 2. 服务器登记你来过了，下次你来的时候我来匹配你； seesion\n\n\n# 7.2、保存会话的两种技术\n\ncookie\n\n * 客户端技术 （响应，请求）\n\nsession\n\n * 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！\n\n常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！\n\n\n# 7.3、Cookie\n\n\n\n 1. 从请求中拿到cookie信息\n 2. 服务器响应给客户端cookie\n\nCookie[] cookies = req.getCookies(); //获得Cookie\ncookie.getName(); //获得cookie中的key\ncookie.getValue(); //获得cookie中的vlaue\nnew Cookie("lastLoginTime", System.currentTimeMillis()+""); //新建一个cookie\ncookie.setMaxAge(24*60*60); //设置cookie的有效期\nresp.addCookie(cookie); //响应给客户端一个cookie\n\n\n1\n2\n3\n4\n5\n6\n\n\ncookie：一般会保存在本地的 用户目录下 appdata；\n\n一个网站cookie是否存在上限！聊聊细节问题\n\n * 一个Cookie只能保存一个信息；\n * 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；\n * Cookie大小有限制4kb；\n * 300个cookie浏览器上限\n\n删除Cookie；\n\n * 不设置有效期，关闭浏览器，自动失效；\n * 设置有效期时间为 0 ；\n\n编码解码：\n\nURLEncoder.encode("秦疆","utf-8")\nURLDecoder.decode(cookie.getValue(),"UTF-8")\n\n\n1\n2\n\n\n\n# 7.4、Session（重点）\n\n\n\n什么是Session：\n\n * 服务器会给每一个用户（浏览器）创建一个Seesion对象；\n * 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；\n * 用户登录之后，整个网站它都可以访问！--\x3e 保存用户的信息；保存购物车的信息…..\n\n\n\nSession和cookie的区别：\n\n * Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）\n * Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费）\n * Session对象由服务创建；\n\n使用场景：\n\n * 保存一个登录用户的信息；\n * 购物车信息；\n * 在整个网站中经常会使用的数据，我们将它保存在Session中；\n\n使用Session：\n\npackage com.kuang.servlet;\n\nimport com.kuang.pojo.Person;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class SessionDemo01 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        \n        //解决乱码问题\n        req.setCharacterEncoding("UTF-8");\n        resp.setCharacterEncoding("UTF-8");\n        resp.setContentType("text/html;charset=utf-8");\n        \n        //得到Session\n        HttpSession session = req.getSession();\n        //给Session中存东西\n        session.setAttribute("name",new Person("秦疆",1));\n        //获取Session的ID\n        String sessionId = session.getId();\n\n        //判断Session是不是新创建\n        if (session.isNew()){\n            resp.getWriter().write("session创建成功,ID:"+sessionId);\n        }else {\n            resp.getWriter().write("session以及在服务器中存在了,ID:"+sessionId);\n        }\n\n        //Session创建的时候做了什么事情；\n//        Cookie cookie = new Cookie("JSESSIONID",sessionId);\n//        resp.addCookie(cookie);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n//得到Session\nHttpSession session = req.getSession();\n\nPerson person = (Person) session.getAttribute("name");\n\nSystem.out.println(person.toString());\n\nHttpSession session = req.getSession();\nsession.removeAttribute("name");\n//手动注销Session\nsession.invalidate();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n会话自动过期：web.xml配置\n\n\x3c!--设置Session默认的失效时间--\x3e\n<session-config>\n    \x3c!--15分钟后Session自动失效，以分钟为单位--\x3e\n    <session-timeout>15</session-timeout>\n</session-config>\n\n\n1\n2\n3\n4\n5\n\n\n',normalizedContent:'# 7、cookie、session\n\n\n# 7.1、会话\n\n会话：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；\n\n有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；\n\n你能怎么证明你是西开的学生？\n\n你 西开\n\n 1. 发票 西开给你发票\n 2. 学校登记 西开标记你来过了\n\n一个网站，怎么证明你来过？\n\n客户端 服务端\n\n 1. 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie\n 2. 服务器登记你来过了，下次你来的时候我来匹配你； seesion\n\n\n# 7.2、保存会话的两种技术\n\ncookie\n\n * 客户端技术 （响应，请求）\n\nsession\n\n * 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在session中！\n\n常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！\n\n\n# 7.3、cookie\n\n\n\n 1. 从请求中拿到cookie信息\n 2. 服务器响应给客户端cookie\n\ncookie[] cookies = req.getcookies(); //获得cookie\ncookie.getname(); //获得cookie中的key\ncookie.getvalue(); //获得cookie中的vlaue\nnew cookie("lastlogintime", system.currenttimemillis()+""); //新建一个cookie\ncookie.setmaxage(24*60*60); //设置cookie的有效期\nresp.addcookie(cookie); //响应给客户端一个cookie\n\n\n1\n2\n3\n4\n5\n6\n\n\ncookie：一般会保存在本地的 用户目录下 appdata；\n\n一个网站cookie是否存在上限！聊聊细节问题\n\n * 一个cookie只能保存一个信息；\n * 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；\n * cookie大小有限制4kb；\n * 300个cookie浏览器上限\n\n删除cookie；\n\n * 不设置有效期，关闭浏览器，自动失效；\n * 设置有效期时间为 0 ；\n\n编码解码：\n\nurlencoder.encode("秦疆","utf-8")\nurldecoder.decode(cookie.getvalue(),"utf-8")\n\n\n1\n2\n\n\n\n# 7.4、session（重点）\n\n\n\n什么是session：\n\n * 服务器会给每一个用户（浏览器）创建一个seesion对象；\n * 一个seesion独占一个浏览器，只要浏览器没有关闭，这个session就存在；\n * 用户登录之后，整个网站它都可以访问！--\x3e 保存用户的信息；保存购物车的信息…..\n\n\n\nsession和cookie的区别：\n\n * cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）\n * session把用户的数据写到用户独占session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费）\n * session对象由服务创建；\n\n使用场景：\n\n * 保存一个登录用户的信息；\n * 购物车信息；\n * 在整个网站中经常会使用的数据，我们将它保存在session中；\n\n使用session：\n\npackage com.kuang.servlet;\n\nimport com.kuang.pojo.person;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.*;\nimport java.io.ioexception;\n\npublic class sessiondemo01 extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        \n        //解决乱码问题\n        req.setcharacterencoding("utf-8");\n        resp.setcharacterencoding("utf-8");\n        resp.setcontenttype("text/html;charset=utf-8");\n        \n        //得到session\n        httpsession session = req.getsession();\n        //给session中存东西\n        session.setattribute("name",new person("秦疆",1));\n        //获取session的id\n        string sessionid = session.getid();\n\n        //判断session是不是新创建\n        if (session.isnew()){\n            resp.getwriter().write("session创建成功,id:"+sessionid);\n        }else {\n            resp.getwriter().write("session以及在服务器中存在了,id:"+sessionid);\n        }\n\n        //session创建的时候做了什么事情；\n//        cookie cookie = new cookie("jsessionid",sessionid);\n//        resp.addcookie(cookie);\n\n    }\n\n    @override\n    protected void dopost(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception {\n        doget(req, resp);\n    }\n}\n\n//得到session\nhttpsession session = req.getsession();\n\nperson person = (person) session.getattribute("name");\n\nsystem.out.println(person.tostring());\n\nhttpsession session = req.getsession();\nsession.removeattribute("name");\n//手动注销session\nsession.invalidate();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n会话自动过期：web.xml配置\n\n\x3c!--设置session默认的失效时间--\x3e\n<session-config>\n    \x3c!--15分钟后session自动失效，以分钟为单位--\x3e\n    <session-timeout>15</session-timeout>\n</session-config>\n\n\n1\n2\n3\n4\n5\n\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaWeb - Maven",frontmatter:{title:"JavaWeb - Maven",categories:["java","java-web"],date:"2021-05-15T18:09:11.000Z",permalink:"/pages/cb259f/"},regularPath:"/01.Java/20.JavaWeb/04.Maven.html",relativePath:"01.Java/20.JavaWeb/04.Maven.md",key:"v-049ddce1",path:"/pages/cb259f/",headers:[{level:2,title:"5.1 Maven项目架构管理工具",slug:"_5-1-maven项目架构管理工具",normalizedTitle:"5.1 maven项目架构管理工具",charIndex:119},{level:2,title:"5.2 下载安装Maven",slug:"_5-2-下载安装maven",normalizedTitle:"5.2 下载安装maven",charIndex:234},{level:2,title:"5.3 配置环境变量",slug:"_5-3-配置环境变量",normalizedTitle:"5.3 配置环境变量",charIndex:309},{level:2,title:"5.4 阿里云镜像",slug:"_5-4-阿里云镜像",normalizedTitle:"5.4 阿里云镜像",charIndex:483},{level:2,title:"5.5 本地仓库",slug:"_5-5-本地仓库",normalizedTitle:"5.5 本地仓库",charIndex:765},{level:2,title:"5.6、在IDEA中使用Maven",slug:"_5-6、在idea中使用maven",normalizedTitle:"5.6、在idea中使用maven",charIndex:885},{level:2,title:"5.7、创建一个普通的Maven项目",slug:"_5-7、创建一个普通的maven项目",normalizedTitle:"5.7、创建一个普通的maven项目",charIndex:1230},{level:2,title:"5.8 标记文件夹功能",slug:"_5-8-标记文件夹功能",normalizedTitle:"5.8 标记文件夹功能",charIndex:1276},{level:2,title:"5.9 在 IDEA中配置Tomcat",slug:"_5-9-在-idea中配置tomcat",normalizedTitle:"5.9 在 idea中配置tomcat",charIndex:1300},{level:2,title:"5.10 pom文件",slug:"_5-10-pom文件",normalizedTitle:"5.10 pom文件",charIndex:1388},{level:2,title:"5.12 IDEA操作",slug:"_5-12-idea操作",normalizedTitle:"5.12 idea操作",charIndex:4669},{level:2,title:"5.13 解决遇到的问题",slug:"_5-13-解决遇到的问题",normalizedTitle:"5.13 解决遇到的问题",charIndex:4689}],headersStr:"5.1 Maven项目架构管理工具 5.2 下载安装Maven 5.3 配置环境变量 5.4 阿里云镜像 5.5 本地仓库 5.6、在IDEA中使用Maven 5.7、创建一个普通的Maven项目 5.8 标记文件夹功能 5.9 在 IDEA中配置Tomcat 5.10 pom文件 5.12 IDEA操作 5.13 解决遇到的问题",content:'# 5、Maven\n\n我为什么要学习这个技术？\n\n 1. 在Javaweb开发中，需要使用大量的jar包，我们手动去导入；\n\n 2. 如何能够让一个东西自动帮我导入和配置这个jar包。\n    \n    由此，Maven诞生了！\n\n\n# 5.1 Maven项目架构管理工具\n\n我们目前用来就是方便导入jar包的！\n\nMaven的核心思想：约定大于配置\n\n * 有约束，不要去违反。\n\nMaven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；\n\n\n# 5.2 下载安装Maven\n\n官网:https://maven.apache.org/，在Download页面\n\n\n\n下载完成后，解压即可；\n\n\n# 5.3 配置环境变量\n\n在我们的系统环境变量中，配置如下：\n\n * M2_HOME\n   \n   maven目录下的bin目录\n\n * MAVEN_HOME\n   \n   maven的目录\n   \n   \n\n * 在系统的path中配置\n   \n   %MAVEN_HOME%\\bin\n\n\n\n测试Maven是否安装成功，保证必须配置完毕！\n\n\n# 5.4 阿里云镜像\n\n\n\n * 镜像：mirrors\n   \n   作用：加速我们的下载\n\n * 国内建议使用阿里云的镜像\n\n<mirror>\n    <id>nexus-aliyun</id>  \n    <mirrorOf>*,!jeecg,!jeecg-snapshots</mirrorOf>  \n    <name>Nexus aliyun</name>  \n    <url>http://maven.aliyun.com/nexus/content/groups/public</url> \n</mirror>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.5 本地仓库\n\n建立一个本地仓库，修改配置里的以下内容\n\n<localRepository>D:\\Environment\\apache-maven-3.6.2\\maven-repo</localRepository>\n\n\n1\n\n\n\n# 5.6、在IDEA中使用Maven\n\n> 先在idea里面配置\n\n在主页面中配置，这样就不用每个项目配置了。\n\n\n\n点击Settings，选择Maven，配置这三个\n\n\n\n> 创建项目：\n\n 1. 启动IDEA\n\n 2. 创建一个MavenWeb项目\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n 3. 等待项目初始化完毕\n    \n    \n    \n    \n\n 4. 观察maven仓库中多了什么东西？\n\n 5. IDEA中的Maven设置\n    \n    注意：IDEA项目创建成功后，看一眼Maven的配置\n    \n    \n    \n    \n\n 6. 到这里，Maven在IDEA中的配置和使用就OK了!\n\n\n# 5.7、创建一个普通的Maven项目\n\n\n\n\n\n这个只有在Web应用下才会有！\n\n\n\n\n# 5.8 标记文件夹功能\n\n\n\n\n\n\n\n\n\n\n# 5.9 在 IDEA中配置Tomcat\n\n\n\n\n\n\n\n\n\n解决警告问题\n\n必须要的配置：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；\n\n\n\n\n\n\n\n\n\n\n# 5.10 pom文件\n\npom.xml 是Maven的核心配置文件\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n\x3c!--Maven版本和头文件--\x3e\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelVersion>4.0.0</modelVersion>\n\n  \x3c!--这里就是我们刚才配置的GAV--\x3e\n  <groupId>com.kuang</groupId>\n  <artifactId>javaweb-01-maven</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  \x3c!--Package：项目的打包方式\n  jar：java应用\n  war：JavaWeb应用\n  --\x3e\n  <packaging>war</packaging>\n\n\n  \x3c!--配置--\x3e\n  <properties>\n    \x3c!--项目的默认构建编码--\x3e\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    \x3c!--编码版本--\x3e\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n  </properties>\n\n  \x3c!--项目依赖--\x3e\n  <dependencies>\n    \x3c!--具体依赖的jar包配置文件--\x3e\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n  </dependencies>\n\n  \x3c!--项目构建用的东西--\x3e\n  <build>\n    <finalName>javaweb-01-maven</finalName>\n    <pluginManagement>\x3c!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n\nmaven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：\n\n\x3c!--在build中配置resources，来防止我们资源导出失败的问题--\x3e\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 5.12 IDEA操作\n\n\n\n\n\n\n# 5.13 解决遇到的问题\n\n 1. Maven 3.6.2\n    \n    解决方法：降级为3.6.1\n    \n    \n\n 2. Tomcat闪退\n\n 3. IDEA中每次都要重复配置Maven 在IDEA中的全局默认配置中去配置\n    \n    \n    \n    \n\n 4. Maven项目中Tomcat无法配置\n\n 5. maven默认web项目中的web.xml版本问题\n    \n    \n\n 6. 替换为webapp4.0版本和tomcat一致\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n                          http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n             version="4.0"\n             metadata-complete="true">\n    \n    \n    \n    </web-app>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 7. Maven仓库的使用\n    \n    地址：https://mvnrepository.com/\n    \n    \n    \n    \n    \n    \n    \n    ',normalizedContent:'# 5、maven\n\n我为什么要学习这个技术？\n\n 1. 在javaweb开发中，需要使用大量的jar包，我们手动去导入；\n\n 2. 如何能够让一个东西自动帮我导入和配置这个jar包。\n    \n    由此，maven诞生了！\n\n\n# 5.1 maven项目架构管理工具\n\n我们目前用来就是方便导入jar包的！\n\nmaven的核心思想：约定大于配置\n\n * 有约束，不要去违反。\n\nmaven会规定好你该如何去编写我们的java代码，必须要按照这个规范来；\n\n\n# 5.2 下载安装maven\n\n官网:https://maven.apache.org/，在download页面\n\n\n\n下载完成后，解压即可；\n\n\n# 5.3 配置环境变量\n\n在我们的系统环境变量中，配置如下：\n\n * m2_home\n   \n   maven目录下的bin目录\n\n * maven_home\n   \n   maven的目录\n   \n   \n\n * 在系统的path中配置\n   \n   %maven_home%\\bin\n\n\n\n测试maven是否安装成功，保证必须配置完毕！\n\n\n# 5.4 阿里云镜像\n\n\n\n * 镜像：mirrors\n   \n   作用：加速我们的下载\n\n * 国内建议使用阿里云的镜像\n\n<mirror>\n    <id>nexus-aliyun</id>  \n    <mirrorof>*,!jeecg,!jeecg-snapshots</mirrorof>  \n    <name>nexus aliyun</name>  \n    <url>http://maven.aliyun.com/nexus/content/groups/public</url> \n</mirror>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.5 本地仓库\n\n建立一个本地仓库，修改配置里的以下内容\n\n<localrepository>d:\\environment\\apache-maven-3.6.2\\maven-repo</localrepository>\n\n\n1\n\n\n\n# 5.6、在idea中使用maven\n\n> 先在idea里面配置\n\n在主页面中配置，这样就不用每个项目配置了。\n\n\n\n点击settings，选择maven，配置这三个\n\n\n\n> 创建项目：\n\n 1. 启动idea\n\n 2. 创建一个mavenweb项目\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n 3. 等待项目初始化完毕\n    \n    \n    \n    \n\n 4. 观察maven仓库中多了什么东西？\n\n 5. idea中的maven设置\n    \n    注意：idea项目创建成功后，看一眼maven的配置\n    \n    \n    \n    \n\n 6. 到这里，maven在idea中的配置和使用就ok了!\n\n\n# 5.7、创建一个普通的maven项目\n\n\n\n\n\n这个只有在web应用下才会有！\n\n\n\n\n# 5.8 标记文件夹功能\n\n\n\n\n\n\n\n\n\n\n# 5.9 在 idea中配置tomcat\n\n\n\n\n\n\n\n\n\n解决警告问题\n\n必须要的配置：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；\n\n\n\n\n\n\n\n\n\n\n# 5.10 pom文件\n\npom.xml 是maven的核心配置文件\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n\n\x3c!--maven版本和头文件--\x3e\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n  <modelversion>4.0.0</modelversion>\n\n  \x3c!--这里就是我们刚才配置的gav--\x3e\n  <groupid>com.kuang</groupid>\n  <artifactid>javaweb-01-maven</artifactid>\n  <version>1.0-snapshot</version>\n  \x3c!--package：项目的打包方式\n  jar：java应用\n  war：javaweb应用\n  --\x3e\n  <packaging>war</packaging>\n\n\n  \x3c!--配置--\x3e\n  <properties>\n    \x3c!--项目的默认构建编码--\x3e\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    \x3c!--编码版本--\x3e\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n  </properties>\n\n  \x3c!--项目依赖--\x3e\n  <dependencies>\n    \x3c!--具体依赖的jar包配置文件--\x3e\n    <dependency>\n      <groupid>junit</groupid>\n      <artifactid>junit</artifactid>\n      <version>4.11</version>\n    </dependency>\n  </dependencies>\n\n  \x3c!--项目构建用的东西--\x3e\n  <build>\n    <finalname>javaweb-01-maven</finalname>\n    <pluginmanagement>\x3c!-- lock down plugins versions to avoid using maven defaults (may be moved to parent pom) --\x3e\n      <plugins>\n        <plugin>\n          <artifactid>maven-clean-plugin</artifactid>\n          <version>3.1.0</version>\n        </plugin>\n        \x3c!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#plugin_bindings_for_war_packaging --\x3e\n        <plugin>\n          <artifactid>maven-resources-plugin</artifactid>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-compiler-plugin</artifactid>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-surefire-plugin</artifactid>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-war-plugin</artifactid>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-install-plugin</artifactid>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactid>maven-deploy-plugin</artifactid>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginmanagement>\n  </build>\n</project>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n\nmaven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：\n\n\x3c!--在build中配置resources，来防止我们资源导出失败的问题--\x3e\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 5.12 idea操作\n\n\n\n\n\n\n# 5.13 解决遇到的问题\n\n 1. maven 3.6.2\n    \n    解决方法：降级为3.6.1\n    \n    \n\n 2. tomcat闪退\n\n 3. idea中每次都要重复配置maven 在idea中的全局默认配置中去配置\n    \n    \n    \n    \n\n 4. maven项目中tomcat无法配置\n\n 5. maven默认web项目中的web.xml版本问题\n    \n    \n\n 6. 替换为webapp4.0版本和tomcat一致\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee\n                          http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n             version="4.0"\n             metadata-complete="true">\n    \n    \n    \n    </web-app>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 7. maven仓库的使用\n    \n    地址：https://mvnrepository.com/\n    \n    \n    \n    \n    \n    \n    \n    ',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"JavaWeb - 其它总览",frontmatter:{title:"JavaWeb - 其它总览",author:{name:"致远",link:"https://oddfar.com"},categories:["java","java-web"],date:"2021-05-07T18:09:11.000Z",permalink:"/pages/e8021e/"},regularPath:"/01.Java/20.JavaWeb/20.%E6%80%BB%E8%A7%88.html",relativePath:"01.Java/20.JavaWeb/20.总览.md",key:"v-38a9c856",path:"/pages/e8021e/",headers:[{level:2,title:"8、JSP",slug:"_8、jsp",normalizedTitle:"8、jsp",charIndex:14},{level:3,title:"8.1、什么是JSP",slug:"_8-1、什么是jsp",normalizedTitle:"8.1、什么是jsp",charIndex:24},{level:3,title:"8.2、JSP原理",slug:"_8-2、jsp原理",normalizedTitle:"8.2、jsp原理",charIndex:180},{level:3,title:"8.3、JSP基础语法",slug:"_8-3、jsp基础语法",normalizedTitle:"8.3、jsp基础语法",charIndex:2053},{level:4,title:"JSP表达式",slug:"jsp表达式",normalizedTitle:"jsp表达式",charIndex:2144},{level:4,title:"jsp脚本片段",slug:"jsp脚本片段",normalizedTitle:"jsp脚本片段",charIndex:2254},{level:4,title:"JSP声明",slug:"jsp声明",normalizedTitle:"jsp声明",charIndex:2739},{level:3,title:"8.4、JSP指令",slug:"_8-4、jsp指令",normalizedTitle:"8.4、jsp指令",charIndex:3095},{level:3,title:"8.5、9大内置对象",slug:"_8-5、9大内置对象",normalizedTitle:"8.5、9大内置对象",charIndex:3477},{level:3,title:"8.6、JSP标签、JSTL标签、EL表达式",slug:"_8-6、jsp标签、jstl标签、el表达式",normalizedTitle:"8.6、jsp标签、jstl标签、el表达式",charIndex:4082},{level:2,title:"9、JavaBean",slug:"_9、javabean",normalizedTitle:"9、javabean",charIndex:6523},{level:2,title:"10、MVC三层架构",slug:"_10、mvc三层架构",normalizedTitle:"10、mvc三层架构",charIndex:7092},{level:3,title:"10.1、早些年",slug:"_10-1、早些年",normalizedTitle:"10.1、早些年",charIndex:7148},{level:3,title:"10.2、MVC三层架构",slug:"_10-2、mvc三层架构",normalizedTitle:"10.2、mvc三层架构",charIndex:7360},{level:2,title:"11、Filter （重点）",slug:"_11、filter-重点",normalizedTitle:"11、filter （重点）",charIndex:7703},{level:2,title:"12、监听器",slug:"_12、监听器",normalizedTitle:"12、监听器",charIndex:9863},{level:2,title:"13、过滤器、监听器常见应用",slug:"_13、过滤器、监听器常见应用",normalizedTitle:"13、过滤器、监听器常见应用",charIndex:11920},{level:2,title:"14、JDBC",slug:"_14、jdbc",normalizedTitle:"14、jdbc",charIndex:13185},{level:2,title:"15、数据库连接池",slug:"_15、数据库连接池",normalizedTitle:"15、数据库连接池",charIndex:19348}],headersStr:"8、JSP 8.1、什么是JSP 8.2、JSP原理 8.3、JSP基础语法 JSP表达式 jsp脚本片段 JSP声明 8.4、JSP指令 8.5、9大内置对象 8.6、JSP标签、JSTL标签、EL表达式 9、JavaBean 10、MVC三层架构 10.1、早些年 10.2、MVC三层架构 11、Filter （重点） 12、监听器 13、过滤器、监听器常见应用 14、JDBC 15、数据库连接池",content:'# JavaWeb\n\n\n# 8、JSP\n\n\n# 8.1、什么是JSP\n\nJava Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！\n\n最大的特点：\n\n * 写JSP就像在写HTML\n * 区别：\n   * HTML只给用户提供静态的数据\n   * JSP页面中可以嵌入JAVA代码，为用户提供动态数据；\n\n\n# 8.2、JSP原理\n\n思路：JSP到底怎么执行的！\n\n * 代码层面没有任何问题\n\n * 服务器内部工作\n   \n   tomcat中有一个work目录；\n   \n   IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录\n   \n   \n   \n   我电脑的地址：\n   \n   C:\\Users\\Administrator\\.IntelliJIdea2018.1\\system\\tomcat\\Unnamed_javaweb-session-cookie\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp\n   \n   \n   1\n   \n   \n   发现页面转变成了Java程序！\n   \n   \n\n浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！\n\nJSP最终也会被转换成为一个Java类！\n\nJSP 本质上就是一个Servlet\n\n//初始化\n  public void _jspInit() {\n      \n  }\n//销毁\n  public void _jspDestroy() {\n  }\n//JSPService\n  public void _jspService(.HttpServletRequest request,HttpServletResponse response)\n      \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n 1. 判断请求\n\n 2. 内置一些对象\n    \n    final javax.servlet.jsp.PageContext pageContext;  //页面上下文\n    javax.servlet.http.HttpSession session = null;    //session\n    final javax.servlet.ServletContext application;   //applicationContext\n    final javax.servlet.ServletConfig config;         //config\n    javax.servlet.jsp.JspWriter out = null;           //out\n    final java.lang.Object page = this;               //page：当前\n    HttpServletRequest request                        //请求\n    HttpServletResponse response                      //响应\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 输出页面前增加的代码\n    \n    response.setContentType("text/html");       //设置响应的页面类型\n    pageContext = _jspxFactory.getPageContext(this, request, response,\n                                              null, true, 8192, true);\n    _jspx_page_context = pageContext;\n    application = pageContext.getServletContext();\n    config = pageContext.getServletConfig();\n    session = pageContext.getSession();\n    out = pageContext.getOut();\n    _jspx_out = out;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 4. 以上的这些个对象我们可以在JSP页面中直接使用！\n\n\n\n在JSP页面中；\n\n只要是 JAVA代码就会原封不动的输出；\n\n如果是HTML代码，就会被转换为：\n\nout.write("<html>\\r\\n");\n\n\n1\n\n\n这样的格式，输出到前端！\n\n\n# 8.3、JSP基础语法\n\n任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！\n\n# JSP表达式\n\n  <%--JSP表达式\n  作用：用来将程序的输出，输出到客户端\n  <%= 变量或者表达式%>\n  --%>\n  <%= new java.util.Date()%>\n\n\n1\n2\n3\n4\n5\n\n\n# jsp脚本片段\n\n\n  <%--jsp脚本片段--%>\n  <%\n    int sum = 0;\n    for (int i = 1; i <=100 ; i++) {\n      sum+=i;\n    }\n    out.println("<h1>Sum="+sum+"</h1>");\n  %>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n脚本片段的再实现\n\n  <%\n    int x = 10;\n    out.println(x);\n  %>\n  <p>这是一个JSP文档</p>\n  <%\n    int y = 2;\n    out.println(y);\n  %>\n\n  <hr>\n\n\n  <%--在代码嵌入HTML元素--%>\n  <%\n    for (int i = 0; i < 5; i++) {\n  %>\n    <h1>Hello,World  <%=i%> </h1>\n  <%\n    }\n  %>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# JSP声明\n\n  <%!\n    static {\n      System.out.println("Loading Servlet!");\n    }\n\n    private int globalVar = 0;\n\n    public void kuang(){\n      System.out.println("进入了方法Kuang！");\n    }\n  %>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nJSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！\n\n在JSP，嵌入Java代码即可！\n\n<%%>\n<%=%>\n<%!%>\n\n<%--注释--%>\n\n\n1\n2\n3\n4\n5\n\n\nJSP的注释，不会在客户端显示，HTML就会！\n\n\n# 8.4、JSP指令\n\n<%@page args.... %>\n<%@include file=""%>\n\n<%--@include会将两个页面合二为一--%>\n\n<%@include file="common/header.jsp"%>\n<h1>网页主体</h1>\n\n<%@include file="common/footer.jsp"%>\n\n<hr>\n\n\n<%--jSP标签\n    jsp:include：拼接页面，本质还是三个\n    --%>\n<jsp:include page="/common/header.jsp"/>\n<h1>网页主体</h1>\n<jsp:include page="/common/footer.jsp"/>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 8.5、9大内置对象\n\n * PageContext 存东西\n * Request 存东西\n * Response\n * Session 存东西\n * Application 【SerlvetContext】 存东西\n * config 【SerlvetConfig】\n * out\n * page ，不用了解\n * exception\n\npageContext.setAttribute("name1","秦疆1号"); //保存的数据只在一个页面中有效\nrequest.setAttribute("name2","秦疆2号"); //保存的数据只在一次请求中有效，请求转发会携带这个数据\nsession.setAttribute("name3","秦疆3号"); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器\napplication.setAttribute("name4","秦疆4号");  //保存的数据只在服务器中有效，从打开服务器到关闭服务器\n\n\n1\n2\n3\n4\n\n\nrequest：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！\n\nsession：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；\n\napplication：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；\n\n\n# 8.6、JSP标签、JSTL标签、EL表达式\n\n\x3c!-- JSTL表达式的依赖 --\x3e\n<dependency>\n    <groupId>javax.servlet.jsp.jstl</groupId>\n    <artifactId>jstl-api</artifactId>\n    <version>1.2</version>\n</dependency>\n\x3c!-- standard标签库 --\x3e\n<dependency>\n    <groupId>taglibs</groupId>\n    <artifactId>standard</artifactId>\n    <version>1.1.2</version>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nEL表达式： ${ }\n\n * 获取数据\n * 执行运算\n * 获取web开发的常用对象\n\nJSP标签\n\n<%--jsp:include--%>\n\n<%--\nhttp://localhost:8080/jsptag.jsp?name=kuangshen&age=12\n--%>\n\n<jsp:forward page="/jsptag2.jsp">\n    <jsp:param name="name" value="kuangshen"></jsp:param>\n    <jsp:param name="age" value="12"></jsp:param>\n</jsp:forward>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nJSTL表达式\n\nJSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！\n\n格式化标签\n\nSQL标签\n\nXML 标签\n\n核心标签 （掌握部分）\n\n\n\nJSTL标签库使用步骤\n\n * 引入对应的 taglib\n * 使用其中的方法\n * 在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误\n\nc：if\n\n<head>\n    <title>Title</title>\n</head>\n<body>\n\n\n<h4>if测试</h4>\n\n<hr>\n\n<form action="coreif.jsp" method="get">\n    <%--\n    EL表达式获取表单中的数据\n    ${param.参数名}\n    --%>\n    <input type="text" name="username" value="${param.username}">\n    <input type="submit" value="登录">\n</form>\n\n<%--判断如果提交的用户名是管理员，则登录成功--%>\n<c:if test="${param.username==\'admin\'}" var="isAdmin">\n    <c:out value="管理员欢迎您！"/>\n</c:if>\n\n<%--自闭合标签--%>\n<c:out value="${isAdmin}"/>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nc:choose c:when\n\n<body>\n\n<%--定义一个变量score，值为85--%>\n<c:set var="score" value="55"/>\n\n<c:choose>\n    <c:when test="${score>=90}">\n        你的成绩为优秀\n    </c:when>\n    <c:when test="${score>=80}">\n        你的成绩为一般\n    </c:when>\n    <c:when test="${score>=70}">\n        你的成绩为良好\n    </c:when>\n    <c:when test="${score<=60}">\n        你的成绩为不及格\n    </c:when>\n</c:choose>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nc:forEach\n\n<%\n\n    ArrayList<String> people = new ArrayList<>();\n    people.add(0,"张三");\n    people.add(1,"李四");\n    people.add(2,"王五");\n    people.add(3,"赵六");\n    people.add(4,"田六");\n    request.setAttribute("list",people);\n%>\n\n\n<%--\nvar , 每一次遍历出来的变量\nitems, 要遍历的对象\nbegin,   哪里开始\nend,     到哪里\nstep,   步长\n--%>\n<c:forEach var="people" items="${list}">\n    <c:out value="${people}"/> <br>\n</c:forEach>\n\n<hr>\n\n<c:forEach var="people" items="${list}" begin="1" end="3" step="1" >\n    <c:out value="${people}"/> <br>\n</c:forEach>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 9、JavaBean\n\n实体类\n\nJavaBean有特定的写法：\n\n * 必须要有一个无参构造\n * 属性必须私有化\n * 必须有对应的get/set方法；\n\n一般用来和数据库的字段做映射 ORM；\n\nORM ：对象关系映射\n\n * 表---\x3e类\n * 字段--\x3e属性\n * 行记录----\x3e对象\n\npeople表\n\nID   NAME   AGE   ADDRESS\n1    秦疆1号   3     西安\n2    秦疆2号   18    西安\n3    秦疆3号   100   西安\n\nclass People{\n    private int id;\n    private String name;\n    private int id;\n    private String address;\n}\n\nclass A{\n    new People(1,"秦疆1号",3，"西安");\n    new People(2,"秦疆2号",3，"西安");\n    new People(3,"秦疆3号",3，"西安");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 过滤器\n * 文件上传\n * 邮件发送\n * JDBC 复习 ： 如何使用JDBC , JDBC crud， jdbc 事务\n\n\n# 10、MVC三层架构\n\n什么是MVC： Model view Controller 模型、视图、控制器\n\n\n# 10.1、早些年\n\n\n\n用户直接访问控制层，控制层就可以直接操作数据库；\n\nservlet--CRUD--\x3e数据库\n弊端：程序十分臃肿，不利于维护  \nservlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码\n\n架构：没有什么是加一层解决不了的！\n程序猿调用\n|\nJDBC\n|\nMysql Oracle SqlServer ....\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 10.2、MVC三层架构\n\n\n\nModel\n\n * 业务处理 ：业务逻辑（Service）\n * 数据持久层：CRUD （Dao）\n\nView\n\n * 展示数据\n * 提供链接发起Servlet请求 （a，form，img…）\n\nController （Servlet）\n\n * 接收用户的请求 ：（req：请求参数、Session信息….）\n\n * 交给业务层处理对应的代码\n\n * 控制视图的跳转\n   \n   登录---\x3e接收用户的登录请求---\x3e处理用户的请求（获取用户登录的参数，username，password）----\x3e交给业务层处理登录业务（判断用户名密码是否正确：事务）---\x3eDao层查询用户名和密码是否正确--\x3e数据库\n   \n   \n   1\n   \n\n\n# 11、Filter （重点）\n\nFilter：过滤器 ，用来过滤网站的数据；\n\n * 处理中文乱码\n * 登录验证….\n\n\n\nFilter开发步骤：\n\n 1. 导包\n\n 2. 编写过滤器\n    \n    1. 导包不要错\n       \n       \n       \n       实现Filter接口，重写对应的方法即可\n       \n       public class CharacterEncodingFilter implements Filter {\n       \n           //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！\n           public void init(FilterConfig filterConfig) throws ServletException {\n               System.out.println("CharacterEncodingFilter初始化");\n           }\n       \n           //Chain : 链\n           /*\n           1. 过滤中的所有代码，在过滤特定请求的时候都会执行\n           2. 必须要让过滤器继续同行\n               chain.doFilter(request,response);\n            */\n           public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n               request.setCharacterEncoding("utf-8");\n               response.setCharacterEncoding("utf-8");\n               response.setContentType("text/html;charset=UTF-8");\n       \n               System.out.println("CharacterEncodingFilter执行前....");\n               chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！\n               System.out.println("CharacterEncodingFilter执行后....");\n           }\n       \n           //销毁：web服务器关闭的时候，过滤会销毁\n           public void destroy() {\n               System.out.println("CharacterEncodingFilter销毁");\n           }\n       }\n       \n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       17\n       18\n       19\n       20\n       21\n       22\n       23\n       24\n       25\n       26\n       27\n       28\n       29\n       \n\n 3. 在web.xml中配置 Filter\n    \n    <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>com.kuang.filter.CharacterEncodingFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        \x3c!--只要是 /servlet的任何请求，会经过这个过滤器--\x3e\n        <url-pattern>/servlet/*</url-pattern>\n        \x3c!--<url-pattern>/*</url-pattern>--\x3e\n    </filter-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 12、监听器\n\n实现一个监听器的接口；（有N种）\n\n 1. 编写一个监听器\n    \n    实现监听器的接口…\n    \n    //统计网站在线人数 ： 统计session\n    public class OnlineCountListener implements HttpSessionListener {\n    \n        //创建session监听： 看你的一举一动\n        //一旦创建Session就会触发一次这个事件！\n        public void sessionCreated(HttpSessionEvent se) {\n            ServletContext ctx = se.getSession().getServletContext();\n    \n            System.out.println(se.getSession().getId());\n    \n            Integer onlineCount = (Integer) ctx.getAttribute("OnlineCount");\n    \n            if (onlineCount==null){\n                onlineCount = new Integer(1);\n            }else {\n                int count = onlineCount.intValue();\n                onlineCount = new Integer(count+1);\n            }\n    \n            ctx.setAttribute("OnlineCount",onlineCount);\n    \n        }\n    \n        //销毁session监听\n        //一旦销毁Session就会触发一次这个事件！\n        public void sessionDestroyed(HttpSessionEvent se) {\n            ServletContext ctx = se.getSession().getServletContext();\n    \n            Integer onlineCount = (Integer) ctx.getAttribute("OnlineCount");\n    \n            if (onlineCount==null){\n                onlineCount = new Integer(0);\n            }else {\n                int count = onlineCount.intValue();\n                onlineCount = new Integer(count-1);\n            }\n    \n            ctx.setAttribute("OnlineCount",onlineCount);\n    \n        }\n    \n    \n        /*\n        Session销毁：\n        1. 手动销毁  getSession().invalidate();\n        2. 自动销毁\n         */\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n 2. web.xml中注册监听器\n    \n    \x3c!--注册监听器--\x3e\n    <listener>\n        <listener-class>com.kuang.listener.OnlineCountListener</listener-class>\n    </listener>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 看情况是否使用！\n\n\n# 13、过滤器、监听器常见应用\n\n监听器：GUI编程中经常使用；\n\npublic class TestPanel {\n    public static void main(String[] args) {\n        Frame frame = new Frame("中秋节快乐");  //新建一个窗体\n        Panel panel = new Panel(null); //面板\n        frame.setLayout(null); //设置窗体的布局\n\n        frame.setBounds(300,300,500,500);\n        frame.setBackground(new Color(0,0,255)); //设置背景颜色\n\n        panel.setBounds(50,50,300,300);\n        panel.setBackground(new Color(0,255,0)); //设置背景颜色\n\n        frame.add(panel);\n\n        frame.setVisible(true);\n\n        //监听事件，监听关闭事件\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                super.windowClosing(e);\n            }\n        });\n\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n用户登录之后才能进入主页！用户注销后就不能进入主页了！\n\n 1. 用户登录之后，向Sesison中放入用户的数据\n\n 2. 进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！\n    \n    HttpServletRequest request = (HttpServletRequest) req;\n    HttpServletResponse response = (HttpServletResponse) resp;\n    \n    if (request.getSession().getAttribute(Constant.USER_SESSION)==null){\n        response.sendRedirect("/error.jsp");\n    }\n    \n    chain.doFilter(request,response);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 14、JDBC\n\n什么是JDBC ： Java连接数据库！\n\n\n\n需要jar包的支持：\n\n * java.sql\n * javax.sql\n * mysql-conneter-java… 连接驱动（必须要导入）\n\n实验环境搭建\n\n\nCREATE TABLE users(\n    id INT PRIMARY KEY,\n    `name` VARCHAR(40),\n    `password` VARCHAR(40),\n    email VARCHAR(60),\n    birthday DATE\n);\n\nINSERT INTO users(id,`name`,`password`,email,birthday)\nVALUES(1,\'张三\',\'123456\',\'zs@qq.com\',\'2000-01-01\');\nINSERT INTO users(id,`name`,`password`,email,birthday)\nVALUES(2,\'李四\',\'123456\',\'ls@qq.com\',\'2000-01-01\');\nINSERT INTO users(id,`name`,`password`,email,birthday)\nVALUES(3,\'王五\',\'123456\',\'ww@qq.com\',\'2000-01-01\');\n\n\nSELECT\t* FROM users;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n导入数据库依赖\n\n\x3c!--mysql的驱动--\x3e\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.47</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\nIDEA中连接数据库：\n\n\n\nJDBC 固定步骤：\n\n 1. 加载驱动\n 2. 连接数据库,代表数据库\n 3. 向数据库发送SQL的对象Statement : CRUD\n 4. 编写SQL （根据业务，不同的SQL）\n 5. 执行SQL\n 6. 关闭连接\n\npublic class TestJdbc {\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //配置信息\n        //useUnicode=true&characterEncoding=utf-8 解决中文乱码\n        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";\n        String username = "root";\n        String password = "123456";\n\n        //1.加载驱动\n        Class.forName("com.mysql.jdbc.Driver");\n        //2.连接数据库,代表数据库\n        Connection connection = DriverManager.getConnection(url, username, password);\n\n        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD\n        Statement statement = connection.createStatement();\n\n        //4.编写SQL\n        String sql = "select * from users";\n\n        //5.执行查询SQL，返回一个 ResultSet  ： 结果集\n        ResultSet rs = statement.executeQuery(sql);\n\n        while (rs.next()){\n            System.out.println("id="+rs.getObject("id"));\n            System.out.println("name="+rs.getObject("name"));\n            System.out.println("password="+rs.getObject("password"));\n            System.out.println("email="+rs.getObject("email"));\n            System.out.println("birthday="+rs.getObject("birthday"));\n        }\n\n        //6.关闭连接，释放资源（一定要做） 先开后关\n        rs.close();\n        statement.close();\n        connection.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n预编译SQL\n\npublic class TestJDBC2 {\n    public static void main(String[] args) throws Exception {\n        //配置信息\n        //useUnicode=true&characterEncoding=utf-8 解决中文乱码\n        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";\n        String username = "root";\n        String password = "123456";\n\n        //1.加载驱动\n        Class.forName("com.mysql.jdbc.Driver");\n        //2.连接数据库,代表数据库\n        Connection connection = DriverManager.getConnection(url, username, password);\n\n        //3.编写SQL\n        String sql = "insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);";\n\n        //4.预编译\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；\n        preparedStatement.setString(2,"狂神说Java");//给第二个占位符？ 的值赋值为狂神说Java；\n        preparedStatement.setString(3,"123456");//给第三个占位符？ 的值赋值为123456；\n        preparedStatement.setString(4,"24736743@qq.com");//给第四个占位符？ 的值赋值为1；\n        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；\n\n        //5.执行SQL\n        int i = preparedStatement.executeUpdate();\n\n        if (i>0){\n            System.out.println("插入成功@");\n        }\n\n        //6.关闭连接，释放资源（一定要做） 先开后关\n        preparedStatement.close();\n        connection.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n事务\n\n要么都成功，要么都失败！\n\nACID原则：保证数据的安全。\n\n开启事务\n事务提交  commit()\n事务回滚  rollback()\n关闭事务\n\n转账：\nA:1000\nB:1000\n    \nA(900)   --100--\x3e   B(1100) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nJunit单元测试\n\n依赖\n\n\x3c!--单元测试--\x3e\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n简单使用\n\n@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！\n\n@Test\npublic void test(){\n    System.out.println("Hello");\n}\n\n\n1\n2\n3\n4\n\n\n\n\n失败的时候是红色：\n\n\n\n搭建一个环境\n\nCREATE TABLE account(\n   id INT PRIMARY KEY AUTO_INCREMENT,\n   `name` VARCHAR(40),\n   money FLOAT\n);\n\nINSERT INTO account(`name`,money) VALUES(\'A\',1000);\nINSERT INTO account(`name`,money) VALUES(\'B\',1000);\nINSERT INTO account(`name`,money) VALUES(\'C\',1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    @Test\n    public void test() {\n        //配置信息\n        //useUnicode=true&characterEncoding=utf-8 解决中文乱码\n        String url="jdbc:mysql://localhost:3306/jdbc?useUnicode=true&characterEncoding=utf-8";\n        String username = "root";\n        String password = "123456";\n\n        Connection connection = null;\n\n        //1.加载驱动\n        try {\n            Class.forName("com.mysql.jdbc.Driver");\n            //2.连接数据库,代表数据库\n             connection = DriverManager.getConnection(url, username, password);\n\n            //3.通知数据库开启事务,false 开启\n            connection.setAutoCommit(false);\n\n            String sql = "update account set money = money-100 where name = \'A\'";\n            connection.prepareStatement(sql).executeUpdate();\n\n            //制造错误\n            //int i = 1/0;\n\n            String sql2 = "update account set money = money+100 where name = \'B\'";\n            connection.prepareStatement(sql2).executeUpdate();\n\n            connection.commit();//以上两条SQL都执行成功了，就提交事务！\n            System.out.println("success");\n        } catch (Exception e) {\n            try {\n                //如果出现异常，就通知数据库回滚事务\n                connection.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            e.printStackTrace();\n        }finally {\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 15、数据库连接池\n\n概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：\n\n 1. 节约资源\n 2. 用户访问高效\n\n实现： 标准接口：DataSource javax.sql包下的\n\n 1. 方法：\n\n> 获取连接：getConnection() 归还连接：Connection.close()。 如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接\n\n 2. 一般我们不去实现它，有数据库厂商来实现\n\n>  1. C3P0：数据库连接池技术\n>  2. Druid：数据库连接池实现技术，由阿里巴巴提供的\n\nC3P0：数据库连接池技术\n\n * 步骤：\n\n 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动 jar 包\n 2. 定义配置文件：\n\n> 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。\n\n 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource()\n 4. 获取连接：getConnection()\n\n * 代码：\n\n//1.创建数据库连接池对象\nDataSource ds  = new ComboPooledDataSource();\n//2. 获取连接对象\nConnection conn = ds.getConnection();\n\n\n1\n2\n3\n4\n\n\nDruid：数据库连接池实现技术，由阿里巴巴提供的\n\n * 步骤：\n\n 1. 导入jar包 druid-1.0.9.jar\n 2. 定义配置文件：\n    * 是properties形式的*\n    * 可以叫任意名称，可以放在任意目录下*\n 3. 加载配置文件。Properties\n 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory()\n 5. 获取连接：getConnection()\n\n * 代码：\n\n//3.加载配置文件\nProperties pro = new Properties();\nInputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");\npro.load(is);\n//4.获取连接池对象\nDataSource ds = DruidDataSourceFactory.createDataSource(pro);\n//5.获取连接\nConnection conn = ds.getConnection();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n定义工具类\n\n 1. 定义一个类 JDBCUtils\n 2. 提供静态代码块加载配置文件，初始化连接池对象\n 3. 提供方法\n\n>  1. 获取连接方法：通过数据库连接池获取连接\n>  2. 释放资源\n>  3. 获取连接池的方法\n\n代码：\n\npublic class JDBCUtils {\n\n    //1.定义成员变量 DataSource\n    private static DataSource ds ;\n\n    static{\n        try {\n            //1.加载配置文件\n            Properties pro = new Properties();\n            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));\n            //2.获取DataSource\n            ds = DruidDataSourceFactory.createDataSource(pro);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 获取连接\n     */\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();\n    }\n\n    /**\n     * 释放资源\n     */\n    public static void close(Statement stmt,Connection conn){\n\t\t\t       /* if(stmt != null){\n\t\t\t            try {\n\t\t\t                stmt.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t        if(conn != null){\n\t\t\t            try {\n\t\t\t                conn.close();//归还连接\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }*/\n\n        close(null,stmt,conn);\n    }\n\n\n    public static void close(ResultSet rs , Statement stmt, Connection conn){\n        \n        if(rs != null){\n            try {\n                rs.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if(stmt != null){\n            try {\n                stmt.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if(conn != null){\n            try {\n                conn.close();//归还连接\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 获取连接池方法\n     */\n\n    public static DataSource getDataSource(){\n        return  ds;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n',normalizedContent:'# javaweb\n\n\n# 8、jsp\n\n\n# 8.1、什么是jsp\n\njava server pages ： java服务器端页面，也和servlet一样，用于动态web技术！\n\n最大的特点：\n\n * 写jsp就像在写html\n * 区别：\n   * html只给用户提供静态的数据\n   * jsp页面中可以嵌入java代码，为用户提供动态数据；\n\n\n# 8.2、jsp原理\n\n思路：jsp到底怎么执行的！\n\n * 代码层面没有任何问题\n\n * 服务器内部工作\n   \n   tomcat中有一个work目录；\n   \n   idea中使用tomcat的会在idea的tomcat中生产一个work目录\n   \n   \n   \n   我电脑的地址：\n   \n   c:\\users\\administrator\\.intellijidea2018.1\\system\\tomcat\\unnamed_javaweb-session-cookie\\work\\catalina\\localhost\\root\\org\\apache\\jsp\n   \n   \n   1\n   \n   \n   发现页面转变成了java程序！\n   \n   \n\n浏览器向服务器发送请求，不管访问什么资源，其实都是在访问servlet！\n\njsp最终也会被转换成为一个java类！\n\njsp 本质上就是一个servlet\n\n//初始化\n  public void _jspinit() {\n      \n  }\n//销毁\n  public void _jspdestroy() {\n  }\n//jspservice\n  public void _jspservice(.httpservletrequest request,httpservletresponse response)\n      \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n 1. 判断请求\n\n 2. 内置一些对象\n    \n    final javax.servlet.jsp.pagecontext pagecontext;  //页面上下文\n    javax.servlet.http.httpsession session = null;    //session\n    final javax.servlet.servletcontext application;   //applicationcontext\n    final javax.servlet.servletconfig config;         //config\n    javax.servlet.jsp.jspwriter out = null;           //out\n    final java.lang.object page = this;               //page：当前\n    httpservletrequest request                        //请求\n    httpservletresponse response                      //响应\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 输出页面前增加的代码\n    \n    response.setcontenttype("text/html");       //设置响应的页面类型\n    pagecontext = _jspxfactory.getpagecontext(this, request, response,\n                                              null, true, 8192, true);\n    _jspx_page_context = pagecontext;\n    application = pagecontext.getservletcontext();\n    config = pagecontext.getservletconfig();\n    session = pagecontext.getsession();\n    out = pagecontext.getout();\n    _jspx_out = out;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 4. 以上的这些个对象我们可以在jsp页面中直接使用！\n\n\n\n在jsp页面中；\n\n只要是 java代码就会原封不动的输出；\n\n如果是html代码，就会被转换为：\n\nout.write("<html>\\r\\n");\n\n\n1\n\n\n这样的格式，输出到前端！\n\n\n# 8.3、jsp基础语法\n\n任何语言都有自己的语法，java中有,。 jsp 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），java所有语法都支持！\n\n# jsp表达式\n\n  <%--jsp表达式\n  作用：用来将程序的输出，输出到客户端\n  <%= 变量或者表达式%>\n  --%>\n  <%= new java.util.date()%>\n\n\n1\n2\n3\n4\n5\n\n\n# jsp脚本片段\n\n\n  <%--jsp脚本片段--%>\n  <%\n    int sum = 0;\n    for (int i = 1; i <=100 ; i++) {\n      sum+=i;\n    }\n    out.println("<h1>sum="+sum+"</h1>");\n  %>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n脚本片段的再实现\n\n  <%\n    int x = 10;\n    out.println(x);\n  %>\n  <p>这是一个jsp文档</p>\n  <%\n    int y = 2;\n    out.println(y);\n  %>\n\n  <hr>\n\n\n  <%--在代码嵌入html元素--%>\n  <%\n    for (int i = 0; i < 5; i++) {\n  %>\n    <h1>hello,world  <%=i%> </h1>\n  <%\n    }\n  %>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# jsp声明\n\n  <%!\n    static {\n      system.out.println("loading servlet!");\n    }\n\n    private int globalvar = 0;\n\n    public void kuang(){\n      system.out.println("进入了方法kuang！");\n    }\n  %>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\njsp声明：会被编译到jsp生成java的类中！其他的，就会被生成到_jspservice方法中！\n\n在jsp，嵌入java代码即可！\n\n<%%>\n<%=%>\n<%!%>\n\n<%--注释--%>\n\n\n1\n2\n3\n4\n5\n\n\njsp的注释，不会在客户端显示，html就会！\n\n\n# 8.4、jsp指令\n\n<%@page args.... %>\n<%@include file=""%>\n\n<%--@include会将两个页面合二为一--%>\n\n<%@include file="common/header.jsp"%>\n<h1>网页主体</h1>\n\n<%@include file="common/footer.jsp"%>\n\n<hr>\n\n\n<%--jsp标签\n    jsp:include：拼接页面，本质还是三个\n    --%>\n<jsp:include page="/common/header.jsp"/>\n<h1>网页主体</h1>\n<jsp:include page="/common/footer.jsp"/>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 8.5、9大内置对象\n\n * pagecontext 存东西\n * request 存东西\n * response\n * session 存东西\n * application 【serlvetcontext】 存东西\n * config 【serlvetconfig】\n * out\n * page ，不用了解\n * exception\n\npagecontext.setattribute("name1","秦疆1号"); //保存的数据只在一个页面中有效\nrequest.setattribute("name2","秦疆2号"); //保存的数据只在一次请求中有效，请求转发会携带这个数据\nsession.setattribute("name3","秦疆3号"); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器\napplication.setattribute("name4","秦疆4号");  //保存的数据只在服务器中有效，从打开服务器到关闭服务器\n\n\n1\n2\n3\n4\n\n\nrequest：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！\n\nsession：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；\n\napplication：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；\n\n\n# 8.6、jsp标签、jstl标签、el表达式\n\n\x3c!-- jstl表达式的依赖 --\x3e\n<dependency>\n    <groupid>javax.servlet.jsp.jstl</groupid>\n    <artifactid>jstl-api</artifactid>\n    <version>1.2</version>\n</dependency>\n\x3c!-- standard标签库 --\x3e\n<dependency>\n    <groupid>taglibs</groupid>\n    <artifactid>standard</artifactid>\n    <version>1.1.2</version>\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nel表达式： ${ }\n\n * 获取数据\n * 执行运算\n * 获取web开发的常用对象\n\njsp标签\n\n<%--jsp:include--%>\n\n<%--\nhttp://localhost:8080/jsptag.jsp?name=kuangshen&age=12\n--%>\n\n<jsp:forward page="/jsptag2.jsp">\n    <jsp:param name="name" value="kuangshen"></jsp:param>\n    <jsp:param name="age" value="12"></jsp:param>\n</jsp:forward>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\njstl表达式\n\njstl标签库的使用就是为了弥补html标签的不足；它自定义许多标签，可以供我们使用，标签的功能和java代码一样！\n\n格式化标签\n\nsql标签\n\nxml 标签\n\n核心标签 （掌握部分）\n\n\n\njstl标签库使用步骤\n\n * 引入对应的 taglib\n * 使用其中的方法\n * 在tomcat 也需要引入 jstl的包，否则会报错：jstl解析错误\n\nc：if\n\n<head>\n    <title>title</title>\n</head>\n<body>\n\n\n<h4>if测试</h4>\n\n<hr>\n\n<form action="coreif.jsp" method="get">\n    <%--\n    el表达式获取表单中的数据\n    ${param.参数名}\n    --%>\n    <input type="text" name="username" value="${param.username}">\n    <input type="submit" value="登录">\n</form>\n\n<%--判断如果提交的用户名是管理员，则登录成功--%>\n<c:if test="${param.username==\'admin\'}" var="isadmin">\n    <c:out value="管理员欢迎您！"/>\n</c:if>\n\n<%--自闭合标签--%>\n<c:out value="${isadmin}"/>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nc:choose c:when\n\n<body>\n\n<%--定义一个变量score，值为85--%>\n<c:set var="score" value="55"/>\n\n<c:choose>\n    <c:when test="${score>=90}">\n        你的成绩为优秀\n    </c:when>\n    <c:when test="${score>=80}">\n        你的成绩为一般\n    </c:when>\n    <c:when test="${score>=70}">\n        你的成绩为良好\n    </c:when>\n    <c:when test="${score<=60}">\n        你的成绩为不及格\n    </c:when>\n</c:choose>\n\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nc:foreach\n\n<%\n\n    arraylist<string> people = new arraylist<>();\n    people.add(0,"张三");\n    people.add(1,"李四");\n    people.add(2,"王五");\n    people.add(3,"赵六");\n    people.add(4,"田六");\n    request.setattribute("list",people);\n%>\n\n\n<%--\nvar , 每一次遍历出来的变量\nitems, 要遍历的对象\nbegin,   哪里开始\nend,     到哪里\nstep,   步长\n--%>\n<c:foreach var="people" items="${list}">\n    <c:out value="${people}"/> <br>\n</c:foreach>\n\n<hr>\n\n<c:foreach var="people" items="${list}" begin="1" end="3" step="1" >\n    <c:out value="${people}"/> <br>\n</c:foreach>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 9、javabean\n\n实体类\n\njavabean有特定的写法：\n\n * 必须要有一个无参构造\n * 属性必须私有化\n * 必须有对应的get/set方法；\n\n一般用来和数据库的字段做映射 orm；\n\norm ：对象关系映射\n\n * 表---\x3e类\n * 字段--\x3e属性\n * 行记录----\x3e对象\n\npeople表\n\nid   name   age   address\n1    秦疆1号   3     西安\n2    秦疆2号   18    西安\n3    秦疆3号   100   西安\n\nclass people{\n    private int id;\n    private string name;\n    private int id;\n    private string address;\n}\n\nclass a{\n    new people(1,"秦疆1号",3，"西安");\n    new people(2,"秦疆2号",3，"西安");\n    new people(3,"秦疆3号",3，"西安");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 过滤器\n * 文件上传\n * 邮件发送\n * jdbc 复习 ： 如何使用jdbc , jdbc crud， jdbc 事务\n\n\n# 10、mvc三层架构\n\n什么是mvc： model view controller 模型、视图、控制器\n\n\n# 10.1、早些年\n\n\n\n用户直接访问控制层，控制层就可以直接操作数据库；\n\nservlet--crud--\x3e数据库\n弊端：程序十分臃肿，不利于维护  \nservlet的代码中：处理请求、响应、视图跳转、处理jdbc、处理业务代码、处理逻辑代码\n\n架构：没有什么是加一层解决不了的！\n程序猿调用\n|\njdbc\n|\nmysql oracle sqlserver ....\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 10.2、mvc三层架构\n\n\n\nmodel\n\n * 业务处理 ：业务逻辑（service）\n * 数据持久层：crud （dao）\n\nview\n\n * 展示数据\n * 提供链接发起servlet请求 （a，form，img…）\n\ncontroller （servlet）\n\n * 接收用户的请求 ：（req：请求参数、session信息….）\n\n * 交给业务层处理对应的代码\n\n * 控制视图的跳转\n   \n   登录---\x3e接收用户的登录请求---\x3e处理用户的请求（获取用户登录的参数，username，password）----\x3e交给业务层处理登录业务（判断用户名密码是否正确：事务）---\x3edao层查询用户名和密码是否正确--\x3e数据库\n   \n   \n   1\n   \n\n\n# 11、filter （重点）\n\nfilter：过滤器 ，用来过滤网站的数据；\n\n * 处理中文乱码\n * 登录验证….\n\n\n\nfilter开发步骤：\n\n 1. 导包\n\n 2. 编写过滤器\n    \n    1. 导包不要错\n       \n       \n       \n       实现filter接口，重写对应的方法即可\n       \n       public class characterencodingfilter implements filter {\n       \n           //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！\n           public void init(filterconfig filterconfig) throws servletexception {\n               system.out.println("characterencodingfilter初始化");\n           }\n       \n           //chain : 链\n           /*\n           1. 过滤中的所有代码，在过滤特定请求的时候都会执行\n           2. 必须要让过滤器继续同行\n               chain.dofilter(request,response);\n            */\n           public void dofilter(servletrequest request, servletresponse response, filterchain chain) throws ioexception, servletexception {\n               request.setcharacterencoding("utf-8");\n               response.setcharacterencoding("utf-8");\n               response.setcontenttype("text/html;charset=utf-8");\n       \n               system.out.println("characterencodingfilter执行前....");\n               chain.dofilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！\n               system.out.println("characterencodingfilter执行后....");\n           }\n       \n           //销毁：web服务器关闭的时候，过滤会销毁\n           public void destroy() {\n               system.out.println("characterencodingfilter销毁");\n           }\n       }\n       \n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       17\n       18\n       19\n       20\n       21\n       22\n       23\n       24\n       25\n       26\n       27\n       28\n       29\n       \n\n 3. 在web.xml中配置 filter\n    \n    <filter>\n        <filter-name>characterencodingfilter</filter-name>\n        <filter-class>com.kuang.filter.characterencodingfilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>characterencodingfilter</filter-name>\n        \x3c!--只要是 /servlet的任何请求，会经过这个过滤器--\x3e\n        <url-pattern>/servlet/*</url-pattern>\n        \x3c!--<url-pattern>/*</url-pattern>--\x3e\n    </filter-mapping>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n\n# 12、监听器\n\n实现一个监听器的接口；（有n种）\n\n 1. 编写一个监听器\n    \n    实现监听器的接口…\n    \n    //统计网站在线人数 ： 统计session\n    public class onlinecountlistener implements httpsessionlistener {\n    \n        //创建session监听： 看你的一举一动\n        //一旦创建session就会触发一次这个事件！\n        public void sessioncreated(httpsessionevent se) {\n            servletcontext ctx = se.getsession().getservletcontext();\n    \n            system.out.println(se.getsession().getid());\n    \n            integer onlinecount = (integer) ctx.getattribute("onlinecount");\n    \n            if (onlinecount==null){\n                onlinecount = new integer(1);\n            }else {\n                int count = onlinecount.intvalue();\n                onlinecount = new integer(count+1);\n            }\n    \n            ctx.setattribute("onlinecount",onlinecount);\n    \n        }\n    \n        //销毁session监听\n        //一旦销毁session就会触发一次这个事件！\n        public void sessiondestroyed(httpsessionevent se) {\n            servletcontext ctx = se.getsession().getservletcontext();\n    \n            integer onlinecount = (integer) ctx.getattribute("onlinecount");\n    \n            if (onlinecount==null){\n                onlinecount = new integer(0);\n            }else {\n                int count = onlinecount.intvalue();\n                onlinecount = new integer(count-1);\n            }\n    \n            ctx.setattribute("onlinecount",onlinecount);\n    \n        }\n    \n    \n        /*\n        session销毁：\n        1. 手动销毁  getsession().invalidate();\n        2. 自动销毁\n         */\n    }\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n 2. web.xml中注册监听器\n    \n    \x3c!--注册监听器--\x3e\n    <listener>\n        <listener-class>com.kuang.listener.onlinecountlistener</listener-class>\n    </listener>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 看情况是否使用！\n\n\n# 13、过滤器、监听器常见应用\n\n监听器：gui编程中经常使用；\n\npublic class testpanel {\n    public static void main(string[] args) {\n        frame frame = new frame("中秋节快乐");  //新建一个窗体\n        panel panel = new panel(null); //面板\n        frame.setlayout(null); //设置窗体的布局\n\n        frame.setbounds(300,300,500,500);\n        frame.setbackground(new color(0,0,255)); //设置背景颜色\n\n        panel.setbounds(50,50,300,300);\n        panel.setbackground(new color(0,255,0)); //设置背景颜色\n\n        frame.add(panel);\n\n        frame.setvisible(true);\n\n        //监听事件，监听关闭事件\n        frame.addwindowlistener(new windowadapter() {\n            @override\n            public void windowclosing(windowevent e) {\n                super.windowclosing(e);\n            }\n        });\n\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n用户登录之后才能进入主页！用户注销后就不能进入主页了！\n\n 1. 用户登录之后，向sesison中放入用户的数据\n\n 2. 进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！\n    \n    httpservletrequest request = (httpservletrequest) req;\n    httpservletresponse response = (httpservletresponse) resp;\n    \n    if (request.getsession().getattribute(constant.user_session)==null){\n        response.sendredirect("/error.jsp");\n    }\n    \n    chain.dofilter(request,response);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 14、jdbc\n\n什么是jdbc ： java连接数据库！\n\n\n\n需要jar包的支持：\n\n * java.sql\n * javax.sql\n * mysql-conneter-java… 连接驱动（必须要导入）\n\n实验环境搭建\n\n\ncreate table users(\n    id int primary key,\n    `name` varchar(40),\n    `password` varchar(40),\n    email varchar(60),\n    birthday date\n);\n\ninsert into users(id,`name`,`password`,email,birthday)\nvalues(1,\'张三\',\'123456\',\'zs@qq.com\',\'2000-01-01\');\ninsert into users(id,`name`,`password`,email,birthday)\nvalues(2,\'李四\',\'123456\',\'ls@qq.com\',\'2000-01-01\');\ninsert into users(id,`name`,`password`,email,birthday)\nvalues(3,\'王五\',\'123456\',\'ww@qq.com\',\'2000-01-01\');\n\n\nselect\t* from users;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n导入数据库依赖\n\n\x3c!--mysql的驱动--\x3e\n<dependency>\n    <groupid>mysql</groupid>\n    <artifactid>mysql-connector-java</artifactid>\n    <version>5.1.47</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\nidea中连接数据库：\n\n\n\njdbc 固定步骤：\n\n 1. 加载驱动\n 2. 连接数据库,代表数据库\n 3. 向数据库发送sql的对象statement : crud\n 4. 编写sql （根据业务，不同的sql）\n 5. 执行sql\n 6. 关闭连接\n\npublic class testjdbc {\n    public static void main(string[] args) throws classnotfoundexception, sqlexception {\n        //配置信息\n        //useunicode=true&characterencoding=utf-8 解决中文乱码\n        string url="jdbc:mysql://localhost:3306/jdbc?useunicode=true&characterencoding=utf-8";\n        string username = "root";\n        string password = "123456";\n\n        //1.加载驱动\n        class.forname("com.mysql.jdbc.driver");\n        //2.连接数据库,代表数据库\n        connection connection = drivermanager.getconnection(url, username, password);\n\n        //3.向数据库发送sql的对象statement,preparedstatement : crud\n        statement statement = connection.createstatement();\n\n        //4.编写sql\n        string sql = "select * from users";\n\n        //5.执行查询sql，返回一个 resultset  ： 结果集\n        resultset rs = statement.executequery(sql);\n\n        while (rs.next()){\n            system.out.println("id="+rs.getobject("id"));\n            system.out.println("name="+rs.getobject("name"));\n            system.out.println("password="+rs.getobject("password"));\n            system.out.println("email="+rs.getobject("email"));\n            system.out.println("birthday="+rs.getobject("birthday"));\n        }\n\n        //6.关闭连接，释放资源（一定要做） 先开后关\n        rs.close();\n        statement.close();\n        connection.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n预编译sql\n\npublic class testjdbc2 {\n    public static void main(string[] args) throws exception {\n        //配置信息\n        //useunicode=true&characterencoding=utf-8 解决中文乱码\n        string url="jdbc:mysql://localhost:3306/jdbc?useunicode=true&characterencoding=utf-8";\n        string username = "root";\n        string password = "123456";\n\n        //1.加载驱动\n        class.forname("com.mysql.jdbc.driver");\n        //2.连接数据库,代表数据库\n        connection connection = drivermanager.getconnection(url, username, password);\n\n        //3.编写sql\n        string sql = "insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);";\n\n        //4.预编译\n        preparedstatement preparedstatement = connection.preparestatement(sql);\n\n        preparedstatement.setint(1,2);//给第一个占位符？ 的值赋值为1；\n        preparedstatement.setstring(2,"狂神说java");//给第二个占位符？ 的值赋值为狂神说java；\n        preparedstatement.setstring(3,"123456");//给第三个占位符？ 的值赋值为123456；\n        preparedstatement.setstring(4,"24736743@qq.com");//给第四个占位符？ 的值赋值为1；\n        preparedstatement.setdate(5,new date(new java.util.date().gettime()));//给第五个占位符？ 的值赋值为new date(new java.util.date().gettime())；\n\n        //5.执行sql\n        int i = preparedstatement.executeupdate();\n\n        if (i>0){\n            system.out.println("插入成功@");\n        }\n\n        //6.关闭连接，释放资源（一定要做） 先开后关\n        preparedstatement.close();\n        connection.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n事务\n\n要么都成功，要么都失败！\n\nacid原则：保证数据的安全。\n\n开启事务\n事务提交  commit()\n事务回滚  rollback()\n关闭事务\n\n转账：\na:1000\nb:1000\n    \na(900)   --100--\x3e   b(1100) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\njunit单元测试\n\n依赖\n\n\x3c!--单元测试--\x3e\n<dependency>\n    <groupid>junit</groupid>\n    <artifactid>junit</artifactid>\n    <version>4.12</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n简单使用\n\n@test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！\n\n@test\npublic void test(){\n    system.out.println("hello");\n}\n\n\n1\n2\n3\n4\n\n\n\n\n失败的时候是红色：\n\n\n\n搭建一个环境\n\ncreate table account(\n   id int primary key auto_increment,\n   `name` varchar(40),\n   money float\n);\n\ninsert into account(`name`,money) values(\'a\',1000);\ninsert into account(`name`,money) values(\'b\',1000);\ninsert into account(`name`,money) values(\'c\',1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    @test\n    public void test() {\n        //配置信息\n        //useunicode=true&characterencoding=utf-8 解决中文乱码\n        string url="jdbc:mysql://localhost:3306/jdbc?useunicode=true&characterencoding=utf-8";\n        string username = "root";\n        string password = "123456";\n\n        connection connection = null;\n\n        //1.加载驱动\n        try {\n            class.forname("com.mysql.jdbc.driver");\n            //2.连接数据库,代表数据库\n             connection = drivermanager.getconnection(url, username, password);\n\n            //3.通知数据库开启事务,false 开启\n            connection.setautocommit(false);\n\n            string sql = "update account set money = money-100 where name = \'a\'";\n            connection.preparestatement(sql).executeupdate();\n\n            //制造错误\n            //int i = 1/0;\n\n            string sql2 = "update account set money = money+100 where name = \'b\'";\n            connection.preparestatement(sql2).executeupdate();\n\n            connection.commit();//以上两条sql都执行成功了，就提交事务！\n            system.out.println("success");\n        } catch (exception e) {\n            try {\n                //如果出现异常，就通知数据库回滚事务\n                connection.rollback();\n            } catch (sqlexception e1) {\n                e1.printstacktrace();\n            }\n            e.printstacktrace();\n        }finally {\n            try {\n                connection.close();\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 15、数据库连接池\n\n概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：\n\n 1. 节约资源\n 2. 用户访问高效\n\n实现： 标准接口：datasource javax.sql包下的\n\n 1. 方法：\n\n> 获取连接：getconnection() 归还连接：connection.close()。 如果连接对象connection是从连接池中获取的，那么调用connection.close()方法，则不会再关闭连接了。而是归还连接\n\n 2. 一般我们不去实现它，有数据库厂商来实现\n\n>  1. c3p0：数据库连接池技术\n>  2. druid：数据库连接池实现技术，由阿里巴巴提供的\n\nc3p0：数据库连接池技术\n\n * 步骤：\n\n 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动 jar 包\n 2. 定义配置文件：\n\n> 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。\n\n 3. 创建核心对象 数据库连接池对象 combopooleddatasource()\n 4. 获取连接：getconnection()\n\n * 代码：\n\n//1.创建数据库连接池对象\ndatasource ds  = new combopooleddatasource();\n//2. 获取连接对象\nconnection conn = ds.getconnection();\n\n\n1\n2\n3\n4\n\n\ndruid：数据库连接池实现技术，由阿里巴巴提供的\n\n * 步骤：\n\n 1. 导入jar包 druid-1.0.9.jar\n 2. 定义配置文件：\n    * 是properties形式的*\n    * 可以叫任意名称，可以放在任意目录下*\n 3. 加载配置文件。properties\n 4. 获取数据库连接池对象：通过工厂来来获取 druiddatasourcefactory()\n 5. 获取连接：getconnection()\n\n * 代码：\n\n//3.加载配置文件\nproperties pro = new properties();\ninputstream is = druiddemo.class.getclassloader().getresourceasstream("druid.properties");\npro.load(is);\n//4.获取连接池对象\ndatasource ds = druiddatasourcefactory.createdatasource(pro);\n//5.获取连接\nconnection conn = ds.getconnection();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n定义工具类\n\n 1. 定义一个类 jdbcutils\n 2. 提供静态代码块加载配置文件，初始化连接池对象\n 3. 提供方法\n\n>  1. 获取连接方法：通过数据库连接池获取连接\n>  2. 释放资源\n>  3. 获取连接池的方法\n\n代码：\n\npublic class jdbcutils {\n\n    //1.定义成员变量 datasource\n    private static datasource ds ;\n\n    static{\n        try {\n            //1.加载配置文件\n            properties pro = new properties();\n            pro.load(jdbcutils.class.getclassloader().getresourceasstream("druid.properties"));\n            //2.获取datasource\n            ds = druiddatasourcefactory.createdatasource(pro);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n    /**\n     * 获取连接\n     */\n    public static connection getconnection() throws sqlexception {\n        return ds.getconnection();\n    }\n\n    /**\n     * 释放资源\n     */\n    public static void close(statement stmt,connection conn){\n\t\t\t       /* if(stmt != null){\n\t\t\t            try {\n\t\t\t                stmt.close();\n\t\t\t            } catch (sqlexception e) {\n\t\t\t                e.printstacktrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t        if(conn != null){\n\t\t\t            try {\n\t\t\t                conn.close();//归还连接\n\t\t\t            } catch (sqlexception e) {\n\t\t\t                e.printstacktrace();\n\t\t\t            }\n\t\t\t        }*/\n\n        close(null,stmt,conn);\n    }\n\n\n    public static void close(resultset rs , statement stmt, connection conn){\n        \n        if(rs != null){\n            try {\n                rs.close();\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        }\n        if(stmt != null){\n            try {\n                stmt.close();\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        }\n\n        if(conn != null){\n            try {\n                conn.close();//归还连接\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n    /**\n     * 获取连接池方法\n     */\n\n    public static datasource getdatasource(){\n        return  ds;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.数据库/05.MySQL",imgUrl:"/img/web.png",description:"MySQL 目录页"}},title:"MySQL - 知识体系",permalink:"/mysql",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2021-08-03T18:04:03.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/02.MySQL.html",relativePath:"03.数据库/05.MySQL/02.MySQL.md",key:"v-6989e0ac",path:"/mysql/",headersStr:null,content:"MySQL入门：\n\nMySQL基础笔记可看 菜鸟教程\n\nmysql基础视频教程 bilibili 上搜即可\n\n----------------------------------------\n\nMySQL进阶：\n\n * 尚硅谷MySQL数据库高级\n   \n   视频：https://www.bilibili.com/video/BV1KW411u7vy\n   \n   笔记链接：https://pan.baidu.com/s/1GUzPFVG3Je9uT419rHE8MQ\n   \n   提取码：ybfi\n\n * 黑马程序员2020最新MySQL高级教程\n   \n   视频：https://www.bilibili.com/video/BV1UQ4y1P7Xr\n   \n   笔记：https://gitee.com/yooome/netty-study\n\n我刚开始看的是尚硅谷的，看了一半跑去看黑马的了\n\n这两教程内容都差不多，黑马的更多一些\n\n推荐书籍：《深入浅出mysql》\n\n视频内容围绕着这本书上内容讲的",normalizedContent:"mysql入门：\n\nmysql基础笔记可看 菜鸟教程\n\nmysql基础视频教程 bilibili 上搜即可\n\n----------------------------------------\n\nmysql进阶：\n\n * 尚硅谷mysql数据库高级\n   \n   视频：https://www.bilibili.com/video/bv1kw411u7vy\n   \n   笔记链接：https://pan.baidu.com/s/1guzpfvg3je9ut419rhe8mq\n   \n   提取码：ybfi\n\n * 黑马程序员2020最新mysql高级教程\n   \n   视频：https://www.bilibili.com/video/bv1uq4y1p7xr\n   \n   笔记：https://gitee.com/yooome/netty-study\n\n我刚开始看的是尚硅谷的，看了一半跑去看黑马的了\n\n这两教程内容都差不多，黑马的更多一些\n\n推荐书籍：《深入浅出mysql》\n\n视频内容围绕着这本书上内容讲的",charsets:{cjk:!0},lastUpdated:"2021/09/12, 15:09:00",lastUpdatedTimestamp:1631461529e3},{title:"MySQL - 索引介绍",frontmatter:{title:"MySQL - 索引介绍",permalink:"/mysql/index/",date:"2021-05-20T20:51:46.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/06.MySQL%20-%20%E7%B4%A2%E5%BC%95.html",relativePath:"03.数据库/05.MySQL/06.MySQL - 索引.md",key:"v-e50b8c2e",path:"/mysql/index/",headers:[{level:2,title:"索引的概念",slug:"索引的概念",normalizedTitle:"索引的概念",charIndex:3},{level:2,title:"推荐文章",slug:"推荐文章",normalizedTitle:"推荐文章",charIndex:12},{level:2,title:"索引结构",slug:"索引结构",normalizedTitle:"索引结构",charIndex:20},{level:3,title:"Btree 索引结构",slug:"btree-索引结构",normalizedTitle:"btree 索引结构",charIndex:30},{level:4,title:"演变过程",slug:"演变过程",normalizedTitle:"演变过程",charIndex:48},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:60},{level:3,title:"B+tree 结构",slug:"b-tree-结构",normalizedTitle:"b+tree 结构",charIndex:68},{level:3,title:"MySQL中的B+Tree",slug:"mysql中的b-tree",normalizedTitle:"mysql中的b+tree",charIndex:83},{level:3,title:"聚簇索引和非聚簇索引",slug:"聚簇索引和非聚簇索引",normalizedTitle:"聚簇索引和非聚簇索引",charIndex:102},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:118},{level:2,title:"索引分类",slug:"索引分类",normalizedTitle:"索引分类",charIndex:127},{level:3,title:"单值索引",slug:"单值索引",normalizedTitle:"单值索引",charIndex:137},{level:3,title:"唯一索引",slug:"唯一索引",normalizedTitle:"唯一索引",charIndex:147},{level:3,title:"复合索引",slug:"复合索引",normalizedTitle:"复合索引",charIndex:157},{level:3,title:"主键索引",slug:"主键索引",normalizedTitle:"主键索引",charIndex:167},{level:3,title:"索引基本语法",slug:"索引基本语法",normalizedTitle:"索引基本语法",charIndex:177},{level:2,title:"索引设计原则",slug:"索引设计原则",normalizedTitle:"索引设计原则",charIndex:187}],headersStr:"索引的概念 推荐文章 索引结构 Btree 索引结构 演变过程 其他 B+tree 结构 MySQL中的B+Tree 聚簇索引和非聚簇索引 时间复杂度 索引分类 单值索引 唯一索引 复合索引 主键索引 索引基本语法 索引设计原则",content:" * 索引的概念\n * 推荐文章\n * 索引结构\n   * Btree 索引结构\n     * 演变过程\n     * 其他\n   * B+tree 结构\n   * MySQL中的B+Tree\n   * 聚簇索引和非聚簇索引\n   * 时间复杂度\n * 索引分类\n   * 单值索引\n   * 唯一索引\n   * 复合索引\n   * 主键索引\n   * 索引基本语法\n * 索引设计原则\n\n\n# 索引的概念\n\n索引（Index）是帮助 MySQL 高效获取数据的数据结构，可以简单理解为排好序的快速查找数据结构。\n\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引\n\n\n\n左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。\n\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。\n\n索引优缺点\n\n优势：\n\n * 提高数据检索的效率，降低数据库的IO成本。\n * 数据排序，降低CPU消耗\n\n劣势：\n\n * 虽然索引大大提高了查询速度，同时却会降低更新表的速度\n   \n   如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因更新所带来的键值变化后的索引信息。\n\n * 索引本质也是一张表，保存着索引字段和指向实际记录的指针，所以也要占用数据库空间，一般而言，索引表占用的空间是数据表的1.5倍\n\n\n# 推荐文章\n\n * MySQL 索引原理 图文讲解\n   \n   涉及到树相关数据结构知识。\n\n * BTree和B+Tree\n   \n   详细介绍\n\n\n# 索引结构\n\n\n# Btree 索引结构\n\n黑马教程：https://www.bilibili.com/video/BV1UQ4y1P7Xr?p=6\n\nBtree又可以写成B-tree（B-Tree，并不是B“减”树，横杠为连接符，容易被误导）\n\nBTree又叫多路平衡搜索树，一颗 m 叉的BTree特性如下：\n\n * 树中每个节点最多包含m个孩子。\n * 除根节点与叶子节点外，每个节点至少有 [ceil(m/2)] 个孩子。\n * 若根节点不是叶子节点，则至少有两个孩子。\n * 所有的叶子节点都在同一层。\n * 每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m/2)-1] <= n <= m-1\n\nceli()：向上取整，例如celi(2.5)=3\n\n# 演变过程\n\n以5叉 BTree 为例，key的数量：公式推导 [ceil(m/2)-1] <= n <= m-1。所以 2 <= n <=4 。\n\n当 n>4 时，中间节点分裂到父节点，两边节点分裂。\n\n插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。（插入时，按照ABCD..顺序）\n\n1). 插入前4个字母 C N G A\n\n\n\n2). 插入H，n>4，中间元素G字母向上分裂到新的节点\n\n\n\n3). 插入E，K，Q不需要分裂\n\n\n\n4). 插入M，中间元素M字母向上分裂到父节点G\n\n（M 在 K、N中间，BTree最多含有n-1个key，这里即4个key，5个指针）\n\n\n\n5). 插入F，W，L，T不需要分裂\n\n\n\n6). 插入Z，中间元素T向上分裂到父节点中\n\n（插入Z后是，NQTWZ，把中间T提出来，方便更快的查询，所以不提出Z）\n\n\n\n7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂\n\n\n\n8). 最后插入S（R后面），NPQR节点n>5，中间节点Q向上分裂，但分裂后父节点DGMT的n>5，中间节点M向上分裂\n\n\n\n到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。\n\n# 其他\n\n\n\n初始化介绍\n\n一颗 b 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色 所示），\n\n如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3， P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。 真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。 非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中\n\n查找过程\n\n如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指 针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。\n\n真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的， 如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。\n\n\n# B+tree 结构\n\n\n\nB+Tree为BTree的变种，B+Tree与BTree的区别为：\n\n1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。\n\n2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。\n\n3). 所有的非叶子节点都可以看作是key的索引部分。\n\n * B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。\n * 在 B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B- 树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B-树多，树高比 B-树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故。\n\n为什么B+树比 B-树更适合索引？\n\n * B+树的磁盘读写代价更低\n   \n   B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就 越多。相对来说 IO 读写次数也就降低了。\n\n * B+树的查询效率更加稳定\n   \n   由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须 走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n\n\n# MySQL中的B+Tree\n\nMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。\n\nMySQL中的 B+Tree 索引结构示意图:\n\n\n\n\n# 聚簇索引和非聚簇索引\n\n聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储 在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。\n\n\n\n聚簇索引的好处\n\n按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多 个数据块中提取数据，所以节省了大量的 io 操作。\n\n聚簇索引的限制\n\n对于 mysql 数据库目前只有 innodb 数据引擎支持聚簇索引，而 Myisam 并不支持聚簇索引。\n\n由于数据物理存储排序方式只能有一种，所以每个 Mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。\n\n为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量选用有序的顺序 id，而不建议用无序的 id，比如 uuid 这种。\n\n\n# 时间复杂度\n\n同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。\n\n时间复杂度是指执行算法所需要的计算工作量，用大 O 表示记为：O(…)\n\n\n\n\n\n\n# 索引分类\n\n\n# 单值索引\n\n概念：即一个索引只包含单个列，一个表可以有多个单列索引\n\n * 所表一起创建\n   \n   CREATE TABLE customer (\n     id INT (10) UNSIGNED AUTO_INCREMENT,\n     customer_no VARCHAR (200),\n     customer_name VARCHAR (200),\n     PRIMARY KEY (id),\n     KEY (customer_name)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 单独建单值索引\n   \n   CREATE INDEX idx_customer_name\n   ON customer (customer_name);\n   \n   \n   1\n   2\n   \n\n\n# 唯一索引\n\n概念：索引列的值必须唯一，但允许有空值\n\n * 随表一起创建\n   \n   CREATE TABLE customer (\n     id INT (10) UNSIGNED AUTO_INCREMENT,\n     customer_no VARCHAR (200),\n     customer_name VARCHAR (200),\n     PRIMARY KEY (id),\n     KEY (customer_name),\n     UNIQUE (customer_no)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 单独建唯一索引：\n   \n   CREATE UNIQUE INDEX idx_customer_no\n   ON customer (customer_no);\n   \n   \n   1\n   2\n   \n\n\n# 复合索引\n\n概念：即一个索引包含多个列\n\n * 随表一起建索引\n   \n   CREATE TABLE customer (\n     id INT (10) UNSIGNED AUTO_INCREMENT,\n     customer_no VARCHAR (200),\n     customer_name VARCHAR (200),\n     PRIMARY KEY (id),\n     KEY (customer_name),\n     UNIQUE (customer_name),\n     KEY (customer_no, customer_name)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 单独建索引：\n   \n   CREATE INDEX idx_no_name\n   ON customer (customer_no, customer_name);\n   \n   \n   1\n   2\n   \n\n\n# 主键索引\n\n概念：设定为主键后数据库会自动建立索引，innodb为聚簇索引\n\n * 随表一起建索引\n   \n   CREATE TABLE customer (\n     id INT (10) UNSIGNED AUTO_INCREMENT,\n     customer_no VARCHAR (200),\n     customer_name VARCHAR (200),\n     PRIMARY KEY (id)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 单独建主键索引：\n   \n   ALTER TABLE customer ADD PRIMARY KEY customer(customer_no);\n   \n   \n   1\n   \n\n * 删除主键索引\n   \n   ALTER TABLE customer drop PRIMARY KEY ;\n   \n   \n   1\n   \n\n * 修改建主键索引\n   \n   必须先删除掉(drop)原索引，再新建(add)索引\n\n\n# 索引基本语法\n\n * 创建\n   \n   CREATE [UNIQUE] INDEX [indexName]\n   ON table_name(column))\n   \n   \n   1\n   2\n   \n   \n   示例 ： 为city表中的city_name字段创建索引 ；\n   \n   \n\n * 删除\n   \n   DROP  INDEX  index_name  ON  tbl_name;\n   \n   \n   1\n   \n\n * 查看\n   \n   show index  from  table_name;\n   \n   \n   1\n   \n\n * AlTER\n   \n   1). alter  table  tb_name  add  primary  key(column_list); \n   \n   \t该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL\n   \t\n   2). alter  table  tb_name  add  unique index_name(column_list);\n   \t\n   \t这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）\n   \t\n   3). alter  table  tb_name  add  index index_name(column_list);\n   \n   \t添加普通索引， 索引值可以出现多次。\n   \t\n   4). alter  table  tb_name  add  fulltext  index_name(column_list);\n   \t\n   \t该语句指定了索引为FULLTEXT， 用于全文索引\n   \t\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 索引设计原则\n\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。\n\n * 对查询频次较高，且数据量比较大的表建立索引。\n\n * 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\n\n * 使用唯一索引，区分度越高，使用索引的效率越高。\n\n * 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\n\n * 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。\n\n * 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。\n   \n   创建复合索引\n   \n   CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);\n   \n   \n   1\n   \n   \n   就相当于\n   \n   对 name 创建索引 ; 对 name , email 创建了索引 ; 对 name , email, status 创建了索引 ;\n\n不适合创建索引的情况\n\n * 表记录太少\n * 经常增删改的表或者字段\n * Where 条件里用不到的字段不创建索引\n * 过滤性不好的不适合建索引",normalizedContent:" * 索引的概念\n * 推荐文章\n * 索引结构\n   * btree 索引结构\n     * 演变过程\n     * 其他\n   * b+tree 结构\n   * mysql中的b+tree\n   * 聚簇索引和非聚簇索引\n   * 时间复杂度\n * 索引分类\n   * 单值索引\n   * 唯一索引\n   * 复合索引\n   * 主键索引\n   * 索引基本语法\n * 索引设计原则\n\n\n# 索引的概念\n\n索引（index）是帮助 mysql 高效获取数据的数据结构，可以简单理解为排好序的快速查找数据结构。\n\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引\n\n\n\n左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。\n\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。\n\n索引优缺点\n\n优势：\n\n * 提高数据检索的效率，降低数据库的io成本。\n * 数据排序，降低cpu消耗\n\n劣势：\n\n * 虽然索引大大提高了查询速度，同时却会降低更新表的速度\n   \n   如对表进行insert、update和delete。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因更新所带来的键值变化后的索引信息。\n\n * 索引本质也是一张表，保存着索引字段和指向实际记录的指针，所以也要占用数据库空间，一般而言，索引表占用的空间是数据表的1.5倍\n\n\n# 推荐文章\n\n * mysql 索引原理 图文讲解\n   \n   涉及到树相关数据结构知识。\n\n * btree和b+tree\n   \n   详细介绍\n\n\n# 索引结构\n\n\n# btree 索引结构\n\n黑马教程：https://www.bilibili.com/video/bv1uq4y1p7xr?p=6\n\nbtree又可以写成b-tree（b-tree，并不是b“减”树，横杠为连接符，容易被误导）\n\nbtree又叫多路平衡搜索树，一颗 m 叉的btree特性如下：\n\n * 树中每个节点最多包含m个孩子。\n * 除根节点与叶子节点外，每个节点至少有 [ceil(m/2)] 个孩子。\n * 若根节点不是叶子节点，则至少有两个孩子。\n * 所有的叶子节点都在同一层。\n * 每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m/2)-1] <= n <= m-1\n\nceli()：向上取整，例如celi(2.5)=3\n\n# 演变过程\n\n以5叉 btree 为例，key的数量：公式推导 [ceil(m/2)-1] <= n <= m-1。所以 2 <= n <=4 。\n\n当 n>4 时，中间节点分裂到父节点，两边节点分裂。\n\n插入 c n g a h e k q m f w l t z d p r x y s 数据为例。（插入时，按照abcd..顺序）\n\n1). 插入前4个字母 c n g a\n\n\n\n2). 插入h，n>4，中间元素g字母向上分裂到新的节点\n\n\n\n3). 插入e，k，q不需要分裂\n\n\n\n4). 插入m，中间元素m字母向上分裂到父节点g\n\n（m 在 k、n中间，btree最多含有n-1个key，这里即4个key，5个指针）\n\n\n\n5). 插入f，w，l，t不需要分裂\n\n\n\n6). 插入z，中间元素t向上分裂到父节点中\n\n（插入z后是，nqtwz，把中间t提出来，方便更快的查询，所以不提出z）\n\n\n\n7). 插入d，中间元素d向上分裂到父节点中。然后插入p，r，x，y不需要分裂\n\n\n\n8). 最后插入s（r后面），npqr节点n>5，中间节点q向上分裂，但分裂后父节点dgmt的n>5，中间节点m向上分裂\n\n\n\n到此，该btree树就已经构建完成了， btree树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，btree的层级结构比二叉树小，因此搜索速度快。\n\n# 其他\n\n\n\n初始化介绍\n\n一颗 b 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色 所示），\n\n如磁盘块 1 包含数据项 17 和 35，包含指针 p1、p2、p3， p1 表示小于 17 的磁盘块，p2 表示在 17 和 35 之间的磁盘块，p3 表示大于 35 的磁盘块。 真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。 非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中\n\n查找过程\n\n如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 io，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 p2 指针，内存时间因为非常短（相比磁盘的 io）可以忽略不计，通过磁盘块 1 的 p2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 io，29 在 26 和 30 之间，锁定磁盘块 3 的 p2 指 针，通过指针加载磁盘块 8 到内存，发生第三次 io，同时内存中做二分查找找到 29，结束查询，总计三次 io。\n\n真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 io，性能提高将是巨大的， 如果没有索引，每个数据项都要发生一次 io，那么总共需要百万次的 io，显然成本非常非常高。\n\n\n# b+tree 结构\n\n\n\nb+tree为btree的变种，b+tree与btree的区别为：\n\n1). n叉b+tree最多含有n个key，而btree最多含有n-1个key。\n\n2). b+tree的叶子节点保存所有的key信息，依key大小顺序排列。\n\n3). 所有的非叶子节点都可以看作是key的索引部分。\n\n * b-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；b+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。\n * 在 b-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 b+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 b- 树的性能好像要比 b+树好，而在实际应用中却是 b+树的性能要好些。因为 b+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 b-树多，树高比 b-树小，这样带来的好处是减少磁盘访问次数。尽管 b+树找到 一个记录所需的比较次数要比 b-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 b+树的性能可能还会好些，而且 b+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 b+树的缘故。\n\n为什么b+树比 b-树更适合索引？\n\n * b+树的磁盘读写代价更低\n   \n   b+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 b 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就 越多。相对来说 io 读写次数也就降低了。\n\n * b+树的查询效率更加稳定\n   \n   由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须 走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n\n\n# mysql中的b+tree\n\nmysql索引数据结构对经典的b+tree进行了优化。在原b+tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的b+tree，提高区间访问的性能。\n\nmysql中的 b+tree 索引结构示意图:\n\n\n\n\n# 聚簇索引和非聚簇索引\n\n聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储 在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。\n\n\n\n聚簇索引的好处\n\n按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多 个数据块中提取数据，所以节省了大量的 io 操作。\n\n聚簇索引的限制\n\n对于 mysql 数据库目前只有 innodb 数据引擎支持聚簇索引，而 myisam 并不支持聚簇索引。\n\n由于数据物理存储排序方式只能有一种，所以每个 mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。\n\n为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量选用有序的顺序 id，而不建议用无序的 id，比如 uuid 这种。\n\n\n# 时间复杂度\n\n同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。\n\n时间复杂度是指执行算法所需要的计算工作量，用大 o 表示记为：o(…)\n\n\n\n\n\n\n# 索引分类\n\n\n# 单值索引\n\n概念：即一个索引只包含单个列，一个表可以有多个单列索引\n\n * 所表一起创建\n   \n   create table customer (\n     id int (10) unsigned auto_increment,\n     customer_no varchar (200),\n     customer_name varchar (200),\n     primary key (id),\n     key (customer_name)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 单独建单值索引\n   \n   create index idx_customer_name\n   on customer (customer_name);\n   \n   \n   1\n   2\n   \n\n\n# 唯一索引\n\n概念：索引列的值必须唯一，但允许有空值\n\n * 随表一起创建\n   \n   create table customer (\n     id int (10) unsigned auto_increment,\n     customer_no varchar (200),\n     customer_name varchar (200),\n     primary key (id),\n     key (customer_name),\n     unique (customer_no)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 单独建唯一索引：\n   \n   create unique index idx_customer_no\n   on customer (customer_no);\n   \n   \n   1\n   2\n   \n\n\n# 复合索引\n\n概念：即一个索引包含多个列\n\n * 随表一起建索引\n   \n   create table customer (\n     id int (10) unsigned auto_increment,\n     customer_no varchar (200),\n     customer_name varchar (200),\n     primary key (id),\n     key (customer_name),\n     unique (customer_name),\n     key (customer_no, customer_name)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 单独建索引：\n   \n   create index idx_no_name\n   on customer (customer_no, customer_name);\n   \n   \n   1\n   2\n   \n\n\n# 主键索引\n\n概念：设定为主键后数据库会自动建立索引，innodb为聚簇索引\n\n * 随表一起建索引\n   \n   create table customer (\n     id int (10) unsigned auto_increment,\n     customer_no varchar (200),\n     customer_name varchar (200),\n     primary key (id)\t#this\n   );\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 单独建主键索引：\n   \n   alter table customer add primary key customer(customer_no);\n   \n   \n   1\n   \n\n * 删除主键索引\n   \n   alter table customer drop primary key ;\n   \n   \n   1\n   \n\n * 修改建主键索引\n   \n   必须先删除掉(drop)原索引，再新建(add)索引\n\n\n# 索引基本语法\n\n * 创建\n   \n   create [unique] index [indexname]\n   on table_name(column))\n   \n   \n   1\n   2\n   \n   \n   示例 ： 为city表中的city_name字段创建索引 ；\n   \n   \n\n * 删除\n   \n   drop  index  index_name  on  tbl_name;\n   \n   \n   1\n   \n\n * 查看\n   \n   show index  from  table_name;\n   \n   \n   1\n   \n\n * alter\n   \n   1). alter  table  tb_name  add  primary  key(column_list); \n   \n   \t该语句添加一个主键，这意味着索引值必须是唯一的，且不能为null\n   \t\n   2). alter  table  tb_name  add  unique index_name(column_list);\n   \t\n   \t这条语句创建索引的值必须是唯一的（除了null外，null可能会出现多次）\n   \t\n   3). alter  table  tb_name  add  index index_name(column_list);\n   \n   \t添加普通索引， 索引值可以出现多次。\n   \t\n   4). alter  table  tb_name  add  fulltext  index_name(column_list);\n   \t\n   \t该语句指定了索引为fulltext， 用于全文索引\n   \t\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n\n# 索引设计原则\n\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。\n\n * 对查询频次较高，且数据量比较大的表建立索引。\n\n * 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\n\n * 使用唯一索引，区分度越高，使用索引的效率越高。\n\n * 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等dml操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低dml操作的效率，增加相应操作的时间消耗。另外索引过多的话，mysql也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\n\n * 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的i/o效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升mysql访问索引的i/o效率。\n\n * 利用最左前缀，n个列组合而成的组合索引，那么相当于是创建了n个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询sql可以利用组合索引来提升查询效率。\n   \n   创建复合索引\n   \n   create index idx_name_email_status on tb_seller(name,email,status);\n   \n   \n   1\n   \n   \n   就相当于\n   \n   对 name 创建索引 ; 对 name , email 创建了索引 ; 对 name , email, status 创建了索引 ;\n\n不适合创建索引的情况\n\n * 表记录太少\n * 经常增删改的表或者字段\n * where 条件里用不到的字段不创建索引\n * 过滤性不好的不适合建索引",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 逻辑架构简介",frontmatter:{title:"MySQL - 逻辑架构简介",permalink:"/mysql/logic/",date:"2021-05-20T09:55:12.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/04.MySQL%20-%20%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.html",relativePath:"03.数据库/05.MySQL/04.MySQL - 逻辑架构.md",key:"v-2a221380",path:"/mysql/logic/",headers:[{level:2,title:"Mysql 逻辑架构简介",slug:"mysql-逻辑架构简介",normalizedTitle:"mysql 逻辑架构简介",charIndex:3},{level:3,title:"整体架构图",slug:"整体架构图",normalizedTitle:"整体架构图",charIndex:21},{level:4,title:"连接层",slug:"连接层",normalizedTitle:"连接层",charIndex:34},{level:4,title:"服务层",slug:"服务层",normalizedTitle:"服务层",charIndex:45},{level:4,title:"引擎层",slug:"引擎层",normalizedTitle:"引擎层",charIndex:56},{level:4,title:"存储层",slug:"存储层",normalizedTitle:"存储层",charIndex:67},{level:3,title:"show profile",slug:"show-profile",normalizedTitle:"show profile",charIndex:76},{level:3,title:"大致的查询流程",slug:"大致的查询流程",normalizedTitle:"大致的查询流程",charIndex:94},{level:3,title:"SQL的执行顺序",slug:"sql的执行顺序",normalizedTitle:"sql的执行顺序",charIndex:107},{level:2,title:"存储引擎",slug:"存储引擎",normalizedTitle:"存储引擎",charIndex:119},{level:3,title:"存储引擎概述",slug:"存储引擎概述",normalizedTitle:"存储引擎概述",charIndex:129},{level:3,title:"各种存储引擎特性",slug:"各种存储引擎特性",normalizedTitle:"各种存储引擎特性",charIndex:141},{level:4,title:"InnoDB",slug:"innodb",normalizedTitle:"innodb",charIndex:157},{level:4,title:"MyISAM",slug:"myisam",normalizedTitle:"myisam",charIndex:171},{level:4,title:"MEMORY",slug:"memory",normalizedTitle:"memory",charIndex:185},{level:4,title:"MERGE",slug:"merge",normalizedTitle:"merge",charIndex:199},{level:2,title:"SQL 预热",slug:"sql-预热",normalizedTitle:"sql 预热",charIndex:208}],headersStr:"Mysql 逻辑架构简介 整体架构图 连接层 服务层 引擎层 存储层 show profile 大致的查询流程 SQL的执行顺序 存储引擎 存储引擎概述 各种存储引擎特性 InnoDB MyISAM MEMORY MERGE SQL 预热",content:" * Mysql 逻辑架构简介\n   * 整体架构图\n     * 连接层\n     * 服务层\n     * 引擎层\n     * 存储层\n   * show profile\n   * 大致的查询流程\n   * SQL的执行顺序\n * 存储引擎\n   * 存储引擎概述\n   * 各种存储引擎特性\n     * InnoDB\n     * MyISAM\n     * MEMORY\n     * MERGE\n * SQL 预热\n\n\n# Mysql 逻辑架构简介\n\n\n# 整体架构图\n\n\n\n和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可 以根据业务的需求和实际需要选择合适的存储引擎。\n\n各层介绍：\n\n# 连接层\n\n最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证 安全接入的客户端提供线程。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个客户端验 证它所具有的操作权限。\n\n# 服务层\n\n * Management Serveices & Utilities\n   \n   系统管理和控制工具\n\n * SQL Interface\n   \n   SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface\n\n * Parser\n   \n   解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析\n\n * Optimizer\n   \n   查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。\n\n * Cache 和 Buffer\n   \n   查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等\n   \n   注：mysql 8.X 取消了查询缓存\n\n# 引擎层\n\n存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同 的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。\n\n# 存储层\n\n数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。\n\n\n# show profile\n\n利用 show profile 可以查看 sql 的执行周期！\n\n开启 profile\n\n查看 profile 是否开启：show variables like '%profiling%'\n\nmysql> show variables like '%profiling%';\n+------------------------+-------+\n| Variable_name          | Value |\n+------------------------+-------+\n| have_profiling         | YES   |\n| profiling              | OFF   |\n| profiling_history_size | 15    |\n+------------------------+-------+\n3 rows in set (0.01 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果没有开启，可以执行 set profiling=1 开启！\n\n使用 profile\n\n执行 show profiles; 命令，可以查看最近的几次查询。\n\n根据 Query_ID，可以进一步执行 show profile cpu,block io for query Query_id 来查看 sql 的具体执行步骤。\n\n\n# 大致的查询流程\n\nmysql 的查询流程大致是：\n\nmysql 客户端通过协议与 mysql 服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果， 否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储 SELECT 语句以及 相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。\n\n语法解析器和预处理：首先 mysql 通过关键字将 SQL 语句进行解析，并生成一颗对应的“解析树”。mysql 解析器将使用 mysql 语法规则验证和解析查询；预处理器则根据一些 mysql 规则进一步检查解析数是否合法。\n\n查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式， 最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。\n\n然后，mysql 默认使用的 BTREE 索引，并且一个大致方向是：无论怎么折腾 sql，至少在目前来说，mysql 最多只用到表中的一个索引。\n\n\n# SQL的执行顺序\n\n手写的顺序：\n\n\n\n真正执行的顺序：\n\n随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动 态调整执行顺序。下面是经常出现的查询顺序：\n\n\n\n\n\n\n# 存储引擎\n\n\n# 存储引擎概述\n\n和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。\n\n存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。\n\nOracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。\n\nMySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。\n\n通过指令查询当前数据库支持的存储引擎 ：\n\nshow engines\n\n\n1\n\n\n\n\n创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。\n\n查看Mysql数据库默认的存储引擎 ， 指令 ：\n\nshow variables like '%storage_engine%' ； \n\n\n1\n\n\n\n\n\n# 各种存储引擎特性\n\n下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ：\n\n特点       INNODB        MYISAM   MEMORY   MERGE   NDB\n存储限制     64TB          有        有        没有      有\n事务安全     支持                                      \n锁机制      行锁(适合高并发)     表锁       表锁       表锁      行锁\nB树索引     支持            支持       支持       支持      支持\n哈希索引                            支持               \n全文索引     支持(5.6版本之后)   支持                        \n集群索引     支持                                      \n数据索引     支持                     支持               支持\n索引缓存     支持            支持       支持       支持      支持\n数据可压缩                  支持                        \n空间使用     高             低        N/A      低       低\n内存使用     高             低        中等       低       高\n批量插入速度   低             高        高        高       高\n支持外键     支持                                      \n\n下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。\n\n# InnoDB\n\nInnoDB 存储引擎是 Mysql 的默认存储引擎。\n\nInnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。\n\nInnoDB 存储引擎不同于其他存储引擎的特点 ：\n\n * 事务控制\n   \n   **\n   \n   create table goods_innodb(\n   \tid int NOT NULL AUTO_INCREMENT,\n   \tname varchar(20) NOT NULL,\n       primary key(id)\n   )ENGINE=innodb DEFAULT CHARSET=utf8;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   #1\n   start transaction;\n   #2\n   insert into goods_innodb(id,name)values(null,'Meta20');\n   #3\n   commit;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   \n   \n   测试发现在 InnoDB 中是存在事务的 ；\n\n * 外键约束\n   \n   MySQL支持外键的存储引擎只有 InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ，子表在创建外键的时候，也会自动的创建对应的索引。\n   \n   下面两张表中 ， country_innodb 是父表 ， country_id 为主键索引，city_innodb 表是子表，country_id 字段为外键，对应于 country_innodb 表的主键 country_id 。\n   \n   create table country_innodb(\n   \tcountry_id int NOT NULL AUTO_INCREMENT,\n       country_name varchar(100) NOT NULL,\n       primary key(country_id)\n   )ENGINE=InnoDB DEFAULT CHARSET=utf8;\n   \n   \n   create table city_innodb(\n   \tcity_id int NOT NULL AUTO_INCREMENT,\n       city_name varchar(50) NOT NULL,\n       country_id int NOT NULL,\n       primary key(city_id),\n       key idx_fk_country_id(country_id),\n       CONSTRAINT `fk_city_country` FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE\n   )ENGINE=InnoDB DEFAULT CHARSET=utf8;\n   \n   \n   \n   insert into country_innodb values(null,'China'),(null,'America'),(null,'Japan');\n   insert into city_innodb values(null,'Xian',1),(null,'NewYork',2),(null,'BeiJing',1);\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   \n   在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。\n   \n   RESTRICT 和NO ACTION 相同， 是指限制在子表有关联记录的情况下， 父表不能更新；\n   \n   CASCADE 表示父表在更新或者删除时，更新或者删除子表对应的记录；\n   \n   SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。\n   \n   针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。\n   \n   表中数据如下图所示 ：\n   \n   \n   \n   查看外键信息\n   \n   show create table city_innodb ;\n   \n   \n   1\n   \n   \n   \n   \n   删除 country_id为 1 的 country 数据，有外键时会删除失败\n   \n   \n   \n   更新主表country表的字段 country_id 时\n   \n   update country_innodb set country_id = 100 where country_id = 1;\n   \n   \n   1\n   \n   \n   \n   \n   更新后， 子表的数据信息为 ：\n   \n   \n\n * 存储方式\n   \n   InnoDB 存储表和索引有以下两种方式 ：\n   \n   ①. 使用共享表空间存储， 这种方式创建的表的表结构保存在 .frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。\n   \n   ②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。\n   \n   \n\n# MyISAM\n\nMyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点：\n\n * 不支持事务\n   \n   create table goods_myisam(\n   \tid int NOT NULL AUTO_INCREMENT,\n   \tname varchar(20) NOT NULL,\n       primary key(id)\n   )ENGINE=myisam DEFAULT CHARSET=utf8;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   \n   \n   通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ；\n\n * 文件存储方式\n   \n   每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ：\n   \n   .frm (存储表定义)；\n   \n   .MYD(MYData , 存储数据)；\n   \n   .MYI(MYIndex , 存储索引)；\n   \n   \n\n# MEMORY\n\nMemory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。\n\n# MERGE\n\nMERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。\n\n对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。\n\n可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。\n\n\n\n下面是一个创建和使用MERGE表的示例 ：\n\n1）. 创建3个测试表 order_1990, order_1991, order_all , 其中 order_all 是前两个表的 MERGE 表 ：\n\ncreate table order_1990(\n    order_id int ,\n    order_money double(10,2),\n    order_address varchar(50),\n    primary key (order_id)\n)engine = myisam default charset=utf8;\n\n\ncreate table order_1991(\n    order_id int ,\n    order_money double(10,2),\n    order_address varchar(50),\n    primary key (order_id)\n)engine = myisam default charset=utf8;\n\n\ncreate table order_all(\n    order_id int ,\n    order_money double(10,2),\n    order_address varchar(50),\n    primary key (order_id)\n)engine = merge union = (order_1990,order_1991) INSERT_METHOD=LAST default charset=utf8;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n2）. 分别向两张表中插入记录\n\ninsert into order_1990 values(1,100.0,'北京');\ninsert into order_1990 values(2,100.0,'上海');\n\ninsert into order_1991 values(10,200.0,'北京');\ninsert into order_1991 values(11,200.0,'上海');\n\n\n1\n2\n3\n4\n5\n\n\n3）. 查询3张表中的数据。\n\norder_1990中的数据 ：\n\n\n\norder_1991中的数据 ：\n\n\n\norder_all中的数据 ：\n\n\n\n4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。\n\ninsert into order_all values(100,10000.0,'西安')；\n\n\n1\n\n\n\n\n\n# SQL 预热\n\n常见的 Join 查询图\n\n",normalizedContent:" * mysql 逻辑架构简介\n   * 整体架构图\n     * 连接层\n     * 服务层\n     * 引擎层\n     * 存储层\n   * show profile\n   * 大致的查询流程\n   * sql的执行顺序\n * 存储引擎\n   * 存储引擎概述\n   * 各种存储引擎特性\n     * innodb\n     * myisam\n     * memory\n     * merge\n * sql 预热\n\n\n# mysql 逻辑架构简介\n\n\n# 整体架构图\n\n\n\n和其它数据库相比，mysql 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可 以根据业务的需求和实际需要选择合适的存储引擎。\n\n各层介绍：\n\n# 连接层\n\n最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证 安全接入的客户端提供线程。同样在该层上可以实现基于 ssl 的安全链接。服务器也会为安全接入的每个客户端验 证它所具有的操作权限。\n\n# 服务层\n\n * management serveices & utilities\n   \n   系统管理和控制工具\n\n * sql interface\n   \n   sql 接口。接受用户的 sql 命令，并且返回用户需要查询的结果。比如 select from 就是调用 sql interface\n\n * parser\n   \n   解析器。 sql 命令传递到解析器的时候会被解析器验证和解析\n\n * optimizer\n   \n   查询优化器。 sql 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。\n\n * cache 和 buffer\n   \n   查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等\n   \n   注：mysql 8.x 取消了查询缓存\n\n# 引擎层\n\n存储引擎层，存储引擎真正的负责了 mysql 中数据的存储和提取，服务器通过 api 与存储引擎进行通信。不同 的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。\n\n# 存储层\n\n数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。\n\n\n# show profile\n\n利用 show profile 可以查看 sql 的执行周期！\n\n开启 profile\n\n查看 profile 是否开启：show variables like '%profiling%'\n\nmysql> show variables like '%profiling%';\n+------------------------+-------+\n| variable_name          | value |\n+------------------------+-------+\n| have_profiling         | yes   |\n| profiling              | off   |\n| profiling_history_size | 15    |\n+------------------------+-------+\n3 rows in set (0.01 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果没有开启，可以执行 set profiling=1 开启！\n\n使用 profile\n\n执行 show profiles; 命令，可以查看最近的几次查询。\n\n根据 query_id，可以进一步执行 show profile cpu,block io for query query_id 来查看 sql 的具体执行步骤。\n\n\n# 大致的查询流程\n\nmysql 的查询流程大致是：\n\nmysql 客户端通过协议与 mysql 服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果， 否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储 select 语句以及 相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。\n\n语法解析器和预处理：首先 mysql 通过关键字将 sql 语句进行解析，并生成一颗对应的“解析树”。mysql 解析器将使用 mysql 语法规则验证和解析查询；预处理器则根据一些 mysql 规则进一步检查解析数是否合法。\n\n查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式， 最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。\n\n然后，mysql 默认使用的 btree 索引，并且一个大致方向是：无论怎么折腾 sql，至少在目前来说，mysql 最多只用到表中的一个索引。\n\n\n# sql的执行顺序\n\n手写的顺序：\n\n\n\n真正执行的顺序：\n\n随着 mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动 态调整执行顺序。下面是经常出现的查询顺序：\n\n\n\n\n\n\n# 存储引擎\n\n\n# 存储引擎概述\n\n和大多数的数据库不同, mysql中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。\n\n存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。\n\noracle，sqlserver等数据库只有一种存储引擎。mysql提供了插件式的存储引擎架构。所以mysql存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。\n\nmysql5.0支持的存储引擎包含 ： innodb 、myisam 、bdb、memory、merge、example、ndb cluster、archive、csv、blackhole、federated等，其中innodb和bdb提供事务安全表，其他存储引擎是非事务安全表。\n\n通过指令查询当前数据库支持的存储引擎 ：\n\nshow engines\n\n\n1\n\n\n\n\n创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，mysql5.5之前的默认存储引擎是myisam，5.5之后就改为了innodb。\n\n查看mysql数据库默认的存储引擎 ， 指令 ：\n\nshow variables like '%storage_engine%' ； \n\n\n1\n\n\n\n\n\n# 各种存储引擎特性\n\n下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ：\n\n特点       innodb        myisam   memory   merge   ndb\n存储限制     64tb          有        有        没有      有\n事务安全     支持                                      \n锁机制      行锁(适合高并发)     表锁       表锁       表锁      行锁\nb树索引     支持            支持       支持       支持      支持\n哈希索引                            支持               \n全文索引     支持(5.6版本之后)   支持                        \n集群索引     支持                                      \n数据索引     支持                     支持               支持\n索引缓存     支持            支持       支持       支持      支持\n数据可压缩                  支持                        \n空间使用     高             低        n/a      低       低\n内存使用     高             低        中等       低       高\n批量插入速度   低             高        高        高       高\n支持外键     支持                                      \n\n下面我们将重点介绍最长使用的两种存储引擎： innodb、myisam ， 另外两种 memory、merge ， 了解即可。\n\n# innodb\n\ninnodb 存储引擎是 mysql 的默认存储引擎。\n\ninnodb存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比 myisam 的存储引擎，innodb 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。\n\ninnodb 存储引擎不同于其他存储引擎的特点 ：\n\n * 事务控制\n   \n   **\n   \n   create table goods_innodb(\n   \tid int not null auto_increment,\n   \tname varchar(20) not null,\n       primary key(id)\n   )engine=innodb default charset=utf8;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   #1\n   start transaction;\n   #2\n   insert into goods_innodb(id,name)values(null,'meta20');\n   #3\n   commit;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   \n   \n   测试发现在 innodb 中是存在事务的 ；\n\n * 外键约束\n   \n   mysql支持外键的存储引擎只有 innodb ， 在创建外键的时候， 要求父表必须有对应的索引 ，子表在创建外键的时候，也会自动的创建对应的索引。\n   \n   下面两张表中 ， country_innodb 是父表 ， country_id 为主键索引，city_innodb 表是子表，country_id 字段为外键，对应于 country_innodb 表的主键 country_id 。\n   \n   create table country_innodb(\n   \tcountry_id int not null auto_increment,\n       country_name varchar(100) not null,\n       primary key(country_id)\n   )engine=innodb default charset=utf8;\n   \n   \n   create table city_innodb(\n   \tcity_id int not null auto_increment,\n       city_name varchar(50) not null,\n       country_id int not null,\n       primary key(city_id),\n       key idx_fk_country_id(country_id),\n       constraint `fk_city_country` foreign key(country_id) references country_innodb(country_id) on delete restrict on update cascade\n   )engine=innodb default charset=utf8;\n   \n   \n   \n   insert into country_innodb values(null,'china'),(null,'america'),(null,'japan');\n   insert into city_innodb values(null,'xian',1),(null,'newyork',2),(null,'beijing',1);\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   \n   在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 restrict、cascade、set null 和 no action。\n   \n   restrict 和no action 相同， 是指限制在子表有关联记录的情况下， 父表不能更新；\n   \n   cascade 表示父表在更新或者删除时，更新或者删除子表对应的记录；\n   \n   set null 则表示父表在更新或者删除的时候，子表的对应字段被set null 。\n   \n   针对上面创建的两个表， 子表的外键指定是on delete restrict on update cascade 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。\n   \n   表中数据如下图所示 ：\n   \n   \n   \n   查看外键信息\n   \n   show create table city_innodb ;\n   \n   \n   1\n   \n   \n   \n   \n   删除 country_id为 1 的 country 数据，有外键时会删除失败\n   \n   \n   \n   更新主表country表的字段 country_id 时\n   \n   update country_innodb set country_id = 100 where country_id = 1;\n   \n   \n   1\n   \n   \n   \n   \n   更新后， 子表的数据信息为 ：\n   \n   \n\n * 存储方式\n   \n   innodb 存储表和索引有以下两种方式 ：\n   \n   ①. 使用共享表空间存储， 这种方式创建的表的表结构保存在 .frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。\n   \n   ②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。\n   \n   \n\n# myisam\n\nmyisam 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点：\n\n * 不支持事务\n   \n   create table goods_myisam(\n   \tid int not null auto_increment,\n   \tname varchar(20) not null,\n       primary key(id)\n   )engine=myisam default charset=utf8;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   \n   \n   通过测试，我们发现，在myisam存储引擎中，是没有事务控制的 ；\n\n * 文件存储方式\n   \n   每个myisam在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ：\n   \n   .frm (存储表定义)；\n   \n   .myd(mydata , 存储数据)；\n   \n   .myi(myindex , 存储索引)；\n   \n   \n\n# memory\n\nmemory存储引擎将表的数据存放在内存中。每个memory表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。memory 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用hash索引 ， 但是服务一旦关闭，表中的数据就会丢失。\n\n# merge\n\nmerge存储引擎是一组myisam表的组合，这些myisam表必须结构完全相同，merge表本身并没有存储数据，对merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的myisam表进行的。\n\n对于merge类型表的插入操作，是通过insert_method子句定义插入的表，可以有3个不同的值，使用first 或 last 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为no，表示不能对这个merge表执行插入操作。\n\n可以对merge表进行drop操作，但是这个操作只是删除merge表的定义，对内部的表是没有任何影响的。\n\n\n\n下面是一个创建和使用merge表的示例 ：\n\n1）. 创建3个测试表 order_1990, order_1991, order_all , 其中 order_all 是前两个表的 merge 表 ：\n\ncreate table order_1990(\n    order_id int ,\n    order_money double(10,2),\n    order_address varchar(50),\n    primary key (order_id)\n)engine = myisam default charset=utf8;\n\n\ncreate table order_1991(\n    order_id int ,\n    order_money double(10,2),\n    order_address varchar(50),\n    primary key (order_id)\n)engine = myisam default charset=utf8;\n\n\ncreate table order_all(\n    order_id int ,\n    order_money double(10,2),\n    order_address varchar(50),\n    primary key (order_id)\n)engine = merge union = (order_1990,order_1991) insert_method=last default charset=utf8;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n2）. 分别向两张表中插入记录\n\ninsert into order_1990 values(1,100.0,'北京');\ninsert into order_1990 values(2,100.0,'上海');\n\ninsert into order_1991 values(10,200.0,'北京');\ninsert into order_1991 values(11,200.0,'上海');\n\n\n1\n2\n3\n4\n5\n\n\n3）. 查询3张表中的数据。\n\norder_1990中的数据 ：\n\n\n\norder_1991中的数据 ：\n\n\n\norder_all中的数据 ：\n\n\n\n4）. 往order_all中插入一条记录 ，由于在merge表定义时，insert_method 选择的是last，那么插入的数据会想最后一张表中插入。\n\ninsert into order_all values(100,10000.0,'西安')；\n\n\n1\n\n\n\n\n\n# sql 预热\n\n常见的 join 查询图\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 索引的使用",frontmatter:{title:"MySQL - 索引的使用",permalink:"/mysql/index-use/",date:"2021-05-20T20:51:46.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/12.MySQL%20-%20%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"03.数据库/05.MySQL/12.MySQL - 索引的使用.md",key:"v-7e2b9df0",path:"/mysql/index-use/",headers:[{level:2,title:"验证索引提升查询效率",slug:"验证索引提升查询效率",normalizedTitle:"验证索引提升查询效率",charIndex:14},{level:2,title:"准备环境",slug:"准备环境",normalizedTitle:"准备环境",charIndex:30},{level:2,title:"避免索引失效",slug:"避免索引失效",normalizedTitle:"避免索引失效",charIndex:40},{level:2,title:"查看索引使用情况",slug:"查看索引使用情况",normalizedTitle:"查看索引使用情况",charIndex:52},{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:66}],headersStr:"验证索引提升查询效率 准备环境 避免索引失效 查看索引使用情况 练习",content:" * 索引的使用\n   * 验证索引提升查询效率\n   * 准备环境\n   * 避免索引失效\n   * 查看索引使用情况\n   * 练习\n\n\n# 索引的使用\n\n索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。\n\n\n# 验证索引提升查询效率\n\n在我们准备的表结构 tb_item 中， 一共存储了 300 万记录；\n\n1). 根据ID查询\n\nselect * from tb_item where id = 1999\\G;\n\n\n1\n\n\n\n\n查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；\n\n\n\n2). 根据 title 进行精确查询\n\nselect * from tb_item where title = 'iphoneX 移动3G 32G941'\\G; \n\n\n1\n\n\n\n\n查看SQL语句的执行计划 ：\n\n\n\n处理方案 ， 针对title字段， 创建索引 ：\n\ncreate index idx_item_title on tb_item(title);\n\n\n1\n\n\n\n\n索引创建完成之后，再次进行查询 ：\n\n\n\n通过 explain ， 查看执行计划，执行SQL时使用了刚才创建的索引\n\n\n\n\n# 准备环境\n\ncreate table `tb_seller` (\n\t`sellerid` varchar (100),\n\t`name` varchar (100),\n\t`nickname` varchar (50),\n\t`password` varchar (60),\n\t`status` varchar (1),\n\t`address` varchar (100),\n\t`createtime` datetime,\n    primary key(`sellerid`)\n)engine=innodb default charset=utf8mb4; \n\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('alibaba','阿里巴巴','阿里小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('baidu','百度科技有限公司','百度小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('huawei','华为科技有限公司','华为小店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itcast','传智播客教育科技有限公司','传智播客','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itheima','黑马程序员','黑马程序员','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('luoji','罗技科技有限公司','罗技小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('oppo','OPPO科技有限公司','OPPO官方旗舰店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('ourpalm','掌趣科技股份有限公司','掌趣小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('qiandu','千度科技','千度小店','e10adc3949ba59abbe56e057f20f883e','2','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('sina','新浪科技有限公司','新浪官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('xiaomi','小米科技','小米官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','西安市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('yijia','宜家家居','宜家家居旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\n\n\ncreate index idx_seller_name_sta_addr on tb_seller(name,status,address);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 避免索引失效\n\n1). 全值匹配 ，对索引中所有列都指定具体值。\n\n该情况下，索引生效，执行效率高。\n\nexplain select * from tb_seller where name='小米科技' and status='1' and address='北京市'\\G;\n\n\n1\n\n\n\n\n2). 最左前缀法则\n\n如果索引了多列（复合索引），要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。\n\n匹配最左前缀法则，走索引：\n\n\n\n违法最左前缀法则 ， 索引失效：\n\n\n\n如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：\n\n\n\n3). 范围查询，不能使用索引 。\n\n\n\n根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。\n\n4). 不要在索引列上进行运算操作，否则索引将失效。\n\n\n\n5). 字符串不加单引号，造成索引失效。\n\n\n\n在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。\n\n**6). 尽量使用覆盖索引，避免select **\n\n尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。\n\n\n\n如果查询列，超出索引列，也会降低性能。\n\n\n\nExtra：\n\n * using index\n   \n   使用覆盖索引的时候就会出现\n\n * using where\n   \n   在查找使用索引的情况下，需要回表去查询所需的数据\n\n * using index condition\n   \n   查找使用了索引，但是需要回表查询数据\n\n * using index ; using where\n   \n   查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\n\n7). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n\n示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：\n\nexplain select * from tb_seller where name='黑马程序员' or createtime = '2088-01-01 12:00:00'\\G;\t\n\n\n1\n\n\n\n\n8). 以%开头的Like模糊查询，索引失效。\n\n如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\n\nexplain select * from tb_seller where name like \"%黑马程序员\";\n\n\n1\n\n\n\n\n解决方案 ：\n\n通过覆盖索引来解决 (不用 select *)\n\n\n\n9). 如果MySQL评估使用索引比全表更慢，则不使用索引。\n\n我们先给 address 创建索引\n\ncreate index idx_seller_address on tb_seller(address);\n\n\n1\n\n\n在我们表 tb_seller 中，12条地区数据其中11个是北京市\n\n查北京地区的走全表扫描\n\n\n\n使用覆盖查询会走索引\n\n explain select address  from tb_seller where address='北京市';\n\n\n1\n\n\n10). is NULL ， is NOT NULL 有时索引失效。\n\n和上一条（9）差不多。\n\n\n\n11). in 走索引， not in 索引失效。\n\n在mysql 5.6中\n\n\n\n个人理解：not in 判断不存在的，需要对表进行大部分数据扫描，类似于第九条\n\nmysql 5.7中都不失效：\n\n\n\n12). 单列索引和复合索引。\n\n尽量使用复合索引，而少使用单列索引 。\n\n创建复合索引\n\ncreate index idx_name_sta_address on tb_seller(name, status, address);\n\n--就相当于创建了三个索引 ： \n--\tname\n--\tname + status\n--\tname + status + address\n\n\n1\n2\n3\n4\n5\n6\n\n\n创建单列索引\n\ncreate index idx_seller_name on tb_seller(name);\ncreate index idx_seller_status on tb_seller(status);\ncreate index idx_seller_address on tb_seller(address);\n\n\n1\n2\n3\n\n\n数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。\n\n\n# 查看索引使用情况\n\nshow status like 'Handler_read%';\t--当前会话级别\n\nshow global status like 'Handler_read%';\t--全局级别\n\n\n1\n2\n3\n\n\n\n\n * Handler_read_first\n   \n   索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。\n\n * Handler_read_key\n   \n   如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。\n\n * Handler_read_next\n   \n   按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。\n\n * Handler_read_prev\n   \n   按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。\n\n * Handler_read_rnd\n   \n   根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。\n\n * Handler_read_rnd_next\n   \n   在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。\n\n\n# 练习\n\n假设 index(a,b,c)；\n\nWHERE 语句                                              索引是否被使用\nwhere a = 3                                           Y,使用到 a\nwhere a = 3 and b = 5                                 Y,使用到 a，b\nwhere a = 3 and b = 5 and c = 4                       Y,使用到 a,b,c\nwhere b = 3 或者 where b = 3 and c = 4 或者 where c = 4   N（第二条，左前缀法则）\nwhere a = 3 and c = 5                                 使用到 a， 但是 c 不可以，b 中间断了\nwhere a = 3 and b > 4 and c = 5                       使用到 a 和 b， c 不能用在范围之后，b 断了\nwhere a is null and b is not null                     is null 支持索引 但是 is not null 不支持\nwhere a <> 3                                          不能使用索引\nwhere abs(a) =3                                       不能使用索引\nwhere a = 3 and b like 'kk%' and c = 4                Y,使用到 a,b,c\nwhere a = 3 and b like '%kk' and c = 4                Y,只用到 a\nwhere a = 3 and b like '%kk%' and c = 4               Y,只用到 a\nwhere a = 3 and b like 'k%kk%' and c = 4              Y,使用到 a,b,c",normalizedContent:" * 索引的使用\n   * 验证索引提升查询效率\n   * 准备环境\n   * 避免索引失效\n   * 查看索引使用情况\n   * 练习\n\n\n# 索引的使用\n\n索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的mysql的性能优化问题。\n\n\n# 验证索引提升查询效率\n\n在我们准备的表结构 tb_item 中， 一共存储了 300 万记录；\n\n1). 根据id查询\n\nselect * from tb_item where id = 1999\\g;\n\n\n1\n\n\n\n\n查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；\n\n\n\n2). 根据 title 进行精确查询\n\nselect * from tb_item where title = 'iphonex 移动3g 32g941'\\g; \n\n\n1\n\n\n\n\n查看sql语句的执行计划 ：\n\n\n\n处理方案 ， 针对title字段， 创建索引 ：\n\ncreate index idx_item_title on tb_item(title);\n\n\n1\n\n\n\n\n索引创建完成之后，再次进行查询 ：\n\n\n\n通过 explain ， 查看执行计划，执行sql时使用了刚才创建的索引\n\n\n\n\n# 准备环境\n\ncreate table `tb_seller` (\n\t`sellerid` varchar (100),\n\t`name` varchar (100),\n\t`nickname` varchar (50),\n\t`password` varchar (60),\n\t`status` varchar (1),\n\t`address` varchar (100),\n\t`createtime` datetime,\n    primary key(`sellerid`)\n)engine=innodb default charset=utf8mb4; \n\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('alibaba','阿里巴巴','阿里小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('baidu','百度科技有限公司','百度小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('huawei','华为科技有限公司','华为小店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itcast','传智播客教育科技有限公司','传智播客','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itheima','黑马程序员','黑马程序员','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('luoji','罗技科技有限公司','罗技小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('oppo','oppo科技有限公司','oppo官方旗舰店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('ourpalm','掌趣科技股份有限公司','掌趣小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('qiandu','千度科技','千度小店','e10adc3949ba59abbe56e057f20f883e','2','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('sina','新浪科技有限公司','新浪官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('xiaomi','小米科技','小米官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','西安市','2088-01-01 12:00:00');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('yijia','宜家家居','宜家家居旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');\n\n\ncreate index idx_seller_name_sta_addr on tb_seller(name,status,address);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 避免索引失效\n\n1). 全值匹配 ，对索引中所有列都指定具体值。\n\n该情况下，索引生效，执行效率高。\n\nexplain select * from tb_seller where name='小米科技' and status='1' and address='北京市'\\g;\n\n\n1\n\n\n\n\n2). 最左前缀法则\n\n如果索引了多列（复合索引），要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。\n\n匹配最左前缀法则，走索引：\n\n\n\n违法最左前缀法则 ， 索引失效：\n\n\n\n如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：\n\n\n\n3). 范围查询，不能使用索引 。\n\n\n\n根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。\n\n4). 不要在索引列上进行运算操作，否则索引将失效。\n\n\n\n5). 字符串不加单引号，造成索引失效。\n\n\n\n在查询时，没有对字符串加单引号，mysql的查询优化器，会自动的进行类型转换，造成索引失效。\n\n**6). 尽量使用覆盖索引，避免select **\n\n尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。\n\n\n\n如果查询列，超出索引列，也会降低性能。\n\n\n\nextra：\n\n * using index\n   \n   使用覆盖索引的时候就会出现\n\n * using where\n   \n   在查找使用索引的情况下，需要回表去查询所需的数据\n\n * using index condition\n   \n   查找使用了索引，但是需要回表查询数据\n\n * using index ; using where\n   \n   查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\n\n7). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n\n示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：\n\nexplain select * from tb_seller where name='黑马程序员' or createtime = '2088-01-01 12:00:00'\\g;\t\n\n\n1\n\n\n\n\n8). 以%开头的like模糊查询，索引失效。\n\n如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。\n\nexplain select * from tb_seller where name like \"%黑马程序员\";\n\n\n1\n\n\n\n\n解决方案 ：\n\n通过覆盖索引来解决 (不用 select *)\n\n\n\n9). 如果mysql评估使用索引比全表更慢，则不使用索引。\n\n我们先给 address 创建索引\n\ncreate index idx_seller_address on tb_seller(address);\n\n\n1\n\n\n在我们表 tb_seller 中，12条地区数据其中11个是北京市\n\n查北京地区的走全表扫描\n\n\n\n使用覆盖查询会走索引\n\n explain select address  from tb_seller where address='北京市';\n\n\n1\n\n\n10). is null ， is not null 有时索引失效。\n\n和上一条（9）差不多。\n\n\n\n11). in 走索引， not in 索引失效。\n\n在mysql 5.6中\n\n\n\n个人理解：not in 判断不存在的，需要对表进行大部分数据扫描，类似于第九条\n\nmysql 5.7中都不失效：\n\n\n\n12). 单列索引和复合索引。\n\n尽量使用复合索引，而少使用单列索引 。\n\n创建复合索引\n\ncreate index idx_name_sta_address on tb_seller(name, status, address);\n\n--就相当于创建了三个索引 ： \n--\tname\n--\tname + status\n--\tname + status + address\n\n\n1\n2\n3\n4\n5\n6\n\n\n创建单列索引\n\ncreate index idx_seller_name on tb_seller(name);\ncreate index idx_seller_status on tb_seller(status);\ncreate index idx_seller_address on tb_seller(address);\n\n\n1\n2\n3\n\n\n数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。\n\n\n# 查看索引使用情况\n\nshow status like 'handler_read%';\t--当前会话级别\n\nshow global status like 'handler_read%';\t--全局级别\n\n\n1\n2\n3\n\n\n\n\n * handler_read_first\n   \n   索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。\n\n * handler_read_key\n   \n   如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。\n\n * handler_read_next\n   \n   按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。\n\n * handler_read_prev\n   \n   按照键顺序读前一行的请求数。该读方法主要用于优化order by ... desc。\n\n * handler_read_rnd\n   \n   根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要mysql扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。\n\n * handler_read_rnd_next\n   \n   在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。\n\n\n# 练习\n\n假设 index(a,b,c)；\n\nwhere 语句                                              索引是否被使用\nwhere a = 3                                           y,使用到 a\nwhere a = 3 and b = 5                                 y,使用到 a，b\nwhere a = 3 and b = 5 and c = 4                       y,使用到 a,b,c\nwhere b = 3 或者 where b = 3 and c = 4 或者 where c = 4   n（第二条，左前缀法则）\nwhere a = 3 and c = 5                                 使用到 a， 但是 c 不可以，b 中间断了\nwhere a = 3 and b > 4 and c = 5                       使用到 a 和 b， c 不能用在范围之后，b 断了\nwhere a is null and b is not null                     is null 支持索引 但是 is not null 不支持\nwhere a <> 3                                          不能使用索引\nwhere abs(a) =3                                       不能使用索引\nwhere a = 3 and b like 'kk%' and c = 4                y,使用到 a,b,c\nwhere a = 3 and b like '%kk' and c = 4                y,只用到 a\nwhere a = 3 and b like '%kk%' and c = 4               y,只用到 a\nwhere a = 3 and b like 'k%kk%' and c = 4              y,使用到 a,b,c",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - SQL语句优化",frontmatter:{title:"MySQL - SQL语句优化",permalink:"/mysql/sql-optimize/",date:"2021-05-23T14:08:28.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/14.MySQL%20-%20SQL%E4%BC%98%E5%8C%96.html",relativePath:"03.数据库/05.MySQL/14.MySQL - SQL优化.md",key:"v-4fa6c7e5",path:"/mysql/sql-optimize/",headers:[{level:2,title:"大批量插入数据时",slug:"大批量插入数据时",normalizedTitle:"大批量插入数据时",charIndex:3},{level:2,title:"优化insert语句",slug:"优化insert语句",normalizedTitle:"优化insert语句",charIndex:15},{level:2,title:"优化order by语句",slug:"优化order-by语句",normalizedTitle:"优化order by语句",charIndex:29},{level:3,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:47},{level:3,title:"两种排序方式",slug:"两种排序方式",normalizedTitle:"两种排序方式",charIndex:57},{level:3,title:"Filesort 的优化",slug:"filesort-的优化",normalizedTitle:"filesort 的优化",charIndex:69},{level:2,title:"优化group by 语句",slug:"优化group-by-语句",normalizedTitle:"优化group by 语句",charIndex:85},{level:2,title:"优化嵌套查询",slug:"优化嵌套查询",normalizedTitle:"优化嵌套查询",charIndex:102},{level:2,title:"优化OR条件",slug:"优化or条件",normalizedTitle:"优化or条件",charIndex:112},{level:2,title:"优化分页查询",slug:"优化分页查询",normalizedTitle:"优化分页查询",charIndex:122},{level:2,title:"使用SQL提示",slug:"使用sql提示",normalizedTitle:"使用sql提示",charIndex:132}],headersStr:"大批量插入数据时 优化insert语句 优化order by语句 环境准备 两种排序方式 Filesort 的优化 优化group by 语句 优化嵌套查询 优化OR条件 优化分页查询 使用SQL提示",content:" * 大批量插入数据时\n * 优化insert语句\n * 优化order by语句\n   * 环境准备\n   * 两种排序方式\n   * Filesort 的优化\n * 优化group by 语句\n * 优化嵌套查询\n * 优化OR条件\n * 优化分页查询\n * 使用SQL提示\n\n\n# 大批量插入数据时\n\n环境准备：\n\nCREATE TABLE `tb_user_2` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(45) NOT NULL,\n  `password` varchar(96) NOT NULL,\n  `name` varchar(45) NOT NULL,\n  `birthday` datetime DEFAULT NULL,\n  `sex` char(1) DEFAULT NULL,\n  `email` varchar(45) DEFAULT NULL,\n  `phone` varchar(45) DEFAULT NULL,\n  `qq` varchar(32) DEFAULT NULL,\n  `status` varchar(32) NOT NULL COMMENT '用户状态',\n  `create_time` datetime NOT NULL,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_user_username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n当使用 load 命令导入数据的时候，适当的设置可以提高导入的效率。\n\n\n\n对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：\n\n1） 主键顺序插入\n\n因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。\n\n> 脚本文件介绍 :\n> \n> sql1.log ----\x3e 主键有序\n> \n> sql2.log ----\x3e 主键无序\n\n插入ID顺序排列数据：\n\n\n\n插入ID无序排列数据：\n\n\n\n2） 关闭唯一性校验\n\n在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验\n\n在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。\n\n\n\n3） 手动提交事务\n\n建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交\n\n导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。\n\n\n\n> load执行可能会报错\n\nThe used command is not allowed with this MySQL version\n\n错误的原因是没有开启 local_infile 模块。\n\n解决方法：\n\n首先看一下 local_infile 模块是否打开：\n\nshow global variables like 'local_infile';\n\n\n1\n\n\n显示如下：\n\n\n\n然后可以发现这个模块已经启用了：\n\n\n\n之后重启一下Mysql服务即可\n\n\n# 优化insert语句\n\n1.）如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。\n\n * 原始方式为：\n\ninsert into tb_test values(1,'Tom');\ninsert into tb_test values(2,'Cat');\ninsert into tb_test values(3,'Jerry');\n\n\n1\n2\n3\n\n\n优化后的方案为 ：\n\ninsert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry');\n\n\n1\n\n\n2.）在事务中进行数据插入。\n\nstart transaction;\ninsert into tb_test values(1,'Tom');\ninsert into tb_test values(2,'Cat');\ninsert into tb_test values(3,'Jerry');\ncommit;\n\n\n1\n2\n3\n4\n5\n\n\n3.）数据有序插入\n\n * 原\n   \n   insert into tb_test values(4,'Tim');\n   insert into tb_test values(1,'Tom');\n   insert into tb_test values(3,'Jerry');\n   insert into tb_test values(5,'Rose');\n   insert into tb_test values(2,'Cat');\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 优化后\n   \n   insert into tb_test values(1,'Tom');\n   insert into tb_test values(2,'Cat');\n   insert into tb_test values(3,'Jerry');\n   insert into tb_test values(4,'Tim');\n   insert into tb_test values(5,'Rose');\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 优化order by语句\n\n\n# 环境准备\n\nCREATE TABLE `emp` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(100) NOT NULL,\n  `age` int(3) NOT NULL,\n  `salary` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;\n\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('1','Tom','25','2300');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('2','Jerry','30','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('3','Luci','25','2800');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('4','Jay','36','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('5','Tom2','21','2200');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('6','Jerry2','31','3300');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('7','Luci2','26','2700');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('8','Jay2','33','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('9','Tom3','23','2400');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('10','Jerry3','32','3100');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('11','Luci3','26','2900');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('12','Jay3','37','4500');\n\ncreate index idx_emp_age_salary on emp(age,salary);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 两种排序方式\n\n1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序\n\n不是通过索引直接返回排序结果的排序都叫 FileSort 排序。\n\n\n\n2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。\n\n\n\n多字段排序\n\n\n\n了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现 FileSort。\n\n\n# Filesort 的优化\n\n通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让 Filesort 消失，那就需要加快 Filesort的排序操作。对于Filesort ，MySQL 有两种排序算法：\n\n1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。\n\n2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。\n\nMySQL 通过比较系统变量 max_length_for_sort_data 的大小和 Query 语句取出的字段总大小， 来判定是否那种排序算法，如果 max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。\n\n可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。\n\n\n\n\n# 优化group by 语句\n\n由于 GROUP BY 实际上也同样会进行排序操作，而且与 ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。\n\n如果查询包含 group by 但是想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：\n\ndrop index idx_emp_age_salary on emp; -- 删除之前创建的索引\n\nexplain select age,count(*) from emp group by age;\n\n\n1\n2\n3\n\n\n\n\n优化后\n\nexplain select age,count(*) from emp group by age order by null;\n\n\n1\n\n\n\n\n从上面的例子可以看出，第一个SQL语句需要进行\"filesort\"，而第二个SQL由于 order by null 不需要进行 \"filesort\"， 而上文提过 Filesort 往往非常耗费时间。\n\n创建索引 ：\n\ncreate index idx_emp_age_salary on emp(age,salary);\n\n\n1\n\n\n\n\n但是在 mysql 5.7 中：\n\n\n\n\n# 优化嵌套查询\n\nMysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。\n\n示例 ，查找有角色的所有的用户信息 :\n\n explain select * from t_user where id in (select user_id from user_role );\n\n\n1\n\n\n执行计划为 :\n\n\n\n优化后 :\n\nexplain select * from t_user u , user_role ur where u.id = ur.user_id;\n\n\n1\n\n\n\n\n连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。\n\n在 mysql 5.7 中\n\n\n\n\n# 优化OR条件\n\n对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。\n\n获取 emp 表中的所有的索引 ：\n\n\n\n示例 ：\n\nexplain select * from emp where id = 1 or age = 30;\n\n\n1\n\n\n\n\n\n\n建议使用 union 替换 or ：\n\n\n\n我们来比较下重要指标，发现主要差别是 type 和 ref 这两项\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：\n\nsystem > const > eq_ref > ref > fulltext > ref_or_null  > index_merge > unique_subquery > index_subquery > range > index > ALL\n\n\n1\n\n\nUNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距\n\nUNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快\n\n这两项的差距就说明了 UNION 要优于 OR 。\n\n在 mysql 8.0 中，默认优化了，具体自行测试。\n\n\n# 优化分页查询\n\n一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。\n\n\n\n优化思路一\n\n在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。\n\n\n\n优化思路二\n\n该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。\n\n\n\n\n# 使用SQL提示\n\nSQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\nUSE INDEX\n\n在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。\n\ncreate index idx_seller_name on tb_seller(name);\n\n\n1\n\n\n\n\nIGNORE INDEX\n\n如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。\n\n explain select * from tb_seller ignore index(idx_seller_name) where name = '小米科技';\n\n\n1\n\n\n\n\nFORCE INDEX\n\n为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。\n\ncreate index idx_seller_address on tb_seller(address);\n\n\n1\n\n\n",normalizedContent:" * 大批量插入数据时\n * 优化insert语句\n * 优化order by语句\n   * 环境准备\n   * 两种排序方式\n   * filesort 的优化\n * 优化group by 语句\n * 优化嵌套查询\n * 优化or条件\n * 优化分页查询\n * 使用sql提示\n\n\n# 大批量插入数据时\n\n环境准备：\n\ncreate table `tb_user_2` (\n  `id` int(11) not null auto_increment,\n  `username` varchar(45) not null,\n  `password` varchar(96) not null,\n  `name` varchar(45) not null,\n  `birthday` datetime default null,\n  `sex` char(1) default null,\n  `email` varchar(45) default null,\n  `phone` varchar(45) default null,\n  `qq` varchar(32) default null,\n  `status` varchar(32) not null comment '用户状态',\n  `create_time` datetime not null,\n  `update_time` datetime default null,\n  primary key (`id`),\n  unique key `unique_user_username` (`username`)\n) engine=innodb default charset=utf8 ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n当使用 load 命令导入数据的时候，适当的设置可以提高导入的效率。\n\n\n\n对于 innodb 类型的表，有以下几种方式可以提高导入的效率：\n\n1） 主键顺序插入\n\n因为innodb类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果innodb表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。\n\n> 脚本文件介绍 :\n> \n> sql1.log ----\x3e 主键有序\n> \n> sql2.log ----\x3e 主键无序\n\n插入id顺序排列数据：\n\n\n\n插入id无序排列数据：\n\n\n\n2） 关闭唯一性校验\n\n在导入数据前执行 set unique_checks=0，关闭唯一性校验\n\n在导入结束后执行set unique_checks=1，恢复唯一性校验，可以提高导入的效率。\n\n\n\n3） 手动提交事务\n\n建议在导入前执行 set autocommit=0，关闭自动提交\n\n导入结束后再执行 set autocommit=1，打开自动提交，也可以提高导入的效率。\n\n\n\n> load执行可能会报错\n\nthe used command is not allowed with this mysql version\n\n错误的原因是没有开启 local_infile 模块。\n\n解决方法：\n\n首先看一下 local_infile 模块是否打开：\n\nshow global variables like 'local_infile';\n\n\n1\n\n\n显示如下：\n\n\n\n然后可以发现这个模块已经启用了：\n\n\n\n之后重启一下mysql服务即可\n\n\n# 优化insert语句\n\n1.）如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。\n\n * 原始方式为：\n\ninsert into tb_test values(1,'tom');\ninsert into tb_test values(2,'cat');\ninsert into tb_test values(3,'jerry');\n\n\n1\n2\n3\n\n\n优化后的方案为 ：\n\ninsert into tb_test values(1,'tom'),(2,'cat')，(3,'jerry');\n\n\n1\n\n\n2.）在事务中进行数据插入。\n\nstart transaction;\ninsert into tb_test values(1,'tom');\ninsert into tb_test values(2,'cat');\ninsert into tb_test values(3,'jerry');\ncommit;\n\n\n1\n2\n3\n4\n5\n\n\n3.）数据有序插入\n\n * 原\n   \n   insert into tb_test values(4,'tim');\n   insert into tb_test values(1,'tom');\n   insert into tb_test values(3,'jerry');\n   insert into tb_test values(5,'rose');\n   insert into tb_test values(2,'cat');\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 优化后\n   \n   insert into tb_test values(1,'tom');\n   insert into tb_test values(2,'cat');\n   insert into tb_test values(3,'jerry');\n   insert into tb_test values(4,'tim');\n   insert into tb_test values(5,'rose');\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 优化order by语句\n\n\n# 环境准备\n\ncreate table `emp` (\n  `id` int(11) not null auto_increment,\n  `name` varchar(100) not null,\n  `age` int(3) not null,\n  `salary` int(11) default null,\n  primary key (`id`)\n) engine=innodb  default charset=utf8mb4;\n\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('1','tom','25','2300');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('2','jerry','30','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('3','luci','25','2800');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('4','jay','36','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('5','tom2','21','2200');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('6','jerry2','31','3300');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('7','luci2','26','2700');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('8','jay2','33','3500');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('9','tom3','23','2400');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('10','jerry3','32','3100');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('11','luci3','26','2900');\ninsert into `emp` (`id`, `name`, `age`, `salary`) values('12','jay3','37','4500');\n\ncreate index idx_emp_age_salary on emp(age,salary);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 两种排序方式\n\n1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序\n\n不是通过索引直接返回排序结果的排序都叫 filesort 排序。\n\n\n\n2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。\n\n\n\n多字段排序\n\n\n\n了解了mysql的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和order by 使用相同的索引，并且order by 的顺序和索引顺序相同， 并且order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现 filesort。\n\n\n# filesort 的优化\n\n通过创建合适的索引，能够减少 filesort 的出现，但是在某些情况下，条件限制不能让 filesort 消失，那就需要加快 filesort的排序操作。对于filesort ，mysql 有两种排序算法：\n\n1） 两次扫描算法 ：mysql4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机i/o操作。\n\n2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。\n\nmysql 通过比较系统变量 max_length_for_sort_data 的大小和 query 语句取出的字段总大小， 来判定是否那种排序算法，如果 max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。\n\n可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。\n\n\n\n\n# 优化group by 语句\n\n由于 group by 实际上也同样会进行排序操作，而且与 order by 相比，group by 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在group by 的实现过程中，与 order by 一样也可以利用到索引。\n\n如果查询包含 group by 但是想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：\n\ndrop index idx_emp_age_salary on emp; -- 删除之前创建的索引\n\nexplain select age,count(*) from emp group by age;\n\n\n1\n2\n3\n\n\n\n\n优化后\n\nexplain select age,count(*) from emp group by age order by null;\n\n\n1\n\n\n\n\n从上面的例子可以看出，第一个sql语句需要进行\"filesort\"，而第二个sql由于 order by null 不需要进行 \"filesort\"， 而上文提过 filesort 往往非常耗费时间。\n\n创建索引 ：\n\ncreate index idx_emp_age_salary on emp(age,salary);\n\n\n1\n\n\n\n\n但是在 mysql 5.7 中：\n\n\n\n\n# 优化嵌套查询\n\nmysql4.1版本之后，开始支持sql的子查询。这个技术可以使用select语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的sql操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（join）替代。\n\n示例 ，查找有角色的所有的用户信息 :\n\n explain select * from t_user where id in (select user_id from user_role );\n\n\n1\n\n\n执行计划为 :\n\n\n\n优化后 :\n\nexplain select * from t_user u , user_role ur where u.id = ur.user_id;\n\n\n1\n\n\n\n\n连接(join)查询之所以更有效率一些 ，是因为mysql不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。\n\n在 mysql 5.7 中\n\n\n\n\n# 优化or条件\n\n对于包含or的查询子句，如果要利用索引，则or之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。\n\n获取 emp 表中的所有的索引 ：\n\n\n\n示例 ：\n\nexplain select * from emp where id = 1 or age = 30;\n\n\n1\n\n\n\n\n\n\n建议使用 union 替换 or ：\n\n\n\n我们来比较下重要指标，发现主要差别是 type 和 ref 这两项\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：\n\nsystem > const > eq_ref > ref > fulltext > ref_or_null  > index_merge > unique_subquery > index_subquery > range > index > all\n\n\n1\n\n\nunion 语句的 type 值为 ref，or 语句的 type 值为 range，可以看到这是一个很明显的差距\n\nunion 语句的 ref 值为 const，or 语句的 type 值为 null，const 表示是常量值引用，非常快\n\n这两项的差距就说明了 union 要优于 or 。\n\n在 mysql 8.0 中，默认优化了，具体自行测试。\n\n\n# 优化分页查询\n\n一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要mysql排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。\n\n\n\n优化思路一\n\n在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。\n\n\n\n优化思路二\n\n该方案适用于主键自增的表，可以把limit 查询转换成某个位置的查询 。\n\n\n\n\n# 使用sql提示\n\nsql提示，是优化数据库的一个重要手段，简单来说，就是在sql语句中加入一些人为的提示来达到优化操作的目的。\n\nuse index\n\n在查询语句中表名的后面，添加 use index 来提供希望mysql去参考的索引列表，就可以让mysql不再考虑其他可用的索引。\n\ncreate index idx_seller_name on tb_seller(name);\n\n\n1\n\n\n\n\nignore index\n\n如果用户只是单纯的想让mysql忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。\n\n explain select * from tb_seller ignore index(idx_seller_name) where name = '小米科技';\n\n\n1\n\n\n\n\nforce index\n\n为强制mysql使用一个特定的索引，可在查询中使用 force index 作为hint 。\n\ncreate index idx_seller_address on tb_seller(address);\n\n\n1\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 缓存查询",frontmatter:{title:"MySQL - 缓存查询",permalink:"/mysql/cache-query/",date:"2021-05-24T15:10:03.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/16.MySQL%20-%20%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2.html",relativePath:"03.数据库/05.MySQL/16.MySQL - 缓存查询.md",key:"v-0734792a",path:"/mysql/cache-query/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:3},{level:2,title:"查询缓存配置",slug:"查询缓存配置",normalizedTitle:"查询缓存配置",charIndex:9},{level:2,title:"开启查询缓存",slug:"开启查询缓存",normalizedTitle:"开启查询缓存",charIndex:19},{level:2,title:"查询缓存SELECT选项",slug:"查询缓存select选项",normalizedTitle:"查询缓存select选项",charIndex:29},{level:2,title:"查询缓存失效的情况",slug:"查询缓存失效的情况",normalizedTitle:"查询缓存失效的情况",charIndex:45}],headersStr:"概述 查询缓存配置 开启查询缓存 查询缓存SELECT选项 查询缓存失效的情况",content:" * 概述\n * 查询缓存配置\n * 开启查询缓存\n * 查询缓存SELECT选项\n * 查询缓存失效的情况\n\n\n# 概述\n\n开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。\n\n\n\n 1. 客户端发送一条查询给服务器；\n 2. 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；\n 3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；\n 4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；\n 5. 将结果返回给客户端。\n\n\n# 查询缓存配置\n\n * 查看当前的MySQL数据库是否支持查询缓存：\n\nSHOW VARIABLES LIKE 'have_query_cache';\t\n\n\n1\n\n\n\n\n在Mysql8，已经取消了查询缓存\n\n * 查看当前MySQL是否开启了查询缓存 ：\n\nSHOW VARIABLES LIKE 'query_cache_type'; \n\n\n1\n\n\n\n\n * 查看查询缓存的占用大小 ：\n\nSHOW VARIABLES LIKE 'query_cache_size';\n\n\n1\n\n\n\n\n * 查看查询缓存的状态变量：\n\nSHOW STATUS LIKE 'Qcache%';\n\n\n1\n\n\n\n\n各个变量的含义如下：\n\n参数                        含义\nQcache_free_blocks        查询缓存中的可用内存块数\nQcache_free_memory        查询缓存的可用内存量\nQcache_hits               查询缓存命中数\nQcache_inserts            添加到查询缓存的查询数\nQcache_lowmen_prunes      由于内存不足而从查询缓存中删除的查询数\nQcache_not_cached         非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）\nQcache_queries_in_cache   查询缓存中注册的查询数\nQcache_total_blocks       查询缓存中的块总数\n\n\n# 开启查询缓存\n\nMySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。\n\nquery_cache_type 该参数的可取值有三个 ：\n\n值            含义\nOFF 或 0      查询缓存功能关闭\nON 或 1       查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存\nDEMAND 或 2   查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存\n\n在 /usr/my.cnf 配置中（宝塔在 /etc/my.cnf ），增加以下配置 ：\n\n# 开启mysql的查询缓存\nquery_cache_type=1\n\n\n1\n2\n\n\n配置完毕之后，重启服务既可生效 , service mysqld restart；\n\n然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。\n\n\n# 查询缓存SELECT选项\n\n可以在 SELECT 语句中指定两个与查询缓存相关的选项 ：\n\n * SQL_CACHE\n   \n   如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为 ON 或 DEMAND ，则缓存查询结果 。\n\n * SQL_NO_CACHE\n   \n   服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。\n\n例子：\n\nSELECT SQL_CACHE id, name FROM customer;\nSELECT SQL_NO_CACHE id, name FROM customer;\n\n\n1\n2\n\n\n\n\n\n# 查询缓存失效的情况\n\n1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。\n\n-- SQL1 : \nselect count(*) from tb_item;\n-- SQL2 : \nSelect count(*) from tb_item;\n\n\n1\n2\n3\n4\n\n\n2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。\n\nselect * from tb_item where updatetime < now() limit 1;\nselect user();\nselect database();\n\n\n1\n2\n3\n\n\n3） 不使用任何表查询语句。\n\nselect 'A';\n\n\n1\n\n\n4） 查询 mysql， information_schema或 performance_schema 系统数据库中的表时，不会走查询缓存。\n\nselect * from information_schema.engines;\n\n\n1\n\n\n5） 在存储的函数，触发器或事件的主体内执行的查询。\n\n6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用MERGE映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。",normalizedContent:" * 概述\n * 查询缓存配置\n * 开启查询缓存\n * 查询缓存select选项\n * 查询缓存失效的情况\n\n\n# 概述\n\n开启mysql的查询缓存，当执行完全相同的sql语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。\n\n\n\n 1. 客户端发送一条查询给服务器；\n 2. 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；\n 3. 服务器端进行sql解析、预处理，再由优化器生成对应的执行计划；\n 4. mysql根据优化器生成的执行计划，调用存储引擎的api来执行查询；\n 5. 将结果返回给客户端。\n\n\n# 查询缓存配置\n\n * 查看当前的mysql数据库是否支持查询缓存：\n\nshow variables like 'have_query_cache';\t\n\n\n1\n\n\n\n\n在mysql8，已经取消了查询缓存\n\n * 查看当前mysql是否开启了查询缓存 ：\n\nshow variables like 'query_cache_type'; \n\n\n1\n\n\n\n\n * 查看查询缓存的占用大小 ：\n\nshow variables like 'query_cache_size';\n\n\n1\n\n\n\n\n * 查看查询缓存的状态变量：\n\nshow status like 'qcache%';\n\n\n1\n\n\n\n\n各个变量的含义如下：\n\n参数                        含义\nqcache_free_blocks        查询缓存中的可用内存块数\nqcache_free_memory        查询缓存的可用内存量\nqcache_hits               查询缓存命中数\nqcache_inserts            添加到查询缓存的查询数\nqcache_lowmen_prunes      由于内存不足而从查询缓存中删除的查询数\nqcache_not_cached         非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）\nqcache_queries_in_cache   查询缓存中注册的查询数\nqcache_total_blocks       查询缓存中的块总数\n\n\n# 开启查询缓存\n\nmysql的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。\n\nquery_cache_type 该参数的可取值有三个 ：\n\n值            含义\noff 或 0      查询缓存功能关闭\non 或 1       查询缓存功能打开，select的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 sql_no_cache，不予缓存\ndemand 或 2   查询缓存功能按需进行，显式指定 sql_cache 的select语句才会缓存；其它均不予缓存\n\n在 /usr/my.cnf 配置中（宝塔在 /etc/my.cnf ），增加以下配置 ：\n\n# 开启mysql的查询缓存\nquery_cache_type=1\n\n\n1\n2\n\n\n配置完毕之后，重启服务既可生效 , service mysqld restart；\n\n然后就可以在命令行执行sql语句进行验证 ，执行一条比较耗时的sql语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。\n\n\n# 查询缓存select选项\n\n可以在 select 语句中指定两个与查询缓存相关的选项 ：\n\n * sql_cache\n   \n   如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为 on 或 demand ，则缓存查询结果 。\n\n * sql_no_cache\n   \n   服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。\n\n例子：\n\nselect sql_cache id, name from customer;\nselect sql_no_cache id, name from customer;\n\n\n1\n2\n\n\n\n\n\n# 查询缓存失效的情况\n\n1） sql 语句不一致的情况， 要想命中查询缓存，查询的sql语句必须一致。\n\n-- sql1 : \nselect count(*) from tb_item;\n-- sql2 : \nselect count(*) from tb_item;\n\n\n1\n2\n3\n4\n\n\n2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。\n\nselect * from tb_item where updatetime < now() limit 1;\nselect user();\nselect database();\n\n\n1\n2\n3\n\n\n3） 不使用任何表查询语句。\n\nselect 'a';\n\n\n1\n\n\n4） 查询 mysql， information_schema或 performance_schema 系统数据库中的表时，不会走查询缓存。\n\nselect * from information_schema.engines;\n\n\n1\n\n\n5） 在存储的函数，触发器或事件的主体内执行的查询。\n\n6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用merge映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 insert， update， delete， truncate table， alter table， drop table，或 drop database 。",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 内存管理",frontmatter:{title:"MySQL - 内存管理",permalink:"/mysql/memory-management/",date:"2021-05-24T15:46:46.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/18.MySQL%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html",relativePath:"03.数据库/05.MySQL/18.MySQL - 内存管理.md",key:"v-5909a860",path:"/mysql/memory-management/",headers:[{level:2,title:"内存优化原则",slug:"内存优化原则",normalizedTitle:"内存优化原则",charIndex:21},{level:2,title:"MyISAM 内存优化",slug:"myisam-内存优化",normalizedTitle:"myisam 内存优化",charIndex:33},{level:2,title:"InnoDB 内存优化",slug:"innodb-内存优化",normalizedTitle:"innodb 内存优化",charIndex:50}],headersStr:"内存优化原则 MyISAM 内存优化 InnoDB 内存优化",content:" * Mysql内存管理及优化\n   * 内存优化原则\n   * MyISAM 内存优化\n   * InnoDB 内存优化\n\n\n# Mysql内存管理及优化\n\n\n# 内存优化原则\n\n1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。\n\n2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。\n\n3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。\n\n\n# MyISAM 内存优化\n\n了解即可，我们平时用的都是 InnoDB\n\nmyisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。\n\n * key_buffer_size\n\nkey_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。\n\n在 /usr/my.cnf 中做如下配置：\n\nkey_buffer_size=512M\n\n\n1\n\n\nSHOW VARIABLES LIKE 'key_buffer_size' -- 查看大小\n\n\n1\n\n * read_buffer_size\n\n如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。\n\n * read_rnd_buffer_size\n\n对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。\n\n\n# InnoDB 内存优化\n\ninnodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。\n\n * innodb_buffer_pool_size\n\n该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。\n\ninnodb_buffer_pool_size=512M\n\n\n1\n\n * innodb_log_buffer_size\n\n决定了 Innodb 重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。\n\ninnodb_log_buffer_size=10M\n\n\n1\n",normalizedContent:" * mysql内存管理及优化\n   * 内存优化原则\n   * myisam 内存优化\n   * innodb 内存优化\n\n\n# mysql内存管理及优化\n\n\n# 内存优化原则\n\n1） 将尽量多的内存分配给mysql做缓存，但要给操作系统和其他程序预留足够内存。\n\n2） myisam 存储引擎的数据文件读取依赖于操作系统自身的io缓存，因此，如果有myisam表，就要预留更多的内存给操作系统做io缓存。\n\n3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。\n\n\n# myisam 内存优化\n\n了解即可，我们平时用的都是 innodb\n\nmyisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的io缓存。\n\n * key_buffer_size\n\nkey_buffer_size决定myisam索引块缓存区的大小，直接影响到myisam表的存取效率。可以在mysql参数文件中设置key_buffer_size的值，对于一般myisam数据库，建议至少将1/4可用内存分配给key_buffer_size。\n\n在 /usr/my.cnf 中做如下配置：\n\nkey_buffer_size=512m\n\n\n1\n\n\nshow variables like 'key_buffer_size' -- 查看大小\n\n\n1\n\n * read_buffer_size\n\n如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。\n\n * read_rnd_buffer_size\n\n对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。\n\n\n# innodb 内存优化\n\ninnodb用一块内存区做io缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。\n\n * innodb_buffer_pool_size\n\n该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问innodb表需要的磁盘i/o 就越少，性能也就越高。\n\ninnodb_buffer_pool_size=512m\n\n\n1\n\n * innodb_log_buffer_size\n\n决定了 innodb 重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。\n\ninnodb_log_buffer_size=10m\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"MySQL - 优化SQL检测步骤",frontmatter:{title:"MySQL - 优化SQL检测步骤",permalink:"/mysql/optimize-sql-check/",date:"2021-05-20T20:51:46.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/10.MySQL%20-%20%E4%BC%98%E5%8C%96SQL%E6%A3%80%E6%B5%8B%E6%AD%A5%E9%AA%A4.html",relativePath:"03.数据库/05.MySQL/10.MySQL - 优化SQL检测步骤.md",key:"v-bcb1749a",path:"/mysql/optimize-sql-check/",headers:[{level:2,title:"查看SQL执行频率",slug:"查看sql执行频率",normalizedTitle:"查看sql执行频率",charIndex:14},{level:2,title:"定位低效率执行SQL",slug:"定位低效率执行sql",normalizedTitle:"定位低效率执行sql",charIndex:27},{level:2,title:"explain分析执行计划",slug:"explain分析执行计划",normalizedTitle:"explain分析执行计划",charIndex:41},{level:3,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:60},{level:3,title:"explain 之 id",slug:"explain-之-id",normalizedTitle:"explain 之 id",charIndex:70},{level:3,title:"explain 之 select_type",slug:"explain-之-select-type",normalizedTitle:"explain 之 select_type",charIndex:88},{level:3,title:"explain 之 table",slug:"explain-之-table",normalizedTitle:"explain 之 table",charIndex:115},{level:3,title:"explain 之 type",slug:"explain-之-type",normalizedTitle:"explain 之 type",charIndex:136},{level:3,title:"explain 之 key",slug:"explain-之-key",normalizedTitle:"explain 之 key",charIndex:156},{level:3,title:"explain 之 rows",slug:"explain-之-rows",normalizedTitle:"explain 之 rows",charIndex:175},{level:3,title:"explain 之 extra",slug:"explain-之-extra",normalizedTitle:"explain 之 extra",charIndex:195},{level:2,title:"show profile分析SQL",slug:"show-profile分析sql",normalizedTitle:"show profile分析sql",charIndex:214},{level:2,title:"trace分析优化器执行计划",slug:"trace分析优化器执行计划",normalizedTitle:"trace分析优化器执行计划",charIndex:235}],headersStr:"查看SQL执行频率 定位低效率执行SQL explain分析执行计划 环境准备 explain 之 id explain 之 select_type explain 之 table explain 之 type explain 之 key explain 之 rows explain 之 extra show profile分析SQL trace分析优化器执行计划",content:'# 优化SQL步骤\n\n * 查看SQL执行频率\n * 定位低效率执行SQL\n * explain分析执行计划\n   * 环境准备\n   * explain 之 id\n   * explain 之 select_type\n   * explain 之 table\n   * explain 之 type\n   * explain 之 key\n   * explain 之 rows\n   * explain 之 extra\n * show profile分析SQL\n * trace分析优化器执行计划\n\n在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。\n\n当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。\n\n\n# 查看SQL执行频率\n\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。\n\nshow [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。\n\n下面的命令显示了当前 session 中所有统计参数的值：\n\nshow status like \'Com_______\';\n\n\n1\n\n\nCom_xxx 表示每个 xxx 语句执行的次数\n\n\n\nshow status like \'Innodb_rows_%\';\n\n\n1\n\n\n我们通常比较关心的是以下几个统计参数\n\n参数                     含义\nCom_select             执行 select 操作的次数，一次查询只累加 1。\nCom_insert             执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。\nCom_update             执行 UPDATE 操作的次数。\nCom_delete             执行 DELETE 操作的次数。\nInnodb_rows_read       select 查询返回的行数。\nInnodb_rows_inserted   执行 INSERT 操作插入的行数。\nInnodb_rows_updated    执行 UPDATE 操作更新的行数。\nInnodb_rows_deleted    执行 DELETE 操作删除的行数。\nConnections            试图连接 MySQL 服务器的次数。\nUptime                 服务器工作时间。\nSlow_queries           慢查询的次数。\n\nCom_*** : 这些参数对于所有存储引擎的表操作都会进行累计。\n\nInnodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。\n\n\n# 定位低效率执行SQL\n\n * 慢查询日志\n   \n   通过慢查询日志定位那些执行效率较低的 SQL 语句，用 log-slow-queries[file_name] 选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看日志管理的相关部分。\n\n * show processlist\n   \n   慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。\n\n\n\n1） id列，用户登录mysql时，系统分配的"connection_id"，可以使用函数connection_id()查看\n\n2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句\n\n3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户\n\n4） db列，显示这个进程目前连接的是哪个数据库\n\n5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等\n\n6） time列，显示这个状态持续的时间，单位是秒\n\n7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成\n\n8） info列，显示这个sql语句，是判断问题语句的一个重要依据\n\n\n# explain分析执行计划\n\n通过 EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。\n\nexplain  select * from tb_item where id = 1;\n\n\n1\n\n\n\n\n\n\n字段              含义\nid              select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。\nselect_type     表示 SELECT 的类型，常见的取值有\n                SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION\n                中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等\ntable           输出结果集的表\ntype            表示表的连接类型，性能由好到差的连接类型为( system ---\x3e const -----\x3e eq_ref\n                ------\x3e ref -------\x3e ref_or_null----\x3e index_merge ---\x3e\n                index_subquery -----\x3e range -----\x3e index ------\x3e all )\npossible_keys   表示查询时，可能使用的索引\nkey             表示实际使用的索引\nkey_len         索引字段的长度\nrows            扫描行的数量\nextra           执行情况的说明和描述\n\n\n# 环境准备\n\n\n\nCREATE TABLE `t_role` (\n  `id` VARCHAR(32) NOT NULL,\n  `role_name` VARCHAR(255) DEFAULT NULL,\n  `role_code` VARCHAR(255) DEFAULT NULL,\n  `description` VARCHAR(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_role_name` (`role_name`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `t_user` (\n  `id` VARCHAR(32) NOT NULL,\n  `username` VARCHAR(45) NOT NULL,\n  `password` VARCHAR(96) NOT NULL,\n  `name` VARCHAR(45) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `unique_user_username` (`username`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `user_role` (\n  `id` INT(11) NOT NULL AUTO_INCREMENT ,\n  `user_id` VARCHAR(32) DEFAULT NULL,\n  `role_id` VARCHAR(32) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `fk_ur_user_id` (`user_id`),\n  KEY `fk_ur_role_id` (`role_id`),\n  CONSTRAINT `fk_ur_role_id` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,\n  CONSTRAINT `fk_ur_user_id` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `t_user` (`id`, `username`, `password`, `name`) VALUES(\'1\',\'super\',\'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe\',\'超级管理员\');\nINSERT INTO `t_user` (`id`, `username`, `password`, `name`) VALUES(\'2\',\'admin\',\'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe\',\'系统管理员\');\nINSERT INTO `t_user` (`id`, `username`, `password`, `name`) VALUES(\'3\',\'itcast\',\'$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui\',\'test02\');\nINSERT INTO `t_user` (`id`, `username`, `password`, `name`) VALUES(\'4\',\'stu1\',\'$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa\',\'学生1\');\nINSERT INTO `t_user` (`id`, `username`, `password`, `name`) VALUES(\'5\',\'stu2\',\'$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm\',\'学生2\');\nINSERT INTO `t_user` (`id`, `username`, `password`, `name`) VALUES(\'6\',\'t1\',\'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe\',\'老师1\');\n\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'5\',\'学生\',\'student\',\'学生\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'7\',\'老师\',\'teacher\',\'老师\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'8\',\'教学管理员\',\'teachmanager\',\'教学管理员\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'9\',\'管理员\',\'admin\',\'管理员\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'10\',\'超级管理员\',\'super\',\'超级管理员\');\n\nINSERT INTO user_role(id,user_id,role_id) VALUES(NULL, \'1\', \'5\'),(NULL, \'1\', \'7\'),(NULL, \'2\', \'8\'),(NULL, \'3\', \'9\'),(NULL, \'4\', \'8\'),(NULL, \'5\', \'10\') ;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# explain 之 id\n\nid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种\n\n1） id 相同表示加载表的顺序是从上到下。\n\nexplain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ;\n\n\n1\n\n\n\n\n2） id 不同id值越大，优先级越高，越先被执行。\n\nEXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = \'stu1\'))\n\n\n1\n\n\n\n\n3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。\n\nEXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = \'2\') a WHERE r.id = a.role_id ; \n\n\n1\n\n\n\n\n\n# explain 之 select_type\n\n表示 SELECT 的类型，常见的取值，如下表所示：\n\nSELECT_TYPE    含义\nSIMPLE         简单的select查询，查询中不包含子查询或者UNION\nPRIMARY        查询中若包含任何复杂的子查询，最外层查询标记为该标识\nSUBQUERY       在SELECT 或 WHERE 列表中包含了子查询\nDERIVED        在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中\nUNION          若第二个SELECT出现在UNION之后，则标记为UNION ；\n               若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED\nUNION RESULT   从UNION表获取结果的SELECT\n\n * SIMPLE\n   \n   SIMPLE 代表单表查询\n   \n   EXPLAIN SELECT * FROM t_user;\n   \n   \n   1\n   \n   \n   \n\n * PRIMARY、SUBQUERY\n   \n   在 SELECT 或 WHERE 列表中包含了子查询。最外层查询则被标记为 Primary。\n   \n   explain select * from t_user where id = (select id from user_role where role_id=\'9\' );\n   \n   \n   1\n   \n   \n   \n\n * DERIVED\n   \n   在 FROM 列表中包含的子查询被标记为 DERIVED(衍生)，MySQL 会递归执行这些子查询, 把结果放在临时表里。\n   \n   explain select a.* from (select * from t_user where id in(\'1\',\'2\') ) a;\n   \n   \n   1\n   \n   \n   mysql 5.7 中为 simple\n   \n   \n   \n   mysql 5.6 中：\n   \n   \n\n * union\n   \n   explain select * from t_user where id=\'1\' union select * from  t_user where id=\'2\';\n   \n   \n   1\n   \n   \n   \n\n\n# explain 之 table\n\n展示这一行的数据是关于哪一张表的\n\n没有与之关系的表为 NULL\n\n\n\n\n# explain 之 type\n\ntype 显示的是访问类型，是较为重要的一个指标，可取值为：\n\nTYPE     含义\nNULL     MySQL不访问任何表，索引，直接返回结果\nsystem   表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现\nconst    表示通过索引一次就找到了，const 用于比较primary key 或者 unique\n         索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将\n         "主键" 或 "唯一" 索引的所有部分与常量值进行比较\neq_ref   类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描\nref      非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）\nrange    只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， < , > , in 等操作。\nindex    index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。\nall      将遍历全表以找到匹配的行\n\n结果值从最好到最坏以此是：\n\n * NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\n\n * system > const > eq_ref > ref > range > index > ALL\n\n一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref\n\n\n# explain 之 key\n\n * possible_keys :\n   \n   显示可能应用在这张表的索引， 一个或多个。\n\n * key\n   \n   实际使用的索引， 如果为NULL， 则没有使用索引。\n\n * key_len\n   \n   表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\n\n\n# explain 之 rows\n\n扫描行的数量。\n\n\n# explain 之 extra\n\n其他的额外的执行计划信息，在该列展示 。\n\nEXTRA             含义\nusing filesort    说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。\nusing temporary   使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by；\n                  效率低\nusing index       表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。\n\n\n# show profile分析SQL\n\nMysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。\n\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。\n\n通过 have_profiling 参数，能够看到当前MySQL是否支持profile：\n\n\n\n默认profiling是关闭的，可以通过set语句在Session级别开启profiling：\n\n\n\nset profiling=1; //开启profiling 开关；\n\n\n1\n\n\n通过profile，我们能够更清楚地了解SQL执行的过程。\n\n我们可以执行一系列的操作：\n\nshow databases;\n\nuse db01;\n\nshow tables;\n\nselect * from tb_item where id < 5;\n\nselect count(*) from tb_item;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n执行完上述命令之后，再执行 show profiles 指令， 来查看SQL语句执行的耗时：\n\n\n\n通过 show profile for query query_id 语句查看该SQL执行过程中每个线程的状态和消耗的时间\n\n\n\nTIP：Sending data 状态表示 MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在 Sending data 状态下，MySQL 线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。\n\n在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ：\n\n\n\n字段           含义\nStatus       sql 语句执行的状态\nDuration     sql 执行过程中每一个步骤的耗时\nCPU_user     当前用户占有的cpu\nCPU_system   系统占有的cpu\n\n\n# trace分析优化器执行计划\n\nMySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。\n\n打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。\n\nSET optimizer_trace="enabled=on",end_markers_in_json=on;\nset optimizer_trace_max_mem_size=1000000;\n\n\n1\n2\n\n\n执行SQL语句 ：\n\nselect * from tb_item where id < 4;\n\n\n1\n\n\n最后， 检查 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：\n\nselect * from information_schema.optimizer_trace\\G;\n\n\n1\n\n\n*************************** 1. row ***************************\nQUERY: select * from tb_item where id < 4\nTRACE: {\n  "steps": [\n    {\n      "join_preparation": {\n        "select#": 1,\n        "steps": [\n          {\n            "expanded_query": "/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` < 4)"\n          }\n        ] /* steps */\n      } /* join_preparation */\n    },\n    {\n      "join_optimization": {\n        "select#": 1,\n        "steps": [\n          {\n            "condition_processing": {\n              "condition": "WHERE",\n              "original_condition": "(`tb_item`.`id` < 4)",\n              "steps": [\n                {\n                  "transformation": "equality_propagation",\n                  "resulting_condition": "(`tb_item`.`id` < 4)"\n                },\n                {\n                  "transformation": "constant_propagation",\n                  "resulting_condition": "(`tb_item`.`id` < 4)"\n                },\n                {\n                  "transformation": "trivial_condition_removal",\n                  "resulting_condition": "(`tb_item`.`id` < 4)"\n                }\n              ] /* steps */\n            } /* condition_processing */\n          },\n          {\n            "table_dependencies": [\n              {\n                "table": "`tb_item`",\n                "row_may_be_null": false,\n                "map_bit": 0,\n                "depends_on_map_bits": [\n                ] /* depends_on_map_bits */\n              }\n            ] /* table_dependencies */\n          },\n          {\n            "ref_optimizer_key_uses": [\n            ] /* ref_optimizer_key_uses */\n          },\n          {\n            "rows_estimation": [\n              {\n                "table": "`tb_item`",\n                "range_analysis": {\n                  "table_scan": {\n                    "rows": 9816098,\n                    "cost": 2.04e6\n                  } /* table_scan */,\n                  "potential_range_indices": [\n                    {\n                      "index": "PRIMARY",\n                      "usable": true,\n                      "key_parts": [\n                        "id"\n                      ] /* key_parts */\n                    }\n                  ] /* potential_range_indices */,\n                  "setup_range_conditions": [\n                  ] /* setup_range_conditions */,\n                  "group_index_range": {\n                    "chosen": false,\n                    "cause": "not_group_by_or_distinct"\n                  } /* group_index_range */,\n                  "analyzing_range_alternatives": {\n                    "range_scan_alternatives": [\n                      {\n                        "index": "PRIMARY",\n                        "ranges": [\n                          "id < 4"\n                        ] /* ranges */,\n                        "index_dives_for_eq_ranges": true,\n                        "rowid_ordered": true,\n                        "using_mrr": false,\n                        "index_only": false,\n                        "rows": 3,\n                        "cost": 1.6154,\n                        "chosen": true\n                      }\n                    ] /* range_scan_alternatives */,\n                    "analyzing_roworder_intersect": {\n                      "usable": false,\n                      "cause": "too_few_roworder_scans"\n                    } /* analyzing_roworder_intersect */\n                  } /* analyzing_range_alternatives */,\n                  "chosen_range_access_summary": {\n                    "range_access_plan": {\n                      "type": "range_scan",\n                      "index": "PRIMARY",\n                      "rows": 3,\n                      "ranges": [\n                        "id < 4"\n                      ] /* ranges */\n                    } /* range_access_plan */,\n                    "rows_for_plan": 3,\n                    "cost_for_plan": 1.6154,\n                    "chosen": true\n                  } /* chosen_range_access_summary */\n                } /* range_analysis */\n              }\n            ] /* rows_estimation */\n          },\n          {\n            "considered_execution_plans": [\n              {\n                "plan_prefix": [\n                ] /* plan_prefix */,\n                "table": "`tb_item`",\n                "best_access_path": {\n                  "considered_access_paths": [\n                    {\n                      "access_type": "range",\n                      "rows": 3,\n                      "cost": 2.2154,\n                      "chosen": true\n                    }\n                  ] /* considered_access_paths */\n                } /* best_access_path */,\n                "cost_for_plan": 2.2154,\n                "rows_for_plan": 3,\n                "chosen": true\n              }\n            ] /* considered_execution_plans */\n          },\n          {\n            "attaching_conditions_to_tables": {\n              "original_condition": "(`tb_item`.`id` < 4)",\n              "attached_conditions_computation": [\n              ] /* attached_conditions_computation */,\n              "attached_conditions_summary": [\n                {\n                  "table": "`tb_item`",\n                  "attached": "(`tb_item`.`id` < 4)"\n                }\n              ] /* attached_conditions_summary */\n            } /* attaching_conditions_to_tables */\n          },\n          {\n            "refine_plan": [\n              {\n                "table": "`tb_item`",\n                "access_type": "range"\n              }\n            ] /* refine_plan */\n          }\n        ] /* steps */\n      } /* join_optimization */\n    },\n    {\n      "join_execution": {\n        "select#": 1,\n        "steps": [\n        ] /* steps */\n      } /* join_execution */\n    }\n  ] /* steps */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n',normalizedContent:'# 优化sql步骤\n\n * 查看sql执行频率\n * 定位低效率执行sql\n * explain分析执行计划\n   * 环境准备\n   * explain 之 id\n   * explain 之 select_type\n   * explain 之 table\n   * explain 之 type\n   * explain 之 key\n   * explain 之 rows\n   * explain 之 extra\n * show profile分析sql\n * trace分析优化器执行计划\n\n在应用的的开发过程中，由于初期数据量小，开发人员写 sql 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 sql 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 sql 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 mysql 中优化 sql 语句的方法。\n\n当面对一个有 sql 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 sql 并尽快解决问题。\n\n\n# 查看sql执行频率\n\nmysql 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。\n\nshow [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。\n\n下面的命令显示了当前 session 中所有统计参数的值：\n\nshow status like \'com_______\';\n\n\n1\n\n\ncom_xxx 表示每个 xxx 语句执行的次数\n\n\n\nshow status like \'innodb_rows_%\';\n\n\n1\n\n\n我们通常比较关心的是以下几个统计参数\n\n参数                     含义\ncom_select             执行 select 操作的次数，一次查询只累加 1。\ncom_insert             执行 insert 操作的次数，对于批量插入的 insert 操作，只累加一次。\ncom_update             执行 update 操作的次数。\ncom_delete             执行 delete 操作的次数。\ninnodb_rows_read       select 查询返回的行数。\ninnodb_rows_inserted   执行 insert 操作插入的行数。\ninnodb_rows_updated    执行 update 操作更新的行数。\ninnodb_rows_deleted    执行 delete 操作删除的行数。\nconnections            试图连接 mysql 服务器的次数。\nuptime                 服务器工作时间。\nslow_queries           慢查询的次数。\n\ncom_*** : 这些参数对于所有存储引擎的表操作都会进行累计。\n\ninnodb_*** : 这几个参数只是针对innodb 存储引擎的，累加的算法也略有不同。\n\n\n# 定位低效率执行sql\n\n * 慢查询日志\n   \n   通过慢查询日志定位那些执行效率较低的 sql 语句，用 log-slow-queries[file_name] 选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 sql 语句的日志文件。具体可以查看日志管理的相关部分。\n\n * show processlist\n   \n   慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前mysql在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 sql 的执行情况，同时对一些锁表操作进行优化。\n\n\n\n1） id列，用户登录mysql时，系统分配的"connection_id"，可以使用函数connection_id()查看\n\n2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句\n\n3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户\n\n4） db列，显示这个进程目前连接的是哪个数据库\n\n5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等\n\n6） time列，显示这个状态持续的时间，单位是秒\n\n7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成\n\n8） info列，显示这个sql语句，是判断问题语句的一个重要依据\n\n\n# explain分析执行计划\n\n通过 explain 或者 desc命令获取 mysql 如何执行 select 语句的信息，包括在 select 语句执行过程中表如何连接和连接的顺序。\n\nexplain  select * from tb_item where id = 1;\n\n\n1\n\n\n\n\n\n\n字段              含义\nid              select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。\nselect_type     表示 select 的类型，常见的取值有\n                simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、union（union\n                中的第二个或者后面的查询语句）、subquery（子查询中的第一个 select）等\ntable           输出结果集的表\ntype            表示表的连接类型，性能由好到差的连接类型为( system ---\x3e const -----\x3e eq_ref\n                ------\x3e ref -------\x3e ref_or_null----\x3e index_merge ---\x3e\n                index_subquery -----\x3e range -----\x3e index ------\x3e all )\npossible_keys   表示查询时，可能使用的索引\nkey             表示实际使用的索引\nkey_len         索引字段的长度\nrows            扫描行的数量\nextra           执行情况的说明和描述\n\n\n# 环境准备\n\n\n\ncreate table `t_role` (\n  `id` varchar(32) not null,\n  `role_name` varchar(255) default null,\n  `role_code` varchar(255) default null,\n  `description` varchar(255) default null,\n  primary key (`id`),\n  unique key `unique_role_name` (`role_name`)\n) engine=innodb default charset=utf8;\n\ncreate table `t_user` (\n  `id` varchar(32) not null,\n  `username` varchar(45) not null,\n  `password` varchar(96) not null,\n  `name` varchar(45) not null,\n  primary key (`id`),\n  unique key `unique_user_username` (`username`)\n) engine=innodb default charset=utf8;\n\ncreate table `user_role` (\n  `id` int(11) not null auto_increment ,\n  `user_id` varchar(32) default null,\n  `role_id` varchar(32) default null,\n  primary key (`id`),\n  key `fk_ur_user_id` (`user_id`),\n  key `fk_ur_role_id` (`role_id`),\n  constraint `fk_ur_role_id` foreign key (`role_id`) references `t_role` (`id`) on delete no action on update no action,\n  constraint `fk_ur_user_id` foreign key (`user_id`) references `t_user` (`id`) on delete no action on update no action\n) engine=innodb default charset=utf8;\n\ninsert into `t_user` (`id`, `username`, `password`, `name`) values(\'1\',\'super\',\'$2a$10$tj4tmcdk.x4wv/tcqhw14.w70u3cc33cevncd3slmymxmknstqkre\',\'超级管理员\');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values(\'2\',\'admin\',\'$2a$10$tj4tmcdk.x4wv/tcqhw14.w70u3cc33cevncd3slmymxmknstqkre\',\'系统管理员\');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values(\'3\',\'itcast\',\'$2a$10$8qmahgufuampr5pouwhywor291wjyjhelulyn07k5elf8zcrw0cui\',\'test02\');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values(\'4\',\'stu1\',\'$2a$10$pltt2kdafpwtwljnsmtei.ou1yozyin9xkzik/y/sph5rftcpumza\',\'学生1\');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values(\'5\',\'stu2\',\'$2a$10$nxpkkysez7uz2yqyunwhr.z57km3yqkn3hr/p1fr6zkgc18u.tvqm\',\'学生2\');\ninsert into `t_user` (`id`, `username`, `password`, `name`) values(\'6\',\'t1\',\'$2a$10$tj4tmcdk.x4wv/tcqhw14.w70u3cc33cevncd3slmymxmknstqkre\',\'老师1\');\n\ninsert into `t_role` (`id`, `role_name`, `role_code`, `description`) values(\'5\',\'学生\',\'student\',\'学生\');\ninsert into `t_role` (`id`, `role_name`, `role_code`, `description`) values(\'7\',\'老师\',\'teacher\',\'老师\');\ninsert into `t_role` (`id`, `role_name`, `role_code`, `description`) values(\'8\',\'教学管理员\',\'teachmanager\',\'教学管理员\');\ninsert into `t_role` (`id`, `role_name`, `role_code`, `description`) values(\'9\',\'管理员\',\'admin\',\'管理员\');\ninsert into `t_role` (`id`, `role_name`, `role_code`, `description`) values(\'10\',\'超级管理员\',\'super\',\'超级管理员\');\n\ninsert into user_role(id,user_id,role_id) values(null, \'1\', \'5\'),(null, \'1\', \'7\'),(null, \'2\', \'8\'),(null, \'3\', \'9\'),(null, \'4\', \'8\'),(null, \'5\', \'10\') ;\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# explain 之 id\n\nid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种\n\n1） id 相同表示加载表的顺序是从上到下。\n\nexplain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ;\n\n\n1\n\n\n\n\n2） id 不同id值越大，优先级越高，越先被执行。\n\nexplain select * from t_role where id = (select role_id from user_role where user_id = (select id from t_user where username = \'stu1\'))\n\n\n1\n\n\n\n\n3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。\n\nexplain select * from t_role r , (select * from user_role ur where ur.`user_id` = \'2\') a where r.id = a.role_id ; \n\n\n1\n\n\n\n\n\n# explain 之 select_type\n\n表示 select 的类型，常见的取值，如下表所示：\n\nselect_type    含义\nsimple         简单的select查询，查询中不包含子查询或者union\nprimary        查询中若包含任何复杂的子查询，最外层查询标记为该标识\nsubquery       在select 或 where 列表中包含了子查询\nderived        在from 列表中包含的子查询，被标记为 derived（衍生） mysql会递归执行这些子查询，把结果放在临时表中\nunion          若第二个select出现在union之后，则标记为union ；\n               若union包含在from子句的子查询中，外层select将被标记为 ： derived\nunion result   从union表获取结果的select\n\n * simple\n   \n   simple 代表单表查询\n   \n   explain select * from t_user;\n   \n   \n   1\n   \n   \n   \n\n * primary、subquery\n   \n   在 select 或 where 列表中包含了子查询。最外层查询则被标记为 primary。\n   \n   explain select * from t_user where id = (select id from user_role where role_id=\'9\' );\n   \n   \n   1\n   \n   \n   \n\n * derived\n   \n   在 from 列表中包含的子查询被标记为 derived(衍生)，mysql 会递归执行这些子查询, 把结果放在临时表里。\n   \n   explain select a.* from (select * from t_user where id in(\'1\',\'2\') ) a;\n   \n   \n   1\n   \n   \n   mysql 5.7 中为 simple\n   \n   \n   \n   mysql 5.6 中：\n   \n   \n\n * union\n   \n   explain select * from t_user where id=\'1\' union select * from  t_user where id=\'2\';\n   \n   \n   1\n   \n   \n   \n\n\n# explain 之 table\n\n展示这一行的数据是关于哪一张表的\n\n没有与之关系的表为 null\n\n\n\n\n# explain 之 type\n\ntype 显示的是访问类型，是较为重要的一个指标，可取值为：\n\ntype     含义\nnull     mysql不访问任何表，索引，直接返回结果\nsystem   表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现\nconst    表示通过索引一次就找到了，const 用于比较primary key 或者 unique\n         索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，mysql 就能将该查询转换为一个常亮。const于将\n         "主键" 或 "唯一" 索引的所有部分与常量值进行比较\neq_ref   类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描\nref      非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）\nrange    只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， < , > , in 等操作。\nindex    index 与 all的区别为 index 类型只是遍历了索引树， 通常比all 快， all 是遍历数据文件。\nall      将遍历全表以找到匹配的行\n\n结果值从最好到最坏以此是：\n\n * null > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > all\n\n * system > const > eq_ref > ref > range > index > all\n\n一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref\n\n\n# explain 之 key\n\n * possible_keys :\n   \n   显示可能应用在这张表的索引， 一个或多个。\n\n * key\n   \n   实际使用的索引， 如果为null， 则没有使用索引。\n\n * key_len\n   \n   表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。\n\n\n# explain 之 rows\n\n扫描行的数量。\n\n\n# explain 之 extra\n\n其他的额外的执行计划信息，在该列展示 。\n\nextra             含义\nusing filesort    说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。\nusing temporary   使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于 order by 和 group by；\n                  效率低\nusing index       表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。\n\n\n# show profile分析sql\n\nmysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。\n\nshow profiles 能够在做sql优化时帮助我们了解时间都耗费到哪里去了。\n\n通过 have_profiling 参数，能够看到当前mysql是否支持profile：\n\n\n\n默认profiling是关闭的，可以通过set语句在session级别开启profiling：\n\n\n\nset profiling=1; //开启profiling 开关；\n\n\n1\n\n\n通过profile，我们能够更清楚地了解sql执行的过程。\n\n我们可以执行一系列的操作：\n\nshow databases;\n\nuse db01;\n\nshow tables;\n\nselect * from tb_item where id < 5;\n\nselect count(*) from tb_item;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n执行完上述命令之后，再执行 show profiles 指令， 来查看sql语句执行的耗时：\n\n\n\n通过 show profile for query query_id 语句查看该sql执行过程中每个线程的状态和消耗的时间\n\n\n\ntip：sending data 状态表示 mysql 线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在 sending data 状态下，mysql 线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。\n\n在获取到最消耗时间的线程状态后，mysql支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看mysql在使用什么资源上耗费了过高的时间。例如，选择查看cpu的耗费时间 ：\n\n\n\n字段           含义\nstatus       sql 语句执行的状态\nduration     sql 执行过程中每一个步骤的耗时\ncpu_user     当前用户占有的cpu\ncpu_system   系统占有的cpu\n\n\n# trace分析优化器执行计划\n\nmysql5.6提供了对sql的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择a计划, 而不是选择b计划。\n\n打开trace ， 设置格式为 json，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。\n\nset optimizer_trace="enabled=on",end_markers_in_json=on;\nset optimizer_trace_max_mem_size=1000000;\n\n\n1\n2\n\n\n执行sql语句 ：\n\nselect * from tb_item where id < 4;\n\n\n1\n\n\n最后， 检查 information_schema.optimizer_trace 就可以知道mysql是如何执行sql的 ：\n\nselect * from information_schema.optimizer_trace\\g;\n\n\n1\n\n\n*************************** 1. row ***************************\nquery: select * from tb_item where id < 4\ntrace: {\n  "steps": [\n    {\n      "join_preparation": {\n        "select#": 1,\n        "steps": [\n          {\n            "expanded_query": "/* select#1 */ select `tb_item`.`id` as `id`,`tb_item`.`title` as `title`,`tb_item`.`price` as `price`,`tb_item`.`num` as `num`,`tb_item`.`categoryid` as `categoryid`,`tb_item`.`status` as `status`,`tb_item`.`sellerid` as `sellerid`,`tb_item`.`createtime` as `createtime`,`tb_item`.`updatetime` as `updatetime` from `tb_item` where (`tb_item`.`id` < 4)"\n          }\n        ] /* steps */\n      } /* join_preparation */\n    },\n    {\n      "join_optimization": {\n        "select#": 1,\n        "steps": [\n          {\n            "condition_processing": {\n              "condition": "where",\n              "original_condition": "(`tb_item`.`id` < 4)",\n              "steps": [\n                {\n                  "transformation": "equality_propagation",\n                  "resulting_condition": "(`tb_item`.`id` < 4)"\n                },\n                {\n                  "transformation": "constant_propagation",\n                  "resulting_condition": "(`tb_item`.`id` < 4)"\n                },\n                {\n                  "transformation": "trivial_condition_removal",\n                  "resulting_condition": "(`tb_item`.`id` < 4)"\n                }\n              ] /* steps */\n            } /* condition_processing */\n          },\n          {\n            "table_dependencies": [\n              {\n                "table": "`tb_item`",\n                "row_may_be_null": false,\n                "map_bit": 0,\n                "depends_on_map_bits": [\n                ] /* depends_on_map_bits */\n              }\n            ] /* table_dependencies */\n          },\n          {\n            "ref_optimizer_key_uses": [\n            ] /* ref_optimizer_key_uses */\n          },\n          {\n            "rows_estimation": [\n              {\n                "table": "`tb_item`",\n                "range_analysis": {\n                  "table_scan": {\n                    "rows": 9816098,\n                    "cost": 2.04e6\n                  } /* table_scan */,\n                  "potential_range_indices": [\n                    {\n                      "index": "primary",\n                      "usable": true,\n                      "key_parts": [\n                        "id"\n                      ] /* key_parts */\n                    }\n                  ] /* potential_range_indices */,\n                  "setup_range_conditions": [\n                  ] /* setup_range_conditions */,\n                  "group_index_range": {\n                    "chosen": false,\n                    "cause": "not_group_by_or_distinct"\n                  } /* group_index_range */,\n                  "analyzing_range_alternatives": {\n                    "range_scan_alternatives": [\n                      {\n                        "index": "primary",\n                        "ranges": [\n                          "id < 4"\n                        ] /* ranges */,\n                        "index_dives_for_eq_ranges": true,\n                        "rowid_ordered": true,\n                        "using_mrr": false,\n                        "index_only": false,\n                        "rows": 3,\n                        "cost": 1.6154,\n                        "chosen": true\n                      }\n                    ] /* range_scan_alternatives */,\n                    "analyzing_roworder_intersect": {\n                      "usable": false,\n                      "cause": "too_few_roworder_scans"\n                    } /* analyzing_roworder_intersect */\n                  } /* analyzing_range_alternatives */,\n                  "chosen_range_access_summary": {\n                    "range_access_plan": {\n                      "type": "range_scan",\n                      "index": "primary",\n                      "rows": 3,\n                      "ranges": [\n                        "id < 4"\n                      ] /* ranges */\n                    } /* range_access_plan */,\n                    "rows_for_plan": 3,\n                    "cost_for_plan": 1.6154,\n                    "chosen": true\n                  } /* chosen_range_access_summary */\n                } /* range_analysis */\n              }\n            ] /* rows_estimation */\n          },\n          {\n            "considered_execution_plans": [\n              {\n                "plan_prefix": [\n                ] /* plan_prefix */,\n                "table": "`tb_item`",\n                "best_access_path": {\n                  "considered_access_paths": [\n                    {\n                      "access_type": "range",\n                      "rows": 3,\n                      "cost": 2.2154,\n                      "chosen": true\n                    }\n                  ] /* considered_access_paths */\n                } /* best_access_path */,\n                "cost_for_plan": 2.2154,\n                "rows_for_plan": 3,\n                "chosen": true\n              }\n            ] /* considered_execution_plans */\n          },\n          {\n            "attaching_conditions_to_tables": {\n              "original_condition": "(`tb_item`.`id` < 4)",\n              "attached_conditions_computation": [\n              ] /* attached_conditions_computation */,\n              "attached_conditions_summary": [\n                {\n                  "table": "`tb_item`",\n                  "attached": "(`tb_item`.`id` < 4)"\n                }\n              ] /* attached_conditions_summary */\n            } /* attaching_conditions_to_tables */\n          },\n          {\n            "refine_plan": [\n              {\n                "table": "`tb_item`",\n                "access_type": "range"\n              }\n            ] /* refine_plan */\n          }\n        ] /* steps */\n      } /* join_optimization */\n    },\n    {\n      "join_execution": {\n        "select#": 1,\n        "steps": [\n        ] /* steps */\n      } /* join_execution */\n    }\n  ] /* steps */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 并发参数",frontmatter:{title:"MySQL - 并发参数",permalink:"/mysql/concurrent-parameter/",date:"2021-05-24T16:13:14.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/20.MySQL%20-%20%E5%B9%B6%E5%8F%91%E5%8F%82%E6%95%B0.html",relativePath:"03.数据库/05.MySQL/20.MySQL - 并发参数.md",key:"v-101289a5",path:"/mysql/concurrent-parameter/",headers:[{level:2,title:"max_connections",slug:"max-connections",normalizedTitle:"max_connections",charIndex:3},{level:2,title:"back_log",slug:"back-log",normalizedTitle:"back_log",charIndex:22},{level:2,title:"tableopencache",slug:"table-open-cache",normalizedTitle:"tableopencache",charIndex:null},{level:2,title:"threadcachesize",slug:"thread-cache-size",normalizedTitle:"threadcachesize",charIndex:null},{level:2,title:"innodblockwait_timeout",slug:"innodb-lock-wait-timeout",normalizedTitle:"innodblockwait_timeout",charIndex:null}],headersStr:"max_connections back_log tableopencache threadcachesize innodblockwait_timeout",content:" * max_connections\n * back_log\n * table_open_cache\n * thread_cache_size\n * innodb_lock_wait_timeout\n\n从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。\n\n\n# max_connections\n\n采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。\n\nMysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。\n\n\n# back_log\n\nback_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。\n\n如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大 back_log 的值。\n\n\n# table_open_cache\n\n该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：max_connections x N ；\n\nSHOW VARIABLES LIKE 'table_open_cache' -- 查看大小\n\n\n1\n\n\n\n# thread_cache_size\n\n为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。\n\n\n# innodb_lock_wait_timeout\n\n该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。",normalizedContent:" * max_connections\n * back_log\n * table_open_cache\n * thread_cache_size\n * innodb_lock_wait_timeout\n\n从实现上来说，mysql server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。\n\n\n# max_connections\n\n采用max_connections 控制允许连接到mysql数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。\n\nmysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、cpu的处理速度，期望的响应时间等。在linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。\n\n\n# back_log\n\nback_log 参数控制mysql监听tcp端口时设置的积压请求栈大小。如果mysql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。\n\n如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大 back_log 的值。\n\n\n# table_open_cache\n\n该参数用来控制所有sql语句执行线程可打开表缓存的数量， 而在执行sql语句时，每一个sql执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：max_connections x n ；\n\nshow variables like 'table_open_cache' -- 查看大小\n\n\n1\n\n\n\n# thread_cache_size\n\n为了加快连接数据库的速度，mysql 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 mysql 缓存客户服务线程的数量。\n\n\n# innodb_lock_wait_timeout\n\n该参数是用来设置innodb 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。",charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"MySQL - 常用sql技巧",frontmatter:{title:"MySQL - 常用sql技巧",permalink:"/mysql/common-use-sql-skill/",date:"2021-05-24T19:06:10.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/24.MySQL%20-%20%E5%B8%B8%E7%94%A8sql%E6%8A%80%E5%B7%A7.html",relativePath:"03.数据库/05.MySQL/24.MySQL - 常用sql技巧.md",key:"v-38a63570",path:"/mysql/common-use-sql-skill/",headers:[{level:2,title:"SQL执行顺序",slug:"sql执行顺序",normalizedTitle:"sql执行顺序",charIndex:3},{level:2,title:"正则表达式使用",slug:"正则表达式使用",normalizedTitle:"正则表达式使用",charIndex:14},{level:2,title:"MySQL 常用函数",slug:"mysql-常用函数",normalizedTitle:"mysql 常用函数",charIndex:25}],headersStr:"SQL执行顺序 正则表达式使用 MySQL 常用函数",content:" * SQL执行顺序\n * 正则表达式使用\n * MySQL 常用函数\n\n\n# SQL执行顺序\n\n编写顺序\n\nSELECT DISTINCT\n\t<select list>\nFROM\n\t<left_table> <join_type>\nJOIN\n\t<right_table> ON <join_condition>\nWHERE\n\t<where_condition>\nGROUP BY\n\t<group_by_list>\nHAVING\n\t<having_condition>\nORDER BY\n\t<order_by_condition>\nLIMIT\n\t<limit_params>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n执行顺序\n\nFROM\t<left_table>\n\nON \t\t<join_condition>\n\n<join_type>\t\tJOIN\t<right_table>\n\nWHERE\t\t<where_condition>\n\nGROUP BY \t<group_by_list>\n\nHAVING\t\t<having_condition>\n\nSELECT DISTINCT\t\t<select list>\n\nORDER BY\t<order_by_condition>\n\nLIMIT\t\t<limit_params>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 正则表达式使用\n\n正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。\n\n符号       含义\n^        在字符串开始处进行匹配\n$        在字符串末尾处进行匹配\n.        匹配任意单个字符, 包括换行符\n[...]    匹配出括号内的任意字符\n[^...]   匹配不出括号内的任意字符\na*       匹配零个或者多个a(包括空串)\na+       匹配一个或者多个a(不包括空串)\na?       匹配零个或者一个a\na1|a2    匹配a1或a2\na(m)     匹配m个a\na(m,)    至少匹配m个a\na(m,n)   匹配m个a 到 n个a\na(,n)    匹配0到n个a\n(...)    将模式元素组成单一元素\n\nselect * from emp where name regexp '^T';\n\nselect * from emp where name regexp '2$';\n\nselect * from emp where name regexp '[uvw]';\n\n\n1\n2\n3\n4\n5\n\n\n\n# MySQL 常用函数\n\n数字函数\n\n函数名称             作 用\nABS              求绝对值\nSQRT             求二次方根\nMOD              求余数\nCEIL 和 CEILING   两个函数功能相同，都是返回不小于参数的最小整数，即向上取整\nFLOOR            向下取整，返回值转化为一个BIGINT\nRAND             生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列\nROUND            对所传参数进行四舍五入\nSIGN             返回参数的符号\nPOW 和 POWER      两个函数的功能相同，都是所传参数的次方的结果值\nSIN              求正弦值\nASIN             求反正弦值，与函数 SIN 互为反函数\nCOS              求余弦值\nACOS             求反余弦值，与函数 COS 互为反函数\nTAN              求正切值\nATAN             求反正切值，与函数 TAN 互为反函数\nCOT              求余切值\n\n字符串函数\n\n函数名称        作 用\nLENGTH      计算字符串长度函数，返回字符串的字节长度\nCONCAT      合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个\nINSERT      替换字符串函数\nLOWER       将字符串中的字母转换为小写\nUPPER       将字符串中的字母转换为大写\nLEFT        从左侧字截取符串，返回字符串左边的若干个字符\nRIGHT       从右侧字截取符串，返回字符串右边的若干个字符\nTRIM        删除字符串左右两侧的空格\nREPLACE     字符串替换函数，返回替换后的新字符串\nSUBSTRING   截取字符串，返回从指定位置开始的指定长度的字符换\nREVERSE     字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串\n\n日期函数\n\n函数名称                     作 用\nCURDATE 和 CURRENT_DATE   两个函数作用相同，返回当前系统的日期值\nCURTIME 和 CURRENT_TIME   两个函数作用相同，返回当前系统的时间值\nNOW 和 SYSDATE            两个函数作用相同，返回当前系统的日期和时间值\nMONTH                    获取指定日期中的月份\nMONTHNAME                获取指定日期中的月份英文名称\nDAYNAME                  获取指定曰期对应的星期几的英文名称\nDAYOFWEEK                获取指定日期对应的一周的索引位置值\nWEEK                     获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53\nDAYOFYEAR                获取指定曰期是一年中的第几天，返回值范围是1~366\nDAYOFMONTH               获取指定日期是一个月中是第几天，返回值范围是1~31\nYEAR                     获取年份，返回值范围是 1970〜2069\nTIME_TO_SEC              将时间参数转换为秒数\nSEC_TO_TIME              将秒数转换为时间，与TIME_TO_SEC 互为反函数\nDATE_ADD 和 ADDDATE       两个函数功能相同，都是向日期添加指定的时间间隔\nDATE_SUB 和 SUBDATE       两个函数功能相同，都是向日期减去指定的时间间隔\nADDTIME                  时间加法运算，在原始时间上添加指定的时间\nSUBTIME                  时间减法运算，在原始时间上减去指定的时间\nDATEDIFF                 获取两个日期之间间隔，返回参数 1 减去参数 2 的值\nDATE_FORMAT              格式化指定的日期，根据参数返回指定格式的值\nWEEKDAY                  获取指定日期在一周内的对应的工作日索引\n\n聚合函数\n\n函数名称    作用\nMAX     查询指定列的最大值\nMIN     查询指定列的最小值\nCOUNT   统计查询结果的行数\nSUM     求和，返回指定列的总和\nAVG     求平均值，返回指定列数据的平均值",normalizedContent:" * sql执行顺序\n * 正则表达式使用\n * mysql 常用函数\n\n\n# sql执行顺序\n\n编写顺序\n\nselect distinct\n\t<select list>\nfrom\n\t<left_table> <join_type>\njoin\n\t<right_table> on <join_condition>\nwhere\n\t<where_condition>\ngroup by\n\t<group_by_list>\nhaving\n\t<having_condition>\norder by\n\t<order_by_condition>\nlimit\n\t<limit_params>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n执行顺序\n\nfrom\t<left_table>\n\non \t\t<join_condition>\n\n<join_type>\t\tjoin\t<right_table>\n\nwhere\t\t<where_condition>\n\ngroup by \t<group_by_list>\n\nhaving\t\t<having_condition>\n\nselect distinct\t\t<select list>\n\norder by\t<order_by_condition>\n\nlimit\t\t<limit_params>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 正则表达式使用\n\n正则表达式（regular expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。\n\n符号       含义\n^        在字符串开始处进行匹配\n$        在字符串末尾处进行匹配\n.        匹配任意单个字符, 包括换行符\n[...]    匹配出括号内的任意字符\n[^...]   匹配不出括号内的任意字符\na*       匹配零个或者多个a(包括空串)\na+       匹配一个或者多个a(不包括空串)\na?       匹配零个或者一个a\na1|a2    匹配a1或a2\na(m)     匹配m个a\na(m,)    至少匹配m个a\na(m,n)   匹配m个a 到 n个a\na(,n)    匹配0到n个a\n(...)    将模式元素组成单一元素\n\nselect * from emp where name regexp '^t';\n\nselect * from emp where name regexp '2$';\n\nselect * from emp where name regexp '[uvw]';\n\n\n1\n2\n3\n4\n5\n\n\n\n# mysql 常用函数\n\n数字函数\n\n函数名称             作 用\nabs              求绝对值\nsqrt             求二次方根\nmod              求余数\nceil 和 ceiling   两个函数功能相同，都是返回不小于参数的最小整数，即向上取整\nfloor            向下取整，返回值转化为一个bigint\nrand             生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列\nround            对所传参数进行四舍五入\nsign             返回参数的符号\npow 和 power      两个函数的功能相同，都是所传参数的次方的结果值\nsin              求正弦值\nasin             求反正弦值，与函数 sin 互为反函数\ncos              求余弦值\nacos             求反余弦值，与函数 cos 互为反函数\ntan              求正切值\natan             求反正切值，与函数 tan 互为反函数\ncot              求余切值\n\n字符串函数\n\n函数名称        作 用\nlength      计算字符串长度函数，返回字符串的字节长度\nconcat      合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个\ninsert      替换字符串函数\nlower       将字符串中的字母转换为小写\nupper       将字符串中的字母转换为大写\nleft        从左侧字截取符串，返回字符串左边的若干个字符\nright       从右侧字截取符串，返回字符串右边的若干个字符\ntrim        删除字符串左右两侧的空格\nreplace     字符串替换函数，返回替换后的新字符串\nsubstring   截取字符串，返回从指定位置开始的指定长度的字符换\nreverse     字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串\n\n日期函数\n\n函数名称                     作 用\ncurdate 和 current_date   两个函数作用相同，返回当前系统的日期值\ncurtime 和 current_time   两个函数作用相同，返回当前系统的时间值\nnow 和 sysdate            两个函数作用相同，返回当前系统的日期和时间值\nmonth                    获取指定日期中的月份\nmonthname                获取指定日期中的月份英文名称\ndayname                  获取指定曰期对应的星期几的英文名称\ndayofweek                获取指定日期对应的一周的索引位置值\nweek                     获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53\ndayofyear                获取指定曰期是一年中的第几天，返回值范围是1~366\ndayofmonth               获取指定日期是一个月中是第几天，返回值范围是1~31\nyear                     获取年份，返回值范围是 1970〜2069\ntime_to_sec              将时间参数转换为秒数\nsec_to_time              将秒数转换为时间，与time_to_sec 互为反函数\ndate_add 和 adddate       两个函数功能相同，都是向日期添加指定的时间间隔\ndate_sub 和 subdate       两个函数功能相同，都是向日期减去指定的时间间隔\naddtime                  时间加法运算，在原始时间上添加指定的时间\nsubtime                  时间减法运算，在原始时间上减去指定的时间\ndatediff                 获取两个日期之间间隔，返回参数 1 减去参数 2 的值\ndate_format              格式化指定的日期，根据参数返回指定格式的值\nweekday                  获取指定日期在一周内的对应的工作日索引\n\n聚合函数\n\n函数名称    作用\nmax     查询指定列的最大值\nmin     查询指定列的最小值\ncount   统计查询结果的行数\nsum     求和，返回指定列的总和\navg     求平均值，返回指定列数据的平均值",charsets:{cjk:!0},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"MySQL - 锁问题",frontmatter:{title:"MySQL - 锁问题",permalink:"/mysql/lock-question/",date:"2021-05-24T16:15:57.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/22.MySQL%20-%20%E9%94%81%E9%97%AE%E9%A2%98.html",relativePath:"03.数据库/05.MySQL/22.MySQL - 锁问题.md",key:"v-5a6a2f10",path:"/mysql/lock-question/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"MyISAM 表锁",slug:"myisam-表锁",normalizedTitle:"myisam 表锁",charIndex:9},{level:3,title:"如何加表锁",slug:"如何加表锁",normalizedTitle:"如何加表锁",charIndex:24},{level:3,title:"读锁案例",slug:"读锁案例",normalizedTitle:"读锁案例",charIndex:35},{level:3,title:"写锁案例",slug:"写锁案例",normalizedTitle:"写锁案例",charIndex:45},{level:3,title:"结论",slug:"结论",normalizedTitle:"结论",charIndex:55},{level:3,title:"查看锁的争用情况",slug:"查看锁的争用情况",normalizedTitle:"查看锁的争用情况",charIndex:63},{level:2,title:"InnoDB 行锁",slug:"innodb-行锁",normalizedTitle:"innodb 行锁",charIndex:75},{level:3,title:"行锁介绍",slug:"行锁介绍",normalizedTitle:"行锁介绍",charIndex:90},{level:3,title:"背景知识",slug:"背景知识",normalizedTitle:"背景知识",charIndex:100},{level:3,title:"InnoDB 的行锁模式",slug:"innodb-的行锁模式",normalizedTitle:"innodb 的行锁模式",charIndex:110},{level:3,title:"行锁基本演示",slug:"行锁基本演示",normalizedTitle:"行锁基本演示",charIndex:128},{level:3,title:"无索引行锁升级为表锁",slug:"无索引行锁升级为表锁",normalizedTitle:"无索引行锁升级为表锁",charIndex:140},{level:3,title:"间隙锁危害",slug:"间隙锁危害",normalizedTitle:"间隙锁危害",charIndex:156},{level:3,title:"InnoDB 行锁争用情况",slug:"innodb-行锁争用情况",normalizedTitle:"innodb 行锁争用情况",charIndex:167},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:186}],headersStr:"简介 MyISAM 表锁 如何加表锁 读锁案例 写锁案例 结论 查看锁的争用情况 InnoDB 行锁 行锁介绍 背景知识 InnoDB 的行锁模式 行锁基本演示 无索引行锁升级为表锁 间隙锁危害 InnoDB 行锁争用情况 总结",content:" * 简介\n * MyISAM 表锁\n   * 如何加表锁\n   * 读锁案例\n   * 写锁案例\n   * 结论\n   * 查看锁的争用情况\n * InnoDB 行锁\n   * 行锁介绍\n   * 背景知识\n   * InnoDB 的行锁模式\n   * 行锁基本演示\n   * 无索引行锁升级为表锁\n   * 间隙锁危害\n   * InnoDB 行锁争用情况\n   * 总结\n\n\n# 简介\n\n * 锁概述\n\n锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。\n\n在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\n\n * 锁分类：\n\n从对数据操作的粒度分 ：\n\n1） 表锁：操作时，会锁定整个表。\n\n2） 行锁：操作时，会锁定当前操作行。\n\n从对数据操作的类型分：\n\n1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。\n\n2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。\n\n * Mysql 锁\n\n相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。\n\n下表中罗列出了各存储引擎对锁的支持情况：\n\n存储引擎     表级锁   行级锁   页面锁\nMyISAM   支持    不支持   不支持\nInnoDB   支持    支持    不支持\nMEMORY   支持    不支持   不支持\nBDB      支持    不支持   支持\n\nMySQL这3种锁的特性可大致归纳如下 ：\n\n锁类型   特点\n表级锁   偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。\n行级锁   偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。\n页面锁   开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。\n\n\n# MyISAM 表锁\n\nMyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。\n\n\n# 如何加表锁\n\nMyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。\n\nlock table table_name read;\t--加读锁\n\nlock table table_name writ;\t--加写锁\n\n\n1\n2\n3\n\n\n\n# 读锁案例\n\n准备环境\n\ncreate database demo_03 default charset=utf8mb4;\n\nuse demo_03;\n\nCREATE TABLE `tb_book` (\n  `id` INT(11) auto_increment,\n  `name` VARCHAR(50) DEFAULT NULL,\n  `publish_time` DATE DEFAULT NULL,\n  `status` CHAR(1) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=myisam DEFAULT CHARSET=utf8 ;\n\nINSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,'java编程思想','2088-08-01','1');\nINSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,'solr编程思想','2088-08-08','0');\n\n\n\nCREATE TABLE `tb_user` (\n  `id` INT(11) auto_increment,\n  `name` VARCHAR(50) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=myisam DEFAULT CHARSET=utf8 ;\n\nINSERT INTO tb_user (id, name) VALUES(NULL,'令狐冲');\nINSERT INTO tb_user (id, name) VALUES(NULL,'田伯光');\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n客户端 一 ：\n\n1）加 tb_book 表的读锁\n\nlock table tb_book read;\n\n\n1\n\n\n2） 执行查询操作\n\nselect * from tb_book;\n\n\n1\n\n\n\n\n可以正常执行 ， 查询出数据。\n\n客户端 二 ：\n\n3） 执行查询操作\n\nselect * from tb_book;\n\n\n1\n\n\n\n\n客户端 一 ：\n\n4）查询未锁定的表\n\nselect name from tb_seller;\n\n\n1\n\n\n\n\n客户端 二 ：\n\n5）查询未锁定的表\n\nselect name from tb_seller;\n\n\n1\n\n\n\n\n可以正常查询出未锁定的表；\n\n客户端 一 ：\n\n6） 执行插入操作\n\ninsert into tb_book values(null,'Mysql高级','2088-01-01','1');\n\n\n1\n\n\n\n\n执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。\n\n客户端 二 ：\n\n7） 执行插入操作\n\ninsert into tb_book values(null,'Mysql高级','2088-01-01','1');\n\n\n1\n\n\n\n\n当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；\n\n\n# 写锁案例\n\n客户端 一 :\n\n1）给 tb_book 表的写锁\n\nlock table tb_book write ;\n\n\n1\n\n\n2）执行查询操作\n\nselect * from tb_book ;\n\n\n1\n\n\n\n\n查询操作执行成功；\n\n3）执行更新操作\n\nupdate tb_book set name = 'java编程思想（第二版）' where id = 1;\n\n\n1\n\n\n\n\n更新操作执行成功 ；\n\n客户端 二 :\n\n4）执行查询操作\n\nselect * from tb_book ;\n\n\n1\n\n\n\n\n当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 select 语句 ， 立即执行 ；\n\n\n\n\n# 结论\n\n锁模式的相互兼容性如表中所示：\n\n\n\n由上表可见：\n\n1） 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；\n\n2） 对MyISAM 表的写操作，会都阻塞其他用户对同一表的读和写操作；\n\n简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。\n\n此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。\n\n\n# 查看锁的争用情况\n\nshow open tables；\n\n\n1\n\n\n\n\nIn_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。\n\nName_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。\n\nshow status like 'Table_locks%';\n\n\n1\n\n\n\n\nTable_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。\n\nTable_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。\n\n\n# InnoDB 行锁\n\n\n# 行锁介绍\n\n行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。\n\nInnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁。\n\n\n# 背景知识\n\n事务及其ACID属性\n\n事务是由一组SQL语句组成的逻辑处理单元。\n\n事务具有以下4个特性，简称为事务ACID属性。\n\nACID属性            含义\n原子性（Atomicity）    事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。\n一致性（Consistent）   在事务开始和完成时，数据都必须保持一致状态。\n隔离性（Isolation）    数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。\n持久性（Durable）      事务完成之后，对于数据的修改是永久的。\n\n并发事务处理带来的问题\n\n问题                            含义\n丢失更新（Lost Update）             当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。\n脏读（Dirty Reads）               当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。\n不可重复读（Non-Repeatable Reads）   一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。\n幻读（Phantom Reads）             一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。\n\n事务隔离级别\n\n为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。\n\n数据库的隔离级别有4个，由低到高依次为 Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决 脏写、脏读、不可重复读、幻读 这几类问题。\n\n隔离级别                  丢失更新   脏读   不可重复读   幻读\nRead uncommitted      ×      √    √       √\nRead committed        ×      ×    √       √\nRepeatable read（默认）   ×      ×    ×       √\nSerializable          ×      ×    ×       ×\n\n备注 ： √ 代表可能出现 ， × 代表不会出现 。\n\nMysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：\n\nshow variables like 'tx_isolation';\n\n\n1\n\n\n\n\n\n# InnoDB 的行锁模式\n\nInnoDB 实现了以下两种类型的行锁。\n\n * 共享锁（S）：又称为读锁，简称 S 锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n * 排他锁（X）：又称为写锁，简称 X 锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。\n\n对于 UPDATE、DELETE、INSERT 语句，InnoDB 会自动给涉及数据集加 排他锁（X)\n\n对于普通SELECT语句，InnoDB不会加任何锁；\n\n可以通过以下语句显示给记录集加共享锁或排他锁 。\n\n-- 共享锁（S）\nSELECT * FROM table_name WHERE ... LOCK IN SHARE MODE\n-- 排他锁（X)\nSELECT * FROM table_name WHERE ... FOR UPDATE\n\n\n1\n2\n3\n4\n\n\n\n# 行锁基本演示\n\n准备 sql\n\ncreate table test_innodb_lock(\n\tid int(11),\n\tname varchar(16),\n\tsex varchar(1)\n)engine = innodb default charset=utf8;\n\ninsert into test_innodb_lock values(1,'100','1');\ninsert into test_innodb_lock values(3,'3','1');\ninsert into test_innodb_lock values(4,'400','0');\ninsert into test_innodb_lock values(5,'500','1');\ninsert into test_innodb_lock values(6,'600','0');\ninsert into test_innodb_lock values(7,'700','0');\ninsert into test_innodb_lock values(8,'800','1');\ninsert into test_innodb_lock values(9,'900','1');\ninsert into test_innodb_lock values(1,'200','0');\n\ncreate index idx_test_innodb_lock_id on test_innodb_lock(id);\ncreate index idx_test_innodb_lock_name on test_innodb_lock(name);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n开启两个会话\n\nSESSION-1                        SESSION-2\n关闭自动提交功能                         关闭自动提交功能\n可以正常的查询出全部的数据                    可以正常的查询出全部的数据\n查询id 为3的数据 ；                     获取id为3的数据 ；\n更新id为3的数据，但是不提交；                 更新id为3 的数据， 出于等待状态\n通过commit， 提交事务                   解除阻塞，更新正常进行\n以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：   \n更新id为3数据，正常的获取到行锁 ，执行更新          由于与 Session-1 操作不是同一行，获取当前行锁，执行更新；\n\n\n# 无索引行锁升级为表锁\n\n如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。\n\n --查看当前表的索引 ：\n show  index  from test_innodb_lock ;\n\n\n1\n2\n\n\n\n\nSESSION-1   SESSION-2\n关闭事务的自动提交   关闭事务的自动提交\n执行更新语句      执行更新语句， 但处于阻塞状态\n提交事务        解除阻塞，执行更新成功\n            执行提交操作\n\n由于执行更新时，name字段本来为varchar类型， 我们是作为数字类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；\n\n\n# 间隙锁危害\n\n当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 \"间隙（GAP）\" ， InnoDB也会对这个 \"间隙\" 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。\n\n示例 ：\n\nSESSION-1    SESSION-2\n关闭事务自动提交 !   关闭事务自动提交\n根据id范围更新数据   \n             插入id为2的记录， 出于阻塞状态!\n提交事务         \n             解除阻塞 ， 执行插入操作\n             提交事务\n\n\n# InnoDB 行锁争用情况\n\nshow  status like 'innodb_row_lock%';\n\n\n1\n\n\n\n\n * Innodb_row_lock_current_waits\n   \n   当前正在等待锁定的数量\n\n * Innodb_row_lock_time\n   \n   从系统启动到现在锁定总时间长度\n\n * Innodb_row_lock_time_avg\n   \n   每次等待所花平均时长\n\n * Innodb_row_lock_time_max\n   \n   从系统启动到现在等待最长的一次所花的时间\n\n * Innodb_row_lock_waits\n   \n   系统启动后到现在总共等待的次数\n\n当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。\n\n\n# 总结\n\nInnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。\n\n但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。\n\n优化建议：\n\n * 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。\n * 合理设计索引，尽量缩小锁的范围\n * 尽可能减少索引条件，及索引范围，避免间隙锁\n * 尽量控制事务大小，减少锁定资源量和时间长度\n * 尽可使用低级别事务隔离（但是需要业务层面满足需求）",normalizedContent:" * 简介\n * myisam 表锁\n   * 如何加表锁\n   * 读锁案例\n   * 写锁案例\n   * 结论\n   * 查看锁的争用情况\n * innodb 行锁\n   * 行锁介绍\n   * 背景知识\n   * innodb 的行锁模式\n   * 行锁基本演示\n   * 无索引行锁升级为表锁\n   * 间隙锁危害\n   * innodb 行锁争用情况\n   * 总结\n\n\n# 简介\n\n * 锁概述\n\n锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。\n\n在数据库中，除传统的计算资源（如 cpu、ram、i/o 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\n\n * 锁分类：\n\n从对数据操作的粒度分 ：\n\n1） 表锁：操作时，会锁定整个表。\n\n2） 行锁：操作时，会锁定当前操作行。\n\n从对数据操作的类型分：\n\n1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。\n\n2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。\n\n * mysql 锁\n\n相对其他数据库而言，mysql的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。\n\n下表中罗列出了各存储引擎对锁的支持情况：\n\n存储引擎     表级锁   行级锁   页面锁\nmyisam   支持    不支持   不支持\ninnodb   支持    支持    不支持\nmemory   支持    不支持   不支持\nbdb      支持    不支持   支持\n\nmysql这3种锁的特性可大致归纳如下 ：\n\n锁类型   特点\n表级锁   偏向myisam 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。\n行级锁   偏向innodb 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。\n页面锁   开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（oltp）系统。\n\n\n# myisam 表锁\n\nmyisam 存储引擎只支持表锁，这也是mysql开始几个版本中唯一支持的锁类型。\n\n\n# 如何加表锁\n\nmyisam 在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行更新操作（update、delete、insert 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 lock table 命令给 myisam 表显式加锁。\n\nlock table table_name read;\t--加读锁\n\nlock table table_name writ;\t--加写锁\n\n\n1\n2\n3\n\n\n\n# 读锁案例\n\n准备环境\n\ncreate database demo_03 default charset=utf8mb4;\n\nuse demo_03;\n\ncreate table `tb_book` (\n  `id` int(11) auto_increment,\n  `name` varchar(50) default null,\n  `publish_time` date default null,\n  `status` char(1) default null,\n  primary key (`id`)\n) engine=myisam default charset=utf8 ;\n\ninsert into tb_book (id, name, publish_time, status) values(null,'java编程思想','2088-08-01','1');\ninsert into tb_book (id, name, publish_time, status) values(null,'solr编程思想','2088-08-08','0');\n\n\n\ncreate table `tb_user` (\n  `id` int(11) auto_increment,\n  `name` varchar(50) default null,\n  primary key (`id`)\n) engine=myisam default charset=utf8 ;\n\ninsert into tb_user (id, name) values(null,'令狐冲');\ninsert into tb_user (id, name) values(null,'田伯光');\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n客户端 一 ：\n\n1）加 tb_book 表的读锁\n\nlock table tb_book read;\n\n\n1\n\n\n2） 执行查询操作\n\nselect * from tb_book;\n\n\n1\n\n\n\n\n可以正常执行 ， 查询出数据。\n\n客户端 二 ：\n\n3） 执行查询操作\n\nselect * from tb_book;\n\n\n1\n\n\n\n\n客户端 一 ：\n\n4）查询未锁定的表\n\nselect name from tb_seller;\n\n\n1\n\n\n\n\n客户端 二 ：\n\n5）查询未锁定的表\n\nselect name from tb_seller;\n\n\n1\n\n\n\n\n可以正常查询出未锁定的表；\n\n客户端 一 ：\n\n6） 执行插入操作\n\ninsert into tb_book values(null,'mysql高级','2088-01-01','1');\n\n\n1\n\n\n\n\n执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。\n\n客户端 二 ：\n\n7） 执行插入操作\n\ninsert into tb_book values(null,'mysql高级','2088-01-01','1');\n\n\n1\n\n\n\n\n当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；\n\n\n# 写锁案例\n\n客户端 一 :\n\n1）给 tb_book 表的写锁\n\nlock table tb_book write ;\n\n\n1\n\n\n2）执行查询操作\n\nselect * from tb_book ;\n\n\n1\n\n\n\n\n查询操作执行成功；\n\n3）执行更新操作\n\nupdate tb_book set name = 'java编程思想（第二版）' where id = 1;\n\n\n1\n\n\n\n\n更新操作执行成功 ；\n\n客户端 二 :\n\n4）执行查询操作\n\nselect * from tb_book ;\n\n\n1\n\n\n\n\n当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 select 语句 ， 立即执行 ；\n\n\n\n\n# 结论\n\n锁模式的相互兼容性如表中所示：\n\n\n\n由上表可见：\n\n1） 对myisam 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；\n\n2） 对myisam 表的写操作，会都阻塞其他用户对同一表的读和写操作；\n\n简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。\n\n此外，myisam 的读写锁调度是写优先，这也是myisam不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。\n\n\n# 查看锁的争用情况\n\nshow open tables；\n\n\n1\n\n\n\n\nin_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。\n\nname_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。\n\nshow status like 'table_locks%';\n\n\n1\n\n\n\n\ntable_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。\n\ntable_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。\n\n\n# innodb 行锁\n\n\n# 行锁介绍\n\n行锁特点 ：偏向innodb 存储引擎，开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。\n\ninnodb 与 myisam 的最大不同有两点：一是支持事务；二是采用了行级锁。\n\n\n# 背景知识\n\n事务及其acid属性\n\n事务是由一组sql语句组成的逻辑处理单元。\n\n事务具有以下4个特性，简称为事务acid属性。\n\nacid属性            含义\n原子性（atomicity）    事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。\n一致性（consistent）   在事务开始和完成时，数据都必须保持一致状态。\n隔离性（isolation）    数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。\n持久性（durable）      事务完成之后，对于数据的修改是永久的。\n\n并发事务处理带来的问题\n\n问题                            含义\n丢失更新（lost update）             当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。\n脏读（dirty reads）               当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。\n不可重复读（non-repeatable reads）   一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。\n幻读（phantom reads）             一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。\n\n事务隔离级别\n\n为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。\n\n数据库的隔离级别有4个，由低到高依次为 read uncommitted、read committed、repeatable read、serializable，这四个级别可以逐个解决 脏写、脏读、不可重复读、幻读 这几类问题。\n\n隔离级别                  丢失更新   脏读   不可重复读   幻读\nread uncommitted      ×      √    √       √\nread committed        ×      ×    √       √\nrepeatable read（默认）   ×      ×    ×       √\nserializable          ×      ×    ×       ×\n\n备注 ： √ 代表可能出现 ， × 代表不会出现 。\n\nmysql 的数据库的默认隔离级别为 repeatable read ， 查看方式：\n\nshow variables like 'tx_isolation';\n\n\n1\n\n\n\n\n\n# innodb 的行锁模式\n\ninnodb 实现了以下两种类型的行锁。\n\n * 共享锁（s）：又称为读锁，简称 s 锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n * 排他锁（x）：又称为写锁，简称 x 锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。\n\n对于 update、delete、insert 语句，innodb 会自动给涉及数据集加 排他锁（x)\n\n对于普通select语句，innodb不会加任何锁；\n\n可以通过以下语句显示给记录集加共享锁或排他锁 。\n\n-- 共享锁（s）\nselect * from table_name where ... lock in share mode\n-- 排他锁（x)\nselect * from table_name where ... for update\n\n\n1\n2\n3\n4\n\n\n\n# 行锁基本演示\n\n准备 sql\n\ncreate table test_innodb_lock(\n\tid int(11),\n\tname varchar(16),\n\tsex varchar(1)\n)engine = innodb default charset=utf8;\n\ninsert into test_innodb_lock values(1,'100','1');\ninsert into test_innodb_lock values(3,'3','1');\ninsert into test_innodb_lock values(4,'400','0');\ninsert into test_innodb_lock values(5,'500','1');\ninsert into test_innodb_lock values(6,'600','0');\ninsert into test_innodb_lock values(7,'700','0');\ninsert into test_innodb_lock values(8,'800','1');\ninsert into test_innodb_lock values(9,'900','1');\ninsert into test_innodb_lock values(1,'200','0');\n\ncreate index idx_test_innodb_lock_id on test_innodb_lock(id);\ncreate index idx_test_innodb_lock_name on test_innodb_lock(name);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n开启两个会话\n\nsession-1                        session-2\n关闭自动提交功能                         关闭自动提交功能\n可以正常的查询出全部的数据                    可以正常的查询出全部的数据\n查询id 为3的数据 ；                     获取id为3的数据 ；\n更新id为3的数据，但是不提交；                 更新id为3 的数据， 出于等待状态\n通过commit， 提交事务                   解除阻塞，更新正常进行\n以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：   \n更新id为3数据，正常的获取到行锁 ，执行更新          由于与 session-1 操作不是同一行，获取当前行锁，执行更新；\n\n\n# 无索引行锁升级为表锁\n\n如果不通过索引条件检索数据，那么innodb将对表中的所有记录加锁，实际效果跟表锁一样。\n\n --查看当前表的索引 ：\n show  index  from test_innodb_lock ;\n\n\n1\n2\n\n\n\n\nsession-1   session-2\n关闭事务的自动提交   关闭事务的自动提交\n执行更新语句      执行更新语句， 但处于阻塞状态\n提交事务        解除阻塞，执行更新成功\n            执行提交操作\n\n由于执行更新时，name字段本来为varchar类型， 我们是作为数字类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；\n\n\n# 间隙锁危害\n\n当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，innodb会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 \"间隙（gap）\" ， innodb也会对这个 \"间隙\" 加锁，这种锁机制就是所谓的 间隙锁（next-key锁） 。\n\n示例 ：\n\nsession-1    session-2\n关闭事务自动提交 !   关闭事务自动提交\n根据id范围更新数据   \n             插入id为2的记录， 出于阻塞状态!\n提交事务         \n             解除阻塞 ， 执行插入操作\n             提交事务\n\n\n# innodb 行锁争用情况\n\nshow  status like 'innodb_row_lock%';\n\n\n1\n\n\n\n\n * innodb_row_lock_current_waits\n   \n   当前正在等待锁定的数量\n\n * innodb_row_lock_time\n   \n   从系统启动到现在锁定总时间长度\n\n * innodb_row_lock_time_avg\n   \n   每次等待所花平均时长\n\n * innodb_row_lock_time_max\n   \n   从系统启动到现在等待最长的一次所花的时间\n\n * innodb_row_lock_waits\n   \n   系统启动后到现在总共等待的次数\n\n当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。\n\n\n# 总结\n\ninnodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于myisam的表锁的。当系统并发量较高的时候，innodb的整体性能和myisam相比就会有比较明显的优势。\n\n但是，innodb的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让innodb的整体性能表现不仅不能比myisam高，甚至可能会更差。\n\n优化建议：\n\n * 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。\n * 合理设计索引，尽量缩小锁的范围\n * 尽可能减少索引条件，及索引范围，避免间隙锁\n * 尽量控制事务大小，减少锁定资源量和时间长度\n * 尽可使用低级别事务隔离（但是需要业务层面满足需求）",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 常用工具",frontmatter:{title:"MySQL - 常用工具",permalink:"/mysql/common-tools/",date:"2021-05-25T16:23:45.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/26.MySQL%20-%20%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7.html",relativePath:"03.数据库/05.MySQL/26.MySQL - 常用工具.md",key:"v-2a0bf03b",path:"/mysql/common-tools/",headers:[{level:2,title:"mysql",slug:"mysql",normalizedTitle:"mysql",charIndex:3},{level:2,title:"mysqladmin",slug:"mysqladmin",normalizedTitle:"mysqladmin",charIndex:12},{level:2,title:"mysqlbinlog",slug:"mysqlbinlog",normalizedTitle:"mysqlbinlog",charIndex:26},{level:2,title:"mysqldump",slug:"mysqldump",normalizedTitle:"mysqldump",charIndex:41},{level:2,title:"mysqlimport和source",slug:"mysqlimport和source",normalizedTitle:"mysqlimport和source",charIndex:54},{level:2,title:"mysqlshow",slug:"mysqlshow",normalizedTitle:"mysqlshow",charIndex:76}],headersStr:"mysql mysqladmin mysqlbinlog mysqldump mysqlimport和source mysqlshow",content:" * mysql\n * mysqladmin\n * mysqlbinlog\n * mysqldump\n * mysqlimport和source\n * mysqlshow\n\n\n# mysql\n\n该mysql不是指mysql服务，而是指mysql的客户端工具。\n\n语法 ：\n\nmysql [options] [database]\n\n\n1\n\n\n连接选项：\n\n参数                   说明\n-u, --user=txt       指定用户名\n-p, --password=txt   指定密码\n-h, --host=txt       指定服务器IP或域名\n-p, --port=#         指定连接端口\n\n示例 ：\n\nmysql -h 127.0.0.1 -P 3306 -u root -p\n\t\nmysql -h127.0.0.1 -P3306 -uroot -p2143\t-- 可不加空格\n\n\n1\n2\n3\n\n\n执行选项\n\n参数                   说明\n-e, --execute=name   执行SQL语句并退出\n\n此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。\n\n示例：\n\nmysql -uroot -p2143 db01 -e \"select * from tb_book\";\n\n\n1\n\n\n\n\n\n# mysqladmin\n\nmysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。\n\n查看帮助文档指令\n\nmysqladmin --help\n\n\n1\n\n\n\n\n示例 ：\n\nmysqladmin -uroot -p2143 create 'test01';  \nmysqladmin -uroot -p2143 drop 'test01';\nmysqladmin -uroot -p2143 version;\n\n\n1\n2\n3\n\n\n\n# mysqlbinlog\n\n由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。\n\n语法 ：\n\nmysqlbinlog [options]  log-files1 log-files2 ...\n\n\n1\n\n\n参数选项                                           说明\n-d, --database=name                            指定数据库名称，只列出指定的数据库相关操作。\n-o, --offset=#                                 忽略掉日志中的前n行命令。\n-r,--result-file=name                          将输出的文本格式日志输出到指定文件。\n-s, --short-form                               显示简单格式， 省略掉一些信息。\n--start-datatime=date1 --stop-datetime=date2   指定日期间隔内的所有日志。\n--start-position=pos1 --stop-position=pos2     指定位置间隔内的所有日志。\n\n\n# mysqldump\n\nmysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。\n\n语法 ：\n\nmysqldump [options] db_name [tables]\n\nmysqldump [options] --database/-B db1 [db2 db3...]\n\nmysqldump [options] --all-databases/-A\n\n\n1\n2\n3\n4\n5\n\n\n连接选项\n\n参数                      说明\n-u, --user=name         指定用户名\n-p, --password[=name]   指定密码\n-h, --host=name         指定服务器IP或域名\n-P, --port=#            指定连接端口\n\n\n\n输出内容选项\n\n参数                     说明\n--add-drop-database    在每个数据库创建语句前加上 Drop database 语句\n--add-drop-table       在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启\n                       (--skip-add-drop-table)\n-n, --no-create-db     不包含数据库的创建语句\n-t, --no-create-info   不包含数据表的创建语句\n-d --no-data           不包含数据\n-T, --tab=name         自动生成两个文件：\n                       一个.sql文件，创建表结构的语句；\n                       一个.txt文件，数据文件，相当于 select into outfile ；\n\n示例 ：\n\nmysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table > a\n\t\nmysqldump -uroot -p2143 -T /tmp test city\n\n\n1\n2\n3\n\n\n\n# mysqlimport和source\n\nmysqlimport 是客户端数据导入工具，用来导入 mysqldump 加 -T 参数后导出的文本文件。\n\n也就是表的数据内容（txt内容）\n\n语法：\n\nmysqlimport [options]  db_name  textfile1  [textfile2...]\n\n\n1\n\n\n示例：\n\nmysqlimport -uroot -p2143 test /tmp/city.txt\n\n\n1\n\n\n如果需要导入sql文件,可以使用mysql中的source 指令 :\n\nsource /root/tb_book.sql\n\n\n1\n\n\n\n# mysqlshow\n\nmysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。\n\n语法：\n\nmysqlshow [options] [db_name [table_name [col_name]]]\n\n\n1\n\n\n参数：\n\n参数        说明\n--count   显示数据库及表的统计信息（数据库，表 均可以不指定）\n-i        显示指定数据库或者指定表的状态信息\n\n示例：\n\n#查询每个数据库的表的数量及表中记录的数量\nmysqlshow -uroot -p2143 --count\n\n#查询test库中每个表中的字段书，及行数\nmysqlshow -uroot -p2143 test --count\n\n#查询test库中book表的详细情况\nmysqlshow -uroot -p2143 test book --count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:" * mysql\n * mysqladmin\n * mysqlbinlog\n * mysqldump\n * mysqlimport和source\n * mysqlshow\n\n\n# mysql\n\n该mysql不是指mysql服务，而是指mysql的客户端工具。\n\n语法 ：\n\nmysql [options] [database]\n\n\n1\n\n\n连接选项：\n\n参数                   说明\n-u, --user=txt       指定用户名\n-p, --password=txt   指定密码\n-h, --host=txt       指定服务器ip或域名\n-p, --port=#         指定连接端口\n\n示例 ：\n\nmysql -h 127.0.0.1 -p 3306 -u root -p\n\t\nmysql -h127.0.0.1 -p3306 -uroot -p2143\t-- 可不加空格\n\n\n1\n2\n3\n\n\n执行选项\n\n参数                   说明\n-e, --execute=name   执行sql语句并退出\n\n此选项可以在mysql客户端执行sql语句，而不用连接到mysql数据库再执行，对于一些批处理脚本，这种方式尤其方便。\n\n示例：\n\nmysql -uroot -p2143 db01 -e \"select * from tb_book\";\n\n\n1\n\n\n\n\n\n# mysqladmin\n\nmysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。\n\n查看帮助文档指令\n\nmysqladmin --help\n\n\n1\n\n\n\n\n示例 ：\n\nmysqladmin -uroot -p2143 create 'test01';  \nmysqladmin -uroot -p2143 drop 'test01';\nmysqladmin -uroot -p2143 version;\n\n\n1\n2\n3\n\n\n\n# mysqlbinlog\n\n由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。\n\n语法 ：\n\nmysqlbinlog [options]  log-files1 log-files2 ...\n\n\n1\n\n\n参数选项                                           说明\n-d, --database=name                            指定数据库名称，只列出指定的数据库相关操作。\n-o, --offset=#                                 忽略掉日志中的前n行命令。\n-r,--result-file=name                          将输出的文本格式日志输出到指定文件。\n-s, --short-form                               显示简单格式， 省略掉一些信息。\n--start-datatime=date1 --stop-datetime=date2   指定日期间隔内的所有日志。\n--start-position=pos1 --stop-position=pos2     指定位置间隔内的所有日志。\n\n\n# mysqldump\n\nmysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的sql语句。\n\n语法 ：\n\nmysqldump [options] db_name [tables]\n\nmysqldump [options] --database/-b db1 [db2 db3...]\n\nmysqldump [options] --all-databases/-a\n\n\n1\n2\n3\n4\n5\n\n\n连接选项\n\n参数                      说明\n-u, --user=name         指定用户名\n-p, --password[=name]   指定密码\n-h, --host=name         指定服务器ip或域名\n-p, --port=#            指定连接端口\n\n\n\n输出内容选项\n\n参数                     说明\n--add-drop-database    在每个数据库创建语句前加上 drop database 语句\n--add-drop-table       在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启\n                       (--skip-add-drop-table)\n-n, --no-create-db     不包含数据库的创建语句\n-t, --no-create-info   不包含数据表的创建语句\n-d --no-data           不包含数据\n-t, --tab=name         自动生成两个文件：\n                       一个.sql文件，创建表结构的语句；\n                       一个.txt文件，数据文件，相当于 select into outfile ；\n\n示例 ：\n\nmysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table > a\n\t\nmysqldump -uroot -p2143 -t /tmp test city\n\n\n1\n2\n3\n\n\n\n# mysqlimport和source\n\nmysqlimport 是客户端数据导入工具，用来导入 mysqldump 加 -t 参数后导出的文本文件。\n\n也就是表的数据内容（txt内容）\n\n语法：\n\nmysqlimport [options]  db_name  textfile1  [textfile2...]\n\n\n1\n\n\n示例：\n\nmysqlimport -uroot -p2143 test /tmp/city.txt\n\n\n1\n\n\n如果需要导入sql文件,可以使用mysql中的source 指令 :\n\nsource /root/tb_book.sql\n\n\n1\n\n\n\n# mysqlshow\n\nmysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。\n\n语法：\n\nmysqlshow [options] [db_name [table_name [col_name]]]\n\n\n1\n\n\n参数：\n\n参数        说明\n--count   显示数据库及表的统计信息（数据库，表 均可以不指定）\n-i        显示指定数据库或者指定表的状态信息\n\n示例：\n\n#查询每个数据库的表的数量及表中记录的数量\nmysqlshow -uroot -p2143 --count\n\n#查询test库中每个表中的字段书，及行数\nmysqlshow -uroot -p2143 test --count\n\n#查询test库中book表的详细情况\nmysqlshow -uroot -p2143 test book --count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 日志",frontmatter:{title:"MySQL - 日志",permalink:"/mysql/log/",date:"2021-05-25T16:50:59.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/28.MySQL%20-%20%E6%97%A5%E5%BF%97.html",relativePath:"03.数据库/05.MySQL/28.MySQL - 日志.md",key:"v-0deb7e9f",path:"/mysql/log/",headers:[{level:2,title:"错误日志",slug:"错误日志",normalizedTitle:"错误日志",charIndex:3},{level:2,title:"二进制日志",slug:"二进制日志",normalizedTitle:"二进制日志",charIndex:11},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:22},{level:3,title:"日志格式",slug:"日志格式",normalizedTitle:"日志格式",charIndex:30},{level:3,title:"日志读取",slug:"日志读取",normalizedTitle:"日志读取",charIndex:40},{level:3,title:"日志删除",slug:"日志删除",normalizedTitle:"日志删除",charIndex:50},{level:2,title:"查询日志",slug:"查询日志",normalizedTitle:"查询日志",charIndex:58},{level:2,title:"慢查询日志",slug:"慢查询日志",normalizedTitle:"慢查询日志",charIndex:66},{level:3,title:"文件位置和格式",slug:"文件位置和格式",normalizedTitle:"文件位置和格式",charIndex:77},{level:3,title:"日志的读取",slug:"日志的读取",normalizedTitle:"日志的读取",charIndex:90}],headersStr:"错误日志 二进制日志 概述 日志格式 日志读取 日志删除 查询日志 慢查询日志 文件位置和格式 日志的读取",content:" * 错误日志\n * 二进制日志\n   * 概述\n   * 日志格式\n   * 日志读取\n   * 日志删除\n * 查询日志\n * 慢查询日志\n   * 文件位置和格式\n   * 日志的读取\n\n\n# 错误日志\n\n错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。\n\n该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录：var/lib/mysql\n\n默认的日志文件名为 hostname.err（hostname是主机名）。\n\n查看日志位置指令 ：\n\nshow variables like 'log_error%';\n\n\n1\n\n\n\n\n查看日志内容 ：\n\ntail -f /var/lib/mysql/xaxh-server.err\n\n\n1\n\n\n\n\n\n# 二进制日志\n\n\n# 概述\n\n二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该 binlog 实现的。\n\n二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。\n\n配置文件位置 : /usr/my.cnf\n\n日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。\n\n#配置开启 binlog 日志，\n#日志的文件前缀为 mysqlbin\n#生成的文件名如 : mysqlbin.000001，mysqlbin.000002\nlog_bin=mysqlbin\n\n#配置二进制日志的格式\nbinlog_format=STATEMENT\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 日志格式\n\nSTATEMENT\n\n该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的 SQL 都会记录在日志文件中，通过 Mysql 提供的 mysqlbinlog 工具，可以清晰的查看到每条语句的文本。\n\n主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。\n\nROW\n\n该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。\n\n比如，执行SQL语句 ： update tb_book set status='1'\n\n如果是 STATEMENT 日志格式，在日志中会记录一行SQL文件；\n\n如果是 ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。\n\nMIXED\n\n这是目前MySQL默认的日志格式，即混合了 STATEMENT 和 ROW 两种格式。\n\n默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。\n\nMIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。\n\n\n# 日志读取\n\n由于日志以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下 ：\n\nmysqlbinlog log-file；\n\n\n1\n\n\n查看STATEMENT格式日志\n\n执行插入语句 ：\n\ninsert into tb_book values(null,'Lucene','2088-05-01','0');\n\n\n1\n\n\n查看日志文件 ：\n\n\n\nmysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；\n\nmysqlbing.000001 ：日志文件\n\n查看日志内容 ：\n\nmysqlbinlog mysqlbing.000001；\n\n\n1\n\n\n\n\n查看ROW格式日志\n\n配置 :\n\n#配置开启 binlog 日志， \n#日志的文件前缀为 mysqlbin\n#生成的文件名如 : mysqlbin.000001，mysqlbin.000002\nlog_bin=mysqlbin\n\n#配置二进制日志的格式\nbinlog_format=ROW\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n插入数据 :\n\ninsert into tb_book values(null,'SpringCloud实战','2088-05-05','0');\n\n\n1\n\n\n如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在 mysqlbinlog 后面加上参数 -vv\n\nmysqlbinlog -vv mysqlbin.000002 \n\n\n1\n\n\n\n\n\n# 日志删除\n\n对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：\n\n * 方式一\n\n通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。\n\n查询之前 ，先查询下日志文件 ：\n\n\n\n执行删除日志指令：\n\nReset Master\n\n\n1\n\n\n执行之后， 查看日志文件 ：\n\n\n\n * 方式二\n\n执行指令 purge master logs to 'mysqlbin.******' ，该命令将删除 ****** 编号之前的所有日志。\n\n * 方式三\n\n执行指令： purge master logs before 'yyyy-mm-dd hh24:mi:ss'\n\n该命令将删除日志为 \"yyyy-mm-dd hh24:mi:ss\" 之前产生的所有日志 。\n\n * 方式四\n\n设置参数 --expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。\n\n配置如下 ：\n\n\n\n\n# 查询日志\n\n查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。\n\n默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：\n\n#该选项用来开启查询日志\n#可选值：0 或者 1 ；0 代表关闭， 1 代表开启 \ngeneral_log=1\n\n#设置日志的文件名，如果没有指定，默认的文件名为 host_name.log \ngeneral_log_file=file_name\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 mysql 的配置文件 /usr/my.cnf 中配置如下内容 ：\n\n\n\n配置完毕之后，在数据库执行以下操作 ：\n\nselect * from tb_book;\nselect * from tb_book where id = 1;\nupdate tb_book set name = 'lucene入门指南' where id = 5;\nselect * from tb_book where id < 8;\n\n\n1\n2\n3\n4\n\n\n执行完毕之后， 再次来查询日志文件 ：\n\n\n\n\n# 慢查询日志\n\n慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。\n\nlong_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。\n\n\n# 文件位置和格式\n\n慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：\n\n# 该参数用来控制慢查询日志是否开启\n#可取值： 1 和 0 ， 1 代表开启， 0 代表关闭\nslow_query_log=1 \n\n# 该参数用来指定慢查询日志的文件名\nslow_query_log_file=slow_query.log\n\n# 该选项用来配置查询的时间限制\n#超过这个时间将认为值慢查询，将需要进行日志记录\n#默认10s\nlong_query_time=10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 日志的读取\n\n和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。\n\n1） 查询 long_query_time 的值。\n\n\n\n2） 执行查询操作\n\nselect id, title,price,num ,status from tb_item where id = 1;\n\n\n1\n\n\n\n\n由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。\n\nselect * from tb_item where title like '%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%' ;\n\n\n1\n\n\n\n\n该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。\n\n3） 查看慢查询日志文件\n\n直接通过cat 指令查询该日志文件 ：\n\n\n\n如果慢查询日志内容很多， 直接查看文件，比较麻烦\n\n这个时候可以借助于 mysql 自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。\n\n",normalizedContent:" * 错误日志\n * 二进制日志\n   * 概述\n   * 日志格式\n   * 日志读取\n   * 日志删除\n * 查询日志\n * 慢查询日志\n   * 文件位置和格式\n   * 日志的读取\n\n\n# 错误日志\n\n错误日志是 mysql 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。\n\n该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录：var/lib/mysql\n\n默认的日志文件名为 hostname.err（hostname是主机名）。\n\n查看日志位置指令 ：\n\nshow variables like 'log_error%';\n\n\n1\n\n\n\n\n查看日志内容 ：\n\ntail -f /var/lib/mysql/xaxh-server.err\n\n\n1\n\n\n\n\n\n# 二进制日志\n\n\n# 概述\n\n二进制日志（binlog）记录了所有的 ddl（数据定义语言）语句和 dml（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，mysql的主从复制， 就是通过该 binlog 实现的。\n\n二进制日志，默认情况下是没有开启的，需要到mysql的配置文件中开启，并配置mysql日志的格式。\n\n配置文件位置 : /usr/my.cnf\n\n日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入mysql的数据目录。\n\n#配置开启 binlog 日志，\n#日志的文件前缀为 mysqlbin\n#生成的文件名如 : mysqlbin.000001，mysqlbin.000002\nlog_bin=mysqlbin\n\n#配置二进制日志的格式\nbinlog_format=statement\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 日志格式\n\nstatement\n\n该日志格式在日志文件中记录的都是sql语句（statement），每一条对数据进行修改的 sql 都会记录在日志文件中，通过 mysql 提供的 mysqlbinlog 工具，可以清晰的查看到每条语句的文本。\n\n主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。\n\nrow\n\n该日志格式在日志文件中记录的是每一行的数据变更，而不是记录sql语句。\n\n比如，执行sql语句 ： update tb_book set status='1'\n\n如果是 statement 日志格式，在日志中会记录一行sql文件；\n\n如果是 row，由于是对全表进行更新，也就是每一行记录都会发生变更，row 格式的日志中会记录每一行的数据变更。\n\nmixed\n\n这是目前mysql默认的日志格式，即混合了 statement 和 row 两种格式。\n\n默认情况下采用statement，但是在一些特殊情况下采用row来进行记录。\n\nmixed 格式能尽量利用两种模式的优点，而避开他们的缺点。\n\n\n# 日志读取\n\n由于日志以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下 ：\n\nmysqlbinlog log-file；\n\n\n1\n\n\n查看statement格式日志\n\n执行插入语句 ：\n\ninsert into tb_book values(null,'lucene','2088-05-01','0');\n\n\n1\n\n\n查看日志文件 ：\n\n\n\nmysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；\n\nmysqlbing.000001 ：日志文件\n\n查看日志内容 ：\n\nmysqlbinlog mysqlbing.000001；\n\n\n1\n\n\n\n\n查看row格式日志\n\n配置 :\n\n#配置开启 binlog 日志， \n#日志的文件前缀为 mysqlbin\n#生成的文件名如 : mysqlbin.000001，mysqlbin.000002\nlog_bin=mysqlbin\n\n#配置二进制日志的格式\nbinlog_format=row\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n插入数据 :\n\ninsert into tb_book values(null,'springcloud实战','2088-05-05','0');\n\n\n1\n\n\n如果日志格式是 row , 直接查看数据 , 是查看不懂的 ; 可以在 mysqlbinlog 后面加上参数 -vv\n\nmysqlbinlog -vv mysqlbin.000002 \n\n\n1\n\n\n\n\n\n# 日志删除\n\n对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：\n\n * 方式一\n\n通过 reset master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。\n\n查询之前 ，先查询下日志文件 ：\n\n\n\n执行删除日志指令：\n\nreset master\n\n\n1\n\n\n执行之后， 查看日志文件 ：\n\n\n\n * 方式二\n\n执行指令 purge master logs to 'mysqlbin.******' ，该命令将删除 ****** 编号之前的所有日志。\n\n * 方式三\n\n执行指令： purge master logs before 'yyyy-mm-dd hh24:mi:ss'\n\n该命令将删除日志为 \"yyyy-mm-dd hh24:mi:ss\" 之前产生的所有日志 。\n\n * 方式四\n\n设置参数 --expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少dba 管理日志的工作量。\n\n配置如下 ：\n\n\n\n\n# 查询日志\n\n查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的sql语句。\n\n默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：\n\n#该选项用来开启查询日志\n#可选值：0 或者 1 ；0 代表关闭， 1 代表开启 \ngeneral_log=1\n\n#设置日志的文件名，如果没有指定，默认的文件名为 host_name.log \ngeneral_log_file=file_name\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 mysql 的配置文件 /usr/my.cnf 中配置如下内容 ：\n\n\n\n配置完毕之后，在数据库执行以下操作 ：\n\nselect * from tb_book;\nselect * from tb_book where id = 1;\nupdate tb_book set name = 'lucene入门指南' where id = 5;\nselect * from tb_book where id < 8;\n\n\n1\n2\n3\n4\n\n\n执行完毕之后， 再次来查询日志文件 ：\n\n\n\n\n# 慢查询日志\n\n慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的sql语句的日志。\n\nlong_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。\n\n\n# 文件位置和格式\n\n慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：\n\n# 该参数用来控制慢查询日志是否开启\n#可取值： 1 和 0 ， 1 代表开启， 0 代表关闭\nslow_query_log=1 \n\n# 该参数用来指定慢查询日志的文件名\nslow_query_log_file=slow_query.log\n\n# 该选项用来配置查询的时间限制\n#超过这个时间将认为值慢查询，将需要进行日志记录\n#默认10s\nlong_query_time=10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 日志的读取\n\n和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。\n\n1） 查询 long_query_time 的值。\n\n\n\n2） 执行查询操作\n\nselect id, title,price,num ,status from tb_item where id = 1;\n\n\n1\n\n\n\n\n由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。\n\nselect * from tb_item where title like '%阿尔卡特 (ot-927) 炭黑 联通3g手机 双卡双待165454%' ;\n\n\n1\n\n\n\n\n该sql语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。\n\n3） 查看慢查询日志文件\n\n直接通过cat 指令查询该日志文件 ：\n\n\n\n如果慢查询日志内容很多， 直接查看文件，比较麻烦\n\n这个时候可以借助于 mysql 自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MySQL - 主从复制",frontmatter:{title:"MySQL - 主从复制",permalink:"/mysql/copy/",date:"2021-05-25T19:01:15.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/05.MySQL/30.MySQL%20-%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html",relativePath:"03.数据库/05.MySQL/30.MySQL - 主从复制.md",key:"v-615e5fce",path:"/mysql/copy/",headers:[{level:2,title:"复制概述",slug:"复制概述",normalizedTitle:"复制概述",charIndex:3},{level:2,title:"复制原理",slug:"复制原理",normalizedTitle:"复制原理",charIndex:11},{level:2,title:"复制优势",slug:"复制优势",normalizedTitle:"复制优势",charIndex:19},{level:2,title:"搭建步骤",slug:"搭建步骤",normalizedTitle:"搭建步骤",charIndex:27},{level:3,title:"master",slug:"master",normalizedTitle:"master",charIndex:37},{level:3,title:"slave",slug:"slave",normalizedTitle:"slave",charIndex:49},{level:3,title:"验证同步操作",slug:"验证同步操作",normalizedTitle:"验证同步操作",charIndex:60}],headersStr:"复制概述 复制原理 复制优势 搭建步骤 master slave 验证同步操作",content:" * 复制概述\n * 复制原理\n * 复制优势\n * 搭建步骤\n   * master\n   * slave\n   * 验证同步操作\n\n\n# 复制概述\n\n复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。\n\nMySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。\n\n\n# 复制原理\n\nMySQL 的主从复制原理如下。\n\n\n\n从上层来看，复制分成三步：\n\n * Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。\n\n * 主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。\n\n * slave 重做中继日志中的事件，将改变反映它自己的数据。\n\n\n# 复制优势\n\nMySQL 复制的有点主要包含以下三个方面：\n\n * 主库出现问题，可以快速切换到从库提供服务。\n\n * 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。\n\n * 可以在从库中执行备份，以避免备份期间影响主库的服务。\n\n\n# 搭建步骤\n\n\n# master\n\n1） 在master 的配置文件（/usr/my.cnf）中，配置如下内容：\n\n#mysql 服务ID,保证整个集群环境中唯一\nserver-id=1\n\n#mysql binlog 日志的存储路径和文件名\nlog-bin=/var/lib/mysql/mysqlbin\n\n#错误日志,默认已经开启\n#log-err\n\n#mysql的安装目录\n#basedir\n\n#mysql的临时目录\n#tmpdir\n\n#mysql的数据存放目录\n#datadir\n\n#是否只读,1 代表只读, 0 代表读写\nread-only=0\n\n#忽略的数据, 指不需要同步的数据库\nbinlog-ignore-db=mysql\n\n#指定同步的数据库\n#binlog-do-db=db01\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n2） 执行完毕之后，需要重启Mysql：\n\nservice mysql restart\n#有的是这个\nservice mysqld restart\n\n\n1\n2\n3\n\n\n3） 创建同步数据的账户，并且进行授权操作：\n\ngrant replication slave on *.* to 'itcast'@'192.168.192.131' identified by 'itcast';\t\n\nflush privileges;\n\n\n1\n2\n3\n\n\n4） 查看master状态：\n\nshow master status;\n\n\n1\n\n\n\n\n字段                 含义\nFile               从哪个日志文件开始推送日志文件\nPosition           从哪个位置开始推送日志\nBinlog_Ignore_DB   指定不需要同步的数据库\n\n\n# slave\n\n1） 在 slave 端配置文件中，配置如下内容：\n\n#mysql服务端ID,唯一\nserver-id=2\n\n#指定binlog日志\nlog-bin=/var/lib/mysql/mysqlbin\n\n\n1\n2\n3\n4\n5\n\n\n2） 执行完毕之后，需要重启Mysql：\n\nservice mysql restart；\n\n\n1\n\n\n3） 执行如下指令 ：\n\nchange master to master_host= '192.168.192.130', master_user='itcast', master_password='itcast', master_log_file='mysqlbin.000001', master_log_pos=413;\n\n\n1\n\n\n指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。\n\n4） 开启同步操作\n\nstart slave;\n\nshow slave status;\n\n\n1\n2\n3\n\n\n\n\n5） 停止同步操作\n\nstop slave;\n\n\n1\n\n\n\n# 验证同步操作\n\n1） 在主库中创建数据库，创建表，并插入数据 ：\n\ncreate database db01;\n\nuser db01;\n\ncreate table user(\n\tid int(11) not null auto_increment,\n\tname varchar(50) not null,\n\tsex varchar(1),\n\tprimary key (id)\n)engine=innodb default charset=utf8;\n\ninsert into user(id,name,sex) values(null,'Tom','1');\ninsert into user(id,name,sex) values(null,'Trigger','0');\ninsert into user(id,name,sex) values(null,'Dawn','1');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n2） 在从库中查询数据，进行验证 ：\n\n在从库中，可以查看到刚才创建的数据库：\n\n\n\n在该数据库中，查询user表中的数据：\n\n",normalizedContent:" * 复制概述\n * 复制原理\n * 复制优势\n * 搭建步骤\n   * master\n   * slave\n   * 验证同步操作\n\n\n# 复制概述\n\n复制是指将主数据库的ddl 和 dml 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。\n\nmysql支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。\n\n\n# 复制原理\n\nmysql 的主从复制原理如下。\n\n\n\n从上层来看，复制分成三步：\n\n * master 主库在事务提交时，会把数据变更作为时间 events 记录在二进制日志文件 binlog 中。\n\n * 主库推送二进制日志文件 binlog 中的日志事件到从库的中继日志 relay log 。\n\n * slave 重做中继日志中的事件，将改变反映它自己的数据。\n\n\n# 复制优势\n\nmysql 复制的有点主要包含以下三个方面：\n\n * 主库出现问题，可以快速切换到从库提供服务。\n\n * 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。\n\n * 可以在从库中执行备份，以避免备份期间影响主库的服务。\n\n\n# 搭建步骤\n\n\n# master\n\n1） 在master 的配置文件（/usr/my.cnf）中，配置如下内容：\n\n#mysql 服务id,保证整个集群环境中唯一\nserver-id=1\n\n#mysql binlog 日志的存储路径和文件名\nlog-bin=/var/lib/mysql/mysqlbin\n\n#错误日志,默认已经开启\n#log-err\n\n#mysql的安装目录\n#basedir\n\n#mysql的临时目录\n#tmpdir\n\n#mysql的数据存放目录\n#datadir\n\n#是否只读,1 代表只读, 0 代表读写\nread-only=0\n\n#忽略的数据, 指不需要同步的数据库\nbinlog-ignore-db=mysql\n\n#指定同步的数据库\n#binlog-do-db=db01\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n2） 执行完毕之后，需要重启mysql：\n\nservice mysql restart\n#有的是这个\nservice mysqld restart\n\n\n1\n2\n3\n\n\n3） 创建同步数据的账户，并且进行授权操作：\n\ngrant replication slave on *.* to 'itcast'@'192.168.192.131' identified by 'itcast';\t\n\nflush privileges;\n\n\n1\n2\n3\n\n\n4） 查看master状态：\n\nshow master status;\n\n\n1\n\n\n\n\n字段                 含义\nfile               从哪个日志文件开始推送日志文件\nposition           从哪个位置开始推送日志\nbinlog_ignore_db   指定不需要同步的数据库\n\n\n# slave\n\n1） 在 slave 端配置文件中，配置如下内容：\n\n#mysql服务端id,唯一\nserver-id=2\n\n#指定binlog日志\nlog-bin=/var/lib/mysql/mysqlbin\n\n\n1\n2\n3\n4\n5\n\n\n2） 执行完毕之后，需要重启mysql：\n\nservice mysql restart；\n\n\n1\n\n\n3） 执行如下指令 ：\n\nchange master to master_host= '192.168.192.130', master_user='itcast', master_password='itcast', master_log_file='mysqlbin.000001', master_log_pos=413;\n\n\n1\n\n\n指定当前从库对应的主库的ip地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。\n\n4） 开启同步操作\n\nstart slave;\n\nshow slave status;\n\n\n1\n2\n3\n\n\n\n\n5） 停止同步操作\n\nstop slave;\n\n\n1\n\n\n\n# 验证同步操作\n\n1） 在主库中创建数据库，创建表，并插入数据 ：\n\ncreate database db01;\n\nuser db01;\n\ncreate table user(\n\tid int(11) not null auto_increment,\n\tname varchar(50) not null,\n\tsex varchar(1),\n\tprimary key (id)\n)engine=innodb default charset=utf8;\n\ninsert into user(id,name,sex) values(null,'tom','1');\ninsert into user(id,name,sex) values(null,'trigger','0');\ninsert into user(id,name,sex) values(null,'dawn','1');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n2） 在从库中查询数据，进行验证 ：\n\n在从库中，可以查看到刚才创建的数据库：\n\n\n\n在该数据库中，查询user表中的数据：\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Redis - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.数据库/10.Redis/01.Redis学习笔记",imgUrl:"/img/web.png",description:"Redis - 知识体系"}},title:"Redis - 知识体系",permalink:"/redis",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2021-08-03T22:08:32.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/00.Redis%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"03.数据库/10.Redis/00.Redis知识体系.md",key:"v-4c80214c",path:"/redis/",headers:[{level:2,title:"视频教程",slug:"视频教程",normalizedTitle:"视频教程",charIndex:2},{level:2,title:"学习资料",slug:"学习资料",normalizedTitle:"学习资料",charIndex:69}],headersStr:"视频教程 学习资料",content:"# 视频教程\n\n * 狂神\n   \n   https://www.bilibili.com/video/BV1S54y1R7SB\n\n\n# 学习资料\n\n * Redis官网:http://redis.io/\n\n * Redis官方文档:http://redis.io/documentation\n\n * Redis教程:http://www.w3cschool.cn/redis/redis-intro.html\n\n * Redis下载:http://redis.io/download\n\n * redis英文文档 https://redis.io/topics/data-types\n\n * redis中文文档 http://www.redis.cn/documentation.html\n\n * 《redis设计与实现 3.0版本》 http://redisbook.com/index.html\n\n * redis菜鸟教程 https://www.runoob.com/redis/redis-tutorial.html\n\n * redis源码解读 3.2.8版本 https://blog.csdn.net/men_wen/article/details/75668345\n\n * ♥Redis教程 - Redis知识体系详解♥\n   \n   https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html",normalizedContent:"# 视频教程\n\n * 狂神\n   \n   https://www.bilibili.com/video/bv1s54y1r7sb\n\n\n# 学习资料\n\n * redis官网:http://redis.io/\n\n * redis官方文档:http://redis.io/documentation\n\n * redis教程:http://www.w3cschool.cn/redis/redis-intro.html\n\n * redis下载:http://redis.io/download\n\n * redis英文文档 https://redis.io/topics/data-types\n\n * redis中文文档 http://www.redis.cn/documentation.html\n\n * 《redis设计与实现 3.0版本》 http://redisbook.com/index.html\n\n * redis菜鸟教程 https://www.runoob.com/redis/redis-tutorial.html\n\n * redis源码解读 3.2.8版本 https://blog.csdn.net/men_wen/article/details/75668345\n\n * ♥redis教程 - redis知识体系详解♥\n   \n   https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html",charsets:{cjk:!0},lastUpdated:"2021/09/11, 2:09:00",lastUpdatedTimestamp:1631327124e3},{title:"Redis - 五大数据类型",frontmatter:{title:"Redis - 五大数据类型",date:"2021-05-17T16:11:13.000Z",permalink:"/pages/6ea36e/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/02.%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"03.数据库/10.Redis/02.五大数据类型.md",key:"v-2fc63d9e",path:"/pages/6ea36e/",headers:[{level:2,title:"五大数据类型",slug:"五大数据类型",normalizedTitle:"五大数据类型",charIndex:2},{level:3,title:"Redis键（key）",slug:"redis键-key",normalizedTitle:"redis键（key）",charIndex:1066},{level:3,title:"字符串String",slug:"字符串string",normalizedTitle:"字符串string",charIndex:2548},{level:3,title:"列表List",slug:"列表list",normalizedTitle:"列表list",charIndex:5329},{level:3,title:"集合Set",slug:"集合set",normalizedTitle:"集合set",charIndex:8622},{level:3,title:"哈希Hash",slug:"哈希hash",normalizedTitle:"哈希hash",charIndex:11041},{level:3,title:"有序集合Zset",slug:"有序集合zset",normalizedTitle:"有序集合zset",charIndex:12784}],headersStr:"五大数据类型 Redis键（key） 字符串String 列表List 集合Set 哈希Hash 有序集合Zset",content:'# 五大数据类型\n\n官方文档：\n\n\n\n全段翻译：\n\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\n\n * String （字符串类型）\n   \n   String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。\n   \n   String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。\n   \n   String类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。\n\n * Hash（哈希，类似 Java里的Map）\n   \n   Redis hash 是一个键值对集合。\n   \n   Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。\n   \n   类似Java里面的Map\n\n * List（列表）\n   \n   Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个链表 !\n\n * Set（集合）\n   \n   Redis的Set是String类型的无序集合，它是通过HashTable实现的 !\n\n * Zset（sorted set：有序集合）\n   \n   Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。\n   \n   不同的是每个元素都会关联一个double类型的分数。\n   \n   Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score） 却可以重复。\n\n\n# Redis键（key）\n\n字母大写小写都一样\n\n * keys *\n   \n   查看所有的key\n   \n   127.0.0.1:6379> keys *\n   (empty list or set)\n   127.0.0.1:6379> set name zhiyuan\n   OK\n   127.0.0.1:6379> keys *\n   1) "name"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * exists key\n\n判断某个key是否存在\n\n127.0.0.1:6379> EXISTS name\n(integer) 1\n127.0.0.1:6379> EXISTS name1\n(integer) 0\n\n\n1\n2\n3\n4\n\n * move key db\n\n移动key到别的库\n\n127.0.0.1:6379> set name zhiyuan\nOK\n127.0.0.1:6379> get name\n"zhiyuan"\n127.0.0.1:6379> move name 1  #自动到1库\n(integer) 1\n127.0.0.1:6379> keys *  #在本库查不到name\n(empty array)\n127.0.0.1:6379> select 1 #选择1库\nOK\n127.0.0.1:6379[1]> keys * #查询到name\n1) "name"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * del key\n   \n   删除key\n   \n   127.0.0.1:6379[1]> del name\n   (integer) 1\n   127.0.0.1:6379[1]> keys *\n   (empty array)\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * expire key 秒钟\n   \n   为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删 除。\n   \n   * ttl key\n   \n   查看还有多少秒过期，-1 表示永不过期，-2 表示已过期\n   \n   127.0.0.1:6379> set name zhiyuan\n   OK\n   127.0.0.1:6379> EXPIRE name 10\n   (integer) 1\n   127.0.0.1:6379> ttl name\n   (integer) 4\n   127.0.0.1:6379> ttl name\n   (integer) 1\n   127.0.0.1:6379> ttl name\n   (integer) -2\n   127.0.0.1:6379> keys *\n   (empty list or set)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * type key\n   \n   查看你的key是什么类型\n   \n   127.0.0.1:6379> set name zhiyuan\n   OK\n   127.0.0.1:6379> get name\n   "zhiyuan"\n   127.0.0.1:6379> type name\n   string\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 字符串String\n\n单值多Value\n\nset、get、del\n\nexists（是否存在）、append（追加）、strlen（获取长度）\n\n127.0.0.1:6379> set key1 value1 # 设置值\nOK\n127.0.0.1:6379> get key1 # 获得key\n"value1"\n127.0.0.1:6379> del key1 # 删除key\n(integer) 1\n127.0.0.1:6379> keys * # 查看全部的key\n(empty list or set)\n127.0.0.1:6379> exists key1 # 确保 key1 不存在\n(integer) 0\n127.0.0.1:6379> append key1 "hello" # 对不存在的 key进行APPEND，等同于SET key1 "hello"\n(integer) 5 # 字符长度\n127.0.0.1:6379> APPEND key1 "-2333" # 对已存在的字符串进行 APPEND\n(integer) 10 # 长度从 5 个字符增加到 10 个字符\n127.0.0.1:6379> get key1\n"hello-2333"\n127.0.0.1:6379> STRLEN key1 # # 获取字符串的长度\n(integer) 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nincr、decr 一定要是数字才能进行加减，+1 和 -1。\n\nincrby、decrby 将 key 中储存的数字加上或减去指定的数量。\n\n127.0.0.1:6379> set views 0 # 设置浏览量为0\nOK\n127.0.0.1:6379> incr views # 浏览 + 1\n(integer) 1\n127.0.0.1:6379> incr views # 浏览 + 1\n(integer) 2\n127.0.0.1:6379> decr views # 浏览 - 1\n(integer) 1\n\n127.0.0.1:6379> incrby views 10 # +10\n(integer) 11\n127.0.0.1:6379> decrby views 10 # -10\n(integer) 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nrange [范围]\n\ngetrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部\n\n127.0.0.1:6379> set key2 abcd123456 # 设置key2的值\nOK\n127.0.0.1:6379> getrange key2 0 -1 # 获得全部的值\n"abcd123456"\n127.0.0.1:6379> getrange key2 0 2 # 截取部分字符串\n"abc"\n\n\n1\n2\n3\n4\n5\n6\n\n\nsetrange 设置指定区间范围内的值，格式是setrange key值 具体值\n\n127.0.0.1:6379> get key2\n"abcd123456"\n127.0.0.1:6379> SETRANGE key2 1 xx # 替换值\n(integer) 10\n127.0.0.1:6379> get key2\n"axxd123456"\n\n\n1\n2\n3\n4\n5\n6\n\n\nsetex（set with expire）设置过期时间\n\nsetnx（set if not exist）如何key存在则不覆盖值，还是原来的值（分布式中常用）\n\n127.0.0.1:6379> setex key3 60 expire # 设置过期时间\nOK\n127.0.0.1:6379> ttl key3 # 查看剩余的时间\n(integer) 55\n\n127.0.0.1:6379> setnx mykey "redis" # 如果不存在就设置，成功返回1\n(integer) 1\n127.0.0.1:6379> setnx mykey "mongodb" # 如果值存在则不覆盖值，返回0\n(integer) 0\n127.0.0.1:6379> get mykey\n"redis"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nmset：同时设置一个或多个 key-value 对。\n\nmget：返回所有(一个或多个) key 的值。 如果给定的 key 里面，有某个 key 不存在，则此 key 返回特殊值nil\n\nmsetnx：当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。相当于原子性操作，要么都成功，要么都不成功。\n\n127.0.0.1:6379> mset k10 v10 k11 v11 k12 v12\nOK\n127.0.0.1:6379> keys *\n1) "k12"\n2) "k11"\n3) "k10"\n\n127.0.0.1:6379> mget k10 k11 k12 k13\n1) "v10"\n2) "v11"\n3) "v12"\n4) (nil)\n\n127.0.0.1:6379> msetnx k10 v10 k15 v15 # 原子性操作！\n(integer) 0\n127.0.0.1:6379> get key15\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n存储对象：\n\nset user:1 value（json数据）\n\n127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2\nOK\n127.0.0.1:6379> mget user:1:name user:1:age\n1) "zhangsan"\n2) "2"\n\n\n1\n2\n3\n4\n5\n\n\ngetset：先get再set\n\n127.0.0.1:6379> getset db mongodb # 没有旧值，返回 nil\n(nil)\n127.0.0.1:6379> get db\n"mongodb"\n127.0.0.1:6379> getset db redis # 返回旧值 mongodb\n"mongodb"\n127.0.0.1:6379> get db\n"redis"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。\n\n常规计数：微博数，粉丝数等。\n\n\n# 列表List\n\n单值多Value\n\n可插入重读的值\n\nLpush：将一个或多个值插入到列表头部。（LeftPush左）\n\nRpush：将一个或多个值插入到列表尾部。（RightPush右）\n\nlrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。\n\n其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。\n\n使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\n\n127.0.0.1:6379> LPUSH list "one"\n(integer) 1\n127.0.0.1:6379> LPUSH list "two"\n(integer) 2\n127.0.0.1:6379> RPUSH list "right"\n(integer) 3\n\n127.0.0.1:6379> Lrange list 0 -1\n1) "two"\n2) "one"\n3) "right"\n127.0.0.1:6379> Lrange list 0 1\n1) "two"\n2) "one"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nlpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。\n\nrpop 移除列表的最后一个元素，返回值为移除的元素。\n\n127.0.0.1:6379> Lpop list\n"two"\n127.0.0.1:6379> Rpop list\n"right"\n127.0.0.1:6379> Lrange list 0 -1\n1) "one"\n\n\n1\n2\n3\n4\n5\n6\n\n\nLindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）\n\n127.0.0.1:6379> Lindex list 1\n(nil)\n127.0.0.1:6379> Lindex list 0\n"one"\n127.0.0.1:6379> Lindex list -1\n"one"\n\n\n1\n2\n3\n4\n5\n6\n\n\nllen 用于返回列表的长度。\n\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> Lpush list "one"\n(integer) 1\n127.0.0.1:6379> Lpush list "two"\n(integer) 2\n127.0.0.1:6379> Lpush list "three"\n(integer) 3\n127.0.0.1:6379> Llen list # 返回列表的长度\n(integer) 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nlrem （lrem key count element）根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。\n\n如果有多个一样的lement，则删除列表最前面的的\n\n127.0.0.1:6379> lrem list 1 "two"\n(integer) 1\n127.0.0.1:6379> Lrange list 0 -1\n1) "three"\n2) "one"\n\n\n1\n2\n3\n4\n5\n\n\nLtrim key 对一个列表进行修剪(trim)，只保留指定列表中区间内的元素，不在指定区间之内的元素都将被删除。\n\n127.0.0.1:6379> RPUSH mylist "hello" "hello" "hello2" "hello3"\n(integer) 4\n127.0.0.1:6379> ltrim mylist 1 2\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "hello2"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nrpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。\n\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "foo"\n(integer) 2\n127.0.0.1:6379> rpush mylist "bar"\n(integer) 3\n127.0.0.1:6379> rpoplpush mylist myotherlist\n"bar"\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "foo"\n127.0.0.1:6379> lrange myotherlist 0 -1\n1) "bar"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nlset key index value ，将列表 key 下标为 index 的元素的值设置为 value 。\n\n127.0.0.1:6379> exists list # 对空列表(key 不存在)进行 LSET\n(integer) 0\n127.0.0.1:6379> lset list 0 item # 报错\n(error) ERR no such key\n\n127.0.0.1:6379> lpush list "value1" # 对非空列表进行 LSET\n(integer) 1\n127.0.0.1:6379> lrange list 0 0\n1) "value1"\n127.0.0.1:6379> lset list 0 "new" # 更新值\nOK\n127.0.0.1:6379> lrange list 0 0\n1) "new"\n127.0.0.1:6379> lset list 1 "new" # index 超出范围报错\n(error) ERR index out of range\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nlinsert key before/after pivot value，用于在列表的元素前或者后插入元素。\n\n将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。\n\n如果pivot有多个，则插入最前面的那个\n\n127.0.0.1:6379> RPUSH mylist "Hello"\n(integer) 1\n127.0.0.1:6379> RPUSH mylist "world"\n(integer) 2\n127.0.0.1:6379> lrange mylist 0 -1\n1) "Hello"\n2) "world"\n\n127.0.0.1:6379> LINSERT mylist BEFORE "world" "There"\n(integer) 3\n127.0.0.1:6379> lrange mylist 0 -1\n1) "Hello"\n2) "There"\n3) "world"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n性能总结：\n\n * 它是一个字符串链表，left，right 都可以插入添加\n * 如果键不存在，创建新的链表\n * 如果键已存在，新增内容\n * 如果值全移除，对应的键也就消失了\n * 链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\nlist就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。\n\nRedis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。\n\n\n# 集合Set\n\n单值多value\n\n无序不重复集合\n\nsadd 将一个或多个成员元素加入到集合中，不能重复\n\nsmembers 返回集合中的所有的成员。\n\nsismember 命令判断成员元素是否是集合的成员。\n\n127.0.0.1:6379> sadd myset "hello"\n(integer) 1\n127.0.0.1:6379> sadd myset "zhiyuan"\n(integer) 1\n127.0.0.1:6379> sadd myset "zhiyuan" # 重复值不插入 返回0\n(integer) 0\n127.0.0.1:6379> SMEMBERS myset #查看集合中所有成员\n1) "zhiyuan"\n2) "hello"\n127.0.0.1:6379> SISMEMBER myset "hello" #是否是此集合的成员 是反正1\n(integer) 1\n127.0.0.1:6379> SISMEMBER myset "world"\n(integer) 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nscard，获取集合里面的元素个数\n\n127.0.0.1:6379> scard myset\n(integer) 2\n\n\n1\n2\n\n\nsrem key value 用于移除集合中的一个或多个成员元素\n\n127.0.0.1:6379> srem myset "zhiyuan"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset\n1) "hello"\n\n\n1\n2\n3\n4\n\n\nsrandmember key 用于返回集合中随机元素。后面加上数字，则随机返回对应数量的成员，默认一个\n\n127.0.0.1:6379> SMEMBERS myset\n1) "zhiyuan"\n2) "world"\n3) "hello"\n127.0.0.1:6379> SRANDMEMBER myset\n"hello"\n127.0.0.1:6379> SRANDMEMBER myset 2\n1) "world"\n2) "zhiyuan"\n127.0.0.1:6379> SRANDMEMBER myset 2\n1) "zhiyuan"\n2) "hello"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nspop key [count] 用于移除指定 key 集合的随机元素，不填则默认一个。\n\n127.0.0.1:6379> SMEMBERS myset\n1) "zhiyuan"\n2) "world"\n3) "hello"\n127.0.0.1:6379> spop myset\n"world"\n127.0.0.1:6379> spop myset 2\n1) "zhiyuan"\n2) "hello"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsmove SOURCE DESTINATION MEMBER， 将指定成员 member 元素从 source 集合移动到 destination 集合\n\n127.0.0.1:6379> sadd myset "hello" #myset 添加元素\n(integer) 1\n127.0.0.1:6379> sadd myset "world"\n(integer) 1\n127.0.0.1:6379> sadd myset "zhiyuan"\n(integer) 1\n127.0.0.1:6379> sadd myset2 "set2" #myset2 添加元素\n(integer) 1\n127.0.0.1:6379> smove myset myset2 "zhiyuan"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset\n1) "world"\n2) "hello"\n127.0.0.1:6379> SMEMBERS myset2\n1) "zhiyuan"\n2) "set2"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n数字集合类：\n\n * 差集： sdiff\n * 交集： sinter\n * 并集： sunion\n\n127.0.0.1:6379> sadd key1 "a" # key1\n(integer) 1\n127.0.0.1:6379> sadd key1 "b"\n(integer) 1\n127.0.0.1:6379> sadd key1 "c"\n(integer) 1\n127.0.0.1:6379> sadd key2 "c" # key2\n(integer) 1\n127.0.0.1:6379> sadd key2 "d"\n(integer) 1\n127.0.0.1:6379> sadd key2 "e"\n(integer) 1\n127.0.0.1:6379> SDIFF key1 key2 # 差集\n1) "a"\n2) "b"\n127.0.0.1:6379> SINTER key1 key2 # 交集\n1) "c"\n127.0.0.1:6379> SUNION key1 key2 # 并集\n1) "a"\n2) "b"\n3) "c"\n4) "e"\n5) "d"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。\n\n\n# 哈希Hash\n\nk-v模式不变，但V是一个键值对\n\nhset、hget 命令用于为哈希表中的字段赋值\n\nhmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段\n\n> Redis 4.0.0开始弃用HMSET，请使用HSET\n\nhgetall 用于返回哈希表中，所有的字段和值。\n\nhdel 用于删除哈希表 key 中的一个或多个指定字段\n\n127.0.0.1:6379>  hset myhash field1 "zhiyuan"\n(integer) 1\n127.0.0.1:6379> hget myhash field1\n"zhiyuan"\n\n127.0.0.1:6379> HSET myhash field1 "Hello" field2 "World"\n(integer) 2\n127.0.0.1:6379> hgetall myhash\n1) "field1"\n2) "Hello"\n3) "field2"\n4) "World"\n127.0.0.1:6379> HGET myhash field1\n"Hello"\n127.0.0.1:6379> HGET myhash field2\n"World"\n\n127.0.0.1:6379> HDEL myhash field1\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "World"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nhlen 获取哈希表中字段的数量\n\n127.0.0.1:6379> hlen myhash\n(integer) 1\n127.0.0.1:6379> HSET myhash field1 "Hello" field2 "World"\nOK\n127.0.0.1:6379> hlen myhash\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n\n\nhexists 查看哈希表的指定字段是否存在\n\n127.0.0.1:6379> hexists myhash field1\n(integer) 1\n127.0.0.1:6379> hexists myhash field3\n(integer) 0\n\n\n1\n2\n3\n4\n\n\nhkeys 获取哈希表中的所有域（field）\n\nhvals 返回哈希表所有域(field)的值\n\n127.0.0.1:6379> HKEYS myhash\n1) "field2"\n2) "field1"\n127.0.0.1:6379> HVALS myhash\n1) "World"\n2) "Hello"\n\n\n1\n2\n3\n4\n5\n6\n\n\nhincrby 为哈希表中的字段值加上指定增量值\n\n127.0.0.1:6379> hset myhash field 5\n(integer) 1\n127.0.0.1:6379> HINCRBY myhash field 1\n(integer) 6\n127.0.0.1:6379> HINCRBY myhash field -1\n(integer) 5\n127.0.0.1:6379> HINCRBY myhash field -10\n(integer) -5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhsetnx 为哈希表中不存在的的字段赋值 ，存在则不赋值\n\n127.0.0.1:6379> HSETNX myhash field1 "hello"\n(integer) 1 # 设置成功，返回 1 。\n127.0.0.1:6379> HSETNX myhash field1 "world"\n(integer) 0 # 如果给定字段已经存在，返回 0 。\n127.0.0.1:6379> HGET myhash field1\n"hello"\n\n\n1\n2\n3\n4\n5\n6\n\n\nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 存储部分变更的数据，如用户信息等。\n\n\n# 有序集合Zset\n\n在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2\n\nzadd 将一个或多个成员元素及其分数值加入到有序集当中。\n\nzrange 返回有序集中，指定区间内的成员\n\n127.0.0.1:6379> zadd myset 1 "one"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 "two" 3 "three"\n(integer) 2\n127.0.0.1:6379> ZRANGE myset 0 -1\n1) "one"\n2) "two"\n3) "three"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nzrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大) 次序排列。\n\nZREVRANGE 从大到小\n\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n\n# Inf无穷大量+∞,同样地,-∞可以表示为-Inf。\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 显示整个有序集\n1) "zhiyuan"\n2) "xiaoming"\n3) "xiaohong"\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores # 递增排列\n1) "zhiyuan"\n2) "500"\n3) "xiaoming"\n4) "2500"\n5) "xiaohong"\n6) "5000"\n127.0.0.1:6379> ZREVRANGE salary 0 -1 WITHSCORES # 递减排列\n1) "xiaohong"\n2) "5000"\n3) "xiaoming"\n4) "2500"\n5) "zhiyuan"\n6) "500"\n# 显示工资 <=2500的所有成员\n127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 WITHSCORES \n1) "zhiyuan"\n2) "500"\n3) "xiaoming"\n4) "2500"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nzrem 移除有序集中的一个或多个成员\n\n127.0.0.1:6379> ZRANGE salary 0 -1\n1) "zhiyuan"\n2) "xiaoming"\n3) "xiaohong"\n127.0.0.1:6379> zrem salary zhiyuan\n(integer) 1\n127.0.0.1:6379> ZRANGE salary 0 -1\n1) "xiaoming"\n2) "xiaohong"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nzcard 命令用于计算集合中元素的数量\n\n127.0.0.1:6379> zcard salary\n(integer) 2\nOK\n\n\n1\n2\n3\n\n\nzcount 计算有序集合中指定分数区间的成员数量。\n\n127.0.0.1:6379> zadd myset 1 "hello"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 "world" 3 "zhiyuan"\n(integer) 2\n127.0.0.1:6379> ZCOUNT myset 1 3\n(integer) 3\n127.0.0.1:6379> ZCOUNT myset 1 2\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nzrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。\n\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n127.0.0.1:6379> ZRANGE salary 0 -1 WITHSCORES # 显示所有成员及其 score 值\n1) "kuangshen"\n2) "500"\n3) "xiaoming"\n4) "2500"\n5) "xiaohong"\n6) "5000"\n127.0.0.1:6379> zrank salary kuangshen # 显示 kuangshen 的薪水排名，最少\n(integer) 0\n127.0.0.1:6379> zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nzrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序\n\n127.0.0.1:6379> ZREVRANK salary kuangshen # 狂神第三\n(integer) 2\n127.0.0.1:6379> ZREVRANK salary xiaohong # 小红第一\n(integer) 0\n\n\n1\n2\n3\n4\n\n\n和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如 一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分， 这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让 重要的任务优先执行。',normalizedContent:'# 五大数据类型\n\n官方文档：\n\n\n\n全段翻译：\n\nredis 是一个开源（bsd许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 redis 内置了 复制（replication），lua脚本（lua scripting）， lru驱动事件（lru eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 redis哨兵（sentinel）和自动 分区（cluster）提供高可用性（high availability）。\n\n * string （字符串类型）\n   \n   string是redis最基本的类型，你可以理解成memcached一模一样的类型，一个key对应一个value。\n   \n   string类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。\n   \n   string类型是redis最基本的数据类型，一个redis中字符串value最多可以是512m。\n\n * hash（哈希，类似 java里的map）\n   \n   redis hash 是一个键值对集合。\n   \n   redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。\n   \n   类似java里面的map\n\n * list（列表）\n   \n   redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个链表 !\n\n * set（集合）\n   \n   redis的set是string类型的无序集合，它是通过hashtable实现的 !\n\n * zset（sorted set：有序集合）\n   \n   redis zset 和 set 一样，也是string类型元素的集合，且不允许重复的成员。\n   \n   不同的是每个元素都会关联一个double类型的分数。\n   \n   redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（score） 却可以重复。\n\n\n# redis键（key）\n\n字母大写小写都一样\n\n * keys *\n   \n   查看所有的key\n   \n   127.0.0.1:6379> keys *\n   (empty list or set)\n   127.0.0.1:6379> set name zhiyuan\n   ok\n   127.0.0.1:6379> keys *\n   1) "name"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * exists key\n\n判断某个key是否存在\n\n127.0.0.1:6379> exists name\n(integer) 1\n127.0.0.1:6379> exists name1\n(integer) 0\n\n\n1\n2\n3\n4\n\n * move key db\n\n移动key到别的库\n\n127.0.0.1:6379> set name zhiyuan\nok\n127.0.0.1:6379> get name\n"zhiyuan"\n127.0.0.1:6379> move name 1  #自动到1库\n(integer) 1\n127.0.0.1:6379> keys *  #在本库查不到name\n(empty array)\n127.0.0.1:6379> select 1 #选择1库\nok\n127.0.0.1:6379[1]> keys * #查询到name\n1) "name"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * del key\n   \n   删除key\n   \n   127.0.0.1:6379[1]> del name\n   (integer) 1\n   127.0.0.1:6379[1]> keys *\n   (empty array)\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * expire key 秒钟\n   \n   为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删 除。\n   \n   * ttl key\n   \n   查看还有多少秒过期，-1 表示永不过期，-2 表示已过期\n   \n   127.0.0.1:6379> set name zhiyuan\n   ok\n   127.0.0.1:6379> expire name 10\n   (integer) 1\n   127.0.0.1:6379> ttl name\n   (integer) 4\n   127.0.0.1:6379> ttl name\n   (integer) 1\n   127.0.0.1:6379> ttl name\n   (integer) -2\n   127.0.0.1:6379> keys *\n   (empty list or set)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n * type key\n   \n   查看你的key是什么类型\n   \n   127.0.0.1:6379> set name zhiyuan\n   ok\n   127.0.0.1:6379> get name\n   "zhiyuan"\n   127.0.0.1:6379> type name\n   string\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 字符串string\n\n单值多value\n\nset、get、del\n\nexists（是否存在）、append（追加）、strlen（获取长度）\n\n127.0.0.1:6379> set key1 value1 # 设置值\nok\n127.0.0.1:6379> get key1 # 获得key\n"value1"\n127.0.0.1:6379> del key1 # 删除key\n(integer) 1\n127.0.0.1:6379> keys * # 查看全部的key\n(empty list or set)\n127.0.0.1:6379> exists key1 # 确保 key1 不存在\n(integer) 0\n127.0.0.1:6379> append key1 "hello" # 对不存在的 key进行append，等同于set key1 "hello"\n(integer) 5 # 字符长度\n127.0.0.1:6379> append key1 "-2333" # 对已存在的字符串进行 append\n(integer) 10 # 长度从 5 个字符增加到 10 个字符\n127.0.0.1:6379> get key1\n"hello-2333"\n127.0.0.1:6379> strlen key1 # # 获取字符串的长度\n(integer) 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nincr、decr 一定要是数字才能进行加减，+1 和 -1。\n\nincrby、decrby 将 key 中储存的数字加上或减去指定的数量。\n\n127.0.0.1:6379> set views 0 # 设置浏览量为0\nok\n127.0.0.1:6379> incr views # 浏览 + 1\n(integer) 1\n127.0.0.1:6379> incr views # 浏览 + 1\n(integer) 2\n127.0.0.1:6379> decr views # 浏览 - 1\n(integer) 1\n\n127.0.0.1:6379> incrby views 10 # +10\n(integer) 11\n127.0.0.1:6379> decrby views 10 # -10\n(integer) 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nrange [范围]\n\ngetrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部\n\n127.0.0.1:6379> set key2 abcd123456 # 设置key2的值\nok\n127.0.0.1:6379> getrange key2 0 -1 # 获得全部的值\n"abcd123456"\n127.0.0.1:6379> getrange key2 0 2 # 截取部分字符串\n"abc"\n\n\n1\n2\n3\n4\n5\n6\n\n\nsetrange 设置指定区间范围内的值，格式是setrange key值 具体值\n\n127.0.0.1:6379> get key2\n"abcd123456"\n127.0.0.1:6379> setrange key2 1 xx # 替换值\n(integer) 10\n127.0.0.1:6379> get key2\n"axxd123456"\n\n\n1\n2\n3\n4\n5\n6\n\n\nsetex（set with expire）设置过期时间\n\nsetnx（set if not exist）如何key存在则不覆盖值，还是原来的值（分布式中常用）\n\n127.0.0.1:6379> setex key3 60 expire # 设置过期时间\nok\n127.0.0.1:6379> ttl key3 # 查看剩余的时间\n(integer) 55\n\n127.0.0.1:6379> setnx mykey "redis" # 如果不存在就设置，成功返回1\n(integer) 1\n127.0.0.1:6379> setnx mykey "mongodb" # 如果值存在则不覆盖值，返回0\n(integer) 0\n127.0.0.1:6379> get mykey\n"redis"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nmset：同时设置一个或多个 key-value 对。\n\nmget：返回所有(一个或多个) key 的值。 如果给定的 key 里面，有某个 key 不存在，则此 key 返回特殊值nil\n\nmsetnx：当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。相当于原子性操作，要么都成功，要么都不成功。\n\n127.0.0.1:6379> mset k10 v10 k11 v11 k12 v12\nok\n127.0.0.1:6379> keys *\n1) "k12"\n2) "k11"\n3) "k10"\n\n127.0.0.1:6379> mget k10 k11 k12 k13\n1) "v10"\n2) "v11"\n3) "v12"\n4) (nil)\n\n127.0.0.1:6379> msetnx k10 v10 k15 v15 # 原子性操作！\n(integer) 0\n127.0.0.1:6379> get key15\n(nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n存储对象：\n\nset user:1 value（json数据）\n\n127.0.0.1:6379> mset user:1:name zhangsan user:1:age 2\nok\n127.0.0.1:6379> mget user:1:name user:1:age\n1) "zhangsan"\n2) "2"\n\n\n1\n2\n3\n4\n5\n\n\ngetset：先get再set\n\n127.0.0.1:6379> getset db mongodb # 没有旧值，返回 nil\n(nil)\n127.0.0.1:6379> get db\n"mongodb"\n127.0.0.1:6379> getset db redis # 返回旧值 mongodb\n"mongodb"\n127.0.0.1:6379> get db\n"redis"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nstring数据结构是简单的key-value类型，value其实不仅可以是string，也可以是数字。\n\n常规计数：微博数，粉丝数等。\n\n\n# 列表list\n\n单值多value\n\n可插入重读的值\n\nlpush：将一个或多个值插入到列表头部。（leftpush左）\n\nrpush：将一个或多个值插入到列表尾部。（rightpush右）\n\nlrange：返回列表中指定区间内的元素，区间以偏移量 start 和 end 指定。\n\n其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。\n\n使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\n\n127.0.0.1:6379> lpush list "one"\n(integer) 1\n127.0.0.1:6379> lpush list "two"\n(integer) 2\n127.0.0.1:6379> rpush list "right"\n(integer) 3\n\n127.0.0.1:6379> lrange list 0 -1\n1) "two"\n2) "one"\n3) "right"\n127.0.0.1:6379> lrange list 0 1\n1) "two"\n2) "one"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nlpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。\n\nrpop 移除列表的最后一个元素，返回值为移除的元素。\n\n127.0.0.1:6379> lpop list\n"two"\n127.0.0.1:6379> rpop list\n"right"\n127.0.0.1:6379> lrange list 0 -1\n1) "one"\n\n\n1\n2\n3\n4\n5\n6\n\n\nlindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）\n\n127.0.0.1:6379> lindex list 1\n(nil)\n127.0.0.1:6379> lindex list 0\n"one"\n127.0.0.1:6379> lindex list -1\n"one"\n\n\n1\n2\n3\n4\n5\n6\n\n\nllen 用于返回列表的长度。\n\n127.0.0.1:6379> flushdb\nok\n127.0.0.1:6379> lpush list "one"\n(integer) 1\n127.0.0.1:6379> lpush list "two"\n(integer) 2\n127.0.0.1:6379> lpush list "three"\n(integer) 3\n127.0.0.1:6379> llen list # 返回列表的长度\n(integer) 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nlrem （lrem key count element）根据参数 count 的值，移除列表中与参数 value 相等的元素。\n\n如果有多个一样的lement，则删除列表最前面的的\n\n127.0.0.1:6379> lrem list 1 "two"\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) "three"\n2) "one"\n\n\n1\n2\n3\n4\n5\n\n\nltrim key 对一个列表进行修剪(trim)，只保留指定列表中区间内的元素，不在指定区间之内的元素都将被删除。\n\n127.0.0.1:6379> rpush mylist "hello" "hello" "hello2" "hello3"\n(integer) 4\n127.0.0.1:6379> ltrim mylist 1 2\nok\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "hello2"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nrpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。\n\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "foo"\n(integer) 2\n127.0.0.1:6379> rpush mylist "bar"\n(integer) 3\n127.0.0.1:6379> rpoplpush mylist myotherlist\n"bar"\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "foo"\n127.0.0.1:6379> lrange myotherlist 0 -1\n1) "bar"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nlset key index value ，将列表 key 下标为 index 的元素的值设置为 value 。\n\n127.0.0.1:6379> exists list # 对空列表(key 不存在)进行 lset\n(integer) 0\n127.0.0.1:6379> lset list 0 item # 报错\n(error) err no such key\n\n127.0.0.1:6379> lpush list "value1" # 对非空列表进行 lset\n(integer) 1\n127.0.0.1:6379> lrange list 0 0\n1) "value1"\n127.0.0.1:6379> lset list 0 "new" # 更新值\nok\n127.0.0.1:6379> lrange list 0 0\n1) "new"\n127.0.0.1:6379> lset list 1 "new" # index 超出范围报错\n(error) err index out of range\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nlinsert key before/after pivot value，用于在列表的元素前或者后插入元素。\n\n将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。\n\n如果pivot有多个，则插入最前面的那个\n\n127.0.0.1:6379> rpush mylist "hello"\n(integer) 1\n127.0.0.1:6379> rpush mylist "world"\n(integer) 2\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "world"\n\n127.0.0.1:6379> linsert mylist before "world" "there"\n(integer) 3\n127.0.0.1:6379> lrange mylist 0 -1\n1) "hello"\n2) "there"\n3) "world"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n性能总结：\n\n * 它是一个字符串链表，left，right 都可以插入添加\n * 如果键不存在，创建新的链表\n * 如果键已存在，新增内容\n * 如果值全移除，对应的键也就消失了\n * 链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\nlist就是链表，略有数据结构知识的人都应该能理解其结构。使用lists结构，我们可以轻松地实现最新消息排行等功能。list的另一个应用就是消息队列，可以利用list的push操作，将任务存在list中，然后工作线程再用pop操作将任务取出进行执行。redis还提供了操作list中某一段的api，你可以直接查询，删除list中某一段的元素。\n\nredis的list是每个子元素都是string类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样list即可以作为栈，也可以作为队列。\n\n\n# 集合set\n\n单值多value\n\n无序不重复集合\n\nsadd 将一个或多个成员元素加入到集合中，不能重复\n\nsmembers 返回集合中的所有的成员。\n\nsismember 命令判断成员元素是否是集合的成员。\n\n127.0.0.1:6379> sadd myset "hello"\n(integer) 1\n127.0.0.1:6379> sadd myset "zhiyuan"\n(integer) 1\n127.0.0.1:6379> sadd myset "zhiyuan" # 重复值不插入 返回0\n(integer) 0\n127.0.0.1:6379> smembers myset #查看集合中所有成员\n1) "zhiyuan"\n2) "hello"\n127.0.0.1:6379> sismember myset "hello" #是否是此集合的成员 是反正1\n(integer) 1\n127.0.0.1:6379> sismember myset "world"\n(integer) 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nscard，获取集合里面的元素个数\n\n127.0.0.1:6379> scard myset\n(integer) 2\n\n\n1\n2\n\n\nsrem key value 用于移除集合中的一个或多个成员元素\n\n127.0.0.1:6379> srem myset "zhiyuan"\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) "hello"\n\n\n1\n2\n3\n4\n\n\nsrandmember key 用于返回集合中随机元素。后面加上数字，则随机返回对应数量的成员，默认一个\n\n127.0.0.1:6379> smembers myset\n1) "zhiyuan"\n2) "world"\n3) "hello"\n127.0.0.1:6379> srandmember myset\n"hello"\n127.0.0.1:6379> srandmember myset 2\n1) "world"\n2) "zhiyuan"\n127.0.0.1:6379> srandmember myset 2\n1) "zhiyuan"\n2) "hello"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nspop key [count] 用于移除指定 key 集合的随机元素，不填则默认一个。\n\n127.0.0.1:6379> smembers myset\n1) "zhiyuan"\n2) "world"\n3) "hello"\n127.0.0.1:6379> spop myset\n"world"\n127.0.0.1:6379> spop myset 2\n1) "zhiyuan"\n2) "hello"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsmove source destination member， 将指定成员 member 元素从 source 集合移动到 destination 集合\n\n127.0.0.1:6379> sadd myset "hello" #myset 添加元素\n(integer) 1\n127.0.0.1:6379> sadd myset "world"\n(integer) 1\n127.0.0.1:6379> sadd myset "zhiyuan"\n(integer) 1\n127.0.0.1:6379> sadd myset2 "set2" #myset2 添加元素\n(integer) 1\n127.0.0.1:6379> smove myset myset2 "zhiyuan"\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) "world"\n2) "hello"\n127.0.0.1:6379> smembers myset2\n1) "zhiyuan"\n2) "set2"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n数字集合类：\n\n * 差集： sdiff\n * 交集： sinter\n * 并集： sunion\n\n127.0.0.1:6379> sadd key1 "a" # key1\n(integer) 1\n127.0.0.1:6379> sadd key1 "b"\n(integer) 1\n127.0.0.1:6379> sadd key1 "c"\n(integer) 1\n127.0.0.1:6379> sadd key2 "c" # key2\n(integer) 1\n127.0.0.1:6379> sadd key2 "d"\n(integer) 1\n127.0.0.1:6379> sadd key2 "e"\n(integer) 1\n127.0.0.1:6379> sdiff key1 key2 # 差集\n1) "a"\n2) "b"\n127.0.0.1:6379> sinter key1 key2 # 交集\n1) "c"\n127.0.0.1:6379> sunion key1 key2 # 并集\n1) "a"\n2) "b"\n3) "c"\n4) "e"\n5) "d"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。\n\n\n# 哈希hash\n\nk-v模式不变，但v是一个键值对\n\nhset、hget 命令用于为哈希表中的字段赋值\n\nhmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段\n\n> redis 4.0.0开始弃用hmset，请使用hset\n\nhgetall 用于返回哈希表中，所有的字段和值。\n\nhdel 用于删除哈希表 key 中的一个或多个指定字段\n\n127.0.0.1:6379>  hset myhash field1 "zhiyuan"\n(integer) 1\n127.0.0.1:6379> hget myhash field1\n"zhiyuan"\n\n127.0.0.1:6379> hset myhash field1 "hello" field2 "world"\n(integer) 2\n127.0.0.1:6379> hgetall myhash\n1) "field1"\n2) "hello"\n3) "field2"\n4) "world"\n127.0.0.1:6379> hget myhash field1\n"hello"\n127.0.0.1:6379> hget myhash field2\n"world"\n\n127.0.0.1:6379> hdel myhash field1\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1) "field2"\n2) "world"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nhlen 获取哈希表中字段的数量\n\n127.0.0.1:6379> hlen myhash\n(integer) 1\n127.0.0.1:6379> hset myhash field1 "hello" field2 "world"\nok\n127.0.0.1:6379> hlen myhash\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n\n\nhexists 查看哈希表的指定字段是否存在\n\n127.0.0.1:6379> hexists myhash field1\n(integer) 1\n127.0.0.1:6379> hexists myhash field3\n(integer) 0\n\n\n1\n2\n3\n4\n\n\nhkeys 获取哈希表中的所有域（field）\n\nhvals 返回哈希表所有域(field)的值\n\n127.0.0.1:6379> hkeys myhash\n1) "field2"\n2) "field1"\n127.0.0.1:6379> hvals myhash\n1) "world"\n2) "hello"\n\n\n1\n2\n3\n4\n5\n6\n\n\nhincrby 为哈希表中的字段值加上指定增量值\n\n127.0.0.1:6379> hset myhash field 5\n(integer) 1\n127.0.0.1:6379> hincrby myhash field 1\n(integer) 6\n127.0.0.1:6379> hincrby myhash field -1\n(integer) 5\n127.0.0.1:6379> hincrby myhash field -10\n(integer) -5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhsetnx 为哈希表中不存在的的字段赋值 ，存在则不赋值\n\n127.0.0.1:6379> hsetnx myhash field1 "hello"\n(integer) 1 # 设置成功，返回 1 。\n127.0.0.1:6379> hsetnx myhash field1 "world"\n(integer) 0 # 如果给定字段已经存在，返回 0 。\n127.0.0.1:6379> hget myhash field1\n"hello"\n\n\n1\n2\n3\n4\n5\n6\n\n\nredis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 存储部分变更的数据，如用户信息等。\n\n\n# 有序集合zset\n\n在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2\n\nzadd 将一个或多个成员元素及其分数值加入到有序集当中。\n\nzrange 返回有序集中，指定区间内的成员\n\n127.0.0.1:6379> zadd myset 1 "one"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 "two" 3 "three"\n(integer) 2\n127.0.0.1:6379> zrange myset 0 -1\n1) "one"\n2) "two"\n3) "three"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nzrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大) 次序排列。\n\nzrevrange 从大到小\n\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n\n# inf无穷大量+∞,同样地,-∞可以表示为-inf。\n127.0.0.1:6379> zrangebyscore salary -inf +inf # 显示整个有序集\n1) "zhiyuan"\n2) "xiaoming"\n3) "xiaohong"\n127.0.0.1:6379> zrangebyscore salary -inf +inf withscores # 递增排列\n1) "zhiyuan"\n2) "500"\n3) "xiaoming"\n4) "2500"\n5) "xiaohong"\n6) "5000"\n127.0.0.1:6379> zrevrange salary 0 -1 withscores # 递减排列\n1) "xiaohong"\n2) "5000"\n3) "xiaoming"\n4) "2500"\n5) "zhiyuan"\n6) "500"\n# 显示工资 <=2500的所有成员\n127.0.0.1:6379> zrangebyscore salary -inf 2500 withscores \n1) "zhiyuan"\n2) "500"\n3) "xiaoming"\n4) "2500"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nzrem 移除有序集中的一个或多个成员\n\n127.0.0.1:6379> zrange salary 0 -1\n1) "zhiyuan"\n2) "xiaoming"\n3) "xiaohong"\n127.0.0.1:6379> zrem salary zhiyuan\n(integer) 1\n127.0.0.1:6379> zrange salary 0 -1\n1) "xiaoming"\n2) "xiaohong"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nzcard 命令用于计算集合中元素的数量\n\n127.0.0.1:6379> zcard salary\n(integer) 2\nok\n\n\n1\n2\n3\n\n\nzcount 计算有序集合中指定分数区间的成员数量。\n\n127.0.0.1:6379> zadd myset 1 "hello"\n(integer) 1\n127.0.0.1:6379> zadd myset 2 "world" 3 "zhiyuan"\n(integer) 2\n127.0.0.1:6379> zcount myset 1 3\n(integer) 3\n127.0.0.1:6379> zcount myset 1 2\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nzrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。\n\n127.0.0.1:6379> zadd salary 2500 xiaoming\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 xiaohong\n(integer) 1\n127.0.0.1:6379> zadd salary 500 kuangshen\n(integer) 1\n127.0.0.1:6379> zrange salary 0 -1 withscores # 显示所有成员及其 score 值\n1) "kuangshen"\n2) "500"\n3) "xiaoming"\n4) "2500"\n5) "xiaohong"\n6) "5000"\n127.0.0.1:6379> zrank salary kuangshen # 显示 kuangshen 的薪水排名，最少\n(integer) 0\n127.0.0.1:6379> zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三\n(integer) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nzrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序\n\n127.0.0.1:6379> zrevrank salary kuangshen # 狂神第三\n(integer) 2\n127.0.0.1:6379> zrevrank salary xiaohong # 小红第一\n(integer) 0\n\n\n1\n2\n3\n4\n\n\n和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如 一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分， 这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让 重要的任务优先执行。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Redis - 概念和基础",frontmatter:{title:"Redis - 概念和基础",date:"2021-05-17T16:10:19.000Z",permalink:"/pages/28aa50/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/01.Redis%20-%20%E5%85%A5%E9%97%A8.html",relativePath:"03.数据库/10.Redis/01.Redis - 入门.md",key:"v-cfeb30e6",path:"/pages/28aa50/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:64},{level:2,title:"常用网站",slug:"常用网站",normalizedTitle:"常用网站",charIndex:406},{level:2,title:"安装Redis",slug:"安装redis",normalizedTitle:"安装redis",charIndex:482},{level:2,title:"基础知识说明",slug:"基础知识说明",normalizedTitle:"基础知识说明",charIndex:2723},{level:3,title:"redis压力测试",slug:"redis压力测试",normalizedTitle:"redis压力测试",charIndex:2734},{level:3,title:"基本数据库常识",slug:"基本数据库常识",normalizedTitle:"基本数据库常识",charIndex:3801},{level:2,title:"关于redis的单线程",slug:"关于redis的单线程",normalizedTitle:"关于redis的单线程",charIndex:4638}],headersStr:"概述 常用网站 安装Redis 基础知识说明 redis压力测试 基本数据库常识 关于redis的单线程",content:'狂神redis视频教程视频教程：https://www.bilibili.com/video/BV1S54y1R7SB\n\n\n# 概述\n\nRedis：REmote DIctionary Server（远程字典服务器）\n\n是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据 库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器\n\nRedis与其他key-value缓存产品有以下三个特点\n\n * Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n * Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。\n * Redis支持数据的备份，即master-slave模式的数据备份。\n\n\n# 常用网站\n\n * 官网\n   \n   https://redis.io/\n\n * 中文网\n   \n   http://www.redis.cn\n\n\n# 安装Redis\n\n由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版，所以这里就以linux版为主，可以自己去测试玩玩，Windows安装及使用教程：https://www.cnblogs.com/xing-nb/p/12146449.html\n\nlinux直接去官网下载：https://redis.io/download\n\n安装步骤（基于当时最新版6.2.1）：\n\n 1. 下载压缩包，放置Linux的目录下 /opt\n\n 2. 在/opt 目录下解压，命令 ： tar -zxvf redis-6.2.1.tar.gz\n\n 3. 解压完成后出现文件夹：redis-6.2.1\n\n 4. 进入目录： cd redis-6.2.1\n\n 5. 在 redis-6.2.1 目录下执行 make 命令\n    \n    运行make命令时故意出现的错误解析：\n    \n    1. 安装gcc （gcc是linux下的一个编译程序，是c程序的编译工具）\n       \n       能上网: yum install gcc-c++\n       \n       版本测试: gcc-v\n    \n    2. 二次make\n    \n    3. Jemalloc/jemalloc.h：没有那个文件或目录\n       \n       运行 make distclean 之后再make\n    \n    4. Redis Test（可以不用执行）\n\n 6. 如果make完成后执行 make install\n\n 7. 查看默认安装目录：cd /usr/local/bin\n    \n    /usr 这是一个非常重要的目录，类似于windows下的Program Files，存放用户的程序\n    \n    \n\n 8. redis默认不是后台启动，修改文件\n    \n    一般我们在 /usr/local/bin 目录下，创建myconfig目录，存放我们的配置文件\n    \n    cd /usr/local/bin\n    mkdir myconfig   #创建目录\n    \n    #拷贝配置文件\n    cd /opt/redis-6.2.1\n    cp redis.conf /usr/local/bin # 拷一个备份，养成良好的习惯，我们就修改这个文件\n    # 修改配置保证可以后台应用\n    vim redis.conf\n    /daemonize   #查找\n    :wq    #保存\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    \n    \n    * A、redis.conf配置文件中daemonize守护线程，默认是NO。\n    * B、daemonize是用来指定redis是否要用守护线程的方式启动。\n    \n    daemonize 设置yes或者no区别\n    \n    * daemonize:yes\n      \n      redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项 pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。\n    \n    * daemonize:no\n      \n      当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。\n\n 9. 启动测试一下！\n\n * 启动redis服务\n   \n   cd /usr/local/bin\n   redis-server myconfig/redis.conf\n   \n   \n   1\n   2\n   \n\n * redis客户端连接\n   \n      redis-cli -p 6379\n   \n   \n   1\n   \n   \n   观察地址的变化，如果连接成功，是直接连上的，redis默认端口号 6379\n   \n   \n\n * 执行ping、get和set操作、退出\n   \n      127.0.0.1:6379> ping\n      PONG\n      127.0.0.1:6379> get hello\n      (nil)\n      127.0.0.1:6379> set hello zhiyuan\n      OK\n      127.0.0.1:6379> get hello\n      "zhiyuan"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   \n\n * 关闭连接\n   \n      127.0.0.1:6379> shutdown\n      not connected> exit\n   \n   \n   1\n   2\n   \n\n可以使用指令ps -ef|grep redis显示系统当前redis 进程信息，查看开启和关闭连接的变化\n\n\n# 基础知识说明\n\n\n# redis压力测试\n\nRedis-benchmark是官方自带的Redis性能测试工具，可以有效的测试Redis服务的性能。\n\nredis 性能测试工具可选参数如下所示：\n\n序号   选项      描述                                  默认值\n1    -h      指定服务器主机名                            127.0.0.1\n2    -p      指定服务器端口                             6379\n3    -s      指定服务器 socket                        \n4    -c      指定并发连接数                             50\n5    -n      指定请求数                               10000\n6    -d      以字节的形式指定 SET/GET 值的数据大小             2\n7    -k      1=keep alive 0=reconnect            1\n8    -r      SET/GET/INCR 使用随机 key, SADD 使用随机值   \n9    -P      通过管道传输 numreq 请求                    1\n10   -q      强制退出 redis。仅显示 query/sec 值          \n11   --csv   以 CSV 格式输出                          \n12   -l      生成循环，永久执行测试                         \n13   -t      仅运行以逗号分隔的测试命令列表。                    \n14   -I      Idle 模式。仅打开 N 个 idle 连接并等待。         \n\n# 测试：100个并发连接，100000个请求，检测host为localhost 端口为6379的redis服务器性能\ncd  /usr/local/bin\nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n\n\n1\n2\n3\n\n\n参考资料：https://www.runoob.com/redis/redis-benchmarks.html\n\n\n# 基本数据库常识\n\n默认16个数据库，类似数组下标从零开始，初始默认使用零号库\n\n查看 redis.conf ，里面有默认的配置\n\n# Set the number of databases. The default database is DB 0, you can select\n# a different one on a per-connection basis using SELECT <dbid> where\n# dbid is a number between 0 and \'databases\'-1\ndatabases 16\n\n\n1\n2\n3\n4\n\n\nSelect命令切换数据库\n\n127.0.0.1:6379> select 7\nOK\n127.0.0.1:6379[7]>\n# 不同的库可以存不同的数据\n\n\n1\n2\n3\n4\n\n\nDbsize查看当前数据库的key的数量\n\n127.0.0.1:6379> select 7\nOK\n127.0.0.1:6379[7]> DBSIZE\n(integer) 0\n127.0.0.1:6379[7]> select 0\nOK\n127.0.0.1:6379> DBSIZE\n(integer) 5\n127.0.0.1:6379> keys * # 查看具体的key\n1) "counter:__rand_int__"\n2) "mylist"\n3) "k1"\n4) "myset:__rand_int__"\n5) "key:__rand_int__"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nFlushdb：清空当前库\n\nFlushall：清空全部的库\n\n127.0.0.1:6379> DBSIZE\n(integer) 5\n127.0.0.1:6379> FLUSHDB\nOK\n127.0.0.1:6379> DBSIZE\n(integer) 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 关于redis的单线程\n\n注：6.x版本有多线程，一般用不到，单线程足够应对\n\n我们首先要明白，Redis很快！官方表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就 顺理成章地采用单线程的方案了！\n\nRedis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！\n\nRedis为什么这么快？\n\nredis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为 多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切 换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存 的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处 理这个事。在内存的情况下，这个方案就是最佳方案。\n\n因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns * 1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据的时间。',normalizedContent:'狂神redis视频教程视频教程：https://www.bilibili.com/video/bv1s54y1r7sb\n\n\n# 概述\n\nredis：remote dictionary server（远程字典服务器）\n\n是完全开源免费的，用c语言编写的，遵守bsd协议，是一个高性能的（key/value）分布式内存数据 库，基于内存运行，并支持持久化的nosql数据库，是当前最热门的nosql数据库之一，也被人们称为数据结构服务器\n\nredis与其他key-value缓存产品有以下三个特点\n\n * redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n * redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。\n * redis支持数据的备份，即master-slave模式的数据备份。\n\n\n# 常用网站\n\n * 官网\n   \n   https://redis.io/\n\n * 中文网\n   \n   http://www.redis.cn\n\n\n# 安装redis\n\n由于企业里面做redis开发，99%都是linux版的运用和安装，几乎不会涉及到windows版，所以这里就以linux版为主，可以自己去测试玩玩，windows安装及使用教程：https://www.cnblogs.com/xing-nb/p/12146449.html\n\nlinux直接去官网下载：https://redis.io/download\n\n安装步骤（基于当时最新版6.2.1）：\n\n 1. 下载压缩包，放置linux的目录下 /opt\n\n 2. 在/opt 目录下解压，命令 ： tar -zxvf redis-6.2.1.tar.gz\n\n 3. 解压完成后出现文件夹：redis-6.2.1\n\n 4. 进入目录： cd redis-6.2.1\n\n 5. 在 redis-6.2.1 目录下执行 make 命令\n    \n    运行make命令时故意出现的错误解析：\n    \n    1. 安装gcc （gcc是linux下的一个编译程序，是c程序的编译工具）\n       \n       能上网: yum install gcc-c++\n       \n       版本测试: gcc-v\n    \n    2. 二次make\n    \n    3. jemalloc/jemalloc.h：没有那个文件或目录\n       \n       运行 make distclean 之后再make\n    \n    4. redis test（可以不用执行）\n\n 6. 如果make完成后执行 make install\n\n 7. 查看默认安装目录：cd /usr/local/bin\n    \n    /usr 这是一个非常重要的目录，类似于windows下的program files，存放用户的程序\n    \n    \n\n 8. redis默认不是后台启动，修改文件\n    \n    一般我们在 /usr/local/bin 目录下，创建myconfig目录，存放我们的配置文件\n    \n    cd /usr/local/bin\n    mkdir myconfig   #创建目录\n    \n    #拷贝配置文件\n    cd /opt/redis-6.2.1\n    cp redis.conf /usr/local/bin # 拷一个备份，养成良好的习惯，我们就修改这个文件\n    # 修改配置保证可以后台应用\n    vim redis.conf\n    /daemonize   #查找\n    :wq    #保存\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    \n    \n    * a、redis.conf配置文件中daemonize守护线程，默认是no。\n    * b、daemonize是用来指定redis是否要用守护线程的方式启动。\n    \n    daemonize 设置yes或者no区别\n    \n    * daemonize:yes\n      \n      redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项 pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。\n    \n    * daemonize:no\n      \n      当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。\n\n 9. 启动测试一下！\n\n * 启动redis服务\n   \n   cd /usr/local/bin\n   redis-server myconfig/redis.conf\n   \n   \n   1\n   2\n   \n\n * redis客户端连接\n   \n      redis-cli -p 6379\n   \n   \n   1\n   \n   \n   观察地址的变化，如果连接成功，是直接连上的，redis默认端口号 6379\n   \n   \n\n * 执行ping、get和set操作、退出\n   \n      127.0.0.1:6379> ping\n      pong\n      127.0.0.1:6379> get hello\n      (nil)\n      127.0.0.1:6379> set hello zhiyuan\n      ok\n      127.0.0.1:6379> get hello\n      "zhiyuan"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   \n\n * 关闭连接\n   \n      127.0.0.1:6379> shutdown\n      not connected> exit\n   \n   \n   1\n   2\n   \n\n可以使用指令ps -ef|grep redis显示系统当前redis 进程信息，查看开启和关闭连接的变化\n\n\n# 基础知识说明\n\n\n# redis压力测试\n\nredis-benchmark是官方自带的redis性能测试工具，可以有效的测试redis服务的性能。\n\nredis 性能测试工具可选参数如下所示：\n\n序号   选项      描述                                  默认值\n1    -h      指定服务器主机名                            127.0.0.1\n2    -p      指定服务器端口                             6379\n3    -s      指定服务器 socket                        \n4    -c      指定并发连接数                             50\n5    -n      指定请求数                               10000\n6    -d      以字节的形式指定 set/get 值的数据大小             2\n7    -k      1=keep alive 0=reconnect            1\n8    -r      set/get/incr 使用随机 key, sadd 使用随机值   \n9    -p      通过管道传输 numreq 请求                    1\n10   -q      强制退出 redis。仅显示 query/sec 值          \n11   --csv   以 csv 格式输出                          \n12   -l      生成循环，永久执行测试                         \n13   -t      仅运行以逗号分隔的测试命令列表。                    \n14   -i      idle 模式。仅打开 n 个 idle 连接并等待。         \n\n# 测试：100个并发连接，100000个请求，检测host为localhost 端口为6379的redis服务器性能\ncd  /usr/local/bin\nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n\n\n1\n2\n3\n\n\n参考资料：https://www.runoob.com/redis/redis-benchmarks.html\n\n\n# 基本数据库常识\n\n默认16个数据库，类似数组下标从零开始，初始默认使用零号库\n\n查看 redis.conf ，里面有默认的配置\n\n# set the number of databases. the default database is db 0, you can select\n# a different one on a per-connection basis using select <dbid> where\n# dbid is a number between 0 and \'databases\'-1\ndatabases 16\n\n\n1\n2\n3\n4\n\n\nselect命令切换数据库\n\n127.0.0.1:6379> select 7\nok\n127.0.0.1:6379[7]>\n# 不同的库可以存不同的数据\n\n\n1\n2\n3\n4\n\n\ndbsize查看当前数据库的key的数量\n\n127.0.0.1:6379> select 7\nok\n127.0.0.1:6379[7]> dbsize\n(integer) 0\n127.0.0.1:6379[7]> select 0\nok\n127.0.0.1:6379> dbsize\n(integer) 5\n127.0.0.1:6379> keys * # 查看具体的key\n1) "counter:__rand_int__"\n2) "mylist"\n3) "k1"\n4) "myset:__rand_int__"\n5) "key:__rand_int__"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nflushdb：清空当前库\n\nflushall：清空全部的库\n\n127.0.0.1:6379> dbsize\n(integer) 5\n127.0.0.1:6379> flushdb\nok\n127.0.0.1:6379> dbsize\n(integer) 0\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 关于redis的单线程\n\n注：6.x版本有多线程，一般用不到，单线程足够应对\n\n我们首先要明白，redis很快！官方表示，因为redis是基于内存的操作，cpu不是redis的瓶颈，redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且cpu不会成为瓶颈，那就 顺理成章地采用单线程的方案了！\n\nredis采用的是基于内存的采用的是单进程单线程模型的 kv 数据库，由c语言编写，官方提供的数据是可以达到100000+的qps（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 kv 数据库 memcached 差！\n\nredis为什么这么快？\n\nredis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为 多线程的本质就是 cpu 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切 换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个cpu 绑定一块内存 的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个cpu上完成的，所以它是单线程处 理这个事。在内存的情况下，这个方案就是最佳方案。\n\n因为一次cpu上下文的切换大概在 1500ns 左右。从内存中读取 1mb 的连续数据，耗时大约为 250us， 假设1mb的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns * 1000 = 1500us ，我单线程的读完1mb数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据的时间。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Redis - 三种特殊数据类型",frontmatter:{title:"Redis - 三种特殊数据类型",date:"2021-05-17T16:12:21.000Z",permalink:"/pages/5898ab/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/03.%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"03.数据库/10.Redis/03.三种特殊数据类型.md",key:"v-7a1e2428",path:"/pages/5898ab/",headers:[{level:2,title:"三种特殊数据类型",slug:"三种特殊数据类型",normalizedTitle:"三种特殊数据类型",charIndex:2},{level:3,title:"GEO地理位置",slug:"geo地理位置",normalizedTitle:"geo地理位置",charIndex:15},{level:4,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:26},{level:4,title:"常用指令",slug:"常用指令",normalizedTitle:"常用指令",charIndex:271},{level:3,title:"HyperLogLog",slug:"hyperloglog",normalizedTitle:"hyperloglog",charIndex:3929},{level:3,title:"BitMap",slug:"bitmap",normalizedTitle:"bitmap",charIndex:5024},{level:4,title:"简介",slug:"简介-2",normalizedTitle:"简介",charIndex:26},{level:4,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:95}],headersStr:"三种特殊数据类型 GEO地理位置 简介 常用指令 HyperLogLog BitMap 简介 操作",content:'# 三种特殊数据类型\n\n\n# GEO地理位置\n\n# 简介\n\nRedis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为 zset。\n\nGEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、 georadiusbymember、gethash\n\n官方文档：https://www.redis.net.cn/order/3685.html\n\n# 常用指令\n\n1、geoadd\n\n语法：geoadd key longitude latitude member ...\n\n将给定的空间元素(经度、纬度、名字)添加到指定的键里面。 这些数据会以有序集的形式被储存在键里面，从而使得georadius和georadiusbymember这样的 命令可以在之后通过位置查询取得这些元素。 geoadd命令以标准的x,y格式接受参数，所以用户必须先输入经度，然后再输入纬度。 geoadd能够记录的坐标是有限的：非常接近两极的区域无法被索引。 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间 当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。\n\n测试：百度搜索经纬度查询，模拟真实数据\n\n127.0.0.1:6379> geoadd china:city 116.23 40.22 北京\n(integer) 1\n127.0.0.1:6379> geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21 30.20 杭州\n(integer) 3\n127.0.0.1:6379> geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02 30.58 武汉\n(integer) 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、geopos\n\n语法：geopos key member [member...]\n\n从key里返回所有给定位置元素的位置（经度和纬度）\n\n127.0.0.1:6379> geopos china:city 北京\n1) 1) "116.23000055551528931"\n2) "40.2200010338739844"\n127.0.0.1:6379> geopos china:city 上海 重庆\n1) 1) "121.48000091314315796"\n2) "31.40000025319353938"\n2) 1) "106.54000014066696167"\n2) "29.39999880018641676"\n127.0.0.1:6379> geopos china:city 新疆\n1) (nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n3、geodist\n\n语法：geodist key member1 member2 [unit]\n\n返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在，那么命令返回空值\n\n指定单位的参数unit必须是以下单位的其中一个：\n\n * m表示单位为米\n * km表示单位为千米\n * mi表示单位为英里\n * ft表示单位为英尺\n\n如果用户没有显式地指定单位参数，那么geodist默认使用 米 作为单位。\n\ngeodist命令在计算距离时会假设地球为完美的球形，在极限情况下，这一假设最大会造成0.5%的误差。\n\n127.0.0.1:6379> geodist china:city 北京 上海\n"1088785.4302"\n127.0.0.1:6379> geodist china:city 北京 上海 km\n"1088.7854"\n127.0.0.1:6379> geodist china:city 重庆 北京 km\n"1491.6716"\n\n\n1\n2\n3\n4\n5\n6\n\n\n4、georadius\n\n语法：\n\ngeoradius key longitude latitude radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]\n\n\n1\n\n\n以给定的经纬度为中心， 找出某一半径内的元素\n\n重新连接 redis-cli，增加参数 --raw ，可以强制输出中文，不然会乱码\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km #乱码\n1) "\\xe9\\x87\\x8d\\xe5\\xba\\x86"\n2) "\\xe8\\xa5\\xbf\\xe5\\xae\\x89"\n127.0.0.1:6379> exit\n[root@localhost bin]#  redis-cli --raw -p 6379\n# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市\n127.0.0.1:6379> georadius china:city 100 30 1000 km\n重庆\n西安\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nwithdist 返回位置名称和中心距离\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km withdist\n重庆\n635.2850\n西安\n963.3171\n\n\n1\n2\n3\n4\n5\n\n\nwithcoord 返回位置名称、经纬度\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord\n重庆\n106.54000014066696167\n29.39999880018641676\n西安\n108.92999857664108276\n34.23000121926852302\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nwithdist withcoord 返回位置名称、距离、经纬度，count 限定寻找个数\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count 1\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count 2\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n西安\n963.3171\n108.92999857664108276\n34.23000121926852302\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n5、georadiusbymember\n\n语法：\n\ngeoradiusbymember key member radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]\n\n\n1\n\n\n找出位于指定范围内的元素，中心点是由给定的位置元素决定\n\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city 北京 1000 km\n北京\n西安\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city 上海 400 km\n杭州\n上海\n\n\n1\n2\n3\n4\n5\n6\n\n\n6、geohash\n\n语法：geohash key member [member...]\n\nRedis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确，两个字符串越相似表示距离越近。\n\n127.0.0.1:6379> geohash china:city 北京 重庆\nwx4sucu47r0\nwm5z22h53v0\n127.0.0.1:6379> geohash china:city 北京 上海\nwx4sucu47r0\nwtw6sk5n300\n\n\n1\n2\n3\n4\n5\n6\n\n\nzrem\n\nGEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。\n\n127.0.0.1:6379> geoadd china:city 116.23 40.22 beijing\n1\n127.0.0.1:6379> zrange china:city 0 -1 # 查看全部的元素\n重庆\n西安\n深圳\n武汉\n杭州\n上海\nbeijing\n北京\n127.0.0.1:6379> zrem china:city beijing # 移除元素\n1\n127.0.0.1:6379> zrem china:city 北京 # 移除元素\n1\n127.0.0.1:6379> zrange china:city 0 -1\n重庆\n西安\n深圳\n武汉\n杭州\n上海\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# HyperLogLog\n\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\n\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\nHyperLogLog则是一种算法，它提供了不精确的去重计数方案。\n\n举个栗子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。\n\n什么是基数？\n\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素的数量)为5。\n\n基数估计就是在误差可接受的范围内，快速计算基数。\n\n基本命令\n\n序号   命令及描述\n1    [PFADD key element element ...]\n     添加指定元素到 HyperLogLog 中。\n2    [PFCOUNT key key ...]\n     返回给定 HyperLogLog 的基数估算值。\n3    [PFMERGE destkey sourcekey sourcekey ...]\n     将多个 HyperLogLog 合并为一个 HyperLogLog，并集计算\n\n127.0.0.1:6379> PFADD mykey a b c d e f g h i j\n1\n127.0.0.1:6379> PFCOUNT mykey\n10\n127.0.0.1:6379> PFADD mykey2 i j z x c v b n m\n1\n127.0.0.1:6379> PFMERGE mykey3 mykey mykey2\nOK\n127.0.0.1:6379> PFCOUNT mykey3\n15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# BitMap\n\n# 简介\n\n在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如 需要记录用户一年的打卡情况，打卡了是1， 没有打卡是0，如果使用普通的 key/value存储，则要记录 365条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构， Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap 表示的形式大概如下：0101000111000111...........................，这样有什么好处呢？当然就是节约内存 了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。\n\nBitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。Redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个 bitmap 相关命令。\n\n# 操作\n\n1、setbit 设置操作\n\nSETBIT key offset value : 设置 key 的第 offset 位为value (1或0)\n\n使用 bitmap 来记录上述事例中一周的打卡记录如下所示：\n\n周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）\n\n127.0.0.1:6379> setbit sign 0 1\n0\n127.0.0.1:6379> setbit sign 1 0\n0\n127.0.0.1:6379> setbit sign 2 0\n0\n127.0.0.1:6379> setbit sign 3 1\n0\n127.0.0.1:6379> setbit sign 4 1\n0\n127.0.0.1:6379> setbit sign 5 0\n0\n127.0.0.1:6379> setbit sign 6 0\n0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n2、getbit 获取操作\n\nGETBIT key offset 获取offset设置的值，未设置过默认返回0\n\n127.0.0.1:6379> getbit sign 3 # 查看周四是否打卡\n1\n127.0.0.1:6379> getbit sign 6 # 查看周七是否打卡\n0\n\n\n1\n2\n3\n4\n\n\n3、bitcount 统计操作\n\nbitcount key [start, end] 统计 key 上位为1的个数\n\n统计这周打卡的记录，可以看到只有3天是打卡的状态：\n\n127.0.0.1:6379> bitcount sign\n3\n\n\n1\n2\n',normalizedContent:'# 三种特殊数据类型\n\n\n# geo地理位置\n\n# 简介\n\nredis 的 geo 特性在 redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为 zset。\n\ngeo 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、 georadiusbymember、gethash\n\n官方文档：https://www.redis.net.cn/order/3685.html\n\n# 常用指令\n\n1、geoadd\n\n语法：geoadd key longitude latitude member ...\n\n将给定的空间元素(经度、纬度、名字)添加到指定的键里面。 这些数据会以有序集的形式被储存在键里面，从而使得georadius和georadiusbymember这样的 命令可以在之后通过位置查询取得这些元素。 geoadd命令以标准的x,y格式接受参数，所以用户必须先输入经度，然后再输入纬度。 geoadd能够记录的坐标是有限的：非常接近两极的区域无法被索引。 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间 当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。\n\n测试：百度搜索经纬度查询，模拟真实数据\n\n127.0.0.1:6379> geoadd china:city 116.23 40.22 北京\n(integer) 1\n127.0.0.1:6379> geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21 30.20 杭州\n(integer) 3\n127.0.0.1:6379> geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02 30.58 武汉\n(integer) 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、geopos\n\n语法：geopos key member [member...]\n\n从key里返回所有给定位置元素的位置（经度和纬度）\n\n127.0.0.1:6379> geopos china:city 北京\n1) 1) "116.23000055551528931"\n2) "40.2200010338739844"\n127.0.0.1:6379> geopos china:city 上海 重庆\n1) 1) "121.48000091314315796"\n2) "31.40000025319353938"\n2) 1) "106.54000014066696167"\n2) "29.39999880018641676"\n127.0.0.1:6379> geopos china:city 新疆\n1) (nil)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n3、geodist\n\n语法：geodist key member1 member2 [unit]\n\n返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在，那么命令返回空值\n\n指定单位的参数unit必须是以下单位的其中一个：\n\n * m表示单位为米\n * km表示单位为千米\n * mi表示单位为英里\n * ft表示单位为英尺\n\n如果用户没有显式地指定单位参数，那么geodist默认使用 米 作为单位。\n\ngeodist命令在计算距离时会假设地球为完美的球形，在极限情况下，这一假设最大会造成0.5%的误差。\n\n127.0.0.1:6379> geodist china:city 北京 上海\n"1088785.4302"\n127.0.0.1:6379> geodist china:city 北京 上海 km\n"1088.7854"\n127.0.0.1:6379> geodist china:city 重庆 北京 km\n"1491.6716"\n\n\n1\n2\n3\n4\n5\n6\n\n\n4、georadius\n\n语法：\n\ngeoradius key longitude latitude radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]\n\n\n1\n\n\n以给定的经纬度为中心， 找出某一半径内的元素\n\n重新连接 redis-cli，增加参数 --raw ，可以强制输出中文，不然会乱码\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km #乱码\n1) "\\xe9\\x87\\x8d\\xe5\\xba\\x86"\n2) "\\xe8\\xa5\\xbf\\xe5\\xae\\x89"\n127.0.0.1:6379> exit\n[root@localhost bin]#  redis-cli --raw -p 6379\n# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市\n127.0.0.1:6379> georadius china:city 100 30 1000 km\n重庆\n西安\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nwithdist 返回位置名称和中心距离\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km withdist\n重庆\n635.2850\n西安\n963.3171\n\n\n1\n2\n3\n4\n5\n\n\nwithcoord 返回位置名称、经纬度\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord\n重庆\n106.54000014066696167\n29.39999880018641676\n西安\n108.92999857664108276\n34.23000121926852302\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nwithdist withcoord 返回位置名称、距离、经纬度，count 限定寻找个数\n\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count 1\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n127.0.0.1:6379> georadius china:city 100 30 1000 km withcoord withdist count 2\n重庆\n635.2850\n106.54000014066696167\n29.39999880018641676\n西安\n963.3171\n108.92999857664108276\n34.23000121926852302\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n5、georadiusbymember\n\n语法：\n\ngeoradiusbymember key member radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]\n\n\n1\n\n\n找出位于指定范围内的元素，中心点是由给定的位置元素决定\n\n127.0.0.1:6379> georadiusbymember china:city 北京 1000 km\n北京\n西安\n127.0.0.1:6379> georadiusbymember china:city 上海 400 km\n杭州\n上海\n\n\n1\n2\n3\n4\n5\n6\n\n\n6、geohash\n\n语法：geohash key member [member...]\n\nredis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确，两个字符串越相似表示距离越近。\n\n127.0.0.1:6379> geohash china:city 北京 重庆\nwx4sucu47r0\nwm5z22h53v0\n127.0.0.1:6379> geohash china:city 北京 上海\nwx4sucu47r0\nwtw6sk5n300\n\n\n1\n2\n3\n4\n5\n6\n\n\nzrem\n\ngeo没有提供删除成员的命令，但是因为geo的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。\n\n127.0.0.1:6379> geoadd china:city 116.23 40.22 beijing\n1\n127.0.0.1:6379> zrange china:city 0 -1 # 查看全部的元素\n重庆\n西安\n深圳\n武汉\n杭州\n上海\nbeijing\n北京\n127.0.0.1:6379> zrem china:city beijing # 移除元素\n1\n127.0.0.1:6379> zrem china:city 北京 # 移除元素\n1\n127.0.0.1:6379> zrange china:city 0 -1\n重庆\n西安\n深圳\n武汉\n杭州\n上海\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# hyperloglog\n\nredis 在 2.8.9 版本添加了 hyperloglog 结构。\n\nredis hyperloglog 是用来做基数统计的算法，hyperloglog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n\n在 redis 里面，每个 hyperloglog 键只需要花费 12 kb 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\nhyperloglog则是一种算法，它提供了不精确的去重计数方案。\n\n举个栗子：假如我要统计网页的uv（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用set来保存用户id，然后统计set中的元素数量来获取页面uv。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用redis的hyperloglog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计uv这种不需要很精确的数据是可以忽略不计的。\n\n什么是基数？\n\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素的数量)为5。\n\n基数估计就是在误差可接受的范围内，快速计算基数。\n\n基本命令\n\n序号   命令及描述\n1    [pfadd key element element ...]\n     添加指定元素到 hyperloglog 中。\n2    [pfcount key key ...]\n     返回给定 hyperloglog 的基数估算值。\n3    [pfmerge destkey sourcekey sourcekey ...]\n     将多个 hyperloglog 合并为一个 hyperloglog，并集计算\n\n127.0.0.1:6379> pfadd mykey a b c d e f g h i j\n1\n127.0.0.1:6379> pfcount mykey\n10\n127.0.0.1:6379> pfadd mykey2 i j z x c v b n m\n1\n127.0.0.1:6379> pfmerge mykey3 mykey mykey2\nok\n127.0.0.1:6379> pfcount mykey3\n15\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# bitmap\n\n# 简介\n\n在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如 需要记录用户一年的打卡情况，打卡了是1， 没有打卡是0，如果使用普通的 key/value存储，则要记录 365条记录，如果用户量很大，需要的空间也会很大，所以 redis 提供了 bitmap 位图这中数据结构， bitmap 就是通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 bitmap 表示的形式大概如下：0101000111000111...........................，这样有什么好处呢？当然就是节约内存 了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可。\n\nbitmap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。redis 从 2.2 版本之后新增了setbit, getbit, bitcount 等几个 bitmap 相关命令。\n\n# 操作\n\n1、setbit 设置操作\n\nsetbit key offset value : 设置 key 的第 offset 位为value (1或0)\n\n使用 bitmap 来记录上述事例中一周的打卡记录如下所示：\n\n周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）\n\n127.0.0.1:6379> setbit sign 0 1\n0\n127.0.0.1:6379> setbit sign 1 0\n0\n127.0.0.1:6379> setbit sign 2 0\n0\n127.0.0.1:6379> setbit sign 3 1\n0\n127.0.0.1:6379> setbit sign 4 1\n0\n127.0.0.1:6379> setbit sign 5 0\n0\n127.0.0.1:6379> setbit sign 6 0\n0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n2、getbit 获取操作\n\ngetbit key offset 获取offset设置的值，未设置过默认返回0\n\n127.0.0.1:6379> getbit sign 3 # 查看周四是否打卡\n1\n127.0.0.1:6379> getbit sign 6 # 查看周七是否打卡\n0\n\n\n1\n2\n3\n4\n\n\n3、bitcount 统计操作\n\nbitcount key [start, end] 统计 key 上位为1的个数\n\n统计这周打卡的记录，可以看到只有3天是打卡的状态：\n\n127.0.0.1:6379> bitcount sign\n3\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2021/09/11, 2:09:00",lastUpdatedTimestamp:1631327124e3},{title:"Redis - 事务",frontmatter:{title:"Redis - 事务",date:"2021-05-17T16:13:06.000Z",permalink:"/pages/41f31b/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/04.Redis%E4%BA%8B%E5%8A%A1.html",relativePath:"03.数据库/10.Redis/04.Redis事务.md",key:"v-6971b032",path:"/pages/41f31b/",headers:[{level:2,title:"Redis事务",slug:"redis事务",normalizedTitle:"redis事务",charIndex:2},{level:3,title:"理论",slug:"理论",normalizedTitle:"理论",charIndex:14},{level:3,title:"实践",slug:"实践",normalizedTitle:"实践",charIndex:609},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:2277}],headersStr:"Redis事务 理论 实践 小结",content:'# Redis事务\n\n\n# 理论\n\nRedis事务的概念：\n\nRedis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事 务执行命令序列中。\n\n总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。\n\nRedis事务没有隔离级别的概念：\n\n批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！\n\nRedis不保证原子性：\n\nRedis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其 余的命令仍会被执行。\n\nRedis事务的三个阶段：\n\n * 开始事务\n * 命令入队\n * 执行事务\n\nRedis事务相关命令：\n\n序号   命令及描述\n1    DISCARD\n     取消事务，放弃执行事务块内的所有命令。\n2    EXEC\n     执行所有事务块内的命令。\n3    MULTI\n     标记一个事务块的开始。\n4    UNWATCH\n     取消 WATCH 命令对所有 key 的监视。\n5    WATCH key [key ...]\n     监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。（\n     类似乐观锁 ）\n\n\n# 实践\n\n正常执行\n\n\n\n放弃事务\n\n\n\n若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行\n\n\n\n若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。\n\n\n\nWatch 监控\n\n * 悲观锁：\n   \n   悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。\n\n * 乐观锁：\n   \n   乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会 锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能 执行更新。\n\n测试：\n\n1、初始化信用卡可用余额和欠额\n\n127.0.0.1:6379> set balance 100\nOK\n127.0.0.1:6379> set debt 0\nOK\n\n\n1\n2\n3\n4\n\n\n2、使用watch检测balance，事务期间balance数据未变动，事务执行成功\n\n127.0.0.1:6379> watch balance\nOK\n127.0.0.1:6379> MULTI\t#开启事务\nOK\n127.0.0.1:6379> decrby balance 20\t#可用余额-20\nQUEUED\n127.0.0.1:6379> incrby debt 20\t#欠款+20\nQUEUED\n127.0.0.1:6379> exec\t#执行事务\n1) (integer) 80\n2) (integer) 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3、使用watch检测balance，若事务期间balance数据变动，事务执行失败！\n\n# 窗口一\n127.0.0.1:6379> watch balance\t#监视balance\nOK\n127.0.0.1:6379> MULTI # 执行完毕后，执行窗口二代码测试\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\nQUEUED\n127.0.0.1:6379> exec # 修改失败！因为被监视的balance值改变\n(nil)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n窗口二\n\n# 窗口二\n127.0.0.1:6379> get balance\n"80"\n127.0.0.1:6379> set balance 200\nOK\n\n\n1\n2\n3\n4\n5\n\n\n窗口一：出现问题后放弃监视，然后重来！\n\n127.0.0.1:6379> UNWATCH # 放弃监视，这是取消所有的监视\nOK\n127.0.0.1:6379> watch balance\t#监视\nOK\n127.0.0.1:6379> MULTI\t#事务\nOK\n127.0.0.1:6379> decrby balance 20\nQUEUED\n127.0.0.1:6379> incrby debt 20\nQUEUED\n127.0.0.1:6379> exec # 成功！\n1) (integer) 180\n2) (integer) 40\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n说明：\n\n一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。\n\n故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。\n\n\n# 小结\n\nwatch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。',normalizedContent:'# redis事务\n\n\n# 理论\n\nredis事务的概念：\n\nredis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事 务执行命令序列中。\n\n总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。\n\nredis事务没有隔离级别的概念：\n\n批量操作在发送 exec 命令前被放入队列缓存，并不会被实际执行！\n\nredis不保证原子性：\n\nredis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其 余的命令仍会被执行。\n\nredis事务的三个阶段：\n\n * 开始事务\n * 命令入队\n * 执行事务\n\nredis事务相关命令：\n\n序号   命令及描述\n1    discard\n     取消事务，放弃执行事务块内的所有命令。\n2    exec\n     执行所有事务块内的命令。\n3    multi\n     标记一个事务块的开始。\n4    unwatch\n     取消 watch 命令对所有 key 的监视。\n5    watch key [key ...]\n     监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。（\n     类似乐观锁 ）\n\n\n# 实践\n\n正常执行\n\n\n\n放弃事务\n\n\n\n若在事务队列中存在命令性错误（类似于java编译性错误），则执行exec命令时，所有命令都不会执行\n\n\n\n若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行exec命令时，其他正确命令会被执行，错误命令抛出异常。\n\n\n\nwatch 监控\n\n * 悲观锁：\n   \n   悲观锁(pessimistic lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。\n\n * 乐观锁：\n   \n   乐观锁(optimistic lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会 锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能 执行更新。\n\n测试：\n\n1、初始化信用卡可用余额和欠额\n\n127.0.0.1:6379> set balance 100\nok\n127.0.0.1:6379> set debt 0\nok\n\n\n1\n2\n3\n4\n\n\n2、使用watch检测balance，事务期间balance数据未变动，事务执行成功\n\n127.0.0.1:6379> watch balance\nok\n127.0.0.1:6379> multi\t#开启事务\nok\n127.0.0.1:6379> decrby balance 20\t#可用余额-20\nqueued\n127.0.0.1:6379> incrby debt 20\t#欠款+20\nqueued\n127.0.0.1:6379> exec\t#执行事务\n1) (integer) 80\n2) (integer) 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3、使用watch检测balance，若事务期间balance数据变动，事务执行失败！\n\n# 窗口一\n127.0.0.1:6379> watch balance\t#监视balance\nok\n127.0.0.1:6379> multi # 执行完毕后，执行窗口二代码测试\nok\n127.0.0.1:6379> decrby balance 20\nqueued\n127.0.0.1:6379> incrby debt 20\nqueued\n127.0.0.1:6379> exec # 修改失败！因为被监视的balance值改变\n(nil)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n窗口二\n\n# 窗口二\n127.0.0.1:6379> get balance\n"80"\n127.0.0.1:6379> set balance 200\nok\n\n\n1\n2\n3\n4\n5\n\n\n窗口一：出现问题后放弃监视，然后重来！\n\n127.0.0.1:6379> unwatch # 放弃监视，这是取消所有的监视\nok\n127.0.0.1:6379> watch balance\t#监视\nok\n127.0.0.1:6379> multi\t#事务\nok\n127.0.0.1:6379> decrby balance 20\nqueued\n127.0.0.1:6379> incrby debt 20\nqueued\n127.0.0.1:6379> exec # 成功！\n1) (integer) 180\n2) (integer) 40\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n说明：\n\n一但执行 exec 开启事务的执行后，无论事务使用执行成功， warch 对变量的监控都将被取消。\n\n故当事务执行失败后，需重新执行watch命令对变量进行监控，并开启新的事务进行操作。\n\n\n# 小结\n\nwatch指令类似于乐观锁，在事务提交时，如果watch监控的多个key中任何key的值已经被其他客户端更改，则使用exec执行事务时，事务队列将不会被执行，同时返回nullmulti-bulk应答以通知调用者事务执行失败。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Redis - Java",frontmatter:{title:"Redis - Java",date:"2021-05-17T16:13:40.000Z",permalink:"/pages/216cfe/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/05.Redis%20-%20Java.html",relativePath:"03.数据库/10.Redis/05.Redis - Java.md",key:"v-597ac620",path:"/pages/216cfe/",headers:[{level:2,title:"Jedis",slug:"jedis",normalizedTitle:"jedis",charIndex:2},{level:3,title:"测试ping",slug:"测试ping",normalizedTitle:"测试ping",charIndex:82},{level:3,title:"常用API",slug:"常用api",normalizedTitle:"常用api",charIndex:786},{level:3,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:11810},{level:2,title:"SpringBoot整合",slug:"springboot整合",normalizedTitle:"springboot整合",charIndex:12899},{level:3,title:"基础使用",slug:"基础使用",normalizedTitle:"基础使用",charIndex:12916},{level:3,title:"序列化config",slug:"序列化config",normalizedTitle:"序列化config",charIndex:13794},{level:3,title:"redis工具类",slug:"redis工具类",normalizedTitle:"redis工具类",charIndex:17823}],headersStr:"Jedis 测试ping 常用API 事务 SpringBoot整合 基础使用 序列化config redis工具类",content:'# Jedis\n\nJedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能 写成漂亮的代码\n\n\n# 测试ping\n\n前提打开了redis服务。\n\n1、新建一个普通的Maven项目\n\n2、导入redis的依赖！\n\n<dependencies>\n    \x3c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\x3e\n    <dependency>\n        <groupId>redis.clients</groupId>\n        <artifactId>jedis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>1.2.75</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3、编写测试代码\n\npublic class Ping {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        //查看服务是否运行\n        System.out.println(jedis.ping());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 常用API\n\n基本操作\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("127.0.0.1", 6379);\n\n    //验证密码，如果没有设置密码这段代码省略\n    // jedis.auth("password");\n\n    jedis.connect(); //连接\n    jedis.disconnect(); //断开连接\n    jedis.flushAll(); //清空所有的key\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n对key操作的命令\n\npublic class TestKey {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        \n        System.out.println("清空数据：" + jedis.flushDB());\n        System.out.println("判断某个键是否存在：" + jedis.exists("username"));\n        System.out.println("新增<\'username\',\'zhiyuan\'>的键值对：" + jedis.set("username", "zhiyuan"));\n        System.out.println("新增<\'password\',\'password\'>的键值对：" + jedis.set("password", "password"));\n\n        System.out.print("系统中所有的键如下：");\n        Set<String> keys = jedis.keys("*");\n        System.out.println(keys);\n\n        System.out.println("删除键password:" + jedis.del("password"));\n        System.out.println("判断键password是否存在：" + jedis.exists("password"));\n        System.out.println("查看键username所存储的值的类型：" + jedis.type("username"));\n        System.out.println("随机返回key空间的一个：" + jedis.randomKey());\n        System.out.println("重命名key：" + jedis.rename("username", "name"));\n        System.out.println("取出改后的name：" + jedis.get("name"));\n        System.out.println("按索引查询：" + jedis.select(0));\n        System.out.println("删除当前选择数据库中的所有key：" + jedis.flushDB());\n        System.out.println("返回当前数据库中key的数目：" + jedis.dbSize());\n        System.out.println("删除所有数据库中的所有key：" + jedis.flushAll());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n对String操作的命令\n\npublic class TestString {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n\n        jedis.flushDB();\n        System.out.println("===========增加数据===========");\n        System.out.println(jedis.set("key1", "value1"));\n        System.out.println(jedis.set("key2", "value2"));\n        System.out.println(jedis.set("key3", "value3"));\n\n        System.out.println("删除键key2:" + jedis.del("key2"));\n        System.out.println("获取键key2:" + jedis.get("key2"));\n        System.out.println("修改key1:" + jedis.set("key1", "value1Changed"));\n        System.out.println("获取key1的值：" + jedis.get("key1"));\n        System.out.println("在key3后面加入值：" + jedis.append("key3", "End"));\n        System.out.println("key3的值：" + jedis.get("key3"));\n        System.out.println("增加多个键值对：" + jedis.mset("key01", "value01", "key02", "value02", "key03", "value03"));\n        System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n        System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03", "key04"));\n        System.out.println("删除多个键值对：" + jedis.del("key01", "key02"));\n        System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n\n        jedis.flushDB();\n\n        System.out.println("===========新增键值对防止覆盖原先值==============");\n        System.out.println(jedis.setnx("key1", "value1"));\n        System.out.println(jedis.setnx("key2", "value2"));\n        System.out.println(jedis.setnx("key2", "value2-new"));\n        System.out.println(jedis.get("key1"));\n        System.out.println(jedis.get("key2"));\n        System.out.println("===========新增键值对并设置有效时间=============");\n        System.out.println(jedis.setex("key3", 2, "value3"));\n        System.out.println(jedis.get("key3"));\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(jedis.get("key3"));\n        System.out.println("===========获取原值，更新为新值==========");\n        System.out.println(jedis.getSet("key2", "key2GetSet"));\n        System.out.println(jedis.get("key2"));\n        System.out.println("获得key2的值的字串：" + jedis.getrange("key2", 2,4));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n对List操作命令\n\npublic class TestList {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        System.out.println("===========添加一个list===========");\n        jedis.lpush("collections", "ArrayList", "Vector", "Stack", "HashMap", "WeakHashMap", "LinkedHashMap");\n        jedis.lpush("collections", "HashSet");\n        jedis.lpush("collections", "TreeSet");\n        jedis.lpush("collections", "TreeMap");\n        System.out.println("collections的内容：" + jedis.lrange("collections", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n        System.out.println("collections区间0-3的元素：" + jedis.lrange("collections", 0, 3));\n        System.out.println("===============================");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        System.out.println("删除指定元素个数：" + jedis.lrem("collections", 2,\n                "HashMap"));\n        System.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        System.out.println("删除下表0-3区间之外的元素：" + jedis.ltrim("collections", 0, 3));\n        System.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        System.out.println("collections列表出栈（左端）：" + jedis.lpop("collections"));\n        System.out.println("collections的内容：" + jedis.lrange("collections", 0, -1));\n        System.out.println("collections添加元素，从列表右端，与lpush相对应：" + jedis.rpush("collections", "EnumMap"));\n        System.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        System.out.println("collections列表出栈（右端）：" + jedis.rpop("collections"));\n        System.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        System.out.println("修改collections指定下标1的内容：" + jedis.lset("collections", 1, "LinkedArrayList"));\n        System.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        System.out.println("===============================");\n        System.out.println("collections的长度：" + jedis.llen("collections"));\n        System.out.println("获取collections下标为2的元素：" + jedis.lindex("collections", 2));\n        System.out.println("===============================");\n        jedis.lpush("sortedList", "3", "6", "2", "0", "7", "4");\n        System.out.println("sortedList排序前：" + jedis.lrange("sortedList", 0,\n                -1));\n        System.out.println(jedis.sort("sortedList"));\n        System.out.println("sortedList排序后：" + jedis.lrange("sortedList", 0, -1));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n对Set的操作命令\n\npublic class TestSet {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        System.out.println("============向集合中添加元素（不重复）============");\n        System.out.println(jedis.sadd("eleSet", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n        System.out.println(jedis.sadd("eleSet", "e6"));\n        System.out.println(jedis.sadd("eleSet", "e6"));\n        System.out.println("eleSet的所有元素为：" + jedis.smembers("eleSet"));\n        System.out.println("删除一个元素e0：" + jedis.srem("eleSet", "e0"));\n\n        System.out.println("eleSet的所有元素为：" + jedis.smembers("eleSet"));\n        System.out.println("删除两个元素e7和e6：" + jedis.srem("eleSet", "e7", "e6"));\n        System.out.println("eleSet的所有元素为：" + jedis.smembers("eleSet"));\n        System.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleSet"));\n        System.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleSet"));\n        System.out.println("eleSet的所有元素为：" + jedis.smembers("eleSet"));\n        System.out.println("eleSet中包含元素的个数：" + jedis.scard("eleSet"));\n        System.out.println("e3是否在eleSet中：" + jedis.sismember("eleSet", "e3"));\n        System.out.println("e1是否在eleSet中：" + jedis.sismember("eleSet", "e1"));\n        System.out.println("e1是否在eleSet中：" + jedis.sismember("eleSet", "e5"));\n        System.out.println("=================================");\n        System.out.println(jedis.sadd("eleSet1", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n        System.out.println(jedis.sadd("eleSet2","e1", "e2", "e4", "e3", "e0", "e8"));\n        System.out.println("将eleSet1中删除e1并存入eleSet3中：" + jedis.smove("eleSet1", "eleSet3", "e1"));//移到集合元素\n        System.out.println("将eleSet1中删除e2并存入eleSet3中：" + jedis.smove("eleSet1", "eleSet3", "e2"));\n        System.out.println("eleSet1中的元素：" + jedis.smembers("eleSet1"));\n        System.out.println("eleSet3中的元素：" + jedis.smembers("eleSet3"));\n        System.out.println("============集合运算=================");\n        System.out.println("eleSet1中的元素：" + jedis.smembers("eleSet1"));\n        System.out.println("eleSet2中的元素：" + jedis.smembers("eleSet2"));\n        System.out.println("eleSet1和eleSet2的交集:" + jedis.sinter("eleSet1", "eleSet2"));\n        System.out.println("eleSet1和eleSet2的并集:" + jedis.sunion("eleSet1", "eleSet2"));\n        System.out.println("eleSet1和eleSet2的差集:" + jedis.sdiff("eleSet1", "eleSet2"));//eleSet1中有，eleSet2中没有\n        jedis.sinterstore("eleSet4", "eleSet1", "eleSet2");//求交集并将交集保存到dstkey的集合\n        System.out.println("eleSet4中的元素：" + jedis.smembers("eleSet4"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n对Hash的操作命令\n\npublic class TestHash {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        Map<String, String> map = new HashMap<>();\n        map.put("key1", "value1");\n        map.put("key2", "value2");\n        map.put("key3", "value3");\n        map.put("key4", "value4");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset("hash", map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset("hash", "key5", "value5");\n        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));//return Map<String,String>\n\n        System.out.println("散列hash的所有键为：" + jedis.hkeys("hash"));//returnSet<String>\n        System.out.println("散列hash的所有值为：" + jedis.hvals("hash"));//returnList<String>\n        System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrBy("hash", "key6", 6));\n        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));\n        System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrBy("hash", "key6", 3));\n        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));\n        System.out.println("删除一个或者多个键值对：" + jedis.hdel("hash", "key2"));\n        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));\n        System.out.println("散列hash中键值对的个数：" + jedis.hlen("hash"));\n        System.out.println("判断hash中是否存在key2：" + jedis.hexists("hash", "key2"));\n        System.out.println("判断hash中是否存在key3：" + jedis.hexists("hash", "key3"));\n        System.out.println("获取hash中的值：" + jedis.hmget("hash", "key3"));\n        System.out.println("获取hash中的值：" + jedis.hmget("hash", "key3", "key4"));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 事务\n\npublic class TestMulti {\n    public static void main(String[] args) {\n        //创建客户端连接服务端，redis服务端需要被开启\n        Jedis jedis = new Jedis("127.0.0.1", 6379);\n        jedis.flushDB();\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put("hello", "world");\n        jsonObject.put("name", "java");\n        //开启事务\n        Transaction multi = jedis.multi();\n        String result = jsonObject.toJSONString();\n        try {\n            //向redis存入一条数据\n            multi.set("json", result);\n            //再存入一条数据\n            multi.set("json2", result);\n            //这里引发了异常，用0作为被除数\n            int i = 100 / 0;\n            //如果没有引发异常，执行进入队列的命令\n            multi.exec();\n        } catch (Exception e) {\n            e.printStackTrace();\n            //如果出现异常，回滚\n            multi.discard();\n        } finally {\n            System.out.println(jedis.get("json"));\n            System.out.println(jedis.get("json2"));\n            //最终关闭客户端\n            jedis.close();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# SpringBoot整合\n\n\n# 基础使用\n\n概述：\n\n在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要 那些步骤呢。\n\n1、 JedisPoolConfig (这个是配置连接池)\n\n2、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了以下四种工厂模型：\n\n * JredisConnectionFactory\n * JedisConnectionFactory\n * LettuceConnectionFactory\n * SrpConnectionFactory\n\n3、 RedisTemplate 基本操作\n\n导入依赖\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n说明：在springboot2.x之后，原来使用的jedis被替换成lettuce\n\nyaml配置\n\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n\n\n1\n2\n3\n4\n\n\n测试类中测试\n\n@Autowired\nprivate RedisTemplate<String, String> redisTemplate;\n\n@Test\nvoid contextLoads() {\n    redisTemplate.opsForValue().set("myKey", "myValue");\n    System.out.println(redisTemplate.opsForValue().get("myKey"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 序列化config\n\n创建springboot新项目，安装上面步骤导入依赖\n\n1、分析 RedisAutoConfiguration 自动配置类\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n\n   @Bean\n   @ConditionalOnMissingBean(name = "redisTemplate")\n   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n   public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n      RedisTemplate<Object, Object> template = new RedisTemplate<>();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n   @Bean\n   @ConditionalOnMissingBean\n   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {\n      StringRedisTemplate template = new StringRedisTemplate();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。\n\n但是，这个RedisTemplate的泛型是，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为形式的RedisTemplate。\n\n并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。\n\n看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了， 这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置 RedisTemplate。\n\n用这个配置我们不可以存储对象，否则会报SerializationException，大家可自己试试\n\n2、既然自动配置不好用，就重新配置一个RedisTemplate\n\npackage com.oddfar.config;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        template.setConnectionFactory(factory);\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n//        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); //此方法已过期\n        //新方法\n        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n\n        return template;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n创建User对象，name和age\n\n测试存对象\n\n@SpringBootTest\npublic class RedisTest {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Test\n    void test() {\n        User user = new User("致远",3);\n        redisTemplate.opsForValue().set("user",user);\n        System.out.println(redisTemplate.opsForValue().get("user"));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# redis工具类\n\n使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。\n\n工具类参考博客：\n\nhttps://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html\n\nhttps://www.cnblogs.com/zhzhlong/p/11434284.html',normalizedContent:'# jedis\n\njedis是redis官方推荐的java连接开发工具。要在java开发中使用好redis中间件，必须对jedis熟悉才能 写成漂亮的代码\n\n\n# 测试ping\n\n前提打开了redis服务。\n\n1、新建一个普通的maven项目\n\n2、导入redis的依赖！\n\n<dependencies>\n    \x3c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\x3e\n    <dependency>\n        <groupid>redis.clients</groupid>\n        <artifactid>jedis</artifactid>\n        <version>3.5.2</version>\n    </dependency>\n    <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>fastjson</artifactid>\n        <version>1.2.75</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3、编写测试代码\n\npublic class ping {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        //查看服务是否运行\n        system.out.println(jedis.ping());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 常用api\n\n基本操作\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("127.0.0.1", 6379);\n\n    //验证密码，如果没有设置密码这段代码省略\n    // jedis.auth("password");\n\n    jedis.connect(); //连接\n    jedis.disconnect(); //断开连接\n    jedis.flushall(); //清空所有的key\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n对key操作的命令\n\npublic class testkey {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        \n        system.out.println("清空数据：" + jedis.flushdb());\n        system.out.println("判断某个键是否存在：" + jedis.exists("username"));\n        system.out.println("新增<\'username\',\'zhiyuan\'>的键值对：" + jedis.set("username", "zhiyuan"));\n        system.out.println("新增<\'password\',\'password\'>的键值对：" + jedis.set("password", "password"));\n\n        system.out.print("系统中所有的键如下：");\n        set<string> keys = jedis.keys("*");\n        system.out.println(keys);\n\n        system.out.println("删除键password:" + jedis.del("password"));\n        system.out.println("判断键password是否存在：" + jedis.exists("password"));\n        system.out.println("查看键username所存储的值的类型：" + jedis.type("username"));\n        system.out.println("随机返回key空间的一个：" + jedis.randomkey());\n        system.out.println("重命名key：" + jedis.rename("username", "name"));\n        system.out.println("取出改后的name：" + jedis.get("name"));\n        system.out.println("按索引查询：" + jedis.select(0));\n        system.out.println("删除当前选择数据库中的所有key：" + jedis.flushdb());\n        system.out.println("返回当前数据库中key的数目：" + jedis.dbsize());\n        system.out.println("删除所有数据库中的所有key：" + jedis.flushall());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n对string操作的命令\n\npublic class teststring {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n\n        jedis.flushdb();\n        system.out.println("===========增加数据===========");\n        system.out.println(jedis.set("key1", "value1"));\n        system.out.println(jedis.set("key2", "value2"));\n        system.out.println(jedis.set("key3", "value3"));\n\n        system.out.println("删除键key2:" + jedis.del("key2"));\n        system.out.println("获取键key2:" + jedis.get("key2"));\n        system.out.println("修改key1:" + jedis.set("key1", "value1changed"));\n        system.out.println("获取key1的值：" + jedis.get("key1"));\n        system.out.println("在key3后面加入值：" + jedis.append("key3", "end"));\n        system.out.println("key3的值：" + jedis.get("key3"));\n        system.out.println("增加多个键值对：" + jedis.mset("key01", "value01", "key02", "value02", "key03", "value03"));\n        system.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n        system.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03", "key04"));\n        system.out.println("删除多个键值对：" + jedis.del("key01", "key02"));\n        system.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n\n        jedis.flushdb();\n\n        system.out.println("===========新增键值对防止覆盖原先值==============");\n        system.out.println(jedis.setnx("key1", "value1"));\n        system.out.println(jedis.setnx("key2", "value2"));\n        system.out.println(jedis.setnx("key2", "value2-new"));\n        system.out.println(jedis.get("key1"));\n        system.out.println(jedis.get("key2"));\n        system.out.println("===========新增键值对并设置有效时间=============");\n        system.out.println(jedis.setex("key3", 2, "value3"));\n        system.out.println(jedis.get("key3"));\n        try {\n            timeunit.seconds.sleep(3);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(jedis.get("key3"));\n        system.out.println("===========获取原值，更新为新值==========");\n        system.out.println(jedis.getset("key2", "key2getset"));\n        system.out.println(jedis.get("key2"));\n        system.out.println("获得key2的值的字串：" + jedis.getrange("key2", 2,4));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n对list操作命令\n\npublic class testlist {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        system.out.println("===========添加一个list===========");\n        jedis.lpush("collections", "arraylist", "vector", "stack", "hashmap", "weakhashmap", "linkedhashmap");\n        jedis.lpush("collections", "hashset");\n        jedis.lpush("collections", "treeset");\n        jedis.lpush("collections", "treemap");\n        system.out.println("collections的内容：" + jedis.lrange("collections", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部\n        system.out.println("collections区间0-3的元素：" + jedis.lrange("collections", 0, 3));\n        system.out.println("===============================");\n        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈\n        system.out.println("删除指定元素个数：" + jedis.lrem("collections", 2,\n                "hashmap"));\n        system.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        system.out.println("删除下表0-3区间之外的元素：" + jedis.ltrim("collections", 0, 3));\n        system.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        system.out.println("collections列表出栈（左端）：" + jedis.lpop("collections"));\n        system.out.println("collections的内容：" + jedis.lrange("collections", 0, -1));\n        system.out.println("collections添加元素，从列表右端，与lpush相对应：" + jedis.rpush("collections", "enummap"));\n        system.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        system.out.println("collections列表出栈（右端）：" + jedis.rpop("collections"));\n        system.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        system.out.println("修改collections指定下标1的内容：" + jedis.lset("collections", 1, "linkedarraylist"));\n        system.out.println("collections的内容：" + jedis.lrange("collections",\n                0, -1));\n        system.out.println("===============================");\n        system.out.println("collections的长度：" + jedis.llen("collections"));\n        system.out.println("获取collections下标为2的元素：" + jedis.lindex("collections", 2));\n        system.out.println("===============================");\n        jedis.lpush("sortedlist", "3", "6", "2", "0", "7", "4");\n        system.out.println("sortedlist排序前：" + jedis.lrange("sortedlist", 0,\n                -1));\n        system.out.println(jedis.sort("sortedlist"));\n        system.out.println("sortedlist排序后：" + jedis.lrange("sortedlist", 0, -1));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n对set的操作命令\n\npublic class testset {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        system.out.println("============向集合中添加元素（不重复）============");\n        system.out.println(jedis.sadd("eleset", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n        system.out.println(jedis.sadd("eleset", "e6"));\n        system.out.println(jedis.sadd("eleset", "e6"));\n        system.out.println("eleset的所有元素为：" + jedis.smembers("eleset"));\n        system.out.println("删除一个元素e0：" + jedis.srem("eleset", "e0"));\n\n        system.out.println("eleset的所有元素为：" + jedis.smembers("eleset"));\n        system.out.println("删除两个元素e7和e6：" + jedis.srem("eleset", "e7", "e6"));\n        system.out.println("eleset的所有元素为：" + jedis.smembers("eleset"));\n        system.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleset"));\n        system.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleset"));\n        system.out.println("eleset的所有元素为：" + jedis.smembers("eleset"));\n        system.out.println("eleset中包含元素的个数：" + jedis.scard("eleset"));\n        system.out.println("e3是否在eleset中：" + jedis.sismember("eleset", "e3"));\n        system.out.println("e1是否在eleset中：" + jedis.sismember("eleset", "e1"));\n        system.out.println("e1是否在eleset中：" + jedis.sismember("eleset", "e5"));\n        system.out.println("=================================");\n        system.out.println(jedis.sadd("eleset1", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n        system.out.println(jedis.sadd("eleset2","e1", "e2", "e4", "e3", "e0", "e8"));\n        system.out.println("将eleset1中删除e1并存入eleset3中：" + jedis.smove("eleset1", "eleset3", "e1"));//移到集合元素\n        system.out.println("将eleset1中删除e2并存入eleset3中：" + jedis.smove("eleset1", "eleset3", "e2"));\n        system.out.println("eleset1中的元素：" + jedis.smembers("eleset1"));\n        system.out.println("eleset3中的元素：" + jedis.smembers("eleset3"));\n        system.out.println("============集合运算=================");\n        system.out.println("eleset1中的元素：" + jedis.smembers("eleset1"));\n        system.out.println("eleset2中的元素：" + jedis.smembers("eleset2"));\n        system.out.println("eleset1和eleset2的交集:" + jedis.sinter("eleset1", "eleset2"));\n        system.out.println("eleset1和eleset2的并集:" + jedis.sunion("eleset1", "eleset2"));\n        system.out.println("eleset1和eleset2的差集:" + jedis.sdiff("eleset1", "eleset2"));//eleset1中有，eleset2中没有\n        jedis.sinterstore("eleset4", "eleset1", "eleset2");//求交集并将交集保存到dstkey的集合\n        system.out.println("eleset4中的元素：" + jedis.smembers("eleset4"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n对hash的操作命令\n\npublic class testhash {\n    public static void main(string[] args) {\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        map<string, string> map = new hashmap<>();\n        map.put("key1", "value1");\n        map.put("key2", "value2");\n        map.put("key3", "value3");\n        map.put("key4", "value4");\n        //添加名称为hash（key）的hash元素\n        jedis.hmset("hash", map);\n        //向名称为hash的hash中添加key为key5，value为value5元素\n        jedis.hset("hash", "key5", "value5");\n        system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));//return map<string,string>\n\n        system.out.println("散列hash的所有键为：" + jedis.hkeys("hash"));//returnset<string>\n        system.out.println("散列hash的所有值为：" + jedis.hvals("hash"));//returnlist<string>\n        system.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrby("hash", "key6", 6));\n        system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));\n        system.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrby("hash", "key6", 3));\n        system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));\n        system.out.println("删除一个或者多个键值对：" + jedis.hdel("hash", "key2"));\n        system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));\n        system.out.println("散列hash中键值对的个数：" + jedis.hlen("hash"));\n        system.out.println("判断hash中是否存在key2：" + jedis.hexists("hash", "key2"));\n        system.out.println("判断hash中是否存在key3：" + jedis.hexists("hash", "key3"));\n        system.out.println("获取hash中的值：" + jedis.hmget("hash", "key3"));\n        system.out.println("获取hash中的值：" + jedis.hmget("hash", "key3", "key4"));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 事务\n\npublic class testmulti {\n    public static void main(string[] args) {\n        //创建客户端连接服务端，redis服务端需要被开启\n        jedis jedis = new jedis("127.0.0.1", 6379);\n        jedis.flushdb();\n        jsonobject jsonobject = new jsonobject();\n        jsonobject.put("hello", "world");\n        jsonobject.put("name", "java");\n        //开启事务\n        transaction multi = jedis.multi();\n        string result = jsonobject.tojsonstring();\n        try {\n            //向redis存入一条数据\n            multi.set("json", result);\n            //再存入一条数据\n            multi.set("json2", result);\n            //这里引发了异常，用0作为被除数\n            int i = 100 / 0;\n            //如果没有引发异常，执行进入队列的命令\n            multi.exec();\n        } catch (exception e) {\n            e.printstacktrace();\n            //如果出现异常，回滚\n            multi.discard();\n        } finally {\n            system.out.println(jedis.get("json"));\n            system.out.println(jedis.get("json2"));\n            //最终关闭客户端\n            jedis.close();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# springboot整合\n\n\n# 基础使用\n\n概述：\n\n在springboot中一般使用redistemplate提供的方法来操作redis。那么使用springboot整合redis需要 那些步骤呢。\n\n1、 jedispoolconfig (这个是配置连接池)\n\n2、 redisconnectionfactory 这个是配置连接信息，这里的redisconnectionfactory是一个接口，我们需要使用它的实现类，在springd data redis方案中提供了以下四种工厂模型：\n\n * jredisconnectionfactory\n * jedisconnectionfactory\n * lettuceconnectionfactory\n * srpconnectionfactory\n\n3、 redistemplate 基本操作\n\n导入依赖\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n说明：在springboot2.x之后，原来使用的jedis被替换成lettuce\n\nyaml配置\n\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n\n\n1\n2\n3\n4\n\n\n测试类中测试\n\n@autowired\nprivate redistemplate<string, string> redistemplate;\n\n@test\nvoid contextloads() {\n    redistemplate.opsforvalue().set("mykey", "myvalue");\n    system.out.println(redistemplate.opsforvalue().get("mykey"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 序列化config\n\n创建springboot新项目，安装上面步骤导入依赖\n\n1、分析 redisautoconfiguration 自动配置类\n\n@configuration(proxybeanmethods = false)\n@conditionalonclass(redisoperations.class)\n@enableconfigurationproperties(redisproperties.class)\n@import({ lettuceconnectionconfiguration.class, jedisconnectionconfiguration.class })\npublic class redisautoconfiguration {\n\n   @bean\n   @conditionalonmissingbean(name = "redistemplate")\n   @conditionalonsinglecandidate(redisconnectionfactory.class)\n   public redistemplate<object, object> redistemplate(redisconnectionfactory redisconnectionfactory) {\n      redistemplate<object, object> template = new redistemplate<>();\n      template.setconnectionfactory(redisconnectionfactory);\n      return template;\n   }\n\n   @bean\n   @conditionalonmissingbean\n   @conditionalonsinglecandidate(redisconnectionfactory.class)\n   public stringredistemplate stringredistemplate(redisconnectionfactory redisconnectionfactory) {\n      stringredistemplate template = new stringredistemplate();\n      template.setconnectionfactory(redisconnectionfactory);\n      return template;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n通过源码可以看出，springboot自动帮我们在容器中生成了一个redistemplate和一个stringredistemplate。\n\n但是，这个redistemplate的泛型是，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为形式的redistemplate。\n\n并且，这个redistemplate没有设置数据存在redis时，key及value的序列化方式。\n\n看到这个@conditionalonmissingbean注解后，就知道如果spring容器中有了redistemplate对象了， 这个自动配置的redistemplate不会实例化。因此我们可以直接自己写个配置类，配置 redistemplate。\n\n用这个配置我们不可以存储对象，否则会报serializationexception，大家可自己试试\n\n2、既然自动配置不好用，就重新配置一个redistemplate\n\npackage com.oddfar.config;\n\nimport com.fasterxml.jackson.annotation.jsonautodetect;\nimport com.fasterxml.jackson.annotation.propertyaccessor;\nimport com.fasterxml.jackson.databind.objectmapper;\nimport com.fasterxml.jackson.databind.jsontype.impl.laissezfairesubtypevalidator;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.data.redis.connection.redisconnectionfactory;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.data.redis.serializer.jackson2jsonredisserializer;\nimport org.springframework.data.redis.serializer.stringredisserializer;\n\n@configuration\npublic class redisconfig {\n    @bean\n    public redistemplate<string, object> redistemplate(redisconnectionfactory factory) {\n        redistemplate<string, object> template = new redistemplate<string, object>();\n        template.setconnectionfactory(factory);\n        jackson2jsonredisserializer jackson2jsonredisserializer = new jackson2jsonredisserializer(object.class);\n        objectmapper om = new objectmapper();\n        om.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n//        om.enabledefaulttyping(objectmapper.defaulttyping.non_final); //此方法已过期\n        //新方法\n        om.activatedefaulttyping(laissezfairesubtypevalidator.instance, objectmapper.defaulttyping.non_final);\n        jackson2jsonredisserializer.setobjectmapper(om);\n        stringredisserializer stringredisserializer = new stringredisserializer();\n\n        // key采用string的序列化方式\n        template.setkeyserializer(stringredisserializer);\n        // hash的key也采用string的序列化方式\n        template.sethashkeyserializer(stringredisserializer);\n        // value序列化方式采用jackson\n        template.setvalueserializer(jackson2jsonredisserializer);\n        // hash的value序列化方式采用jackson\n        template.sethashvalueserializer(jackson2jsonredisserializer);\n        template.afterpropertiesset();\n\n        return template;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n创建user对象，name和age\n\n测试存对象\n\n@springboottest\npublic class redistest {\n\n    @autowired\n    private redistemplate redistemplate;\n\n    @test\n    void test() {\n        user user = new user("致远",3);\n        redistemplate.opsforvalue().set("user",user);\n        system.out.println(redistemplate.opsforvalue().get("user"));\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# redis工具类\n\n使用redistemplate需要频繁调用.opforxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共api抽取出来封装成为一个工具类，然后直接使用工具类来间接操作redis,不但效率高并且易用。\n\n工具类参考博客：\n\nhttps://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html\n\nhttps://www.cnblogs.com/zhzhlong/p/11434284.html',charsets:{cjk:!0},lastUpdated:"2021/09/11, 2:09:00",lastUpdatedTimestamp:1631327124e3},{title:"Redis - 学习笔记-总览",frontmatter:{title:"Redis - 学习笔记-总览",date:"2021-05-10T16:16:46.000Z",permalink:"/pages/feab74/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis/10.Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%80%BB%E8%A7%88.html",relativePath:"03.数据库/10.Redis/10.Redis学习笔记-总览.md",key:"v-7f6d5ac0",path:"/pages/feab74/",headers:[{level:2,title:"Redis.conf",slug:"redis-conf",normalizedTitle:"redis.conf",charIndex:2},{level:3,title:"熟悉基本配置",slug:"熟悉基本配置",normalizedTitle:"熟悉基本配置",charIndex:17},{level:2,title:"Redis的持久化",slug:"redis的持久化",normalizedTitle:"redis的持久化",charIndex:2280},{level:3,title:"RDB（Redis DataBase）",slug:"rdb-redis-database",normalizedTitle:"rdb（redis database）",charIndex:2395},{level:3,title:"AOF（Append Only File）",slug:"aof-append-only-file",normalizedTitle:"aof（append only file）",charIndex:3809},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5297},{level:2,title:"Redis 发布订阅",slug:"redis-发布订阅",normalizedTitle:"redis 发布订阅",charIndex:6190},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3834},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:525},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:4840},{level:2,title:"Redis主从复制",slug:"redis主从复制",normalizedTitle:"redis主从复制",charIndex:7993},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:8007},{level:3,title:"环境配置",slug:"环境配置",normalizedTitle:"环境配置",charIndex:8765},{level:3,title:"一主二从",slug:"一主二从",normalizedTitle:"一主二从",charIndex:9999},{level:3,title:"哨兵模式",slug:"哨兵模式",normalizedTitle:"哨兵模式",charIndex:10685},{level:2,title:"缓存穿透与雪崩",slug:"缓存穿透与雪崩",normalizedTitle:"缓存穿透与雪崩",charIndex:14968},{level:3,title:"缓存穿透（查不到）",slug:"缓存穿透-查不到",normalizedTitle:"缓存穿透（查不到）",charIndex:14980},{level:3,title:"缓存击穿（量太大，缓存过期）",slug:"缓存击穿-量太大-缓存过期",normalizedTitle:"缓存击穿（量太大，缓存过期）",charIndex:15420},{level:3,title:"缓存雪崩",slug:"缓存雪崩",normalizedTitle:"缓存雪崩",charIndex:15837}],headersStr:"Redis.conf 熟悉基本配置 Redis的持久化 RDB（Redis DataBase） AOF（Append Only File） 总结 Redis 发布订阅 简介 测试 原理 Redis主从复制 概念 环境配置 一主二从 哨兵模式 缓存穿透与雪崩 缓存穿透（查不到） 缓存击穿（量太大，缓存过期） 缓存雪崩",content:'# Redis.conf\n\n\n# 熟悉基本配置\n\n> 位置\n\nRedis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf\n\nconfig get * # 获取全部的配置\n\n\n1\n\n\n我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。\n\n正如在 安装redis 中的讲解中拷贝一份\n\n> 容量单位不区分大小写，G和GB有区别\n\n\n\n> include 组合多个配置\n\n\n\n和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！\n\n> NETWORK 网络配置\n\nbind 127.0.0.1 # 绑定的ip\nprotected-mode yes # 保护模式\nport 6379 # 默认端口\n\n\n1\n2\n3\n\n\n> GENERAL 通用\n\ndaemonize yes # 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yes\n\nsupervised no # 可通过upstart和systemd管理Redis守护进程\n\nloglevel notice # 日志级别。可选项有：\n\t\t\t\t# debug（记录大量日志信息，适用于开发、测试阶段）\n\t\t\t\t# verbose（较多日志信息）\n\t\t\t\t# notice（适量日志信息，使用于生产环境）\n\t\t\t\t# warning（仅有部分重要、关键信息才会被记录）\nlogfile "" # 日志文件的位置，当指定为空字符串时，为标准输出\ndatabases 16 # 设置数据库的数目。默认的数据库是DB 0\nalways-show-logo yes # 是否总是显示logo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> SNAPSHOPTING 快照，持久化规则\n\n由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中\n\n持久化方式：\n\n * RDB\n * AOF\n\n# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）\nsave 900 1\n# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）\nsave 300 10\n# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）\nsave 60 10000\n\n\n1\n2\n3\n4\n5\n6\n\n\nRDB文件相关\n\nstop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作\n\nrdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间\n\nrdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗\n\ndbfilename dump.rdb # dbfilenamerdb文件名称\n\ndir ./ # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> REPLICATION主从复制\n\n\n\n后面详细说\n\n> SECURITY安全\n\n访问密码的查看，设置和取消\n\n# 启动redis\n# 连接客户端\n\n# 获得和设置密码\nconfig get requirepass\nconfig set requirepass "123456"\n\n#测试ping，发现需要验证\n127.0.0.1:6379> ping\nNOAUTH Authentication required.\n# 验证\n127.0.0.1:6379> auth 123456\nOK\n127.0.0.1:6379> ping\nPONG\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 客户端连接相关\n\nmaxclients 10000  最大客户端数量\nmaxmemory <bytes> 最大内存限制\nmaxmemory-policy noeviction # 内存达到限制值的处理策略\n\n\n1\n2\n3\n\n\nmaxmemory-policy 六种方式\n\n**1、volatile-lru：**利用LRU算法移除设置过过期时间的key。\n\n2、allkeys-lru ： 用lru算法删除lkey\n\n**3、volatile-random：**随机删除即将过期key\n\n**4、allkeys-random：**随机删除\n\n5、volatile-ttl ： 删除即将过期的\n\n6、noeviction ： 不移除任何key，只是返回一个写错误。\n\nredis 中的默认的过期策略是 volatile-lru 。\n\n设置方式\n\nconfig set maxmemory-policy volatile-lru \n\n\n1\n\n\n> append only模式\n\n（AOF相关部分）\n\n\n\n\n\nappendfsync everysec # appendfsync aof持久化策略的配置\n        # no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。\n        # always表示每次写入都执行fsync，以保证数据同步到磁盘。\n        # everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\n\n1\n2\n3\n4\n\n\n\n# Redis的持久化\n\nRedis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！\n\nRdb 保存的是 dump.rdb 文件\n\n\n# RDB（Redis DataBase）\n\n> 什么是RDB\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快 照文件直接读到内存里。\n\nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。 这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n\n> Fork\n\nFork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。\n\n配置位置及SNAPSHOTTING解析\n\n\n\n这里的触发条件机制，我们可以修改测试一下：\n\nsave 120 10 # 120秒内修改10次则触发RDB\n\n\n1\n\n\nRDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。\n\n如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。\n\n若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !\n\nsave不是创建一个新进程去进行持久化\n\n> 其余命令解析\n\nStop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。\n\nrbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用 LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。\n\nrdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约 10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。\n\n> 如何触发RDB快照\n\n1、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb\n\n2、命令save或者是bgsave\n\n * save 时只管保存，其他不管，全部阻塞\n\n * bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间。\n\n3、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义 !\n\n4、退出的时候也会产生 dump.rdb 文件！\n\n> 如何恢复\n\n1、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可\n\n2、CONFIG GET dir 获取目录\n\n127.0.0.1:6379> config get dir\ndir\n/usr/local/bin\n\n\n1\n2\n3\n\n\n> 优点和缺点\n\n优点：\n\n1、适合大规模的数据恢复\n\n2、对数据完整性和一致性要求不高\n\n缺点：\n\n1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n\n2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。\n\n> 小结\n\n\n\n\n# AOF（Append Only File）\n\n> 简介\n\n以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件 的内容将写指令从前到后执行一次以完成数据的恢复工作\n\nAof保存的是 appendonly.aof 文件\n\n> 配置\n\n\n\n * appendonly no\n   \n   是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这 种方式在许多应用中已经足够用了\n\n * appendfilename "appendonly.aof"\n   \n   appendfilename AOF 文件名称\n\n * appendfsync everysec\n   \n   appendfsync aof持久化策略的配置\n   \n   > no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 always表示每次写入都执行fsync，以保证数据同步到磁盘。 everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\n * No-appendfsync-on-rewrite\n   \n   重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性\n\n * Auto-aof-rewrite-min-size\n   \n   设置重写的基准值\n\n * Auto-aof-rewrite-percentage\n   \n   设置重写的基准值\n\n> AOF 启动/修复/恢复\n\n正常恢复：\n\n启动：设置Yes，修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录（config get dir） 恢复：重启redis然后重新加载\n\n异常恢复：\n\n启动：设置Yes 故意破坏 appendonly.aof 文件！ 修复：命令redis-check-aof --fix appendonly.aof 进行修复 恢复：重启 redis 然后重新加载\n\n> Rewrite重写\n\nAOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以 使用命令 bgrewriteaof ！\n\n重写原理：\n\nAOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再 rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧 的aof文件，这点和快照有点类似！\n\n触发机制：\n\nRedis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大 于64M的触发。\n\n> 优点和缺点\n\n优点：\n\n1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好\n\n2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失\n\n3、不同步： appendfsync no 从不同步\n\n缺点：\n\n1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。\n\n2、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。\n\n> 小结\n\n\n\n\n# 总结\n\n1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储\n\n2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。\n\n3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化\n\n4、同时开启两种持久化方式\n\n * 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF 文件保存的数据集要比RDB文件保存的数据集要完整。\n * RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有 AOF可能潜在的Bug，留着作为一个万一的手段。\n\n5、性能建议\n\n * 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够 了，只保留 save 900 1 这条规则。\n * 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自 己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产 生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重 写可以改到适当的数值。\n * 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也 减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据， 启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。\n\n\n# Redis 发布订阅\n\n\n# 简介\n\nRedis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n\nRedis 客户端可以订阅任意数量的频道。\n\n订阅/发布消息图：\n\n\n\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\n\n\n\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n\n\n命令\n\n下表列出了 redis 发布订阅常用命令：\n\n序号   命令及描述\n1    [PSUBSCRIBE pattern [pattern ...]]\n     订阅一个或多个符合给定模式的频道。\n2    [PUBSUB subcommand [argument [argument ...]]]\n     查看订阅与发布系统状态。\n3    [PUBLISH channel message]\n     将信息发送到指定的频道。\n4    [PUNSUBSCRIBE [pattern [pattern ...]]]\n     退订所有给定模式的频道。\n5    [SUBSCRIBE channel [channel ...]]\n     订阅给定的一个或多个频道的信息。\n6    [UNSUBSCRIBE [channel [channel ...]]]\n     指退订给定的频道。\n\n\n# 测试\n\n以下实例演示了发布订阅是如何工作的。\n\n我们先打开两个 redis-cli 客户端\n\n在第一个 redis-cli 客户端，创建订阅频道名为 redisChat，输入SUBSCRIBE redisChat\n\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\nReading messages... (press Ctrl-C to quit)\n1) "subscribe"\n2) "redisChat"\n3) (integer) 1\n\n\n1\n2\n3\n4\n5\n\n\n在第二个客户端，发布两次消息，订阅者就能接收 到消息。\n\nredis 127.0.0.1:6379> PUBLISH redisChat "Hello,Redis"\n(integer) 1\nredis 127.0.0.1:6379> PUBLISH redisChat "Hello，java"\n(integer) 1\n\n\n1\n2\n3\n4\n\n\n订阅者的客户端会显示如下消息\n\n>  1. "message"\n>  2. "redisChat"\n>  3. "Hello,Redis"\n>  4. "message"\n>  5. "redisChat"\n>  6. "Hello，java"\n\n\n# 原理\n\nRedis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，来加深对 Redis 的理解。\n\nRedis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。\n\n通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel ，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。\n\n通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\n\nPub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个 key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。\n\n使用场景：\n\nRedis的Pub/Sub系统可以构建实时的消息系统，比如很多用Pub/Sub构建的实时聊天系统的例子。\n\n\n# Redis主从复制\n\n\n# 概念\n\n主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点 (master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。 Master以写为主，Slave 以读为主。\n\n默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\n\n主从复制的作用主要包括：\n\n1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n\n2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n\n3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。\n\n4、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis高可用的基础。\n\n一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：\n\n1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大；\n\n2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。\n\n电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是"多读少写"。\n\n对于这种场景，我们可以使如下这种架构：\n\n\n\n\n# 环境配置\n\n> 基本配置\n\n查看当前库的信息：info replication\n\n127.0.0.1:6379> info replication\n# Replication\nrole:master\t# 角色\nconnected_slaves:0\t# 从机数量\nmaster_failover_state:no-failover\nmaster_replid:1a6933acf7ec9711bfa0a1848976676557e1e6a0\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6379> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n因为没有多个服务器，就以本地开启3个端口，模拟3个服务\n\n既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：\n\n * 端口号（port）\n * pid文件名（pidfile）\n * 日志文件名（logfile）\n * rdb文件名（dbfilename）\n\n1、拷贝多个redis.conf 文件\n\n端口分别是6379、6380、6381\n\n[root@localhost ~]# cd /usr/local/bin/myconfig\n[root@localhost myconfig]# ls\ndump.rdb  redis.conf\n[root@localhost myconfig]# cp redis.conf redis79.conf\n[root@localhost myconfig]# cp redis.conf redis80.conf\n[root@localhost myconfig]# cp redis.conf redis81.conf\n[root@localhost myconfig]# ls\ndump.rdb  redis79.conf  redis80.conf  redis81.conf  redis.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n分别修改配置上面四点对应的配置，举例：\n\n\n\n\n\n\n\n配置好分别启动3个不同端口服务\n\n * redis-server myconfig/redis79.conf\n\n * redis-server myconfig/redis80.conf\n\n * redis-server myconfig/redis81.conf\n\nredis-server myconfig/redis79.conf\n\n\n\n\n# 一主二从\n\n1、之后我们再分别开启redis连接，redis-cli -p 6379，redis-cli -p 6380，redis-cli -p 6381\n\n通过指令\n\n127.0.0.1:6379> info replication\n\n\n1\n\n\n可以发现，默认情况下，开启的每个redis服务器都是主节点\n\n\n\n2、配置为一个Master 两个Slave（即一主二从）\n\n6379为主，6380,6381为从\n\nslaveof 127.0.0.1 6379\n\n\n\n3、在主机设置值，在从机都可以取到！从机不能写值！\n\n\n\n我们这里是使用命令搭建，是“暂时的”，也可去配置里进行修改，这样话则是“永久的”\n\n\n\n> 使用规则\n\n当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。\n\n当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。\n\n有两种方式可以产生新的主机：看下文“谋权篡位”\n\n> 层层链路\n\n上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么 该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！\n\n\n\n\n\n> 谋权篡位\n\n有两种方式可以产生新的主机：\n\n * 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机\n * 使用哨兵模式（自动选举）\n\n> 复制原理\n\nSlave 启动成功连接到 master 后会发送一个sync命令\n\nMaster 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行 完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。\n\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步\n\n但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n\n\n# 哨兵模式\n\n更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d\n\n> 概述\n\n主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。\n\n谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。\n\n哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。\n\n\n\n这里的哨兵有两个作用\n\n * 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\n * 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。\n\n然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n\n\n\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认 为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一 定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 客观下线。\n\n> 配置测试\n\n1、调整结构，6379带着80、81\n\n2、自定义的 /myconfig 目录下新建 sentinel.conf 文件，名字千万不要错\n\n3、配置哨兵，填写内容\n\n * sentinel monitor 被监控主机名字 127.0.0.1 6379 1\n   \n   例如：sentinel monitor mymaster 127.0.0.1 6379 1，\n   \n   上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机\n\n4、启动哨兵\n\n * Redis-sentinel myconfig/sentinel.conf\n   \n   上述目录依照各自的实际情况配置，可能目录不同\n\n成功启动哨兵模式\n\n\n\n此时哨兵监视着我们的主机6379，当我们断开主机后：\n\n\n\n> 哨兵模式的优缺点\n\n优点\n\n 1. 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有\n 2. 主从可以切换，故障可以转移，系统的可用性更好\n 3. 哨兵模式是主从模式的升级，手动到自动，更加健壮\n\n缺点：\n\n 1. Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦\n 2. 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项\n\n> 哨兵模式的全部配置\n\n完整的哨兵模式配置文件 sentinel.conf\n\n# Example sentinel.conf\n \n# 哨兵sentinel实例运行的端口 默认26379\nport 26379\n \n# 哨兵sentinel的工作目录\ndir /tmp\n \n# 哨兵sentinel监控的redis主节点的 ip port \n# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。\n# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\nsentinel monitor mymaster 127.0.0.1 6379 1\n \n# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码\n# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass <master-name> <password>\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n \n \n# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒\n# sentinel down-after-milliseconds <master-name> <milliseconds>\nsentinel down-after-milliseconds mymaster 30000\n \n# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，\n这个数字越小，完成failover所需的时间就越长，\n但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。\n可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs <master-name> <numslaves>\nsentinel parallel-syncs mymaster 1\n \n \n \n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： \n#1. 同一个sentinel对同一个master两次failover之间的间隔时间。\n#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。\n#3.当想要取消一个正在进行的failover所需要的时间。  \n#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了\n# 默认三分钟\n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n \n# SCRIPTS EXECUTION\n \n#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。\n#对于脚本的运行结果有以下规则：\n#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10\n#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。\n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。\n#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。\n \n#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，\n#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，\n#一个是事件的类型，\n#一个是事件的描述。\n#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。\n#通知脚本\n# sentinel notification-script <master-name> <script-path>\n  sentinel notification-script mymaster /var/redis/notify.sh\n \n# 客户端重新配置主节点参数脚本\n# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>\n# 目前<state>总是“failover”,\n# <role>是“leader”或者“observer”中的一个。 \n# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的\n# 这个脚本应该是通用的，能被多次调用，不是针对性的。\n# sentinel client-reconfig-script <master-name> <script-path>\nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 缓存穿透与雪崩\n\n\n# 缓存穿透（查不到）\n\n> 概念\n\n在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。\n\n> 解决方案\n\n布隆过滤器\n\n对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。\n\n\n\n缓存空对象\n\n一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。\n\n\n\n这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间\n\n即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\n\n\n# 缓存击穿（量太大，缓存过期）\n\n> 概念\n\n相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。\n\n比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。\n\n> 解决方案\n\n 1. 设置热点数据永不过期\n    \n    这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。\n\n 2. 加互斥锁(分布式锁)\n    \n    在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。\n\n\n# 缓存雪崩\n\n> 概念\n\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\n\n产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。\n\n\n\n其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然 形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就 是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。\n\n> 解决方案\n\n * redis高可用\n   \n   这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群\n\n * 限流降级\n   \n   这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n\n * 数据预热\n   \n   数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。',normalizedContent:'# redis.conf\n\n\n# 熟悉基本配置\n\n> 位置\n\nredis 的配置文件位于 redis 安装目录下，文件名为 redis.conf\n\nconfig get * # 获取全部的配置\n\n\n1\n\n\n我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。\n\n正如在 安装redis 中的讲解中拷贝一份\n\n> 容量单位不区分大小写，g和gb有区别\n\n\n\n> include 组合多个配置\n\n\n\n和spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！\n\n> network 网络配置\n\nbind 127.0.0.1 # 绑定的ip\nprotected-mode yes # 保护模式\nport 6379 # 默认端口\n\n\n1\n2\n3\n\n\n> general 通用\n\ndaemonize yes # 默认情况下，redis不作为守护进程运行。需要开启的话，改为 yes\n\nsupervised no # 可通过upstart和systemd管理redis守护进程\n\nloglevel notice # 日志级别。可选项有：\n\t\t\t\t# debug（记录大量日志信息，适用于开发、测试阶段）\n\t\t\t\t# verbose（较多日志信息）\n\t\t\t\t# notice（适量日志信息，使用于生产环境）\n\t\t\t\t# warning（仅有部分重要、关键信息才会被记录）\nlogfile "" # 日志文件的位置，当指定为空字符串时，为标准输出\ndatabases 16 # 设置数据库的数目。默认的数据库是db 0\nalways-show-logo yes # 是否总是显示logo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> snapshopting 快照，持久化规则\n\n由于redis是基于内存的数据库，需要将数据由内存持久化到文件中\n\n持久化方式：\n\n * rdb\n * aof\n\n# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）\nsave 900 1\n# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）\nsave 300 10\n# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）\nsave 60 10000\n\n\n1\n2\n3\n4\n5\n6\n\n\nrdb文件相关\n\nstop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作\n\nrdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间\n\nrdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗\n\ndbfilename dump.rdb # dbfilenamerdb文件名称\n\ndir ./ # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> replication主从复制\n\n\n\n后面详细说\n\n> security安全\n\n访问密码的查看，设置和取消\n\n# 启动redis\n# 连接客户端\n\n# 获得和设置密码\nconfig get requirepass\nconfig set requirepass "123456"\n\n#测试ping，发现需要验证\n127.0.0.1:6379> ping\nnoauth authentication required.\n# 验证\n127.0.0.1:6379> auth 123456\nok\n127.0.0.1:6379> ping\npong\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n> 客户端连接相关\n\nmaxclients 10000  最大客户端数量\nmaxmemory <bytes> 最大内存限制\nmaxmemory-policy noeviction # 内存达到限制值的处理策略\n\n\n1\n2\n3\n\n\nmaxmemory-policy 六种方式\n\n**1、volatile-lru：**利用lru算法移除设置过过期时间的key。\n\n2、allkeys-lru ： 用lru算法删除lkey\n\n**3、volatile-random：**随机删除即将过期key\n\n**4、allkeys-random：**随机删除\n\n5、volatile-ttl ： 删除即将过期的\n\n6、noeviction ： 不移除任何key，只是返回一个写错误。\n\nredis 中的默认的过期策略是 volatile-lru 。\n\n设置方式\n\nconfig set maxmemory-policy volatile-lru \n\n\n1\n\n\n> append only模式\n\n（aof相关部分）\n\n\n\n\n\nappendfsync everysec # appendfsync aof持久化策略的配置\n        # no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。\n        # always表示每次写入都执行fsync，以保证数据同步到磁盘。\n        # everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\n\n1\n2\n3\n4\n\n\n\n# redis的持久化\n\nredis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 redis 提供了持久化功能！\n\nrdb 保存的是 dump.rdb 文件\n\n\n# rdb（redis database）\n\n> 什么是rdb\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的snapshot快照，它恢复时是将快 照文件直接读到内存里。\n\nredis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何io操作的。 这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 rdb方式要比aof方式更加的高效。rdb的缺点是最后一次持久化后的数据可能丢失。\n\n> fork\n\nfork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。\n\n配置位置及snapshotting解析\n\n\n\n这里的触发条件机制，我们可以修改测试一下：\n\nsave 120 10 # 120秒内修改10次则触发rdb\n\n\n1\n\n\nrdb 是整合内存的压缩过的snapshot，rdb 的数据结构，可以配置复合的快照触发条件。\n\n如果想禁用rdb持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。\n\n若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !\n\nsave不是创建一个新进程去进行持久化\n\n> 其余命令解析\n\nstop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。\n\nrbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用 lzf算法进行压缩，如果你不想消耗cpu来进行压缩的话，可以设置为关闭此功能。\n\nrdbchecksum：在存储快照后，还可以让redis使用crc64算法来进行数据校验，但是这样做会增加大约 10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。\n\n> 如何触发rdb快照\n\n1、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb\n\n2、命令save或者是bgsave\n\n * save 时只管保存，其他不管，全部阻塞\n\n * bgsave，redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间。\n\n3、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义 !\n\n4、退出的时候也会产生 dump.rdb 文件！\n\n> 如何恢复\n\n1、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可\n\n2、config get dir 获取目录\n\n127.0.0.1:6379> config get dir\ndir\n/usr/local/bin\n\n\n1\n2\n3\n\n\n> 优点和缺点\n\n优点：\n\n1、适合大规模的数据恢复\n\n2、对数据完整性和一致性要求不高\n\n缺点：\n\n1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n\n2、fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。\n\n> 小结\n\n\n\n\n# aof（append only file）\n\n> 简介\n\n以日志的形式来记录每个写操作，将redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件 的内容将写指令从前到后执行一次以完成数据的恢复工作\n\naof保存的是 appendonly.aof 文件\n\n> 配置\n\n\n\n * appendonly no\n   \n   是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这 种方式在许多应用中已经足够用了\n\n * appendfilename "appendonly.aof"\n   \n   appendfilename aof 文件名称\n\n * appendfsync everysec\n   \n   appendfsync aof持久化策略的配置\n   \n   > no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 always表示每次写入都执行fsync，以保证数据同步到磁盘。 everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\n * no-appendfsync-on-rewrite\n   \n   重写时是否可以运用appendfsync，用默认no即可，保证数据安全性\n\n * auto-aof-rewrite-min-size\n   \n   设置重写的基准值\n\n * auto-aof-rewrite-percentage\n   \n   设置重写的基准值\n\n> aof 启动/修复/恢复\n\n正常恢复：\n\n启动：设置yes，修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录（config get dir） 恢复：重启redis然后重新加载\n\n异常恢复：\n\n启动：设置yes 故意破坏 appendonly.aof 文件！ 修复：命令redis-check-aof --fix appendonly.aof 进行修复 恢复：重启 redis 然后重新加载\n\n> rewrite重写\n\naof 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当aof文件的大小超过所设定的阈值时，redis 就会启动aof 文件的内容压缩，只保留可以恢复数据的最小指令集，可以 使用命令 bgrewriteaof ！\n\n重写原理：\n\naof 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再 rename），遍历新进程的内存中数据，每条记录有一条的set语句。重写aof文件的操作，并没有读取旧 的aof文件，这点和快照有点类似！\n\n触发机制：\n\nredis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的已被且文件大 于64m的触发。\n\n> 优点和缺点\n\n优点：\n\n1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好\n\n2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失\n\n3、不同步： appendfsync no 从不同步\n\n缺点：\n\n1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。\n\n2、aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。\n\n> 小结\n\n\n\n\n# 总结\n\n1、rdb 持久化方式能够在指定的时间间隔内对你的数据进行快照存储\n\n2、aof 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，aof命令以redis 协议追加保存每次写的操作到文件末尾，redis还能对aof文件进行后台重写，使得aof文件的体积不至于过大。\n\n3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化\n\n4、同时开启两种持久化方式\n\n * 在这种情况下，当redis重启的时候会优先载入aof文件来恢复原始的数据，因为在通常情况下aof 文件保存的数据集要比rdb文件保存的数据集要完整。\n * rdb 的数据不实时，同时使用两者时服务器重启也只会找aof文件，那要不要只使用aof呢？建议不要，因为rdb更适合用于备份数据库（aof在不断变化不好备份），快速重启，而且不会有 aof可能潜在的bug，留着作为一个万一的手段。\n\n5、性能建议\n\n * 因为rdb文件只用作后备用途，建议只在slave上持久化rdb文件，而且只要15分钟备份一次就够 了，只保留 save 900 1 这条规则。\n * 如果enable aof ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自 己的aof文件就可以了，代价一是带来了持续的io，二是aof rewrite 的最后将 rewrite 过程中产 生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少aof rewrite 的频率，aof重写的基础大小默认值64m太小了，可以设到5g以上，默认超过原大小100%大小重 写可以改到适当的数值。\n * 如果不enable aof ，仅靠 master-slave repllcation 实现高可用性也可以，能省掉一大笔io，也 减少了rewrite时带来的系统波动。代价是如果master/slave 同时倒掉，会丢失十几分钟的数据， 启动脚本也要比较两个 master/slave 中的 rdb文件，载入较新的那个，微博就是这种架构。\n\n\n# redis 发布订阅\n\n\n# 简介\n\nredis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n\nredis 客户端可以订阅任意数量的频道。\n\n订阅/发布消息图：\n\n\n\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\n\n\n\n当有新消息通过 publish 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n\n\n命令\n\n下表列出了 redis 发布订阅常用命令：\n\n序号   命令及描述\n1    [psubscribe pattern [pattern ...]]\n     订阅一个或多个符合给定模式的频道。\n2    [pubsub subcommand [argument [argument ...]]]\n     查看订阅与发布系统状态。\n3    [publish channel message]\n     将信息发送到指定的频道。\n4    [punsubscribe [pattern [pattern ...]]]\n     退订所有给定模式的频道。\n5    [subscribe channel [channel ...]]\n     订阅给定的一个或多个频道的信息。\n6    [unsubscribe [channel [channel ...]]]\n     指退订给定的频道。\n\n\n# 测试\n\n以下实例演示了发布订阅是如何工作的。\n\n我们先打开两个 redis-cli 客户端\n\n在第一个 redis-cli 客户端，创建订阅频道名为 redischat，输入subscribe redischat\n\nredis 127.0.0.1:6379> subscribe redischat\nreading messages... (press ctrl-c to quit)\n1) "subscribe"\n2) "redischat"\n3) (integer) 1\n\n\n1\n2\n3\n4\n5\n\n\n在第二个客户端，发布两次消息，订阅者就能接收 到消息。\n\nredis 127.0.0.1:6379> publish redischat "hello,redis"\n(integer) 1\nredis 127.0.0.1:6379> publish redischat "hello，java"\n(integer) 1\n\n\n1\n2\n3\n4\n\n\n订阅者的客户端会显示如下消息\n\n>  1. "message"\n>  2. "redischat"\n>  3. "hello,redis"\n>  4. "message"\n>  5. "redischat"\n>  6. "hello，java"\n\n\n# 原理\n\nredis是使用c实现的，通过分析 redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，来加深对 redis 的理解。\n\nredis 通过 publish 、subscribe 和 psubscribe 等命令实现发布和订阅功能。\n\n通过 subscribe 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel ，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。subscribe 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。\n\n通过 publish 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\n\npub/sub 从字面上理解就是发布（publish）与订阅（subscribe），在redis中，你可以设定对某一个 key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。\n\n使用场景：\n\nredis的pub/sub系统可以构建实时的消息系统，比如很多用pub/sub构建的实时聊天系统的例子。\n\n\n# redis主从复制\n\n\n# 概念\n\n主从复制，是指将一台redis服务器的数据，复制到其他的redis服务器。前者称为主节点 (master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。 master以写为主，slave 以读为主。\n\n默认情况下，每台redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\n\n主从复制的作用主要包括：\n\n1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n\n2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n\n3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写redis数据时应用连接主节点，读redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高redis服务器的并发量。\n\n4、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 redis高可用的基础。\n\n一般来说，要将redis运用于工程项目中，只使用一台redis是万万不能的，原因如下：\n\n1、从结构上，单个redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大；\n\n2、从容量上，单个redis服务器内存容量有限，就算一台redis服务器内存容量为256g，也不能将所有内存用作redis存储内存，一般来说，单台redis最大使用内存不应该超过20g。\n\n电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是"多读少写"。\n\n对于这种场景，我们可以使如下这种架构：\n\n\n\n\n# 环境配置\n\n> 基本配置\n\n查看当前库的信息：info replication\n\n127.0.0.1:6379> info replication\n# replication\nrole:master\t# 角色\nconnected_slaves:0\t# 从机数量\nmaster_failover_state:no-failover\nmaster_replid:1a6933acf7ec9711bfa0a1848976676557e1e6a0\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6379> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n因为没有多个服务器，就以本地开启3个端口，模拟3个服务\n\n既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：\n\n * 端口号（port）\n * pid文件名（pidfile）\n * 日志文件名（logfile）\n * rdb文件名（dbfilename）\n\n1、拷贝多个redis.conf 文件\n\n端口分别是6379、6380、6381\n\n[root@localhost ~]# cd /usr/local/bin/myconfig\n[root@localhost myconfig]# ls\ndump.rdb  redis.conf\n[root@localhost myconfig]# cp redis.conf redis79.conf\n[root@localhost myconfig]# cp redis.conf redis80.conf\n[root@localhost myconfig]# cp redis.conf redis81.conf\n[root@localhost myconfig]# ls\ndump.rdb  redis79.conf  redis80.conf  redis81.conf  redis.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n分别修改配置上面四点对应的配置，举例：\n\n\n\n\n\n\n\n配置好分别启动3个不同端口服务\n\n * redis-server myconfig/redis79.conf\n\n * redis-server myconfig/redis80.conf\n\n * redis-server myconfig/redis81.conf\n\nredis-server myconfig/redis79.conf\n\n\n\n\n# 一主二从\n\n1、之后我们再分别开启redis连接，redis-cli -p 6379，redis-cli -p 6380，redis-cli -p 6381\n\n通过指令\n\n127.0.0.1:6379> info replication\n\n\n1\n\n\n可以发现，默认情况下，开启的每个redis服务器都是主节点\n\n\n\n2、配置为一个master 两个slave（即一主二从）\n\n6379为主，6380,6381为从\n\nslaveof 127.0.0.1 6379\n\n\n\n3、在主机设置值，在从机都可以取到！从机不能写值！\n\n\n\n我们这里是使用命令搭建，是“暂时的”，也可去配置里进行修改，这样话则是“永久的”\n\n\n\n> 使用规则\n\n当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。\n\n当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。\n\n有两种方式可以产生新的主机：看下文“谋权篡位”\n\n> 层层链路\n\n上一个slave 可以是下一个slave 和 master，slave 同样可以接收其他 slaves 的连接和同步请求，那么 该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！\n\n\n\n\n\n> 谋权篡位\n\n有两种方式可以产生新的主机：\n\n * 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机\n * 使用哨兵模式（自动选举）\n\n> 复制原理\n\nslave 启动成功连接到 master 后会发送一个sync命令\n\nmaster 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行 完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。\n\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n增量复制：master 继续将新的所有收集到的修改命令依次传给slave，完成同步\n\n但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n\n\n# 哨兵模式\n\n更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d\n\n> 概述\n\n主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。redis从2.8开始正式提供了sentinel（哨兵） 架构来解决这个问题。\n\n谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。\n\n哨兵模式是一种特殊的模式，首先redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例。\n\n\n\n这里的哨兵有两个作用\n\n * 通过发送命令，让redis服务器返回监控其运行状态，包括主服务器和从服务器。\n * 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。\n\n然而一个哨兵进程对redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n\n\n\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认 为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一 定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 客观下线。\n\n> 配置测试\n\n1、调整结构，6379带着80、81\n\n2、自定义的 /myconfig 目录下新建 sentinel.conf 文件，名字千万不要错\n\n3、配置哨兵，填写内容\n\n * sentinel monitor 被监控主机名字 127.0.0.1 6379 1\n   \n   例如：sentinel monitor mymaster 127.0.0.1 6379 1，\n   \n   上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机\n\n4、启动哨兵\n\n * redis-sentinel myconfig/sentinel.conf\n   \n   上述目录依照各自的实际情况配置，可能目录不同\n\n成功启动哨兵模式\n\n\n\n此时哨兵监视着我们的主机6379，当我们断开主机后：\n\n\n\n> 哨兵模式的优缺点\n\n优点\n\n 1. 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有\n 2. 主从可以切换，故障可以转移，系统的可用性更好\n 3. 哨兵模式是主从模式的升级，手动到自动，更加健壮\n\n缺点：\n\n 1. redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦\n 2. 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项\n\n> 哨兵模式的全部配置\n\n完整的哨兵模式配置文件 sentinel.conf\n\n# example sentinel.conf\n \n# 哨兵sentinel实例运行的端口 默认26379\nport 26379\n \n# 哨兵sentinel的工作目录\ndir /tmp\n \n# 哨兵sentinel监控的redis主节点的 ip port \n# master-name  可以自己命名的主节点名字 只能由字母a-z、数字0-9 、这三个字符".-_"组成。\n# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\nsentinel monitor mymaster 127.0.0.1 6379 1\n \n# 当在redis实例中开启了requirepass foobared 授权密码 这样所有连接redis实例的客户端都要提供密码\n# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass <master-name> <password>\nsentinel auth-pass mymaster mysuper--secret-0123passw0rd\n \n \n# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒\n# sentinel down-after-milliseconds <master-name> <milliseconds>\nsentinel down-after-milliseconds mymaster 30000\n \n# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，\n这个数字越小，完成failover所需的时间就越长，\n但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。\n可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs <master-name> <numslaves>\nsentinel parallel-syncs mymaster 1\n \n \n \n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： \n#1. 同一个sentinel对同一个master两次failover之间的间隔时间。\n#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。\n#3.当想要取消一个正在进行的failover所需要的时间。  \n#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了\n# 默认三分钟\n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n \n# scripts execution\n \n#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。\n#对于脚本的运行结果有以下规则：\n#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10\n#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。\n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。\n#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个sigkill信号终止，之后重新执行。\n \n#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，\n#这时这个脚本应该通过邮件，sms等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，\n#一个是事件的类型，\n#一个是事件的描述。\n#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。\n#通知脚本\n# sentinel notification-script <master-name> <script-path>\n  sentinel notification-script mymaster /var/redis/notify.sh\n \n# 客户端重新配置主节点参数脚本\n# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>\n# 目前<state>总是“failover”,\n# <role>是“leader”或者“observer”中的一个。 \n# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的\n# 这个脚本应该是通用的，能被多次调用，不是针对性的。\n# sentinel client-reconfig-script <master-name> <script-path>\nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 缓存穿透与雪崩\n\n\n# 缓存穿透（查不到）\n\n> 概念\n\n在默认情况下，用户请求数据时，会先在缓存(redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。\n\n> 解决方案\n\n布隆过滤器\n\n对所有可能查询的参数以hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。\n\n\n\n缓存空对象\n\n一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。\n\n\n\n这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间\n\n即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\n\n\n# 缓存击穿（量太大，缓存过期）\n\n> 概念\n\n相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到db，造成瞬时db请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。\n\n比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。\n\n> 解决方案\n\n 1. 设置热点数据永不过期\n    \n    这样就不会出现热点数据过期的情况，但是当redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。\n\n 2. 加互斥锁(分布式锁)\n    \n    在访问key之前，采用setnx（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。\n\n\n# 缓存雪崩\n\n> 概念\n\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时db请求量大、压力骤增，引起雪崩。\n\n产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。\n\n\n\n其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然 形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就 是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。\n\n> 解决方案\n\n * redis高可用\n   \n   这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群\n\n * 限流降级\n   \n   这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n\n * 数据预热\n   \n   数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ElasticSearch - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.数据库/15.ElasticSearch",imgUrl:"/img/web.png",description:"ElasticSearch目录页"}},title:"ElasticSearch - 知识体系",permalink:"/es",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2021-08-03T18:04:03.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/01.ElasticSearch.html",relativePath:"03.数据库/15.ElasticSearch/01.ElasticSearch.md",key:"v-56b0312c",path:"/es/",headers:[{level:2,title:"视频教程",slug:"视频教程",normalizedTitle:"视频教程",charIndex:3},{level:2,title:"官方文档",slug:"官方文档",normalizedTitle:"官方文档",charIndex:11},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:19}],headersStr:"视频教程 官方文档 参考文章",content:" * 视频教程\n * 官方文档\n * 参考文章\n\n\n# 视频教程\n\n中华石杉的讲解视频\n\n * 初级视频：\n   \n   https://www.bilibili.com/video/BV1p4411h7sR\n\n * 进阶视频：\n   \n   https://www.bilibili.com/video/BV1p4411Y7F4\n\n听说中华石衫讲的好，尚硅谷、狂神（我看的是狂神讲的）讲的也都可以\n\n\n# 官方文档\n\n * 低版本中文文档\n   \n   https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html\n\n * 最新版本的官方文档\n   \n   https://www.elastic.co/guide/en/elasticsearch/reference/7.x/index.html\n\n * Java操作Es的客户端文档\n   \n   https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html\n\n * Kibana数据可视化界面使用官方文档\n   \n   https://www.elastic.co/guide/en/kibana/current/index.html\n\n\n# 参考文章\n\n学习资料以官网文档为主\n\n * ElasticSearch知识体系详解\n   \n   https://www.pdai.tech/md/db/nosql-es/elasticsearch.html\n\n * SpringBoot 检索篇 - 整合 Elasticsearch7.6.2\n   \n   https://blog.csdn.net/weixin_41105242/article/details/107711634\n\n本人ElasticSearch学习笔记借鉴于此网站、狂神教程、尚硅谷教程以及其他博客内容",normalizedContent:" * 视频教程\n * 官方文档\n * 参考文章\n\n\n# 视频教程\n\n中华石杉的讲解视频\n\n * 初级视频：\n   \n   https://www.bilibili.com/video/bv1p4411h7sr\n\n * 进阶视频：\n   \n   https://www.bilibili.com/video/bv1p4411y7f4\n\n听说中华石衫讲的好，尚硅谷、狂神（我看的是狂神讲的）讲的也都可以\n\n\n# 官方文档\n\n * 低版本中文文档\n   \n   https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html\n\n * 最新版本的官方文档\n   \n   https://www.elastic.co/guide/en/elasticsearch/reference/7.x/index.html\n\n * java操作es的客户端文档\n   \n   https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html\n\n * kibana数据可视化界面使用官方文档\n   \n   https://www.elastic.co/guide/en/kibana/current/index.html\n\n\n# 参考文章\n\n学习资料以官网文档为主\n\n * elasticsearch知识体系详解\n   \n   https://www.pdai.tech/md/db/nosql-es/elasticsearch.html\n\n * springboot 检索篇 - 整合 elasticsearch7.6.2\n   \n   https://blog.csdn.net/weixin_41105242/article/details/107711634\n\n本人elasticsearch学习笔记借鉴于此网站、狂神教程、尚硅谷教程以及其他博客内容",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"ES - ElasticSearch基础概念",frontmatter:{permalink:"/es/introduce",title:"ES - ElasticSearch基础概念",date:"2021-06-07T17:02:23.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/02.ES%20-%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html",relativePath:"03.数据库/15.ElasticSearch/02.ES - 基础概念.md",key:"v-78e814f8",path:"/es/introduce/",headers:[{level:2,title:"为什么需要学习ElasticSearch",slug:"为什么需要学习elasticsearch",normalizedTitle:"为什么需要学习elasticsearch",charIndex:24},{level:2,title:"Doug Cutting",slug:"doug-cutting",normalizedTitle:"doug cutting",charIndex:48},{level:3,title:"Lucene",slug:"lucene",normalizedTitle:"lucene",charIndex:66},{level:2,title:"什么是ElasticSearch",slug:"什么是elasticsearch",normalizedTitle:"什么是elasticsearch",charIndex:76},{level:3,title:"ElasticSearch的由来",slug:"elasticsearch的由来",normalizedTitle:"elasticsearch的由来",charIndex:98},{level:3,title:"谁在使用ElasticSearch",slug:"谁在使用elasticsearch",normalizedTitle:"谁在使用elasticsearch",charIndex:120},{level:3,title:"为什么不是直接使用Lucene",slug:"为什么不是直接使用lucene",normalizedTitle:"为什么不是直接使用lucene",charIndex:143},{level:2,title:"ES和solr的差别",slug:"es和solr的差别",normalizedTitle:"es和solr的差别",charIndex:162},{level:2,title:"ES的基础概念",slug:"es的基础概念",normalizedTitle:"es的基础概念",charIndex:176},{level:2,title:"RESTful",slug:"restful",normalizedTitle:"restful",charIndex:187}],headersStr:"为什么需要学习ElasticSearch Doug Cutting Lucene 什么是ElasticSearch ElasticSearch的由来 谁在使用ElasticSearch 为什么不是直接使用Lucene ES和solr的差别 ES的基础概念 RESTful",content:"# ElasticSearch基础概念\n\n * 为什么需要学习ElasticSearch\n * Doug Cutting\n   * Lucene\n * 什么是ElasticSearch\n   * ElasticSearch的由来\n   * 谁在使用ElasticSearch\n   * 为什么不是直接使用Lucene\n * ES和solr的差别\n * ES的基础概念\n * RESTful\n\n\n# 为什么需要学习ElasticSearch\n\n排名\n\n根据 DB Engine的排名 显示，ElasticSearch是最受欢迎的企业级搜索引擎。\n\nElasticSearch在前十名内：\n\n\n\n所以为什么要学习ElasticSearch呢？\n\n1、在当前软件行业中，搜索是一个软件系统或平台的基本功能， 学习ElasticSearch就可以为相应的软件打造出良好的搜索体验。\n\n2、其次，ElasticSearch具备非常强的大数据分析能力。虽然Hadoop也可以做大数据分析，但是ElasticSearch的分析能力非常高，具备Hadoop不具备的能力。比如有时候用Hadoop分析一个结果，可能等待的时间比较长。\n\n3、ElasticSearch可以很方便的进行使用，可以将其安装在个人的笔记本电脑，也可以在生产环境中，将其进行水平扩展。\n\n4、国内比较大的互联网公司都在使用，比如小米、滴滴、携程等公司。另外，在腾讯云、阿里云的云平台上，也都有相应的ElasticSearch云产品可以使用。\n\n5、在当今大数据时代，掌握近实时的搜索和分析能力，才能掌握核心竞争力，洞见未来。\n\n\n# Doug Cutting\n\nHadoop之父：Doug Cutting\n\n1998年9月4日，Google 公司在美国硅谷成立。正如大家所知，它是一家做搜索引擎起家的公司。\n\n\n\n一位名叫 **Doug Cutting **的美国工程师，也迷上了搜索引擎。他做了一个用于文本搜索的函数库（姑且理解为软件的功能组件），命名为 Lucene。\n\n\n\nLucene 是用 JAVA 写成的，目标是为各种中小型应用软件加入全文检索功能。因为好用而且开源，非常受程序员们的欢迎。\n\n早期的时候，这个项目被发布在Doug Cutting的个人网站和SourceForge（一个开源软件网站）。后来，2001年底，Lucene 成为 Apache 软件基金会 jakarta 项目的一个子项目。\n\n\n\n2004年，Doug Cutting再接再励，在Lucene的基础上，和Apache开源伙伴 Mike Cafarella 合作，开发了一款可以代替当时的主流搜索的开源搜索引擎，命名为 Nutch 。\n\n\n\nNutch是一个建立在Lucene核心之上的网页搜索应用程序，可以下载下来直接使用。它在Lucene的基础上加了网络爬虫和一些网页相关的功能，目的就是从一个简单的站内检索推广到全球网络的搜索上，就像Google一样。\n\nNutch在业界的影响力比Lucene更大。\n\n大批网站采用了Nutch平台，大大降低了技术门槛，使低成本的普通计算机取代高价的Web服务器成为可能。甚至有一段时间，在硅谷有了一股用Nutch低成本创业的潮流。\n\n随着时间的推移，无论是Google还是Nutch，都面临搜索对象“体积”不断增大的问题。\n\n尤其是Google，作为互联网搜索引擎，需要存储大量的网页，并不断优化自己的搜索算法，提升搜索效率。\n\n\n\n在这个过程中，Google确实找到了不少好办法，并且无私地分享了出来。\n\n2003年，Google发表了一篇技术学术论文，公开介绍了自己的谷歌文件系统GFS（Google File  System）。\n\n这是Google公司为了存储海量搜索数据而设计的专用文件系统。\n\n第二年，也就是2004年，Doug Cutting基于Google的GFS论文，实现了分布式文件存储系统，并将它命名为NDFS（Nutch Distributed File System）。\n\n\n\n还是2004年，Google又发表了一篇技术学术论文，介绍自己的MapReduce编程模型。这个编程模型， 用于大规模数据集（大于1TB）的并行分析运算。\n\n第二年（2005年），Doug Cutting又基于MapReduce，在Nutch搜索引擎实现了该功能。\n\n\n\n2006年，Yahoo（雅虎）公司，招安了Doug Cutting\n\n\n\n加盟Yahoo之后，Doug Cutting将NDFS和MapReduce进行了升级改造，并重新命名为 Hadoop（NDFS也改名为HDFS，Hadoop Distributed File System）。\n\n这个，就是后来大名鼎鼎的大数据框架系统——Hadoop的由来。\n\n而Doug Cutting，则被人们称为 Hadoop之父。\n\n\n\nHadoop这个名字，实际上是Doug Cutting他儿子的黄色玩具大象的名字。所以，Hadoop的Logo，就是一只奔跑的黄色大象。\n\n\n\n我们继续往下说。 还是2006年，Google又发论文了。\n\n这次，它们介绍了自己的BigTable。这是一种分布式数据存储系统，一种用来处理海量数据的非关系型数据库。\n\nDoug Cutting当然没有放过，在自己的hadoop系统里面，引入了BigTable，并命名为HBase。\n\n\n\n好吧，反正就是紧跟Google时代步伐，你出什么，我学什么。\n\n所以，Hadoop的核心部分，基本上都有Google的影子。\n\n\n\n2008年1月，Hadoop成功上位，正式成为Apache基金会的顶级项目。\n\n同年2月，Yahoo宣布建成了一个拥有1万个内核的 Hadoop 集群，并将自己的搜索引擎产品部署在上面。\n\n7月，Hadoop打破世界纪录，成为最快排序1TB数据的系统，用时 209 秒。\n\n\n# Lucene\n\nLucene是一套信息检索工具包，并不包含搜索引擎系统，它包含了索引结构、读写索引工具、相关性工具、排序等功能，因此在使用Lucene时仍需要关注搜索引擎系统，例如数据获取、解析、分词等方面的 东西。\n\n为什么要给大家介绍下Lucene呢，因为我们学过的 solr 和 即将要学习的 elasticsearch 都是基于该工具包做的一些封装和增强罢了\n\n\n# 什么是ElasticSearch\n\n\n# ElasticSearch的由来\n\n许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。\n\n直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。\n\n后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。\n\n第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。\n\n据说，Shay 的妻子还在等着她的食谱搜索引擎…\n\n\n# 谁在使用ElasticSearch\n\nElasticSearch是一款非常强大的、基于Lucene的开源搜索及分析引擎；它是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。\n\n它被用作全文检索、结构化搜索、分析以及这三个功能的组合：\n\n * Wikipedia 使用 Elasticsearch 提供带有高亮片段的全文搜索，还有 search-as-you-type 和 did-you-mean 的建议。\n\n * The Guardian （国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，为它的编辑们提供公众对于新文章的实时反馈（好，坏，热门，垃圾，鄙视，崇拜）\n\n * Stack Overflow 将地理位置查询融入全文检索中去，并且使用 more-like-this 接口去查找相关的问题和回答。\n\n * GitHub 使用 Elasticsearch 对1300亿行代码进行查询。\n\n * .....\n\n除了搜索，结合Kibana、Logstash、Beats开源产品，Elastic Stack（简称ELK）还被广泛运用在大数据近实时分析领域，包括：日志分析、指标监控、信息安全等。它可以帮助你探索海量结构化、非结构化数据，按需创建可视化报表，对监控数据设置报警阈值，通过使用机器学习，自动识别异常状况。\n\n\n# 为什么不是直接使用Lucene\n\nLucene简介\n\nLucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具 包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。\n\nLucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。\n\nLucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。\n\nLucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。\n\n在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。\n\n全文搜索引擎是名副其实的搜索引擎，国外具代表性的有Google、Fast/AllTheWeb、AltaVista、 Inktomi、Teoma、WiseNut等，国内著名的有百度（Baidu）。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。\n\n从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（Indexer），俗称 “蜘蛛”（Spider）程序或“机器人”（Robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中 调用，如上面提到的7家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如 Lycos引擎。\n\nElasticSearch是基于Lucene的，那么为什么不是直接使用Lucene呢？\n\nLucene 可以说是当下最先进、高性能、全功能的搜索引擎库。\n\n但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene 非常 复杂。\n\nElasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单，通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。\n\n然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：\n\n * 一个分布式的实时文档存储，每个字段 可以被索引与搜索\n * 一个分布式实时分析搜索引擎\n * 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据\n\n\n# ES和solr的差别\n\nSolr简介\n\nSolr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了 比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化\n\nSolr可以独立运行，运行在 Jetty、Tomcat 等这些 Servlet 容器中，Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr 根据 xml 文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json 等格式的查询结果进行解析，组织页面布局。Solr 不提供构建 UI 的功能，Solr 提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。\n\nsolr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene。\n\nSolr是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的API接口。用户可以通过 http 请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。\n\nElasticsearch和Solr比较\n\n\n\n\n\n\n\n\n\n\n\n总结\n\n1、es基本是开箱即用，非常简单。Solr安装略微复杂一丢丢！\n\n2、Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。\n\n3、Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式。\n\n4、Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要 kibana 友好支撑\n\n5、Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用；\n\n * ES建立索引快（即查询慢），即实时性查询快，用于facebook新浪等搜索。\n * Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。\n\n6、Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。\n\n\n# ES的基础概念\n\n我们还需对比结构化数据库，看看ES的基础概念，为我们后面学习作铺垫。\n\n * Near Realtime（NRT） 近实时。数据提交索引后，立马就可以搜索到。\n * Cluster 集群，一个集群由一个唯一的名字标识，默认为“elasticsearch”。集群名称非常重要，具有相同集群名的节点才会组成一个集群。集群名称可以在配置文件中指定。\n * Node 节点：存储集群的数据，参与集群的索引和搜索功能。像集群有名字，节点也有自己的名称，默认在启动时会以一个随机的UUID的前七个字符作为节点的名字，你可以为其指定任意的名字。通过集群名在网络中发现同伴组成集群。一个节点也可是集群。\n * Index 索引: 一个索引是一个文档的集合（等同于solr中的集合）。每个索引有唯一的名字，通过这个名字来操作它。一个集群中可以有任意多个索引。\n * Type 类型：指在一个索引中，可以索引不同类型的文档，如用户数据、博客数据。从6.0.0 版本起已废弃，一个索引中只存放一类数据。\n * Document 文档：被索引的一条数据，索引的基本信息单元，以JSON格式来表示。\n * Shard 分片：在创建一个索引时可以指定分成多少个分片来存储。每个分片本身也是一个功能完善且独立的“索引”，可以被放置在集群的任意节点上。\n * Replication 备份: 一个分片可以有多个备份（副本）\n\n为了方便理解，作一个ES和数据库的对比\n\n\n\n和 mysql 的类比\n\n\n\nElasticsearch 7.X 中, Type 的概念已经被删除了。\n\n\n# RESTful\n\nREST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。\n\n在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客 户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。\n\n在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、 PUT、DELETE，还可能包括 HEAD 和 OPTIONS。简单的理解就是，如果想要访问互联网上的资源，就必须向资源所在的服务器发出请求，请求体中必须包含资源的网络路径，以及对资源进行的操作(增删改查)。",normalizedContent:"# elasticsearch基础概念\n\n * 为什么需要学习elasticsearch\n * doug cutting\n   * lucene\n * 什么是elasticsearch\n   * elasticsearch的由来\n   * 谁在使用elasticsearch\n   * 为什么不是直接使用lucene\n * es和solr的差别\n * es的基础概念\n * restful\n\n\n# 为什么需要学习elasticsearch\n\n排名\n\n根据 db engine的排名 显示，elasticsearch是最受欢迎的企业级搜索引擎。\n\nelasticsearch在前十名内：\n\n\n\n所以为什么要学习elasticsearch呢？\n\n1、在当前软件行业中，搜索是一个软件系统或平台的基本功能， 学习elasticsearch就可以为相应的软件打造出良好的搜索体验。\n\n2、其次，elasticsearch具备非常强的大数据分析能力。虽然hadoop也可以做大数据分析，但是elasticsearch的分析能力非常高，具备hadoop不具备的能力。比如有时候用hadoop分析一个结果，可能等待的时间比较长。\n\n3、elasticsearch可以很方便的进行使用，可以将其安装在个人的笔记本电脑，也可以在生产环境中，将其进行水平扩展。\n\n4、国内比较大的互联网公司都在使用，比如小米、滴滴、携程等公司。另外，在腾讯云、阿里云的云平台上，也都有相应的elasticsearch云产品可以使用。\n\n5、在当今大数据时代，掌握近实时的搜索和分析能力，才能掌握核心竞争力，洞见未来。\n\n\n# doug cutting\n\nhadoop之父：doug cutting\n\n1998年9月4日，google 公司在美国硅谷成立。正如大家所知，它是一家做搜索引擎起家的公司。\n\n\n\n一位名叫 **doug cutting **的美国工程师，也迷上了搜索引擎。他做了一个用于文本搜索的函数库（姑且理解为软件的功能组件），命名为 lucene。\n\n\n\nlucene 是用 java 写成的，目标是为各种中小型应用软件加入全文检索功能。因为好用而且开源，非常受程序员们的欢迎。\n\n早期的时候，这个项目被发布在doug cutting的个人网站和sourceforge（一个开源软件网站）。后来，2001年底，lucene 成为 apache 软件基金会 jakarta 项目的一个子项目。\n\n\n\n2004年，doug cutting再接再励，在lucene的基础上，和apache开源伙伴 mike cafarella 合作，开发了一款可以代替当时的主流搜索的开源搜索引擎，命名为 nutch 。\n\n\n\nnutch是一个建立在lucene核心之上的网页搜索应用程序，可以下载下来直接使用。它在lucene的基础上加了网络爬虫和一些网页相关的功能，目的就是从一个简单的站内检索推广到全球网络的搜索上，就像google一样。\n\nnutch在业界的影响力比lucene更大。\n\n大批网站采用了nutch平台，大大降低了技术门槛，使低成本的普通计算机取代高价的web服务器成为可能。甚至有一段时间，在硅谷有了一股用nutch低成本创业的潮流。\n\n随着时间的推移，无论是google还是nutch，都面临搜索对象“体积”不断增大的问题。\n\n尤其是google，作为互联网搜索引擎，需要存储大量的网页，并不断优化自己的搜索算法，提升搜索效率。\n\n\n\n在这个过程中，google确实找到了不少好办法，并且无私地分享了出来。\n\n2003年，google发表了一篇技术学术论文，公开介绍了自己的谷歌文件系统gfs（google file  system）。\n\n这是google公司为了存储海量搜索数据而设计的专用文件系统。\n\n第二年，也就是2004年，doug cutting基于google的gfs论文，实现了分布式文件存储系统，并将它命名为ndfs（nutch distributed file system）。\n\n\n\n还是2004年，google又发表了一篇技术学术论文，介绍自己的mapreduce编程模型。这个编程模型， 用于大规模数据集（大于1tb）的并行分析运算。\n\n第二年（2005年），doug cutting又基于mapreduce，在nutch搜索引擎实现了该功能。\n\n\n\n2006年，yahoo（雅虎）公司，招安了doug cutting\n\n\n\n加盟yahoo之后，doug cutting将ndfs和mapreduce进行了升级改造，并重新命名为 hadoop（ndfs也改名为hdfs，hadoop distributed file system）。\n\n这个，就是后来大名鼎鼎的大数据框架系统——hadoop的由来。\n\n而doug cutting，则被人们称为 hadoop之父。\n\n\n\nhadoop这个名字，实际上是doug cutting他儿子的黄色玩具大象的名字。所以，hadoop的logo，就是一只奔跑的黄色大象。\n\n\n\n我们继续往下说。 还是2006年，google又发论文了。\n\n这次，它们介绍了自己的bigtable。这是一种分布式数据存储系统，一种用来处理海量数据的非关系型数据库。\n\ndoug cutting当然没有放过，在自己的hadoop系统里面，引入了bigtable，并命名为hbase。\n\n\n\n好吧，反正就是紧跟google时代步伐，你出什么，我学什么。\n\n所以，hadoop的核心部分，基本上都有google的影子。\n\n\n\n2008年1月，hadoop成功上位，正式成为apache基金会的顶级项目。\n\n同年2月，yahoo宣布建成了一个拥有1万个内核的 hadoop 集群，并将自己的搜索引擎产品部署在上面。\n\n7月，hadoop打破世界纪录，成为最快排序1tb数据的系统，用时 209 秒。\n\n\n# lucene\n\nlucene是一套信息检索工具包，并不包含搜索引擎系统，它包含了索引结构、读写索引工具、相关性工具、排序等功能，因此在使用lucene时仍需要关注搜索引擎系统，例如数据获取、解析、分词等方面的 东西。\n\n为什么要给大家介绍下lucene呢，因为我们学过的 solr 和 即将要学习的 elasticsearch 都是基于该工具包做的一些封装和增强罢了\n\n\n# 什么是elasticsearch\n\n\n# elasticsearch的由来\n\n许多年前，一个刚结婚的名叫 shay banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 lucene 的一个早期版本。\n\n直接使用 lucene 是很难的，因此 shay 开始做一个抽象层，java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 compass。\n\n后来 shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 compass，把它变为一个独立的服务并取名 elasticsearch。\n\n第一个公开版本在2010年2月发布，从此以后，elasticsearch 已经成为了 github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 elasticsearch 提供商业服务，并开发新的特性，但是，elasticsearch 将永远开源并对所有人可用。\n\n据说，shay 的妻子还在等着她的食谱搜索引擎…\n\n\n# 谁在使用elasticsearch\n\nelasticsearch是一款非常强大的、基于lucene的开源搜索及分析引擎；它是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。\n\n它被用作全文检索、结构化搜索、分析以及这三个功能的组合：\n\n * wikipedia 使用 elasticsearch 提供带有高亮片段的全文搜索，还有 search-as-you-type 和 did-you-mean 的建议。\n\n * the guardian （国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，为它的编辑们提供公众对于新文章的实时反馈（好，坏，热门，垃圾，鄙视，崇拜）\n\n * stack overflow 将地理位置查询融入全文检索中去，并且使用 more-like-this 接口去查找相关的问题和回答。\n\n * github 使用 elasticsearch 对1300亿行代码进行查询。\n\n * .....\n\n除了搜索，结合kibana、logstash、beats开源产品，elastic stack（简称elk）还被广泛运用在大数据近实时分析领域，包括：日志分析、指标监控、信息安全等。它可以帮助你探索海量结构化、非结构化数据，按需创建可视化报表，对监控数据设置报警阈值，通过使用机器学习，自动识别异常状况。\n\n\n# 为什么不是直接使用lucene\n\nlucene简介\n\nlucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具 包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。\n\nlucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。\n\nlucene是一套用于全文检索和搜寻的开源程式库，由apache软件基金会支持和提供。\n\nlucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。\n\n在java开发环境里lucene是一个成熟的免费开源工具。就其本身而言，lucene是当前以及最近几年最受欢迎的免费java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。\n\n全文搜索引擎是名副其实的搜索引擎，国外具代表性的有google、fast/alltheweb、altavista、 inktomi、teoma、wisenut等，国内著名的有百度（baidu）。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。\n\n从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（indexer），俗称 “蜘蛛”（spider）程序或“机器人”（robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中 调用，如上面提到的7家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如 lycos引擎。\n\nelasticsearch是基于lucene的，那么为什么不是直接使用lucene呢？\n\nlucene 可以说是当下最先进、高性能、全功能的搜索引擎库。\n\n但是 lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 java 并将 lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。lucene 非常 复杂。\n\nelasticsearch 也是使用 java 编写的，它的内部使用 lucene 做索引与搜索，但是它的目的是使全文检索变得简单，通过隐藏 lucene 的复杂性，取而代之的提供一套简单一致的 restful api。\n\n然而，elasticsearch 不仅仅是 lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：\n\n * 一个分布式的实时文档存储，每个字段 可以被索引与搜索\n * 一个分布式实时分析搜索引擎\n * 能胜任上百个服务节点的扩展，并支持 pb 级别的结构化或者非结构化数据\n\n\n# es和solr的差别\n\nsolr简介\n\nsolr 是apache下的一个顶级开源项目，采用java开发，它是基于lucene的全文搜索服务器。solr提供了 比lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化\n\nsolr可以独立运行，运行在 jetty、tomcat 等这些 servlet 容器中，solr 索引的实现方法很简单，用 post 方法向 solr 服务器发送一个描述 field 及其内容的 xml 文档，solr 根据 xml 文档添加、删除、更新索引 。solr 搜索只需要发送 http get 请求，然后对 solr 返回xml、json 等格式的查询结果进行解析，组织页面布局。solr 不提供构建 ui 的功能，solr 提供了一个管理界面，通过管理界面可以查询solr的配置和运行情况。\n\nsolr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene。\n\nsolr是一个独立的企业级搜索应用服务器，它对外提供类似于 web-service 的api接口。用户可以通过 http 请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。\n\nelasticsearch和solr比较\n\n\n\n\n\n\n\n\n\n\n\n总结\n\n1、es基本是开箱即用，非常简单。solr安装略微复杂一丢丢！\n\n2、solr 利用 zookeeper 进行分布式管理，而 elasticsearch 自身带有分布式协调管理功能。\n\n3、solr 支持更多格式的数据，比如json、xml、csv，而 elasticsearch 仅支持json文件格式。\n\n4、solr 官方提供的功能更多，而 elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要 kibana 友好支撑\n\n5、solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用；\n\n * es建立索引快（即查询慢），即实时性查询快，用于facebook新浪等搜索。\n * solr 是传统搜索应用的有力解决方案，但 elasticsearch 更适用于新兴的实时搜索应用。\n\n6、solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。\n\n\n# es的基础概念\n\n我们还需对比结构化数据库，看看es的基础概念，为我们后面学习作铺垫。\n\n * near realtime（nrt） 近实时。数据提交索引后，立马就可以搜索到。\n * cluster 集群，一个集群由一个唯一的名字标识，默认为“elasticsearch”。集群名称非常重要，具有相同集群名的节点才会组成一个集群。集群名称可以在配置文件中指定。\n * node 节点：存储集群的数据，参与集群的索引和搜索功能。像集群有名字，节点也有自己的名称，默认在启动时会以一个随机的uuid的前七个字符作为节点的名字，你可以为其指定任意的名字。通过集群名在网络中发现同伴组成集群。一个节点也可是集群。\n * index 索引: 一个索引是一个文档的集合（等同于solr中的集合）。每个索引有唯一的名字，通过这个名字来操作它。一个集群中可以有任意多个索引。\n * type 类型：指在一个索引中，可以索引不同类型的文档，如用户数据、博客数据。从6.0.0 版本起已废弃，一个索引中只存放一类数据。\n * document 文档：被索引的一条数据，索引的基本信息单元，以json格式来表示。\n * shard 分片：在创建一个索引时可以指定分成多少个分片来存储。每个分片本身也是一个功能完善且独立的“索引”，可以被放置在集群的任意节点上。\n * replication 备份: 一个分片可以有多个备份（副本）\n\n为了方便理解，作一个es和数据库的对比\n\n\n\n和 mysql 的类比\n\n\n\nelasticsearch 7.x 中, type 的概念已经被删除了。\n\n\n# restful\n\nrest 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 restful。web 应用程序最重要的 rest 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。\n\n在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 uri (universal resource identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客 户端和服务器之间传输状态。使用的是标准的 http 方法，比如 get、put、post 和 delete。\n\n在 rest 样式的 web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 http get、post、 put、delete，还可能包括 head 和 options。简单的理解就是，如果想要访问互联网上的资源，就必须向资源所在的服务器发出请求，请求体中必须包含资源的网络路径，以及对资源进行的操作(增删改查)。",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ES - 安装ElasticSearch",frontmatter:{permalink:"/es/install",title:"ES - 安装ElasticSearch",date:"2021-06-09T21:44:50.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/04.ES%20-%20%E5%AE%89%E8%A3%85.html",relativePath:"03.数据库/15.ElasticSearch/04.ES - 安装.md",key:"v-b013a97e",path:"/es/install/",headers:[{level:2,title:"官网相关教程",slug:"官网相关教程",normalizedTitle:"官网相关教程",charIndex:3},{level:2,title:"安装ElasticSearch",slug:"安装elasticsearch",normalizedTitle:"安装elasticsearch",charIndex:13},{level:3,title:"windows 版本",slug:"windows-版本",normalizedTitle:"windows 版本",charIndex:34},{level:3,title:"linux 版本",slug:"linux-版本",normalizedTitle:"linux 版本",charIndex:50},{level:3,title:"使用 Docker",slug:"使用-docker",normalizedTitle:"使用 docker",charIndex:64},{level:2,title:"配置密码访问",slug:"配置密码访问",normalizedTitle:"配置密码访问",charIndex:77}],headersStr:"官网相关教程 安装ElasticSearch windows 版本 linux 版本 使用 Docker 配置密码访问",content:' * 官网相关教程\n * 安装ElasticSearch\n   * windows 版本\n   * linux 版本\n   * 使用 Docker\n * 配置密码访问\n\n\n# 官网相关教程\n\n> 安装ElasticSearch还是先要看下官方网站。\n\n * 官方网站\n * 官方2.x中文教程中安装教程\n * 官方ElasticSearch下载地址\n * 官方Kibana下载地址\n\n本系列教程基于ElasticSearch 7.x版本。\n\n\n# 安装ElasticSearch\n\nElasticSearch 是使用 java 开发的，且本版本的 es 需要的 jdk 版本要是 1.8 以上，所以安装ElasticSearch 之前保证 JDK1.8+ ，并正确的配置好JDK环境变量，否则会启动ElasticSearch失败。\n\n\n# windows 版本\n\nElasticSearch\n\nwin下载：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1.zip\n\n * 文件：\n\nbin：启动文件\nconfig：配置文件\n    log4j2.properties：日志配置文件\n    jvm.options：java虚拟机的配置\n    elasticsearch.yml：es的配置文件\ndata：索引数据目录\nlib：相关类库Jar包\nlogs：日志目录\nmodules：功能模块\nplugins：插件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 启动：\n\n双击 ElasticSearch 下的 bin 目录中的 elasticsearch.bat 启动\n\n * 访问：\n\nhttp://localhost:9200\n\n安装ES的图形化界面插件客户端Head\n\n注意：需要 NodeJS 的环境\n\nHead 是 elasticsearch 的集群管理工具，可以用于数据的浏览查询！被托管在 github 上面！\n\n地址： https://github.com/mobz/elasticsearch-head/\n\n1、下载并解压\n\n下载 elasticsearch-head-master.zip\n\n#安装依赖！\ncnpm install\n#运行\nnpm run start\n\n\n1\n2\n3\n4\n\n\n2、修改配置文件 elasticsearch.yml\n\n由于 ES 进程和客户端进程端口号不同，存在跨域问题，所以我们要在 ES 的配置文件中配置下跨域问题\n\n# 跨域配置：\nhttp.cors.enabled: true\nhttp.cors.allow-origin: "*"\n\n\n1\n2\n3\n\n\n3、启动测试\n\n启动 ElasticSearch\n\n并使用head工具进行连接测试！\n\n访问url：http://localhost:9100/\n\n安装Kibana\n\nKibana 是一个针对 Elasticsearch 的开源分析及可视化平台，用来搜索、查看交互存储在 Elasticsearch 索引中的数据。\n\n使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。\n\n设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动 Elasticsearch索引监测。\n\n * 下载Kibana\n\n注意版本对应关系： https://www.elastic.co/cn/downloads/kibana\n\n解压后进入，双击 kibana.bat 启动服务就可以了，ELK基本上都是拆箱即用的\n\n然后访问 http://localhost:5601/\n\nkibana会自动去访问9200，也就是 elasticsearch 的端口号（当然 elasticsearch 这个时候必须启动着），然后就可以使用 kibana 了！\n\n * 访问界面是英文，可修改成中文\n\n只需要在配置文件 kibana.yml 中加入\n\ni18n.locale: "zh-CN"\n\n\n1\n\n\n重启即可！\n\n\n# linux 版本\n\n请先确保安装了 jdk1.8 以上版本\n\n安装ElasticSearch\n\n * 进入一个目录，下载\n\ncurl -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1-linux-x86_64.tar.gz\n\n\n1\n\n * 解压\n\ntar zxvf /opt/elasticsearch-7.6.1-linux-x86_64.tar.gz\n\n\n1\n\n * 增加elasticSearch用户\n\n必须创建一个非root用户来运行ElasticSearch\n\n如果你使用root用户来启动ElasticSearch，则会有如下错误信息：\n\n[root@VM-0-6-centos elasticsearch-7.6.1]# ./bin/elasticsearch\nOpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.\n[2021-06-11T17:15:56,884][ERROR][o.e.b.ElasticsearchUncaughtExceptionHandler] [VM-0-6-centos] uncaught exception in thread [main]\norg.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root\n\tat org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:174) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:161) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:125) ~[elasticsearch-cli-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:126) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92) ~[elasticsearch-7.6.1.jar:7.6.1]\nCaused by: java.lang.RuntimeException: can not run elasticsearch as root\n\tat org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:105) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:172) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:349) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:170) ~[elasticsearch-7.6.1.jar:7.6.1]\n\t... 6 more\nuncaught exception in thread [main]\njava.lang.RuntimeException: can not run elasticsearch as root\n\tat org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:105)\n\tat org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:172)\n\tat org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:349)\n\tat org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:170)\n\tat org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:161)\n\tat org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86)\n\tat org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:125)\n\tat org.elasticsearch.cli.Command.main(Command.java:90)\n\tat org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:126)\n\tat org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92)\nFor complete error details, refer to the log at /opt/elasticsearch-7.6.1/logs/elasticsearch.log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n增加 elasticsearch 用户：\n\n[root@VM-0-6-centos elasticsearch-7.6.1]# useradd elasticsearch\n[root@VM-0-6-centos elasticsearch-7.6.1]# passwd elasticsearch\nChanging password for user elasticsearch.\nNew password: \nBAD PASSWORD: The password contains the user name in some form\nRetype new password: \npasswd: all authentication tokens updated successfully.\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n修改目录权限至新增的 elasticsearch 用户（没权限启动会报错）\n\n在 root 用户下执行命令\n\n[root@VM-0-6-centos ~]# chown -R elasticsearch /opt/elasticsearch-7.6.1\n\n\n1\n\n * 启动\n\n#\t切换用户\nsu elasticsearch\n#\t启动\n./bin/elasticsearch -d\n\n\n1\n2\n3\n4\n\n * 查看安装是否成功\n\n[root@VM-0-6-centos ~]# netstat -ntlp | grep 9200\ntcp6       0      0 127.0.0.1:9200          :::*                    LISTEN      11601/java          \ntcp6       0      0 ::1:9200                :::*                    LISTEN      11601/java          \n#\t访问成功\n[root@VM-0-6-centos ~]# curl 127.0.0.1:9200\n{\n  "name" : "VM-0-6-centos",\n  "cluster_name" : "elasticsearch",\n  "cluster_uuid" : "sLGiUbfQQ5-btWB9QiOnxg",\n  "version" : {\n    "number" : "7.6.1",\n    "build_flavor" : "default",\n    "build_type" : "tar",\n    "build_hash" : "aa751e09be0a5072e8570670309b1f12348f023b",\n    "build_date" : "2020-02-29T00:15:25.529771Z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.4.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "You Know, for Search"\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n安装Kibana\n\n安装 Kibana 及 ElasticSearch 相关配置请访问：https://www.pdai.tech/md/db/nosql-es/elasticsearch-x-install.html\n\n\n# 使用 Docker\n\n官方文档：https://www.elastic.co/guide/en/kibana/current/docker.html\n\n创建网络\n\ndocker network create elastic\n\n\n1\n\n\n加上内存限制启动 ES\n\ndocker run -d --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.1\n\n\n1\n\n\n启动 Kibana\n\ndocker run -d --name kib01-test --net elastic -p 5601:5601 -e "ELASTICSEARCH_HOSTS=http://es01-test:9200" kibana:7.6.1\n\n\n1\n\n\n可视化工具 Elasticsearch-head（可选）\n\ndocker run -d --name head-test --net elastic -p 9100:9100  mobz/elasticsearch-head:5\n\n\n1\n\n\n\n# 配置密码访问\n\n修改Elastic配置\n\n使用基本许可证时，默认情况下禁用Elasticsearch安全功能。由于我测试环境是放在公网上的，所以需要设置下密码访问。相关文档可以参考这里\n\n1、进入正在运行的容器\n\n#\ndocker exec -it 容器id /bin/bash\n#安装 vim\nyum -y install vim\n\n\n1\n2\n3\n4\n\n\n2、更改 config/elasticsearch.yml 文件，设置 xpack.security.enabled 为 true\n\n[root@06c5914709a5 config]# vim elasticsearch.yml\n[root@06c5914709a5 config]# cat elasticsearch.yml\ncluster.name: "docker-cluster"\nnetwork.host: 0.0.0.0\nxpack.security.enabled: true\n\n\n1\n2\n3\n4\n5\n\n\n3、重启elasticsearch容器\n\n[root@VM-0-6-centos z-test]# docker restart es01-test\nes01-test\n\n\n1\n2\n\n\n4、进入容器设置各个组件的密码\n\n[root@06c5914709a5 elasticsearch]# ./bin/elasticsearch-setup-passwords interactive\nInitiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.\nYou will be prompted to enter passwords as the process progresses.\nPlease confirm that you would like to continue [y/N]y\n\n\nEnter password for [elastic]: \nReenter password for [elastic]: \nEnter password for [apm_system]: \nReenter password for [apm_system]: \nEnter password for [kibana]: \nReenter password for [kibana]: \nEnter password for [logstash_system]: \nReenter password for [logstash_system]: \nEnter password for [beats_system]: \nReenter password for [beats_system]: \nEnter password for [remote_monitoring_user]: \nReenter password for [remote_monitoring_user]: \nChanged password for user [apm_system]\nChanged password for user [kibana]\nChanged password for user [logstash_system]\nChanged password for user [beats_system]\nChanged password for user [remote_monitoring_user]\nChanged password for user [elastic]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n修改 Kibana 配置\n\n1、修改 kibana.yml\n\n进入容器\n\n添加配置： elasticsearch.username: "elastic"\n\nbash-4.2$ vi kibana.yml\nbash-4.2$ cat kibana.yml\n#\n# ** THIS IS AN AUTO-GENERATED FILE **\n#\n\n# Default Kibana configuration for docker target\nserver.name: kibana\nserver.host: "0"\nelasticsearch.hosts: [ "http://elasticsearch:9200" ]\nxpack.monitoring.ui.container.elasticsearch.enabled: true\nelasticsearch.username: "elastic"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n2、创建kibana keystore\n\n./bin/kibana-keystore create\n\n\n1\n\n\n3、在kibana keystore 中添加密码\n\n./bin/kibana-keystore add elasticsearch.password\n\n\n1\n\n\n4、重启容器\n\n[root@VM-0-6-centos /]# docker restart kib01-test\nkib01-test\n\n\n1\n2\n\n\n再次访问：ip:9200，则需要输入账号和密码\n\n账号为：elastic\n\n',normalizedContent:' * 官网相关教程\n * 安装elasticsearch\n   * windows 版本\n   * linux 版本\n   * 使用 docker\n * 配置密码访问\n\n\n# 官网相关教程\n\n> 安装elasticsearch还是先要看下官方网站。\n\n * 官方网站\n * 官方2.x中文教程中安装教程\n * 官方elasticsearch下载地址\n * 官方kibana下载地址\n\n本系列教程基于elasticsearch 7.x版本。\n\n\n# 安装elasticsearch\n\nelasticsearch 是使用 java 开发的，且本版本的 es 需要的 jdk 版本要是 1.8 以上，所以安装elasticsearch 之前保证 jdk1.8+ ，并正确的配置好jdk环境变量，否则会启动elasticsearch失败。\n\n\n# windows 版本\n\nelasticsearch\n\nwin下载：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1.zip\n\n * 文件：\n\nbin：启动文件\nconfig：配置文件\n    log4j2.properties：日志配置文件\n    jvm.options：java虚拟机的配置\n    elasticsearch.yml：es的配置文件\ndata：索引数据目录\nlib：相关类库jar包\nlogs：日志目录\nmodules：功能模块\nplugins：插件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 启动：\n\n双击 elasticsearch 下的 bin 目录中的 elasticsearch.bat 启动\n\n * 访问：\n\nhttp://localhost:9200\n\n安装es的图形化界面插件客户端head\n\n注意：需要 nodejs 的环境\n\nhead 是 elasticsearch 的集群管理工具，可以用于数据的浏览查询！被托管在 github 上面！\n\n地址： https://github.com/mobz/elasticsearch-head/\n\n1、下载并解压\n\n下载 elasticsearch-head-master.zip\n\n#安装依赖！\ncnpm install\n#运行\nnpm run start\n\n\n1\n2\n3\n4\n\n\n2、修改配置文件 elasticsearch.yml\n\n由于 es 进程和客户端进程端口号不同，存在跨域问题，所以我们要在 es 的配置文件中配置下跨域问题\n\n# 跨域配置：\nhttp.cors.enabled: true\nhttp.cors.allow-origin: "*"\n\n\n1\n2\n3\n\n\n3、启动测试\n\n启动 elasticsearch\n\n并使用head工具进行连接测试！\n\n访问url：http://localhost:9100/\n\n安装kibana\n\nkibana 是一个针对 elasticsearch 的开源分析及可视化平台，用来搜索、查看交互存储在 elasticsearch 索引中的数据。\n\n使用kibana，可以通过各种图表进行高级数据分析及展示。kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示elasticsearch查询动态。\n\n设置kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成kibana安装并启动 elasticsearch索引监测。\n\n * 下载kibana\n\n注意版本对应关系： https://www.elastic.co/cn/downloads/kibana\n\n解压后进入，双击 kibana.bat 启动服务就可以了，elk基本上都是拆箱即用的\n\n然后访问 http://localhost:5601/\n\nkibana会自动去访问9200，也就是 elasticsearch 的端口号（当然 elasticsearch 这个时候必须启动着），然后就可以使用 kibana 了！\n\n * 访问界面是英文，可修改成中文\n\n只需要在配置文件 kibana.yml 中加入\n\ni18n.locale: "zh-cn"\n\n\n1\n\n\n重启即可！\n\n\n# linux 版本\n\n请先确保安装了 jdk1.8 以上版本\n\n安装elasticsearch\n\n * 进入一个目录，下载\n\ncurl -o https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1-linux-x86_64.tar.gz\n\n\n1\n\n * 解压\n\ntar zxvf /opt/elasticsearch-7.6.1-linux-x86_64.tar.gz\n\n\n1\n\n * 增加elasticsearch用户\n\n必须创建一个非root用户来运行elasticsearch\n\n如果你使用root用户来启动elasticsearch，则会有如下错误信息：\n\n[root@vm-0-6-centos elasticsearch-7.6.1]# ./bin/elasticsearch\nopenjdk 64-bit server vm warning: option useconcmarksweepgc was deprecated in version 9.0 and will likely be removed in a future release.\n[2021-06-11t17:15:56,884][error][o.e.b.elasticsearchuncaughtexceptionhandler] [vm-0-6-centos] uncaught exception in thread [main]\norg.elasticsearch.bootstrap.startupexception: java.lang.runtimeexception: can not run elasticsearch as root\n\tat org.elasticsearch.bootstrap.elasticsearch.init(elasticsearch.java:174) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.elasticsearch.execute(elasticsearch.java:161) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.cli.environmentawarecommand.execute(environmentawarecommand.java:86) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.cli.command.mainwithouterrorhandling(command.java:125) ~[elasticsearch-cli-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.cli.command.main(command.java:90) ~[elasticsearch-cli-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.elasticsearch.main(elasticsearch.java:126) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.elasticsearch.main(elasticsearch.java:92) ~[elasticsearch-7.6.1.jar:7.6.1]\ncaused by: java.lang.runtimeexception: can not run elasticsearch as root\n\tat org.elasticsearch.bootstrap.bootstrap.initializenatives(bootstrap.java:105) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.bootstrap.setup(bootstrap.java:172) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.bootstrap.init(bootstrap.java:349) ~[elasticsearch-7.6.1.jar:7.6.1]\n\tat org.elasticsearch.bootstrap.elasticsearch.init(elasticsearch.java:170) ~[elasticsearch-7.6.1.jar:7.6.1]\n\t... 6 more\nuncaught exception in thread [main]\njava.lang.runtimeexception: can not run elasticsearch as root\n\tat org.elasticsearch.bootstrap.bootstrap.initializenatives(bootstrap.java:105)\n\tat org.elasticsearch.bootstrap.bootstrap.setup(bootstrap.java:172)\n\tat org.elasticsearch.bootstrap.bootstrap.init(bootstrap.java:349)\n\tat org.elasticsearch.bootstrap.elasticsearch.init(elasticsearch.java:170)\n\tat org.elasticsearch.bootstrap.elasticsearch.execute(elasticsearch.java:161)\n\tat org.elasticsearch.cli.environmentawarecommand.execute(environmentawarecommand.java:86)\n\tat org.elasticsearch.cli.command.mainwithouterrorhandling(command.java:125)\n\tat org.elasticsearch.cli.command.main(command.java:90)\n\tat org.elasticsearch.bootstrap.elasticsearch.main(elasticsearch.java:126)\n\tat org.elasticsearch.bootstrap.elasticsearch.main(elasticsearch.java:92)\nfor complete error details, refer to the log at /opt/elasticsearch-7.6.1/logs/elasticsearch.log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n增加 elasticsearch 用户：\n\n[root@vm-0-6-centos elasticsearch-7.6.1]# useradd elasticsearch\n[root@vm-0-6-centos elasticsearch-7.6.1]# passwd elasticsearch\nchanging password for user elasticsearch.\nnew password: \nbad password: the password contains the user name in some form\nretype new password: \npasswd: all authentication tokens updated successfully.\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n修改目录权限至新增的 elasticsearch 用户（没权限启动会报错）\n\n在 root 用户下执行命令\n\n[root@vm-0-6-centos ~]# chown -r elasticsearch /opt/elasticsearch-7.6.1\n\n\n1\n\n * 启动\n\n#\t切换用户\nsu elasticsearch\n#\t启动\n./bin/elasticsearch -d\n\n\n1\n2\n3\n4\n\n * 查看安装是否成功\n\n[root@vm-0-6-centos ~]# netstat -ntlp | grep 9200\ntcp6       0      0 127.0.0.1:9200          :::*                    listen      11601/java          \ntcp6       0      0 ::1:9200                :::*                    listen      11601/java          \n#\t访问成功\n[root@vm-0-6-centos ~]# curl 127.0.0.1:9200\n{\n  "name" : "vm-0-6-centos",\n  "cluster_name" : "elasticsearch",\n  "cluster_uuid" : "slgiubfqq5-btwb9qionxg",\n  "version" : {\n    "number" : "7.6.1",\n    "build_flavor" : "default",\n    "build_type" : "tar",\n    "build_hash" : "aa751e09be0a5072e8570670309b1f12348f023b",\n    "build_date" : "2020-02-29t00:15:25.529771z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.4.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "you know, for search"\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n安装kibana\n\n安装 kibana 及 elasticsearch 相关配置请访问：https://www.pdai.tech/md/db/nosql-es/elasticsearch-x-install.html\n\n\n# 使用 docker\n\n官方文档：https://www.elastic.co/guide/en/kibana/current/docker.html\n\n创建网络\n\ndocker network create elastic\n\n\n1\n\n\n加上内存限制启动 es\n\ndocker run -d --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e es_java_opts="-xms64m -xmx512m" elasticsearch:7.6.1\n\n\n1\n\n\n启动 kibana\n\ndocker run -d --name kib01-test --net elastic -p 5601:5601 -e "elasticsearch_hosts=http://es01-test:9200" kibana:7.6.1\n\n\n1\n\n\n可视化工具 elasticsearch-head（可选）\n\ndocker run -d --name head-test --net elastic -p 9100:9100  mobz/elasticsearch-head:5\n\n\n1\n\n\n\n# 配置密码访问\n\n修改elastic配置\n\n使用基本许可证时，默认情况下禁用elasticsearch安全功能。由于我测试环境是放在公网上的，所以需要设置下密码访问。相关文档可以参考这里\n\n1、进入正在运行的容器\n\n#\ndocker exec -it 容器id /bin/bash\n#安装 vim\nyum -y install vim\n\n\n1\n2\n3\n4\n\n\n2、更改 config/elasticsearch.yml 文件，设置 xpack.security.enabled 为 true\n\n[root@06c5914709a5 config]# vim elasticsearch.yml\n[root@06c5914709a5 config]# cat elasticsearch.yml\ncluster.name: "docker-cluster"\nnetwork.host: 0.0.0.0\nxpack.security.enabled: true\n\n\n1\n2\n3\n4\n5\n\n\n3、重启elasticsearch容器\n\n[root@vm-0-6-centos z-test]# docker restart es01-test\nes01-test\n\n\n1\n2\n\n\n4、进入容器设置各个组件的密码\n\n[root@06c5914709a5 elasticsearch]# ./bin/elasticsearch-setup-passwords interactive\ninitiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user.\nyou will be prompted to enter passwords as the process progresses.\nplease confirm that you would like to continue [y/n]y\n\n\nenter password for [elastic]: \nreenter password for [elastic]: \nenter password for [apm_system]: \nreenter password for [apm_system]: \nenter password for [kibana]: \nreenter password for [kibana]: \nenter password for [logstash_system]: \nreenter password for [logstash_system]: \nenter password for [beats_system]: \nreenter password for [beats_system]: \nenter password for [remote_monitoring_user]: \nreenter password for [remote_monitoring_user]: \nchanged password for user [apm_system]\nchanged password for user [kibana]\nchanged password for user [logstash_system]\nchanged password for user [beats_system]\nchanged password for user [remote_monitoring_user]\nchanged password for user [elastic]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n修改 kibana 配置\n\n1、修改 kibana.yml\n\n进入容器\n\n添加配置： elasticsearch.username: "elastic"\n\nbash-4.2$ vi kibana.yml\nbash-4.2$ cat kibana.yml\n#\n# ** this is an auto-generated file **\n#\n\n# default kibana configuration for docker target\nserver.name: kibana\nserver.host: "0"\nelasticsearch.hosts: [ "http://elasticsearch:9200" ]\nxpack.monitoring.ui.container.elasticsearch.enabled: true\nelasticsearch.username: "elastic"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n2、创建kibana keystore\n\n./bin/kibana-keystore create\n\n\n1\n\n\n3、在kibana keystore 中添加密码\n\n./bin/kibana-keystore add elasticsearch.password\n\n\n1\n\n\n4、重启容器\n\n[root@vm-0-6-centos /]# docker restart kib01-test\nkib01-test\n\n\n1\n2\n\n\n再次访问：ip:9200，则需要输入账号和密码\n\n账号为：elastic\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ES - 索引和文档的基本操作",frontmatter:{title:"ES - 索引和文档的基本操作",date:"2021-06-20T22:46:20.000Z",permalink:"/es/index-doc/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/06.ES%20-%20%E7%B4%A2%E5%BC%95%E5%92%8C%E6%96%87%E6%A1%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",relativePath:"03.数据库/15.ElasticSearch/06.ES - 索引和文档的基本操作.md",key:"v-23662401",path:"/es/index-doc/",headers:[{level:2,title:"索引简单操作",slug:"索引简单操作",normalizedTitle:"索引简单操作",charIndex:3},{level:3,title:"创建索引",slug:"创建索引",normalizedTitle:"创建索引",charIndex:15},{level:3,title:"查看和删除索引",slug:"查看和删除索引",normalizedTitle:"查看和删除索引",charIndex:25},{level:3,title:"批量索引文档_bulk",slug:"批量索引文档-bulk",normalizedTitle:"批量索引文档_bulk",charIndex:1802},{level:2,title:"文档基本操作",slug:"文档基本操作",normalizedTitle:"文档基本操作",charIndex:48},{level:3,title:"添加数据 PUT",slug:"添加数据-put",normalizedTitle:"添加数据 put",charIndex:60},{level:3,title:"查询数据 GET",slug:"查询数据-get",normalizedTitle:"查询数据 get",charIndex:74},{level:3,title:"更新数据 POST",slug:"更新数据-post",normalizedTitle:"更新数据 post",charIndex:88},{level:3,title:"删除数据 DELETE",slug:"删除数据-delete",normalizedTitle:"删除数据 delete",charIndex:103},{level:2,title:"索引的自动创建",slug:"索引的自动创建",normalizedTitle:"索引的自动创建",charIndex:118},{level:2,title:"索引的格式",slug:"索引的格式",normalizedTitle:"索引的格式",charIndex:129},{level:2,title:"索引管理操作",slug:"索引管理操作",normalizedTitle:"索引管理操作",charIndex:138}],headersStr:"索引简单操作 创建索引 查看和删除索引 批量索引文档_bulk 文档基本操作 添加数据 PUT 查询数据 GET 更新数据 POST 删除数据 DELETE 索引的自动创建 索引的格式 索引管理操作",content:' * 索引简单操作\n   * 创建索引\n   * 查看和删除索引\n   * 批量索引文档\n * 文档基本操作\n   * 添加数据 PUT\n   * 查询数据 GET\n   * 更新数据 POST\n   * 删除数据 DELETE\n * 索引的自动创建\n * 索引的格式\n * 索引管理操作\n\n\n# 索引简单操作\n\n\n# 创建索引\n\nPostman 进行测试\n\n * Postman官网下载：https://www.postman.com/downloads/\n\n * 汉化教程：https://gitee.com/hlmd/PostmanCn/\n\n由于我的 ElasticSearch 部署到在公关上，且有账号和密码\n\n所以地址为：http://用户名:密码@url\n\n本地则为：http://127.0.0.1:9200\n\n * 创建索引：http://127.0.0.1:9200/shopping\n\n\n\n{\n    //响应结果\n    "acknowledged": true,\n    //分片结果\n    "shards_acknowledged": true,\n    //索引名称\n    "index": "shopping"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意：创建索引库的分片数默认 1 片，在 7.0.0 之前的 Elasticsearch 版本中，默认 5 片\n\nKibana的 dev tool 进行测试\n\n如果重复添加索引，会返回错误信息\n\n\n\n为了方便测试，后续使用kibana的dev tool来进行学习测试\n\n\n# 查看和删除索引\n\n查看所有索引\n\nGET /_cat/indices?v\n\n\n1\n\n\n\n\n这里请求路径中的_cat 表示查看的意思，indices 表示索引，所以整体含义就是查看当前 ES 服务器中的所有索引\n\n表头               含义\nhealth           当前服务器健康状态：\n                 green(集群完整)；yellow(单点正常、集群不完整)；red(单点不正常)\nstatus           索引打开、关闭状态\nindex            索引名\nuuid             索引统一编号\npri              主分片数量\nrep              副本数量\ndocs.count       可用文档数量\ndocs.deleted     文档删除状态（逻辑删除）\nstore.size       主分片和副分片整体占空间大小\npri.store.size   主分片占空间大小\n\n查看单个索引\n\nGET /shopping\n\n\n1\n\n\n查看索引向 ES 服务器发送的请求路径和创建索引是一致的。但是 HTTP 方法不一致。这里可以体会一下 RESTful 的意义，\n\n响应结果：\n\n{\n  "shopping" : {//【索引名】\n    "aliases" : { },//【别名】\n    "mappings" : { },//"【映射】\n    "settings" : {\n      "index" : {\n        "creation_date" : "1624201817578",//【创建时间】\n        "number_of_shards" : "1",//【主分片数量】\n        "number_of_replicas" : "1",//【副分片数量】\n        "uuid" : "5fPfnRjcTuyxReq7AFKQnw",//【唯一标识】\n        "version" : {\n          "created" : "7060199"//【版本】】\n        },\n        "provided_name" : "shopping"\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n删除索引\n\n * DELETE /索引\n\nDELETE /shopping\n\n\n1\n\n\n{\n  "acknowledged" : true\n}\n\n\n\n1\n2\n3\n4\n\n\n\n# 批量索引文档_bulk\n\nES 还提供了批量操作，比如这里我们可以使用批量操作来插入一些数据，供我们在后面学习使用。\n\n使用批量来批处理文档操作比单独提交请求要快得多，因为它减少了网络往返。\n\n * 下载测试数据\n   \n   https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip\n\n数据的格式如下\n\n{\n  "account_number": 0,\n  "balance": 16623,\n  "firstname": "Bradshaw",\n  "lastname": "Mckenzie",\n  "age": 29,\n  "gender": "F",\n  "address": "244 Columbus Place",\n  "employer": "Euron",\n  "email": "bradshawmckenzie@euron.com",\n  "city": "Hobucken",\n  "state": "CO"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n例如把文件复制到 ES 目录的 data\n\ndocker：\n\ndocker cp /home/accounts.json  06c5914709a5:/usr/share/elasticsearch/data/\n\n\n1\n\n\n然后执行\n\ncurl -H "Content-Type: application/json" -XPOST "localhost:9200/bank/_bulk?pretty&refresh" --data-binary @accounts.json\n\n\n1\n\n\n如果在其他目录，例如 /opt//accounts.json\n\ncurl -H "Content-Type: application/json" -XPOST "localhost:9200/bank/_bulk?pretty&refresh" --data-binary "@/opt/accounts.json"\n\n\n1\n\n\n> 或者我们可以直接插入数据：\n> \n> 注意格式json和text均不可，要去kibana里Dev Tools\n\nPOST http://localhost:9200/bank/_bulk\n\n两行为一个整体，index代表索引，也就是保存操作，下面一行为保存的数据\n\n{"index":{"_id":"1"}}\n{"name":"a"}\n{"index":{"_id":"2"}}\n{"name":"b"}\n\n\n1\n2\n3\n4\n\n * 语法格式：\n\naction：执行的动作，新增，修改，删除等\n\nmetadata：要操作的数据，比如id是多少\n\n{action:{metadata}}\\n\n{request body  }\\n\n\n{action:{metadata}}\\n\n{request body  }\\n\n\n\n1\n2\n3\n4\n5\n\n\n这里的批量操作，当发生某一条执行发生失败时，其他的数据仍然能够接着执行，也就是说彼此之间是独立的。\n\nbulk API 以此按顺序执行所有的 action(动作)。如果一个单个的动作因任何原因而失败， 它将继续处理它后面剩余的动作。当 bulk API 返回时，它将提供每个动作的状态(与发送 的顺序相同)，所以您可以检查是否一个指定的动作是不是失败了。\n\n * 实例：\n   \n   对于整个索引执行批量操作(需在kibana里Dev Tools)\n   \n   当没指定任何索引时，就是对整个作批量操作\n   \n   POST /_bulk\n   {"delete":{"_index":"website","_type":"blog","_id":"123"}}\n   {"create":{"_index":"website","_type":"blog","_id":"123"}}\n   {"title":"my first blog post"}\n   {"index":{"_index":"website","_type":"blog"}}\n   {"title":"my second blog post"}\n   {"update":{"_index":"website","_type":"blog","_id":"123"}}\n   {"doc":{"title":"my updated blog post"}}\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# 文档基本操作\n\n\n# 添加数据 PUT\n\n * 添加用户1\n\nPUT /stars/_doc/1\n{\n  "name": "蔡徐坤",\n  "age": "22",\n  "desc": "鸡你太美",\n  "tags": ["唱","跳","rap","篮球"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n得到响应如下：\n\n{\n  "_index" : "stars",\n  "_type" : "_doc",\n  "_id" : "1",\n  "_version" : 1,\n  "result" : "created",\n  "_shards" : {\n    "total" : 2,\n    "successful" : 1,\n    "failed" : 0\n  },\n  "_seq_no" : 0,\n  "_primary_term" : 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 添加用户2\n\nPUT /stars/_doc/2\n{\n  "name": "吴亦凡",\n  "age": "29",\n  "desc": "大碗宽面",\n  "tags": ["加拿大","电鳗","说唱","嘻哈"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 添加用户3\n\nPUT /stars/_doc/3\n{\n  "name": "吴小凡",\n  "age": "10",\n  "desc": "一个吴小凡",\n  "tags": ["帅哥","干饭"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 查询数据 GET\n\n * 简单查询\n\nGET /stars/_doc/1\n\n\n1\n\n\n{\n  "_index" : "stars",\n  "_type" : "_doc",\n  "_id" : "1",\n  "_version" : 1,\n  "_seq_no" : 0,\n  "_primary_term" : 1,\n  "found" : true,\n  "_source" : {\n    "name" : "蔡徐坤",\n    "age" : "22",\n    "desc" : "鸡你太美",\n    "tags" : [\n      "唱",\n      "跳",\n      "rap",\n      "篮球"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 条件查询_search?q=\n\n例如查询 name 是 赵深宸\n\nGET /stars/_search?q=name:吴小凡\n\n\n1\n\n\n{\n  "took" : 996,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 2,\n      "relation" : "eq"\n    },\n    "max_score" : 2.5902672,\n    "hits" : [\n      {\n        "_index" : "stars",\n        "_type" : "_doc",\n        "_id" : "3",\n        "_score" : 2.5902672,\n        "_source" : {\n          "name" : "吴小凡",\n          "age" : "10",\n          "desc" : "一个吴小凡",\n          "tags" : [\n            "帅哥",\n            "干饭"\n          ]\n        }\n      },\n      {\n        "_index" : "stars",\n        "_type" : "_doc",\n        "_id" : "2",\n        "_score" : 1.3862942,\n        "_source" : {\n          "name" : "吴亦凡",\n          "age" : "29",\n          "desc" : "大碗宽面",\n          "tags" : [\n            "加拿大",\n            "电鳗",\n            "说唱",\n            "嘻哈"\n          ]\n        }\n      }\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n * 查询所有\n\nGET /stars/_search\n{\n  "query": { \n    "match_all": {} \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n相关字段解释\n\n * took – Elasticsearch运行查询所花费的时间（以毫秒为单位）\n * timed_out –搜索请求是否超时\n * _shards - 搜索了多少个碎片，以及成功，失败或跳过了多少个碎片的细目分类。\n * max_score – 找到的最相关文档的分数\n * hits.total.value - 找到了多少个匹配的文档\n * hits.sort - 文档的排序位置（不按相关性得分排序时）\n * hits._score - 文档的相关性得分（使用match_all时不适用）\n\n\n# 更新数据 POST\n\n * post\n\nPOST /stars/_doc/1/_update\n{\n  "doc": {\n    "name": "坤坤"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n{\n  "_index" : "stars",\n  "_type" : "_doc",\n  "_id" : "1",\n  "_version" : 2,\n  "result" : "updated",\n  "_shards" : {\n    "total" : 2,\n    "successful" : 1,\n    "failed" : 0\n  },\n  "_seq_no" : 3,\n  "_primary_term" : 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n_version - 版本，也就是更新次数\n\nresult - 操作结果为更新\n\n * put\n\n也可覆盖数据来更新\n\nPUT /stars/_doc/1\n{\n  "name": "蔡坤坤",\n  "age": "22",\n  "desc": "鸡你太美",\n  "tags": ["唱","跳","rap","篮球"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 删除数据 DELETE\n\n删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）。\n\n * 根据 ID 删除数据\n\nDELETE /stars/_doc/1\n\n\n1\n\n * 条件删除文档\n\n一般删除数据都是根据文档的唯一性标识进行删除，实际操作时，也可以根据条件对多条数据进行删除\n\n例如：查询 age 为 22 的\n\nPOST /stars/_delete_by_query\n{\n "query":{\n   "match":{\n     "age": 22\n   }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 索引的自动创建\n\n添加数据时，没有索引会自动创建索引和字段\n\nPUT /customer/_doc/1\n{\n  "name": "John Doe"\n}\n\n\n1\n2\n3\n4\n\n\n我们可以查看下这个索引的 mapping => GET /customer/_mapping\n\n{\n  "customer" : {\n    "mappings" : {\n      "properties" : {\n        "name" : {\n          "type" : "text",\n          "fields" : {\n            "keyword" : {\n              "type" : "keyword",\n              "ignore_above" : 256\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n那么如果我们需要对这个建立索引的过程做更多的控制：比如想要确保这个索引有数量适中的主分片，并且在我们索引任何数据之前，分析器和映射已经被建立好。那么就会引入两点：第一个禁止自动创建索引，第二个是手动创建索引。\n\n * 禁止自动创建索引\n\n可以通过在 config/elasticsearch.yml 的每个节点下添加下面的配置：\n\naction.auto_create_index: false\n\n\n1\n\n\n\n# 索引的格式\n\n在请求体里面传入设置或类型映射，如下所示：\n\nPUT /my_index\n{\n    "settings": { ... any settings ... },\n    "mappings": {\n        "properties": { ... any properties ... }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * settings: 用来设置分片,副本等配置信息\n * mappings: 字段映射，类型等\n   * properties: 由于type在后续版本中会被Deprecated, 所以无需被type嵌套\n\n\n# 索引管理操作\n\nhttps://www.pdai.tech/md/db/nosql-es/elasticsearch-x-index-mapping.html#索引管理操作',normalizedContent:' * 索引简单操作\n   * 创建索引\n   * 查看和删除索引\n   * 批量索引文档\n * 文档基本操作\n   * 添加数据 put\n   * 查询数据 get\n   * 更新数据 post\n   * 删除数据 delete\n * 索引的自动创建\n * 索引的格式\n * 索引管理操作\n\n\n# 索引简单操作\n\n\n# 创建索引\n\npostman 进行测试\n\n * postman官网下载：https://www.postman.com/downloads/\n\n * 汉化教程：https://gitee.com/hlmd/postmancn/\n\n由于我的 elasticsearch 部署到在公关上，且有账号和密码\n\n所以地址为：http://用户名:密码@url\n\n本地则为：http://127.0.0.1:9200\n\n * 创建索引：http://127.0.0.1:9200/shopping\n\n\n\n{\n    //响应结果\n    "acknowledged": true,\n    //分片结果\n    "shards_acknowledged": true,\n    //索引名称\n    "index": "shopping"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意：创建索引库的分片数默认 1 片，在 7.0.0 之前的 elasticsearch 版本中，默认 5 片\n\nkibana的 dev tool 进行测试\n\n如果重复添加索引，会返回错误信息\n\n\n\n为了方便测试，后续使用kibana的dev tool来进行学习测试\n\n\n# 查看和删除索引\n\n查看所有索引\n\nget /_cat/indices?v\n\n\n1\n\n\n\n\n这里请求路径中的_cat 表示查看的意思，indices 表示索引，所以整体含义就是查看当前 es 服务器中的所有索引\n\n表头               含义\nhealth           当前服务器健康状态：\n                 green(集群完整)；yellow(单点正常、集群不完整)；red(单点不正常)\nstatus           索引打开、关闭状态\nindex            索引名\nuuid             索引统一编号\npri              主分片数量\nrep              副本数量\ndocs.count       可用文档数量\ndocs.deleted     文档删除状态（逻辑删除）\nstore.size       主分片和副分片整体占空间大小\npri.store.size   主分片占空间大小\n\n查看单个索引\n\nget /shopping\n\n\n1\n\n\n查看索引向 es 服务器发送的请求路径和创建索引是一致的。但是 http 方法不一致。这里可以体会一下 restful 的意义，\n\n响应结果：\n\n{\n  "shopping" : {//【索引名】\n    "aliases" : { },//【别名】\n    "mappings" : { },//"【映射】\n    "settings" : {\n      "index" : {\n        "creation_date" : "1624201817578",//【创建时间】\n        "number_of_shards" : "1",//【主分片数量】\n        "number_of_replicas" : "1",//【副分片数量】\n        "uuid" : "5fpfnrjctuyxreq7afkqnw",//【唯一标识】\n        "version" : {\n          "created" : "7060199"//【版本】】\n        },\n        "provided_name" : "shopping"\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n删除索引\n\n * delete /索引\n\ndelete /shopping\n\n\n1\n\n\n{\n  "acknowledged" : true\n}\n\n\n\n1\n2\n3\n4\n\n\n\n# 批量索引文档_bulk\n\nes 还提供了批量操作，比如这里我们可以使用批量操作来插入一些数据，供我们在后面学习使用。\n\n使用批量来批处理文档操作比单独提交请求要快得多，因为它减少了网络往返。\n\n * 下载测试数据\n   \n   https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip\n\n数据的格式如下\n\n{\n  "account_number": 0,\n  "balance": 16623,\n  "firstname": "bradshaw",\n  "lastname": "mckenzie",\n  "age": 29,\n  "gender": "f",\n  "address": "244 columbus place",\n  "employer": "euron",\n  "email": "bradshawmckenzie@euron.com",\n  "city": "hobucken",\n  "state": "co"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n例如把文件复制到 es 目录的 data\n\ndocker：\n\ndocker cp /home/accounts.json  06c5914709a5:/usr/share/elasticsearch/data/\n\n\n1\n\n\n然后执行\n\ncurl -h "content-type: application/json" -xpost "localhost:9200/bank/_bulk?pretty&refresh" --data-binary @accounts.json\n\n\n1\n\n\n如果在其他目录，例如 /opt//accounts.json\n\ncurl -h "content-type: application/json" -xpost "localhost:9200/bank/_bulk?pretty&refresh" --data-binary "@/opt/accounts.json"\n\n\n1\n\n\n> 或者我们可以直接插入数据：\n> \n> 注意格式json和text均不可，要去kibana里dev tools\n\npost http://localhost:9200/bank/_bulk\n\n两行为一个整体，index代表索引，也就是保存操作，下面一行为保存的数据\n\n{"index":{"_id":"1"}}\n{"name":"a"}\n{"index":{"_id":"2"}}\n{"name":"b"}\n\n\n1\n2\n3\n4\n\n * 语法格式：\n\naction：执行的动作，新增，修改，删除等\n\nmetadata：要操作的数据，比如id是多少\n\n{action:{metadata}}\\n\n{request body  }\\n\n\n{action:{metadata}}\\n\n{request body  }\\n\n\n\n1\n2\n3\n4\n5\n\n\n这里的批量操作，当发生某一条执行发生失败时，其他的数据仍然能够接着执行，也就是说彼此之间是独立的。\n\nbulk api 以此按顺序执行所有的 action(动作)。如果一个单个的动作因任何原因而失败， 它将继续处理它后面剩余的动作。当 bulk api 返回时，它将提供每个动作的状态(与发送 的顺序相同)，所以您可以检查是否一个指定的动作是不是失败了。\n\n * 实例：\n   \n   对于整个索引执行批量操作(需在kibana里dev tools)\n   \n   当没指定任何索引时，就是对整个作批量操作\n   \n   post /_bulk\n   {"delete":{"_index":"website","_type":"blog","_id":"123"}}\n   {"create":{"_index":"website","_type":"blog","_id":"123"}}\n   {"title":"my first blog post"}\n   {"index":{"_index":"website","_type":"blog"}}\n   {"title":"my second blog post"}\n   {"update":{"_index":"website","_type":"blog","_id":"123"}}\n   {"doc":{"title":"my updated blog post"}}\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# 文档基本操作\n\n\n# 添加数据 put\n\n * 添加用户1\n\nput /stars/_doc/1\n{\n  "name": "蔡徐坤",\n  "age": "22",\n  "desc": "鸡你太美",\n  "tags": ["唱","跳","rap","篮球"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n得到响应如下：\n\n{\n  "_index" : "stars",\n  "_type" : "_doc",\n  "_id" : "1",\n  "_version" : 1,\n  "result" : "created",\n  "_shards" : {\n    "total" : 2,\n    "successful" : 1,\n    "failed" : 0\n  },\n  "_seq_no" : 0,\n  "_primary_term" : 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 添加用户2\n\nput /stars/_doc/2\n{\n  "name": "吴亦凡",\n  "age": "29",\n  "desc": "大碗宽面",\n  "tags": ["加拿大","电鳗","说唱","嘻哈"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 添加用户3\n\nput /stars/_doc/3\n{\n  "name": "吴小凡",\n  "age": "10",\n  "desc": "一个吴小凡",\n  "tags": ["帅哥","干饭"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 查询数据 get\n\n * 简单查询\n\nget /stars/_doc/1\n\n\n1\n\n\n{\n  "_index" : "stars",\n  "_type" : "_doc",\n  "_id" : "1",\n  "_version" : 1,\n  "_seq_no" : 0,\n  "_primary_term" : 1,\n  "found" : true,\n  "_source" : {\n    "name" : "蔡徐坤",\n    "age" : "22",\n    "desc" : "鸡你太美",\n    "tags" : [\n      "唱",\n      "跳",\n      "rap",\n      "篮球"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 条件查询_search?q=\n\n例如查询 name 是 赵深宸\n\nget /stars/_search?q=name:吴小凡\n\n\n1\n\n\n{\n  "took" : 996,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 2,\n      "relation" : "eq"\n    },\n    "max_score" : 2.5902672,\n    "hits" : [\n      {\n        "_index" : "stars",\n        "_type" : "_doc",\n        "_id" : "3",\n        "_score" : 2.5902672,\n        "_source" : {\n          "name" : "吴小凡",\n          "age" : "10",\n          "desc" : "一个吴小凡",\n          "tags" : [\n            "帅哥",\n            "干饭"\n          ]\n        }\n      },\n      {\n        "_index" : "stars",\n        "_type" : "_doc",\n        "_id" : "2",\n        "_score" : 1.3862942,\n        "_source" : {\n          "name" : "吴亦凡",\n          "age" : "29",\n          "desc" : "大碗宽面",\n          "tags" : [\n            "加拿大",\n            "电鳗",\n            "说唱",\n            "嘻哈"\n          ]\n        }\n      }\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n * 查询所有\n\nget /stars/_search\n{\n  "query": { \n    "match_all": {} \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n相关字段解释\n\n * took – elasticsearch运行查询所花费的时间（以毫秒为单位）\n * timed_out –搜索请求是否超时\n * _shards - 搜索了多少个碎片，以及成功，失败或跳过了多少个碎片的细目分类。\n * max_score – 找到的最相关文档的分数\n * hits.total.value - 找到了多少个匹配的文档\n * hits.sort - 文档的排序位置（不按相关性得分排序时）\n * hits._score - 文档的相关性得分（使用match_all时不适用）\n\n\n# 更新数据 post\n\n * post\n\npost /stars/_doc/1/_update\n{\n  "doc": {\n    "name": "坤坤"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n{\n  "_index" : "stars",\n  "_type" : "_doc",\n  "_id" : "1",\n  "_version" : 2,\n  "result" : "updated",\n  "_shards" : {\n    "total" : 2,\n    "successful" : 1,\n    "failed" : 0\n  },\n  "_seq_no" : 3,\n  "_primary_term" : 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n_version - 版本，也就是更新次数\n\nresult - 操作结果为更新\n\n * put\n\n也可覆盖数据来更新\n\nput /stars/_doc/1\n{\n  "name": "蔡坤坤",\n  "age": "22",\n  "desc": "鸡你太美",\n  "tags": ["唱","跳","rap","篮球"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 删除数据 delete\n\n删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）。\n\n * 根据 id 删除数据\n\ndelete /stars/_doc/1\n\n\n1\n\n * 条件删除文档\n\n一般删除数据都是根据文档的唯一性标识进行删除，实际操作时，也可以根据条件对多条数据进行删除\n\n例如：查询 age 为 22 的\n\npost /stars/_delete_by_query\n{\n "query":{\n   "match":{\n     "age": 22\n   }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 索引的自动创建\n\n添加数据时，没有索引会自动创建索引和字段\n\nput /customer/_doc/1\n{\n  "name": "john doe"\n}\n\n\n1\n2\n3\n4\n\n\n我们可以查看下这个索引的 mapping => get /customer/_mapping\n\n{\n  "customer" : {\n    "mappings" : {\n      "properties" : {\n        "name" : {\n          "type" : "text",\n          "fields" : {\n            "keyword" : {\n              "type" : "keyword",\n              "ignore_above" : 256\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n那么如果我们需要对这个建立索引的过程做更多的控制：比如想要确保这个索引有数量适中的主分片，并且在我们索引任何数据之前，分析器和映射已经被建立好。那么就会引入两点：第一个禁止自动创建索引，第二个是手动创建索引。\n\n * 禁止自动创建索引\n\n可以通过在 config/elasticsearch.yml 的每个节点下添加下面的配置：\n\naction.auto_create_index: false\n\n\n1\n\n\n\n# 索引的格式\n\n在请求体里面传入设置或类型映射，如下所示：\n\nput /my_index\n{\n    "settings": { ... any settings ... },\n    "mappings": {\n        "properties": { ... any properties ... }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * settings: 用来设置分片,副本等配置信息\n * mappings: 字段映射，类型等\n   * properties: 由于type在后续版本中会被deprecated, 所以无需被type嵌套\n\n\n# 索引管理操作\n\nhttps://www.pdai.tech/md/db/nosql-es/elasticsearch-x-index-mapping.html#索引管理操作',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ES - 高级查询操作",frontmatter:{title:"ES - 高级查询操作",date:"2021-06-21T09:43:35.000Z",permalink:"/es/query/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/08.ES%20-%20%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C.html",relativePath:"03.数据库/15.ElasticSearch/08.ES - 高级查询操作.md",key:"v-d48a660e",path:"/es/query/",headers:[{level:2,title:"SearchAPI",slug:"searchapi",normalizedTitle:"searchapi",charIndex:3},{level:2,title:"查询数据Query DSL",slug:"查询数据query-dsl",normalizedTitle:"查询数据query dsl",charIndex:16},{level:3,title:"指定字段查询 match",slug:"指定字段查询-match",normalizedTitle:"指定字段查询 match",charIndex:35},{level:3,title:"查询短语匹配 match_phrase",slug:"查询短语匹配-match-phrase",normalizedTitle:"查询短语匹配 match_phrase",charIndex:53},{level:3,title:"多字段匹配 multi_match",slug:"多字段匹配-multi-match",normalizedTitle:"多字段匹配 multi_match",charIndex:78},{level:3,title:"查询结果显示指定字段",slug:"查询结果显示指定字段",normalizedTitle:"查询结果显示指定字段",charIndex:101},{level:3,title:"排序和分页",slug:"排序和分页",normalizedTitle:"排序和分页",charIndex:117},{level:3,title:"多条件查询",slug:"多条件查询",normalizedTitle:"多条件查询",charIndex:128},{level:3,title:"结果过滤查询 filter",slug:"结果过滤查询-filter",normalizedTitle:"结果过滤查询 filter",charIndex:139},{level:3,title:"匹配多个条件查询",slug:"匹配多个条件查询",normalizedTitle:"匹配多个条件查询",charIndex:158},{level:3,title:"精确查询term",slug:"精确查询term",normalizedTitle:"精确查询term",charIndex:172},{level:3,title:"高亮查询",slug:"高亮查询",normalizedTitle:"高亮查询",charIndex:186},{level:2,title:"聚合查询",slug:"聚合查询",normalizedTitle:"聚合查询",charIndex:194},{level:3,title:"简单聚合",slug:"简单聚合",normalizedTitle:"简单聚合",charIndex:204},{level:3,title:"嵌套聚合",slug:"嵌套聚合",normalizedTitle:"嵌套聚合",charIndex:214},{level:3,title:"对聚合结果排序",slug:"对聚合结果排序",normalizedTitle:"对聚合结果排序",charIndex:224}],headersStr:"SearchAPI 查询数据Query DSL 指定字段查询 match 查询短语匹配 match_phrase 多字段匹配 multi_match 查询结果显示指定字段 排序和分页 多条件查询 结果过滤查询 filter 匹配多个条件查询 精确查询term 高亮查询 聚合查询 简单聚合 嵌套聚合 对聚合结果排序",content:' * SearchAPI\n * 查询数据Query DSL\n   * 指定字段查询 match\n   * 查询短语匹配 match_phrase\n   * 多字段匹配 multi_match\n   * 查询结果显示指定字段\n   * 排序和分页\n   * 多条件查询\n   * 结果过滤查询 filter\n   * 匹配多个条件查询\n   * 精确查询term\n   * 高亮查询\n * 聚合查询\n   * 简单聚合\n   * 嵌套聚合\n   * 对聚合结果排序\n\n\n\n\n# SearchAPI\n\nES支持两种基本方式检索；\n\n * 通过REST request uri 发送搜索参数 （uri +检索参数）；\n * 通过REST request body 来发送它们（uri+请求体）；\n\n> 检索信息\n\n * 检索从_search开始\n   \n   例如：\n   \n   GET bank/_search?q=*&sort=account_number:asc\n   \n   \n   1\n   \n   \n   等价于\n   \n   GET bank/_search \n   {\n       "query":{\n           "match_all":{ }\n       },\n       "sort":[\n           {\n               "account_number":{\n                   "order":"desc"\n               }\n           }\n       ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 响应结果解释: took - Elasticsearch 执行搜索的时间(毫秒) time_out - 告诉我们搜索是否超时 _shards - 告诉我们多少个分片被搜索了，以及统计了成功/失败的搜索分片 hits - 搜索结果 hits.total - 搜索结果 hits.hits - 实际的搜索结果数组(默认为前 10 的文档) sort - 结果的排序 key(键)(没有则按 score 排序) score 和 max_score –相关性得分和最高得分(全文检索用)\n\n\n# 查询数据Query DSL\n\n\n# 指定字段查询 match\n\n查询 name 中含有 坤 或 小 的\n\nGET /stars/_search\n{\n  "query": {\n    "match": {\n      "name": "坤 小"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 查询短语匹配 match_phrase\n\n如果我们希望查询的条件是某字段中包含 "坤 小"\n\n也就是将需要匹配的值当成一个整体单词(不分词)进行检索，使用 match_phrase\n\nGET /stars/_search\n{\n  "query": {\n    "match_phrase": {\n      "name": "坤 小"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 多字段匹配 multi_match\n\n查询 state 或者 address 包含 mill\n\n GET bank/_search \n{\n    "query":{\n        "multi_match":{\n            "query":"mill",\n            "fields":[\n                "state",\n                "address"\n            ]\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 查询结果显示指定字段\n\n例如，查询结果只显示 age 和 desc\n\nGET /stars/_search\n{\n  "query": {\n    "match": {\n      "name": "凡"\n    }\n  },\n  "_source":["age", "desc"] \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 排序和分页\n\n * asc 升序、desc 降序\n\nGET /stars/_search\n{\n  "query": { "match_all": {} },\n  "sort": [\n    {\n      "age.keyword": {\n        "order": "desc"\n      }\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 分页查询\n\n本质上就是 from（开始位置）和 size（返回数据数目）两个字段\n\nGET /stars/_search\n{\n  "query": { "match_all": {} },\n  "from": 0,\n  "size": 2\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 多条件查询\n\n * bool\n\nmust：相当于关系型数据库 and\n\nGET stars/_search\n{\n  "query": {\n    "bool": {\n      "must": [\n        {\n          "match": {\n            "name": "吴亦凡"\n          }\n        },\n        {\n          "match": {\n            "age": "29"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nshould：相当于关系型数据库 or\n\nGET stars/_search\n{\n  "query": {\n    "bool": {\n      "should": [\n        {\n          "match": {\n            "name": "吴亦凡"\n          }\n        },\n        {\n          "match": {\n            "age": "19"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nmust_not：相当于关系型数据库 not\n\n\n# 结果过滤查询 filter\n\n例如，查询 10岁<=age=<30岁\n\nGET stars/_search\n{\n  "query": {\n    "bool": {\n      "filter": [\n        {\n          "range": {\n            "age": {\n              "gte": 10, \n              "lte": 30 \n            }\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 匹配多个条件查询\n\n查询 tags 有 唱跳 的\n\nGET stars/_search\n{\n  "query": {\n    "match": {\n      "tags": "唱 跳"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n多个条件使用空格隔开\n\n\n# 精确查询term\n\n关于分词\n\n * term：直接通过倒排索引指定的词条进行精确查询\n\nGET stars/_search\n{\n  "query": {\n    "bool": {\n      "must": [\n        {\n          "term": {\n            "name": "吴亦凡"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n返回\n\n{\n  "took" : 0,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 0,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * match：先分析文档，再通过分析的文档进行查询\n\n吴小凡 也会被查出来\n\n\n\n两个字段类型\n\n * text：会被分词器解析\n * keyword：不会被分词器解析\n\n创建索引，用mappings指明类型，并插入数据\n\nPUT testdb\n{\n    "mappings": {\n        "properties": {\n            "name": {\n                "type": "text"\n            }, \n            "desc": {\n                "type": "keyword"\n            }\n        }\n    }\n}\n\n\nPUT testdb/_doc/1\n{\n  "name": "赵深宸 name",\n  "desc": "致远 desc"\n}\n\nPUT testdb/_doc/2\n{\n  "name": "赵深宸 name2",\n  "desc": "致远 desc2"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上述中 testdb 索引中，字段name在被查询时会被分析器进行分析后匹配查询。而属于keyword类型不会被分析器处理。\n\n我们来验证一下：\n\n * keyword\n\nGET _analyze\n{\n  "analyzer": "keyword",\n  "text": "赵深宸 name"\n}\n\n\n1\n2\n3\n4\n5\n\n\n返回\n\n{\n  "tokens" : [\n    {\n      "token" : "赵深宸 name",\n      "start_offset" : 0,\n      "end_offset" : 8,\n      "type" : "word",\n      "position" : 0\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * standard\n\nGET _analyze\n{\n  "analyzer": "standard",\n  "text": "赵深宸 name"\n}\n\n\n1\n2\n3\n4\n5\n\n\n返回\n\n{\n  "tokens" : [\n    {\n      "token" : "赵",\n      "start_offset" : 0,\n      "end_offset" : 1,\n      "type" : "<IDEOGRAPHIC>",\n      "position" : 0\n    },\n    {\n      "token" : "深",\n      "start_offset" : 1,\n      "end_offset" : 2,\n      "type" : "<IDEOGRAPHIC>",\n      "position" : 1\n    },\n    {\n      "token" : "宸",\n      "start_offset" : 2,\n      "end_offset" : 3,\n      "type" : "<IDEOGRAPHIC>",\n      "position" : 2\n    },\n    {\n      "token" : "name",\n      "start_offset" : 4,\n      "end_offset" : 8,\n      "type" : "<ALPHANUM>",\n      "position" : 3\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n查询测试下：\n\nGET testdb/_search\n{\n  "query": {\n    "match": {\n     "desc": "致远 desc"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n结果：\n\n只返回 一条数据，查询结果没有 “致远 desc2”\n\n * 指定字段类型进行查询\n\nGET stars/_search\n{\n  "query": {\n    "bool": {\n      "must": [\n        {\n          "match": {\n            "name.keyword": "吴亦凡"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n * 查找多个精确值\n   \n   https://www.elastic.co/guide/cn/elasticsearch/guide/current/_finding_multiple_exact_values.html\n\n\n# 高亮查询\n\n * 默认高亮标签\n\nGET stars/_search\n{\n  "query": {\n    "match": {\n      "name": "吴亦凡"\n    }\n  },\n  "highlight": {\n    "fields": {\n      "name": {}\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n返回\n\n{\n  "took" : 160,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1,\n      "relation" : "eq"\n    },\n    "max_score" : 2.9424872,\n    "hits" : [\n      {\n        "_index" : "stars",\n        "_type" : "_doc",\n        "_id" : "2",\n        "_score" : 2.9424872,\n        "_source" : {\n          "name" : "吴亦凡",\n          "age" : "29",\n          "desc" : "大碗宽面",\n          "tags" : [\n            "加拿大",\n            "电鳗",\n            "说唱",\n            "嘻哈"\n          ]\n        },\n        "highlight" : {\n          "name" : [\n            "<em>吴</em><em>亦</em><em>凡</em>"\n          ]\n        }\n      }\n    ]\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n * 自定义高亮标签\n\nGET stars/_search\n{\n  "query": {\n    "match": {\n      "name": "吴亦凡"\n    }\n  },\n  "highlight": {\n    "pre_tags": "<p class=\'key\' style=\'color:red\'>",\n    "post_tags": "</p>", \n    "fields": {\n      "name": {}\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果：\n\n"highlight" : {\n          "name" : [\n            "<p class=\'key\' style=\'color:red\'>吴</p><p class=\'key\' style=\'color:red\'>亦</p><p class=\'key\' style=\'color:red\'>凡</p>"\n          ]\n        }\n\n"highlight" : {\n          "name" : [\n            "<p class=\'key\' style=\'color:red\'>吴</p>小<p class=\'key\' style=\'color:red\'>凡</p>"\n          ]\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 聚合查询\n\n我们知道SQL中有group by，在ES中它叫Aggregation，即聚合运算。\n\n用之前导入索引的数据进行测试\n\n\n# 简单聚合\n\n比如我们希望计算出每个州的统计数量， 使用aggs关键字对state字段聚合，被聚合的字段无需对分词统计，所以使用state.keyword对整个字段统计\n\ngroup_by_state 为取的名字，根据自己需求取名\n\nGET /bank/_search\n{\n  "size": 0,\n  "aggs": {\n    "group_by_state": {\n      "terms": {\n        "field": "state.keyword"\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n返回：\n\n{\n  "took" : 1,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1000,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  },\n  "aggregations" : {\n    "group_by_state" : {\n      "doc_count_error_upper_bound" : 0,\n      "sum_other_doc_count" : 743,\n      "buckets" : [\n        {\n          "key" : "TX",\n          "doc_count" : 30\n        },\n        {\n          "key" : "MD",\n          "doc_count" : 28\n        },\n        {\n          "key" : "ID",\n          "doc_count" : 27\n        },\n        {\n          "key" : "AL",\n          "doc_count" : 25\n        },\n        {\n          "key" : "ME",\n          "doc_count" : 25\n        },\n        {\n          "key" : "TN",\n          "doc_count" : 25\n        },\n        {\n          "key" : "WY",\n          "doc_count" : 25\n        },\n        {\n          "key" : "DC",\n          "doc_count" : 24\n        },\n        {\n          "key" : "MA",\n          "doc_count" : 24\n        },\n        {\n          "key" : "ND",\n          "doc_count" : 24\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n因为无需返回条件的具体数据, 所以设置size=0，返回hits为空。\n\ndoc_count表示bucket中每个州的数据条数。\n\n\n# 嵌套聚合\n\n比如承接上个例子， 计算每个州的平均结余。涉及到的就是在对state分组的基础上，嵌套计算avg(balance):\n\nGET /bank/_search\n{\n  "size": 0,\n  "aggs": {\n    "group_by_state": {\n      "terms": {\n        "field": "state.keyword"\n      },\n      "aggs": {\n        "average_balance": {\n          "avg": {\n            "field": "balance"\n          }\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n返回：\n\n{\n  "took" : 49,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1000,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  },\n  "aggregations" : {\n    "group_by_state" : {\n      "doc_count_error_upper_bound" : 0,\n      "sum_other_doc_count" : 743,\n      "buckets" : [\n        {\n          "key" : "TX",\n          "doc_count" : 30,\n          "average_balance" : {\n            "value" : 26073.3\n          }\n        },\n        {\n          "key" : "MD",\n          "doc_count" : 28,\n          "average_balance" : {\n            "value" : 26161.535714285714\n          }\n        },\n        {\n          "key" : "ID",\n          "doc_count" : 27,\n          "average_balance" : {\n            "value" : 24368.777777777777\n          }\n        },\n        {\n          "key" : "AL",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 25739.56\n          }\n        },\n        {\n          "key" : "ME",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 21663.0\n          }\n        },\n        {\n          "key" : "TN",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 28365.4\n          }\n        },\n        {\n          "key" : "WY",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 21731.52\n          }\n        },\n        {\n          "key" : "DC",\n          "doc_count" : 24,\n          "average_balance" : {\n            "value" : 23180.583333333332\n          }\n        },\n        {\n          "key" : "MA",\n          "doc_count" : 24,\n          "average_balance" : {\n            "value" : 29600.333333333332\n          }\n        },\n        {\n          "key" : "ND",\n          "doc_count" : 24,\n          "average_balance" : {\n            "value" : 26577.333333333332\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n\n# 对聚合结果排序\n\n可以通过在aggs中对嵌套聚合的结果进行排序\n\n比如承接上个例子， 对嵌套计算出的avg(balance)，这里是average_balance，进行排序\n\nGET /bank/_search\n{\n  "size": 0,\n  "aggs": {\n    "group_by_state": {\n      "terms": {\n        "field": "state.keyword",\n        "order": {\n          "average_balance": "desc"\n        }\n      },\n      "aggs": {\n        "average_balance": {\n          "avg": {\n            "field": "balance"\n          }\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:' * searchapi\n * 查询数据query dsl\n   * 指定字段查询 match\n   * 查询短语匹配 match_phrase\n   * 多字段匹配 multi_match\n   * 查询结果显示指定字段\n   * 排序和分页\n   * 多条件查询\n   * 结果过滤查询 filter\n   * 匹配多个条件查询\n   * 精确查询term\n   * 高亮查询\n * 聚合查询\n   * 简单聚合\n   * 嵌套聚合\n   * 对聚合结果排序\n\n\n\n\n# searchapi\n\nes支持两种基本方式检索；\n\n * 通过rest request uri 发送搜索参数 （uri +检索参数）；\n * 通过rest request body 来发送它们（uri+请求体）；\n\n> 检索信息\n\n * 检索从_search开始\n   \n   例如：\n   \n   get bank/_search?q=*&sort=account_number:asc\n   \n   \n   1\n   \n   \n   等价于\n   \n   get bank/_search \n   {\n       "query":{\n           "match_all":{ }\n       },\n       "sort":[\n           {\n               "account_number":{\n                   "order":"desc"\n               }\n           }\n       ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 响应结果解释: took - elasticsearch 执行搜索的时间(毫秒) time_out - 告诉我们搜索是否超时 _shards - 告诉我们多少个分片被搜索了，以及统计了成功/失败的搜索分片 hits - 搜索结果 hits.total - 搜索结果 hits.hits - 实际的搜索结果数组(默认为前 10 的文档) sort - 结果的排序 key(键)(没有则按 score 排序) score 和 max_score –相关性得分和最高得分(全文检索用)\n\n\n# 查询数据query dsl\n\n\n# 指定字段查询 match\n\n查询 name 中含有 坤 或 小 的\n\nget /stars/_search\n{\n  "query": {\n    "match": {\n      "name": "坤 小"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 查询短语匹配 match_phrase\n\n如果我们希望查询的条件是某字段中包含 "坤 小"\n\n也就是将需要匹配的值当成一个整体单词(不分词)进行检索，使用 match_phrase\n\nget /stars/_search\n{\n  "query": {\n    "match_phrase": {\n      "name": "坤 小"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 多字段匹配 multi_match\n\n查询 state 或者 address 包含 mill\n\n get bank/_search \n{\n    "query":{\n        "multi_match":{\n            "query":"mill",\n            "fields":[\n                "state",\n                "address"\n            ]\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 查询结果显示指定字段\n\n例如，查询结果只显示 age 和 desc\n\nget /stars/_search\n{\n  "query": {\n    "match": {\n      "name": "凡"\n    }\n  },\n  "_source":["age", "desc"] \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 排序和分页\n\n * asc 升序、desc 降序\n\nget /stars/_search\n{\n  "query": { "match_all": {} },\n  "sort": [\n    {\n      "age.keyword": {\n        "order": "desc"\n      }\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 分页查询\n\n本质上就是 from（开始位置）和 size（返回数据数目）两个字段\n\nget /stars/_search\n{\n  "query": { "match_all": {} },\n  "from": 0,\n  "size": 2\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 多条件查询\n\n * bool\n\nmust：相当于关系型数据库 and\n\nget stars/_search\n{\n  "query": {\n    "bool": {\n      "must": [\n        {\n          "match": {\n            "name": "吴亦凡"\n          }\n        },\n        {\n          "match": {\n            "age": "29"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nshould：相当于关系型数据库 or\n\nget stars/_search\n{\n  "query": {\n    "bool": {\n      "should": [\n        {\n          "match": {\n            "name": "吴亦凡"\n          }\n        },\n        {\n          "match": {\n            "age": "19"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nmust_not：相当于关系型数据库 not\n\n\n# 结果过滤查询 filter\n\n例如，查询 10岁<=age=<30岁\n\nget stars/_search\n{\n  "query": {\n    "bool": {\n      "filter": [\n        {\n          "range": {\n            "age": {\n              "gte": 10, \n              "lte": 30 \n            }\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 匹配多个条件查询\n\n查询 tags 有 唱跳 的\n\nget stars/_search\n{\n  "query": {\n    "match": {\n      "tags": "唱 跳"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n多个条件使用空格隔开\n\n\n# 精确查询term\n\n关于分词\n\n * term：直接通过倒排索引指定的词条进行精确查询\n\nget stars/_search\n{\n  "query": {\n    "bool": {\n      "must": [\n        {\n          "term": {\n            "name": "吴亦凡"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n返回\n\n{\n  "took" : 0,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 0,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * match：先分析文档，再通过分析的文档进行查询\n\n吴小凡 也会被查出来\n\n\n\n两个字段类型\n\n * text：会被分词器解析\n * keyword：不会被分词器解析\n\n创建索引，用mappings指明类型，并插入数据\n\nput testdb\n{\n    "mappings": {\n        "properties": {\n            "name": {\n                "type": "text"\n            }, \n            "desc": {\n                "type": "keyword"\n            }\n        }\n    }\n}\n\n\nput testdb/_doc/1\n{\n  "name": "赵深宸 name",\n  "desc": "致远 desc"\n}\n\nput testdb/_doc/2\n{\n  "name": "赵深宸 name2",\n  "desc": "致远 desc2"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上述中 testdb 索引中，字段name在被查询时会被分析器进行分析后匹配查询。而属于keyword类型不会被分析器处理。\n\n我们来验证一下：\n\n * keyword\n\nget _analyze\n{\n  "analyzer": "keyword",\n  "text": "赵深宸 name"\n}\n\n\n1\n2\n3\n4\n5\n\n\n返回\n\n{\n  "tokens" : [\n    {\n      "token" : "赵深宸 name",\n      "start_offset" : 0,\n      "end_offset" : 8,\n      "type" : "word",\n      "position" : 0\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * standard\n\nget _analyze\n{\n  "analyzer": "standard",\n  "text": "赵深宸 name"\n}\n\n\n1\n2\n3\n4\n5\n\n\n返回\n\n{\n  "tokens" : [\n    {\n      "token" : "赵",\n      "start_offset" : 0,\n      "end_offset" : 1,\n      "type" : "<ideographic>",\n      "position" : 0\n    },\n    {\n      "token" : "深",\n      "start_offset" : 1,\n      "end_offset" : 2,\n      "type" : "<ideographic>",\n      "position" : 1\n    },\n    {\n      "token" : "宸",\n      "start_offset" : 2,\n      "end_offset" : 3,\n      "type" : "<ideographic>",\n      "position" : 2\n    },\n    {\n      "token" : "name",\n      "start_offset" : 4,\n      "end_offset" : 8,\n      "type" : "<alphanum>",\n      "position" : 3\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n查询测试下：\n\nget testdb/_search\n{\n  "query": {\n    "match": {\n     "desc": "致远 desc"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n结果：\n\n只返回 一条数据，查询结果没有 “致远 desc2”\n\n * 指定字段类型进行查询\n\nget stars/_search\n{\n  "query": {\n    "bool": {\n      "must": [\n        {\n          "match": {\n            "name.keyword": "吴亦凡"\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n * 查找多个精确值\n   \n   https://www.elastic.co/guide/cn/elasticsearch/guide/current/_finding_multiple_exact_values.html\n\n\n# 高亮查询\n\n * 默认高亮标签\n\nget stars/_search\n{\n  "query": {\n    "match": {\n      "name": "吴亦凡"\n    }\n  },\n  "highlight": {\n    "fields": {\n      "name": {}\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n返回\n\n{\n  "took" : 160,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1,\n      "relation" : "eq"\n    },\n    "max_score" : 2.9424872,\n    "hits" : [\n      {\n        "_index" : "stars",\n        "_type" : "_doc",\n        "_id" : "2",\n        "_score" : 2.9424872,\n        "_source" : {\n          "name" : "吴亦凡",\n          "age" : "29",\n          "desc" : "大碗宽面",\n          "tags" : [\n            "加拿大",\n            "电鳗",\n            "说唱",\n            "嘻哈"\n          ]\n        },\n        "highlight" : {\n          "name" : [\n            "<em>吴</em><em>亦</em><em>凡</em>"\n          ]\n        }\n      }\n    ]\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n * 自定义高亮标签\n\nget stars/_search\n{\n  "query": {\n    "match": {\n      "name": "吴亦凡"\n    }\n  },\n  "highlight": {\n    "pre_tags": "<p class=\'key\' style=\'color:red\'>",\n    "post_tags": "</p>", \n    "fields": {\n      "name": {}\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果：\n\n"highlight" : {\n          "name" : [\n            "<p class=\'key\' style=\'color:red\'>吴</p><p class=\'key\' style=\'color:red\'>亦</p><p class=\'key\' style=\'color:red\'>凡</p>"\n          ]\n        }\n\n"highlight" : {\n          "name" : [\n            "<p class=\'key\' style=\'color:red\'>吴</p>小<p class=\'key\' style=\'color:red\'>凡</p>"\n          ]\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 聚合查询\n\n我们知道sql中有group by，在es中它叫aggregation，即聚合运算。\n\n用之前导入索引的数据进行测试\n\n\n# 简单聚合\n\n比如我们希望计算出每个州的统计数量， 使用aggs关键字对state字段聚合，被聚合的字段无需对分词统计，所以使用state.keyword对整个字段统计\n\ngroup_by_state 为取的名字，根据自己需求取名\n\nget /bank/_search\n{\n  "size": 0,\n  "aggs": {\n    "group_by_state": {\n      "terms": {\n        "field": "state.keyword"\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n返回：\n\n{\n  "took" : 1,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1000,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  },\n  "aggregations" : {\n    "group_by_state" : {\n      "doc_count_error_upper_bound" : 0,\n      "sum_other_doc_count" : 743,\n      "buckets" : [\n        {\n          "key" : "tx",\n          "doc_count" : 30\n        },\n        {\n          "key" : "md",\n          "doc_count" : 28\n        },\n        {\n          "key" : "id",\n          "doc_count" : 27\n        },\n        {\n          "key" : "al",\n          "doc_count" : 25\n        },\n        {\n          "key" : "me",\n          "doc_count" : 25\n        },\n        {\n          "key" : "tn",\n          "doc_count" : 25\n        },\n        {\n          "key" : "wy",\n          "doc_count" : 25\n        },\n        {\n          "key" : "dc",\n          "doc_count" : 24\n        },\n        {\n          "key" : "ma",\n          "doc_count" : 24\n        },\n        {\n          "key" : "nd",\n          "doc_count" : 24\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n因为无需返回条件的具体数据, 所以设置size=0，返回hits为空。\n\ndoc_count表示bucket中每个州的数据条数。\n\n\n# 嵌套聚合\n\n比如承接上个例子， 计算每个州的平均结余。涉及到的就是在对state分组的基础上，嵌套计算avg(balance):\n\nget /bank/_search\n{\n  "size": 0,\n  "aggs": {\n    "group_by_state": {\n      "terms": {\n        "field": "state.keyword"\n      },\n      "aggs": {\n        "average_balance": {\n          "avg": {\n            "field": "balance"\n          }\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n返回：\n\n{\n  "took" : 49,\n  "timed_out" : false,\n  "_shards" : {\n    "total" : 1,\n    "successful" : 1,\n    "skipped" : 0,\n    "failed" : 0\n  },\n  "hits" : {\n    "total" : {\n      "value" : 1000,\n      "relation" : "eq"\n    },\n    "max_score" : null,\n    "hits" : [ ]\n  },\n  "aggregations" : {\n    "group_by_state" : {\n      "doc_count_error_upper_bound" : 0,\n      "sum_other_doc_count" : 743,\n      "buckets" : [\n        {\n          "key" : "tx",\n          "doc_count" : 30,\n          "average_balance" : {\n            "value" : 26073.3\n          }\n        },\n        {\n          "key" : "md",\n          "doc_count" : 28,\n          "average_balance" : {\n            "value" : 26161.535714285714\n          }\n        },\n        {\n          "key" : "id",\n          "doc_count" : 27,\n          "average_balance" : {\n            "value" : 24368.777777777777\n          }\n        },\n        {\n          "key" : "al",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 25739.56\n          }\n        },\n        {\n          "key" : "me",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 21663.0\n          }\n        },\n        {\n          "key" : "tn",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 28365.4\n          }\n        },\n        {\n          "key" : "wy",\n          "doc_count" : 25,\n          "average_balance" : {\n            "value" : 21731.52\n          }\n        },\n        {\n          "key" : "dc",\n          "doc_count" : 24,\n          "average_balance" : {\n            "value" : 23180.583333333332\n          }\n        },\n        {\n          "key" : "ma",\n          "doc_count" : 24,\n          "average_balance" : {\n            "value" : 29600.333333333332\n          }\n        },\n        {\n          "key" : "nd",\n          "doc_count" : 24,\n          "average_balance" : {\n            "value" : 26577.333333333332\n          }\n        }\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n\n# 对聚合结果排序\n\n可以通过在aggs中对嵌套聚合的结果进行排序\n\n比如承接上个例子， 对嵌套计算出的avg(balance)，这里是average_balance，进行排序\n\nget /bank/_search\n{\n  "size": 0,\n  "aggs": {\n    "group_by_state": {\n      "terms": {\n        "field": "state.keyword",\n        "order": {\n          "average_balance": "desc"\n        }\n      },\n      "aggs": {\n        "average_balance": {\n          "avg": {\n            "field": "balance"\n          }\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ES - 分词",frontmatter:{title:"ES - 分词",date:"2022-07-28T22:08:54.000Z",permalink:"/pages/87178e/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/12.ES%20-%20%E5%88%86%E8%AF%8D.html",relativePath:"03.数据库/15.ElasticSearch/12.ES - 分词.md",key:"v-792e46c1",path:"/pages/87178e/",headers:[{level:2,title:"安装IK分词器插件",slug:"安装ik分词器插件",normalizedTitle:"安装ik分词器插件",charIndex:3},{level:2,title:"测试分词器",slug:"测试分词器",normalizedTitle:"测试分词器",charIndex:16},{level:2,title:"自定义词库",slug:"自定义词库",normalizedTitle:"自定义词库",charIndex:25},{level:2,title:"Elasticsearch-Rest-Client",slug:"elasticsearch-rest-client",normalizedTitle:"elasticsearch-rest-client",charIndex:34}],headersStr:"安装IK分词器插件 测试分词器 自定义词库 Elasticsearch-Rest-Client",content:' * 安装IK分词器插件\n * 测试分词器\n * 自定义词库\n * Elasticsearch-Rest-Client\n\n\n\n一个tokenizer（分词器）接收一个字符流，将之分割为独立的tokens（词元，通常是独立的单词），然后输出tokens流。\n\n例如：whitespace tokenizer遇到空白字符时分割文本。它会将文本"Quick brown fox!"分割为[Quick,brown,fox!]\n\nElasticSearch提供了很多内置的分词器（标准分词器），可以用来构建custom analyzers（自定义分词器）。\n\n官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.17/analysis.html\n\nPOST _analyze\n{\n  "analyzer": "standard",\n  "text": "The 2 Brown-Foxes bone."\n}\n\n\n1\n2\n3\n4\n5\n\n\n执行结果：\n\n{\n  "tokens" : [\n    {\n      "token" : "the",\n      "start_offset" : 0,\n      "end_offset" : 3,\n      "type" : "<ALPHANUM>",\n      "position" : 0\n    },\n    {\n      "token" : "2",\n      "start_offset" : 4,\n      "end_offset" : 5,\n      "type" : "<NUM>",\n      "position" : 1\n    },\n    {\n      "token" : "brown",\n      "start_offset" : 6,\n      "end_offset" : 11,\n      "type" : "<ALPHANUM>",\n      "position" : 2\n    },\n    {\n      "token" : "foxes",\n      "start_offset" : 12,\n      "end_offset" : 17,\n      "type" : "<ALPHANUM>",\n      "position" : 3\n    },\n    {\n      "token" : "bone",\n      "start_offset" : 18,\n      "end_offset" : 22,\n      "type" : "<ALPHANUM>",\n      "position" : 4\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n对于中文，我们需要安装额外的分词器\n\n\n# 安装IK分词器插件\n\n * 下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n\n需要版本号对应\n\n * 创建目录elasticsearch/plugins/ik，并在目录下解压，之后重启\n * 在命令行执行elasticsearch-plugin list命令，确认ik插件安装成功\n\n\n# 测试分词器\n\n使用默认分词器\n\nGET _analyze\n{\n   "text":"我是中国人"\n}\n\n\n1\n2\n3\n4\n\n\n使用分词器\n\nGET _analyze\n{\n   "analyzer": "ik_smart", \n   "text":"我是中国人"\n}\n\n\n1\n2\n3\n4\n5\n\n\n另外一个分词器\n\nGET _analyze\n{\n   "analyzer": "ik_max_word", \n   "text":"我是中国人"\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 自定义词库\n\n * 修改/elasticsearch/plugins/ik/config中的IKAnalyzer.cfg.xml\n\n根据自己需求修改，如果是配置自己的扩展字典（本地），则在ik/config目录下新建文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">\n<properties>\n\t<comment>IK Analyzer 扩展配置</comment>\n\t\x3c!--用户可以在这里配置自己的扩展字典 --\x3e\n\t<entry key="ext_dict"></entry>\n\t \x3c!--用户可以在这里配置自己的扩展停止词字典--\x3e\n\t<entry key="ext_stopwords"></entry>\n\t\x3c!--用户可以在这里配置远程扩展字典 --\x3e\n\t<entry key="remote_ext_dict">http://192.168.56.10/es/fenci.txt</entry> \n\t\x3c!--用户可以在这里配置远程扩展停止词字典--\x3e\n\t\x3c!-- <entry key="remote_ext_stopwords">words_location</entry> --\x3e\n</properties>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n修改完成后，需要重启elasticsearch容器，否则修改不生效。\n\n更新完成后，es只会对于新增的数据用更新分词。\n\n历史数据是不会重新分词的。如果想要历史数据重新分词，需要执行：\n\nPOST my_index/_update_by_query?conflicts=proceed\n\n\n1\n\n\n\n# Elasticsearch-Rest-Client\n\njava-rest-high：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html\n\n安装：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-getting-started-initialization.html\n\n使用api：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-index.html',normalizedContent:' * 安装ik分词器插件\n * 测试分词器\n * 自定义词库\n * elasticsearch-rest-client\n\n\n\n一个tokenizer（分词器）接收一个字符流，将之分割为独立的tokens（词元，通常是独立的单词），然后输出tokens流。\n\n例如：whitespace tokenizer遇到空白字符时分割文本。它会将文本"quick brown fox!"分割为[quick,brown,fox!]\n\nelasticsearch提供了很多内置的分词器（标准分词器），可以用来构建custom analyzers（自定义分词器）。\n\n官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.17/analysis.html\n\npost _analyze\n{\n  "analyzer": "standard",\n  "text": "the 2 brown-foxes bone."\n}\n\n\n1\n2\n3\n4\n5\n\n\n执行结果：\n\n{\n  "tokens" : [\n    {\n      "token" : "the",\n      "start_offset" : 0,\n      "end_offset" : 3,\n      "type" : "<alphanum>",\n      "position" : 0\n    },\n    {\n      "token" : "2",\n      "start_offset" : 4,\n      "end_offset" : 5,\n      "type" : "<num>",\n      "position" : 1\n    },\n    {\n      "token" : "brown",\n      "start_offset" : 6,\n      "end_offset" : 11,\n      "type" : "<alphanum>",\n      "position" : 2\n    },\n    {\n      "token" : "foxes",\n      "start_offset" : 12,\n      "end_offset" : 17,\n      "type" : "<alphanum>",\n      "position" : 3\n    },\n    {\n      "token" : "bone",\n      "start_offset" : 18,\n      "end_offset" : 22,\n      "type" : "<alphanum>",\n      "position" : 4\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n对于中文，我们需要安装额外的分词器\n\n\n# 安装ik分词器插件\n\n * 下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n\n需要版本号对应\n\n * 创建目录elasticsearch/plugins/ik，并在目录下解压，之后重启\n * 在命令行执行elasticsearch-plugin list命令，确认ik插件安装成功\n\n\n# 测试分词器\n\n使用默认分词器\n\nget _analyze\n{\n   "text":"我是中国人"\n}\n\n\n1\n2\n3\n4\n\n\n使用分词器\n\nget _analyze\n{\n   "analyzer": "ik_smart", \n   "text":"我是中国人"\n}\n\n\n1\n2\n3\n4\n5\n\n\n另外一个分词器\n\nget _analyze\n{\n   "analyzer": "ik_max_word", \n   "text":"我是中国人"\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 自定义词库\n\n * 修改/elasticsearch/plugins/ik/config中的ikanalyzer.cfg.xml\n\n根据自己需求修改，如果是配置自己的扩展字典（本地），则在ik/config目录下新建文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype properties system "http://java.sun.com/dtd/properties.dtd">\n<properties>\n\t<comment>ik analyzer 扩展配置</comment>\n\t\x3c!--用户可以在这里配置自己的扩展字典 --\x3e\n\t<entry key="ext_dict"></entry>\n\t \x3c!--用户可以在这里配置自己的扩展停止词字典--\x3e\n\t<entry key="ext_stopwords"></entry>\n\t\x3c!--用户可以在这里配置远程扩展字典 --\x3e\n\t<entry key="remote_ext_dict">http://192.168.56.10/es/fenci.txt</entry> \n\t\x3c!--用户可以在这里配置远程扩展停止词字典--\x3e\n\t\x3c!-- <entry key="remote_ext_stopwords">words_location</entry> --\x3e\n</properties>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n修改完成后，需要重启elasticsearch容器，否则修改不生效。\n\n更新完成后，es只会对于新增的数据用更新分词。\n\n历史数据是不会重新分词的。如果想要历史数据重新分词，需要执行：\n\npost my_index/_update_by_query?conflicts=proceed\n\n\n1\n\n\n\n# elasticsearch-rest-client\n\njava-rest-high：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html\n\n安装：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-getting-started-initialization.html\n\n使用api：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-index.html',charsets:{cjk:!0},lastUpdated:"2022/08/07, 3:08:00",lastUpdatedTimestamp:1659842691e3},{title:"Mongo - 基础概念",frontmatter:{title:"Mongo - 基础概念",date:"2021-09-11T10:39:30.000Z",permalink:"/pages/34c4ae/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/20.MongoDB/05.Mongo%20-%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html",relativePath:"03.数据库/20.MongoDB/05.Mongo - 基础概念.md",key:"v-7a59e988",path:"/pages/34c4ae/",headers:[{level:2,title:"什么是NoSQL？",slug:"什么是nosql",normalizedTitle:"什么是nosql？",charIndex:2},{level:3,title:"为什么使用NoSQL？",slug:"为什么使用nosql",normalizedTitle:"为什么使用nosql？",charIndex:315},{level:3,title:"NoSQL数据库的简要历史",slug:"nosql数据库的简要历史",normalizedTitle:"nosql数据库的简要历史",charIndex:553},{level:3,title:"NoSQL的功能",slug:"nosql的功能",normalizedTitle:"nosql的功能",charIndex:769},{level:2,title:"什么是MongoDB",slug:"什么是mongodb",normalizedTitle:"什么是mongodb",charIndex:1268},{level:3,title:"业务场景",slug:"业务场景",normalizedTitle:"业务场景",charIndex:1356},{level:3,title:"MongoDB 简介",slug:"mongodb-简介",normalizedTitle:"mongodb 简介",charIndex:2417},{level:3,title:"MongoDB与RDBMS区别",slug:"mongodb与rdbms区别",normalizedTitle:"mongodb与rdbms区别",charIndex:2801},{level:3,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:2136},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3797}],headersStr:"什么是NoSQL？ 为什么使用NoSQL？ NoSQL数据库的简要历史 NoSQL的功能 什么是MongoDB 业务场景 MongoDB 简介 MongoDB与RDBMS区别 数据模型 参考资料",content:"# 什么是NoSQL？\n\nNoSQL是一种非关系型DMS，不需要固定的架构，可以避免joins链接，并且易于扩展。NoSQL数据库用于具有庞大数据存储需求的分布式数据存储。NoSQL用于大数据和实时Web应用程序。例如，像Twitter，Facebook，Google这样的大型公司，每天可能产生TB级的用户数据。\n\nNoSQL数据库代表“不仅仅是SQL”或“不是SQL”。虽然NoRELNoSQL会是一个更好的名词。Carl Strozz在1998年引入了NoSQL概念。\n\n传统的RDBMS使用SQL语法来存储和查询数据。相反，NoSQL数据库系统包含可存储结构化，半结构化，非结构化和多态数据的多种数据库技术。\n\n\n\n\n# 为什么使用NoSQL？\n\nNoSQL数据库的概念在处理大量数据的互联网巨头（例如Google，Facebook，Amazon等）中变得很流行。使用RDBMS处理海量数据时，系统响应时间变慢。\n\n为了解决此问题，当然可以通过升级现有硬件来“横向扩展”我们的系统。但这个成本很高。\n\n这个问题的替代方案是在负载增加时将数据库负载分配到多个主机上。这种方法称为“横向扩展”。\n\n\n\nNoSQL数据库是非关系数据库，因此在设计时考虑到Web应用程序，比关系数据库更好地扩展。\n\n\n# NoSQL数据库的简要历史\n\n * 1998年-Carlo Strozzi在他的轻量级开源关系数据库中使用术语NoSQL\n * 2000-图形数据库Neo4j启动\n * 2004年-推出Google BigTable\n * 2005年-启动CouchDB\n * 2007年-发布有关Amazon Dynamo的研究论文\n * 2008年-Facebook开源Cassandra项目\n * 2009年-重新引入NoSQL术语\n\n\n# NoSQL的功能\n\n非关系\n\n * NoSQL数据库从不遵循关系模型\n * 切勿为tables 提供固定的固定列记录\n * 使用自包含的聚合或BLOB\n * 不需要对象关系映射和数据规范化\n * 没有复杂的功能，例如查询语言，查询计划者，\n * 参照完整性联接，ACID\n\n动态架构\n\n * NoSQL数据库是无模式的或具有宽松模式的数据库\n * 不需要对数据架构进行任何形式的定义\n * 提供同一域中的异构数据结构\n\n\n\n简单的API\n\n * 提供易于使用的界面，用于存储和查询提供的数据\n * API允许进行低级数据操作和选择方法\n * 基于文本的协议，通常与带有JSON的HTTP REST一起使用\n * 多数不使用基于标准的查询语言\n * 支持Web的数据库作为面向互联网的服务运行\n\n分布式\n\n * 可以以分布式方式执行多个NoSQL数据库\n * 提供自动缩放和故障转移功能\n * 通常可牺牲ACID概念来实现可伸缩性和吞吐量\n * 分布式节点之间几乎没有同步复制，多为异步多主复制，对等，HDFS复制\n * 仅提供最终的一致性\n * 无共享架构。这样可以减少协调并提高分布\n\n\n\n\n# 什么是MongoDB\n\nMongoDB是面向文档的NoSQL数据库，用于大量数据存储。MongoDB是一个在2000年代中期问世的数据库。属于NoSQL数据库的类别。\n\n\n# 业务场景\n\n传统的关系型数据库 (比如 MySQL), 在数据操作的”三高”需求以及对应的 Web 2.0 网站需求面前, 会有”力不从心”的感觉\n\n所谓的三高需求:\n\n高并发, 高性能, 高可用, 简称三高\n\n * High Performance: 对数据库的高并发读写的要求\n * High Storage: 对海量数据的高效率存储和访问的需求\n * High Scalability && High Available: 对数据的高扩展性和高可用性的需求\n\n而 MongoDB 可以应对三高需求\n\n具体的应用场景:\n\n * 社交场景, 使用 MongoDB 存储存储用户信息, 以及用户发表的朋友圈信息, 通过地理位置索引实现附近的人, 地点等功能.\n * 游戏场景, 使用 MongoDB 存储游戏用户信息, 用户的装备, 积分等直接以内嵌文档的形式存储, 方便查询, 高效率存储和访问.\n * 物流场景, 使用 MongoDB 存储订单信息, 订单状态在运送过程中会不断更新, 以 MongoDB 内嵌数组的形式来存储, 一次查询就能将订单所有的变更读取出来.\n * 物联网场景, 使用 MongoDB 存储所有接入的智能设备信息, 以及设备汇报的日志信息, 并对这些信息进行多维度的分析.\n * 视频直播, 使用 MongoDB 存储用户信息, 点赞互动信息等.\n\n这些应用场景中, 数据操作方面的共同点有:\n\n 1. 数据量大\n 2. 写入操作频繁\n 3. 价值较低的数据, 对事务性要求不高\n\n对于这样的数据, 更适合用 MongoDB 来实现数据存储\n\n那么我们什么时候选择 MongoDB 呢?\n\n除了架构选型上, 除了上述三个特点之外, 还要考虑下面这些问题:\n\n * 应用不需要事务及复杂 JOIN 支持\n * 新应用, 需求会变, 数据模型无法确定, 想快速迭代开发\n * 应用需要 2000 - 3000 以上的读写QPS（更高也可以）\n * 应用需要 TB 甚至 PB 级别数据存储\n * 应用发展迅速, 需要能快速水平扩展\n * 应用要求存储的数据不丢失\n * 应用需要 99.999% 高可用\n * 应用需要大量的地理位置查询, 文本查询\n\n如果上述有1个符合, 可以考虑 MongoDB, 2个及以上的符合, 选择 MongoDB 绝不会后悔.\n\n> 如果用MySQL呢?\n> \n> 相对MySQL, MongoDB可以以更低的成本解决问题（包括学习, 开发, 运维等成本）\n\n\n# MongoDB 简介\n\nMongoDB是一个开源， 高性能，无模式的文档型数据库，当初的设计就是用于简化开发和方便扩展，是NoSQL数据库产品中的一种。是最像关系型数据库（MySQL）的非关系型数据库。 它支持的数据结构非常松散，是一种类似于 JSON 的 格式叫BSON， 所以它既可以存储比较复杂的数据类型， 又相当的灵活。MongoDB中的记录是一个文档，它是一个由字段和值对（ﬁeld:value）组成的数据结构。MongoDB文档类似于JSON对象，即一个文档认 为就是一个对象。字段的数据类型是字符型， 它的值除了使用基本的一些类型外, 还可以包括其他文档， 普通数组和文档数组。\n\nMongoDB 数据模型是面向文档的, 所谓文档就是一种类似于 JSON 的结构, 简单理解 MongoDB 这个数据库中存在的是各种各样的 JSON（BSON）\n\n\n# MongoDB与RDBMS区别\n\n下表将帮助您更容易理解Mongo中的一些概念：\n\nSQL术语/概念      MONGODB术语/概念   解释/说明\ndatabase      database       数据库\ntable         collection     数据库表/集合\nrow           document       数据记录行/文档\ncolumn        field          数据字段/域\nindex         index          索引\ntable joins                  表连接,MongoDB不支持\nprimary key   primary key    主键,MongoDB自动将_id字段设置为主键\n\n\n\n在 MongoDB 中, 数据库和集合都不需要手动创建, 当我们创建文档时, 如果文档所在的集合或者数据库不存在, 则会自动创建数据库或者集合\n\n\n# 数据模型\n\nMongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以 BSON（Binary-JSON）文档的格式存储在磁盘上。\n\nBSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持 内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。\n\nBSON采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可 以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。\n\nBson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详细信息。\n\nBSON数据类型参考列表：\n\n\n\n\n# 参考资料\n\n * https://www.pdai.tech/md/db/nosql-mongo/mongo-x-basic.html\n * https://zhenye-na.github.io/2020/01/27/intro-to-mongodb.html\n * https://gitee.com/heguangchuan/rainmeter/blob/master/document/mongodb/01-概述.md",normalizedContent:"# 什么是nosql？\n\nnosql是一种非关系型dms，不需要固定的架构，可以避免joins链接，并且易于扩展。nosql数据库用于具有庞大数据存储需求的分布式数据存储。nosql用于大数据和实时web应用程序。例如，像twitter，facebook，google这样的大型公司，每天可能产生tb级的用户数据。\n\nnosql数据库代表“不仅仅是sql”或“不是sql”。虽然norelnosql会是一个更好的名词。carl strozz在1998年引入了nosql概念。\n\n传统的rdbms使用sql语法来存储和查询数据。相反，nosql数据库系统包含可存储结构化，半结构化，非结构化和多态数据的多种数据库技术。\n\n\n\n\n# 为什么使用nosql？\n\nnosql数据库的概念在处理大量数据的互联网巨头（例如google，facebook，amazon等）中变得很流行。使用rdbms处理海量数据时，系统响应时间变慢。\n\n为了解决此问题，当然可以通过升级现有硬件来“横向扩展”我们的系统。但这个成本很高。\n\n这个问题的替代方案是在负载增加时将数据库负载分配到多个主机上。这种方法称为“横向扩展”。\n\n\n\nnosql数据库是非关系数据库，因此在设计时考虑到web应用程序，比关系数据库更好地扩展。\n\n\n# nosql数据库的简要历史\n\n * 1998年-carlo strozzi在他的轻量级开源关系数据库中使用术语nosql\n * 2000-图形数据库neo4j启动\n * 2004年-推出google bigtable\n * 2005年-启动couchdb\n * 2007年-发布有关amazon dynamo的研究论文\n * 2008年-facebook开源cassandra项目\n * 2009年-重新引入nosql术语\n\n\n# nosql的功能\n\n非关系\n\n * nosql数据库从不遵循关系模型\n * 切勿为tables 提供固定的固定列记录\n * 使用自包含的聚合或blob\n * 不需要对象关系映射和数据规范化\n * 没有复杂的功能，例如查询语言，查询计划者，\n * 参照完整性联接，acid\n\n动态架构\n\n * nosql数据库是无模式的或具有宽松模式的数据库\n * 不需要对数据架构进行任何形式的定义\n * 提供同一域中的异构数据结构\n\n\n\n简单的api\n\n * 提供易于使用的界面，用于存储和查询提供的数据\n * api允许进行低级数据操作和选择方法\n * 基于文本的协议，通常与带有json的http rest一起使用\n * 多数不使用基于标准的查询语言\n * 支持web的数据库作为面向互联网的服务运行\n\n分布式\n\n * 可以以分布式方式执行多个nosql数据库\n * 提供自动缩放和故障转移功能\n * 通常可牺牲acid概念来实现可伸缩性和吞吐量\n * 分布式节点之间几乎没有同步复制，多为异步多主复制，对等，hdfs复制\n * 仅提供最终的一致性\n * 无共享架构。这样可以减少协调并提高分布\n\n\n\n\n# 什么是mongodb\n\nmongodb是面向文档的nosql数据库，用于大量数据存储。mongodb是一个在2000年代中期问世的数据库。属于nosql数据库的类别。\n\n\n# 业务场景\n\n传统的关系型数据库 (比如 mysql), 在数据操作的”三高”需求以及对应的 web 2.0 网站需求面前, 会有”力不从心”的感觉\n\n所谓的三高需求:\n\n高并发, 高性能, 高可用, 简称三高\n\n * high performance: 对数据库的高并发读写的要求\n * high storage: 对海量数据的高效率存储和访问的需求\n * high scalability && high available: 对数据的高扩展性和高可用性的需求\n\n而 mongodb 可以应对三高需求\n\n具体的应用场景:\n\n * 社交场景, 使用 mongodb 存储存储用户信息, 以及用户发表的朋友圈信息, 通过地理位置索引实现附近的人, 地点等功能.\n * 游戏场景, 使用 mongodb 存储游戏用户信息, 用户的装备, 积分等直接以内嵌文档的形式存储, 方便查询, 高效率存储和访问.\n * 物流场景, 使用 mongodb 存储订单信息, 订单状态在运送过程中会不断更新, 以 mongodb 内嵌数组的形式来存储, 一次查询就能将订单所有的变更读取出来.\n * 物联网场景, 使用 mongodb 存储所有接入的智能设备信息, 以及设备汇报的日志信息, 并对这些信息进行多维度的分析.\n * 视频直播, 使用 mongodb 存储用户信息, 点赞互动信息等.\n\n这些应用场景中, 数据操作方面的共同点有:\n\n 1. 数据量大\n 2. 写入操作频繁\n 3. 价值较低的数据, 对事务性要求不高\n\n对于这样的数据, 更适合用 mongodb 来实现数据存储\n\n那么我们什么时候选择 mongodb 呢?\n\n除了架构选型上, 除了上述三个特点之外, 还要考虑下面这些问题:\n\n * 应用不需要事务及复杂 join 支持\n * 新应用, 需求会变, 数据模型无法确定, 想快速迭代开发\n * 应用需要 2000 - 3000 以上的读写qps（更高也可以）\n * 应用需要 tb 甚至 pb 级别数据存储\n * 应用发展迅速, 需要能快速水平扩展\n * 应用要求存储的数据不丢失\n * 应用需要 99.999% 高可用\n * 应用需要大量的地理位置查询, 文本查询\n\n如果上述有1个符合, 可以考虑 mongodb, 2个及以上的符合, 选择 mongodb 绝不会后悔.\n\n> 如果用mysql呢?\n> \n> 相对mysql, mongodb可以以更低的成本解决问题（包括学习, 开发, 运维等成本）\n\n\n# mongodb 简介\n\nmongodb是一个开源， 高性能，无模式的文档型数据库，当初的设计就是用于简化开发和方便扩展，是nosql数据库产品中的一种。是最像关系型数据库（mysql）的非关系型数据库。 它支持的数据结构非常松散，是一种类似于 json 的 格式叫bson， 所以它既可以存储比较复杂的数据类型， 又相当的灵活。mongodb中的记录是一个文档，它是一个由字段和值对（ﬁeld:value）组成的数据结构。mongodb文档类似于json对象，即一个文档认 为就是一个对象。字段的数据类型是字符型， 它的值除了使用基本的一些类型外, 还可以包括其他文档， 普通数组和文档数组。\n\nmongodb 数据模型是面向文档的, 所谓文档就是一种类似于 json 的结构, 简单理解 mongodb 这个数据库中存在的是各种各样的 json（bson）\n\n\n# mongodb与rdbms区别\n\n下表将帮助您更容易理解mongo中的一些概念：\n\nsql术语/概念      mongodb术语/概念   解释/说明\ndatabase      database       数据库\ntable         collection     数据库表/集合\nrow           document       数据记录行/文档\ncolumn        field          数据字段/域\nindex         index          索引\ntable joins                  表连接,mongodb不支持\nprimary key   primary key    主键,mongodb自动将_id字段设置为主键\n\n\n\n在 mongodb 中, 数据库和集合都不需要手动创建, 当我们创建文档时, 如果文档所在的集合或者数据库不存在, 则会自动创建数据库或者集合\n\n\n# 数据模型\n\nmongodb的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在mongodb中以 bson（binary-json）文档的格式存储在磁盘上。\n\nbson（binary serialized document format）是一种类json的一种二进制形式的存储格式，简称binary json。bson和json一样，支持 内嵌的文档对象和数组对象，但是bson有json没有的一些数据类型，如date和bindata类型。\n\nbson采用了类似于 c 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可 以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。\n\nbson中，除了基本的json类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括 date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详细信息。\n\nbson数据类型参考列表：\n\n\n\n\n# 参考资料\n\n * https://www.pdai.tech/md/db/nosql-mongo/mongo-x-basic.html\n * https://zhenye-na.github.io/2020/01/27/intro-to-mongodb.html\n * https://gitee.com/heguangchuan/rainmeter/blob/master/document/mongodb/01-概述.md",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"ES - 索引管理",frontmatter:{title:"ES - 索引管理",date:"2022-07-28T20:46:32.000Z",permalink:"/pages/8b85ee/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/15.ElasticSearch/10.ES%20-%20%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86.html",relativePath:"03.数据库/15.ElasticSearch/10.ES - 索引管理.md",key:"v-37e966eb",path:"/pages/8b85ee/",headers:[{level:2,title:"Mapping",slug:"mapping",normalizedTitle:"mapping",charIndex:3},{level:3,title:"字段类型",slug:"字段类型",normalizedTitle:"字段类型",charIndex:16},{level:3,title:"映射",slug:"映射",normalizedTitle:"映射",charIndex:26},{level:2,title:"索引管理操作",slug:"索引管理操作",normalizedTitle:"索引管理操作",charIndex:32},{level:2,title:"数据迁移",slug:"数据迁移",normalizedTitle:"数据迁移",charIndex:42}],headersStr:"Mapping 字段类型 映射 索引管理操作 数据迁移",content:' * Mapping\n   * 字段类型\n   * 映射\n * 索引管理操作\n * 数据迁移\n\n\n\n\n# Mapping\n\n\n# 字段类型\n\n官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.17/mapping-types.html\n\n> 核心数据类型\n\n * 字符串\n   \n   text ⽤于全⽂索引，搜索时会自动使用分词器进⾏分词再匹配 keyword 不分词，搜索时需要匹配完整的值\n\n * 数值型\n   \n   整型： byte，short，integer，long 浮点型： float, half_float, scaled_float，double\n\n * 日期类型：date\n\n * 范围型\n   \n   integer_range， long_range， float_range，double_range，date_range\n   \n   gt是大于，lt是小于，e是equals等于。\n   \n   age_limit的区间包含了此值的文档都算是匹配。\n\n * 布尔\n   \n   boolean\n\n * 二进制\n   \n   binary 会把值当做经过 base64 编码的字符串，默认不存储，且不可搜索\n\n> 复杂数据类型\n\n * 对象\n   \n   object一个对象中可以嵌套对象。\n\n * 数组\n   \n   Array：嵌套类型\n   \n   nested 用于json对象数组\n\n\n# 映射\n\nMapping(映射)是用来定义一个文档（document），以及它所包含的属性（field）是如何存储和索引的。\n\n看mapping信息:\n\nGET bank/_mapping\n\n\n1\n\n\n\n# 索引管理操作\n\n * 创建索引并指定映射\n\nPUT /my_index\n{\n  "mappings": {\n    "properties": {\n      "age": {\n        "type": "integer"\n      },\n      "email": {\n        "type": "keyword" # 指定为keyword\n      },\n      "name": {\n        "type": "text" # 全文检索。保存时候分词，检索时候进行分词匹配\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 查看映射\n\nGET /my_index\n\n\n1\n\n * 添加新的字段映射\n\nPUT /my_index/_mapping\n{\n  "properties": {\n    "employee-id": {\n      "type": "keyword",\n      "index": false # 字段不能被检索。检索\n    }\n  }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该index选项控制字段值是否被索引。它接受true orfalse并默认为true. 未编入索引的字段不可查询。\n\n * 修改映射\n   \n   不能更新映射，对于已经存在的字段映射不能更新。\n   \n   更新必须创建新的索引，进行数据迁移。\n\n\n# 数据迁移\n\n官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.16/docs-reindex.html\n\n先创建new_twitter的正确映射。\n\n然后使用如下方式进行数据迁移，把twitter迁移到new_twitters\n\nPOST _reindex\n{\n  "source":{\n      "index":"twitter"\n   },\n  "dest":{\n      "index":"new_twitters"\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:' * mapping\n   * 字段类型\n   * 映射\n * 索引管理操作\n * 数据迁移\n\n\n\n\n# mapping\n\n\n# 字段类型\n\n官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.17/mapping-types.html\n\n> 核心数据类型\n\n * 字符串\n   \n   text ⽤于全⽂索引，搜索时会自动使用分词器进⾏分词再匹配 keyword 不分词，搜索时需要匹配完整的值\n\n * 数值型\n   \n   整型： byte，short，integer，long 浮点型： float, half_float, scaled_float，double\n\n * 日期类型：date\n\n * 范围型\n   \n   integer_range， long_range， float_range，double_range，date_range\n   \n   gt是大于，lt是小于，e是equals等于。\n   \n   age_limit的区间包含了此值的文档都算是匹配。\n\n * 布尔\n   \n   boolean\n\n * 二进制\n   \n   binary 会把值当做经过 base64 编码的字符串，默认不存储，且不可搜索\n\n> 复杂数据类型\n\n * 对象\n   \n   object一个对象中可以嵌套对象。\n\n * 数组\n   \n   array：嵌套类型\n   \n   nested 用于json对象数组\n\n\n# 映射\n\nmapping(映射)是用来定义一个文档（document），以及它所包含的属性（field）是如何存储和索引的。\n\n看mapping信息:\n\nget bank/_mapping\n\n\n1\n\n\n\n# 索引管理操作\n\n * 创建索引并指定映射\n\nput /my_index\n{\n  "mappings": {\n    "properties": {\n      "age": {\n        "type": "integer"\n      },\n      "email": {\n        "type": "keyword" # 指定为keyword\n      },\n      "name": {\n        "type": "text" # 全文检索。保存时候分词，检索时候进行分词匹配\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 查看映射\n\nget /my_index\n\n\n1\n\n * 添加新的字段映射\n\nput /my_index/_mapping\n{\n  "properties": {\n    "employee-id": {\n      "type": "keyword",\n      "index": false # 字段不能被检索。检索\n    }\n  }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该index选项控制字段值是否被索引。它接受true orfalse并默认为true. 未编入索引的字段不可查询。\n\n * 修改映射\n   \n   不能更新映射，对于已经存在的字段映射不能更新。\n   \n   更新必须创建新的索引，进行数据迁移。\n\n\n# 数据迁移\n\n官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/7.16/docs-reindex.html\n\n先创建new_twitter的正确映射。\n\n然后使用如下方式进行数据迁移，把twitter迁移到new_twitters\n\npost _reindex\n{\n  "source":{\n      "index":"twitter"\n   },\n  "dest":{\n      "index":"new_twitters"\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/08/07, 3:08:00",lastUpdatedTimestamp:1659842691e3},{title:"Mongo - 安装和CRUD",frontmatter:{title:"Mongo - 安装和CRUD",date:"2021-09-11T11:24:13.000Z",permalink:"/pages/f04bc7/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/20.MongoDB/10.Mongo%20-%20%E5%AE%89%E8%A3%85%E5%92%8CCRUD.html",relativePath:"03.数据库/20.MongoDB/10.Mongo - 安装和CRUD.md",key:"v-66cd1cb0",path:"/pages/f04bc7/",headers:[{level:2,title:"MongoDB安装",slug:"mongodb安装",normalizedTitle:"mongodb安装",charIndex:2},{level:3,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:16},{level:3,title:"以Docker为例安装",slug:"以docker为例安装",normalizedTitle:"以docker为例安装",charIndex:213},{level:2,title:"连接和建库",slug:"连接和建库",normalizedTitle:"连接和建库",charIndex:1578},{level:2,title:"文档基本 CRUD",slug:"文档基本-crud",normalizedTitle:"文档基本 crud",charIndex:2071},{level:3,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:2130},{level:3,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:4229},{level:3,title:"更新",slug:"更新",normalizedTitle:"更新",charIndex:5661},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:4414},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:8380}],headersStr:"MongoDB安装 参考文档 以Docker为例安装 连接和建库 文档基本 CRUD 插入 查询 更新 删除 参考文章",content:'# MongoDB安装\n\n\n# 参考文档\n\n官网下载：https://www.mongodb.com/try/download/community\n\n官网文档：https://docs.mongodb.com/v3.6/administration/install-community/\n\n菜鸟教程：https://www.runoob.com/mongodb/mongodb-window-install.html\n\n\n# 以Docker为例安装\n\n1、拉取镜像\n\ndocker pull mongo:latest\n\n\n1\n\n\n注意：有的服务器不支持新版本，会导致Docker启动失败，具体原因看报错内容\n\n可选择其他版本（我使用的服务器5.0及以上版本都不可使）\n\ndocker pull mongo:4.4.8\n\n\n1\n\n\n2、创建和启动容器\n\n以 4.4.8 版本为例\n\ndocker run -d --restart=always  --name mymongo \\\n  -p 27017:27017 \\\n  -v /data/docker/mongodb:/data/db \\\n  mongo:4.4.8\n\n\n1\n2\n3\n4\n\n\ndocker run -d --restart=always --name mymongo \\\n  -p 27017:27017  \\\n  -e MONGO_INITDB_ROOT_USERNAME=mymongoadmin \\\n  -e MONGO_INITDB_ROOT_PASSWORD=root123456 \\\n  -v /data/docker/mongodb:/data/db \\\n  mongo:4.4.8\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用账户密码启动的，需要给数据库创建用户权限：\n\ndb.createUser(\n    {\n        user:"admin",\n        pwd:"root123456",\n        roles:[\n            {role:"dbOwner",db:"yygh_hosp"}\n        ]\n    }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n之后sping中MongoDB地址改成：\n\nspring.data.mongodb.uri=mongodb://admin:root123456@IP:端口/yygh_hosp\n\n\n1\n\n\n角色权限说明(role)：\n\nBuilt-In Roles（内置角色）：\n\n 1. 数据库用户角色：read、readWrite;\n 2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；\n 3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；\n 4. 备份恢复角色：backup、restore；\n 5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase\n 6. 超级用户角色：root\n\n> 这里还有几个角色间接或直接提供了系统超级用户的访问\n> \n> （dbOwner 、userAdmin、userAdminAnyDatabase）\n\n之前学习 尚硅谷-尚医通项目 用到了MongoDB\n\n我安装到了服务器上，没换端口地址且没设密码\n\n后来某一天，数据库让淦了，所有数据都没了，只剩下个勒索数据：\n\n\n\n翻译后：\n\n\n\n还好只是学习的测试数据，不然就完犊子了\n\n百度了一下参考了 mongoDB 数据莫名其妙的没了 这篇文章，才知道数据库是被黑了\n\n\n# 连接和建库\n\n默认保留的数据库\n\n * admin: 从权限角度考虑, 这是 root 数据库, 如果将一个用户添加到这个数据库, 这个用户自动继承所有数据库的权限, 一些特定的服务器端命令也只能从这个数据库运行, 比如列出所有的数据库或者关闭服务器\n * local: 数据永远不会被复制, 可以用来存储限于本地的单台服务器的集合 (部署集群, 分片等)\n * config: Mongo 用于分片设置时, config 数据库在内部使用, 用来保存分片的相关信息\n\n进入容器\n\ndocker exec -it mymongo /bin/bash \n\n\n1\n\n\n连接mongo\n\nmongo -u mymongoadmin -p root123456\n\n\n1\n\n\n基本操作：\n\n#查看所有数据库\nshow dbs\n#使用数据库，没有这个数据则自动创建\nuse testdb\n\n\n1\n2\n3\n4\n\n\n当 use testdb 的时候. testdb 其实存放在内存之中,\n\n当 testdb 中存在一个 document 之后, mongo 才会将这个数据库持久化到硬盘之中.\n\n\n# 文档基本 CRUD\n\n官方文档\n\nhttps://docs.mongodb.com/manual/crud/\n\n\n# 插入\n\n * 图例\n\nusers 为要插入的"表"\n\n\n\n#向集合中添加一个文档\ndb.inventory.insertOne(\n   { item: "canvas", qty: 100, tags: ["cotton"], size: { h: 28, w: 35.5, uom: "cm" } }\n)\n#向集合中添加多个文档\ndb.inventory.insertMany([\n   { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },\n   { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },\n   { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }\n])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注：当我们向 inventory 中插入 document 文档时, 如果没有给文档指定 _id 属性, 那么数据库会为文档自动添加 _id field, 并且值类型是 ObjectId(blablabla), 就是文档的唯一标识, 类似于 relational database 里的 primary key\n\n这个数据库工具叫 Navicat\n\n> “Navicat”是一套可创建多个连接的数据库管理工具，用以方便管理 MySQL、Oracle、PostgreSQL、SQLite、SQL Server、MariaDB 和/或 MongoDB 等不同类型的数据库，并支持管理某些云数据库，例如阿里云、‎腾讯云。\n\n\n\n>  * mongo 中的数字, 默认情况下是 double 类型, 如果要存整型, 必须使用函数 NumberInt(整型数字), 否则取出来就有问题了\n>  * 插入当前日期可以使用 new Date()\n\n如果某条数据插入失败, 将会终止插入, 但已经插入成功的数据不会回滚掉. 因为批量插入由于数据较多容易出现失败, 因此, 可以使用 try catch 进行异常捕捉处理, 测试的时候可以不处理.如：\n\ntry {\n  db.comment.insertMany([\n    {"_id":"1","articleid":"100001","content":"我们不应该把清晨浪费在手机上, 健康很重要, 一杯温水幸福你我 他.","userid":"1002","nickname":"相忘于江湖","createdatetime":new Date("2019-0805T22:08:15.522Z"),"likenum":NumberInt(1000),"state":"1"},\n    {"_id":"2","articleid":"100001","content":"我夏天空腹喝凉开水, 冬天喝温开水","userid":"1005","nickname":"伊人憔 悴","createdatetime":new Date("2019-08-05T23:58:51.485Z"),"likenum":NumberInt(888),"state":"1"},\n    {"_id":"3","articleid":"100001","content":"我一直喝凉开水, 冬天夏天都喝.","userid":"1004","nickname":"杰克船 长","createdatetime":new Date("2019-08-06T01:05:06.321Z"),"likenum":NumberInt(666),"state":"1"},\n    {"_id":"4","articleid":"100001","content":"专家说不能空腹吃饭, 影响健康.","userid":"1003","nickname":"凯 撒","createdatetime":new Date("2019-08-06T08:18:35.288Z"),"likenum":NumberInt(2000),"state":"1"},\n    {"_id":"5","articleid":"100001","content":"研究表明, 刚烧开的水千万不能喝, 因为烫 嘴.","userid":"1003","nickname":"凯撒","createdatetime":new Date("2019-0806T11:01:02.521Z"),"likenum":NumberInt(3000),"state":"1"}\n\n]);\n\n} catch (e) {\n  print (e);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 查询\n\n\n\n * 使用 db.<collection_name>.find() 方法对集合进行查询, 接受一个 json 格式的查询条件. 返回的是一个数组\n * db.<collection_name>.findOne() 查询集合中符合条件的第一个文档, 返回的是一个对象\n\n查询全部数据：\n\ndb.inventory.find()\n\n\n1\n\n * 数据准备：\n\n先删除之前的数据：\n\ndb.comment.deleteMany({})\n\n\n1\n\n\n我们先往 comment 插入一些数据：\n\ndb.comment.insertMany([\n   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },\n   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },\n   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },\n   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },\n   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }\n]);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 可以使用 $in 操作符表示：查看状态是 A 和 D 的\n\ndb.comment.find( { status: { $in: [ "A", "D" ] } } )\n\n\n1\n\n * 多个查询条件用逗号分隔, 表示 AND 的关系\n\ndb.comment.find( { status: "A", qty: { $lt: 30 } } )\n\n\n1\n\n\n等价于sql : SELECT * FROM comment WHERE status = "A" AND qty < 30\n\n * 使用 $or 操作符表示后边数组中的条件是OR的关系\n\ndb.comment.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } )\n\n\n1\n\n\n等价于sql : SELECT * FROM inventory WHERE status = "A" OR qty < 30\n\n * 可以使用 pretty() 来帮助阅读\n\ndb.comment.find().pretty()\n\n\n1\n\n\n创建索引\n\ndb.posts.createIndex({\n  { title : \'text\' }\n})\n\n// 文本搜索\n// will return document with title "Post One"\n// if there is no more posts created\ndb.posts.find({\n  $text : {\n    $search : "\\"Post O\\""\n  }\n}).pretty()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 更新\n\n\n\n * 使用 db.<collection_name>.updateOne(<filter>, <update>, <options>) 方法修改一个匹配 <filter> 条件的文档\n * 使用 db.<collection_name>.updateMany(<filter>, <update>, <options>) 方法修改所有匹配 <filter> 条件的文档\n * 使用 db.<collection_name>.replaceOne(<filter>, <update>, <options>) 方法替换一个匹配 <filter> 条件的文档\n * db.<collection_name>.update(查询对象, 新对象) 默认情况下会使用新对象替换旧对象\n\n其中 <filter> 参数与查询方法中的条件参数用法一致.\n\n如果需要修改指定的属性, 而不是替换需要用“修改操作符”来进行修改\n\n * $set 修改文档中的制定属性\n\n其中最常用的修改操作符即为$set和$unset,分别表示赋值和取消赋值.\n\n先加入一些数据：\n\ndb.inventory.insertMany( [\n   { item: "canvas", qty: 100, size: { h: 28, w: 35.5, uom: "cm" }, status: "A" },\n   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },\n   { item: "mat", qty: 85, size: { h: 27.9, w: 35.5, uom: "cm" }, status: "A" },\n   { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "P" },\n   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },\n   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },\n   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },\n   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" },\n   { item: "sketchbook", qty: 80, size: { h: 14, w: 21, uom: "cm" }, status: "A" },\n   { item: "sketch pad", qty: 95, size: { h: 22.85, w: 30.5, uom: "cm" }, status: "A" }\n] );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n更新数据：\n\ndb.inventory.updateOne(\n    { item: "paper" },\n    {\n        $set: { "size.uom": "cm", status: "P" },\n        $currentDate: { lastModified: true }\n    }\n)\n\ndb.inventory.updateMany(\n    { qty: { $lt: 50 } },\n    {\n        $set: { "size.uom": "in", status: "P" },\n        $currentDate: { lastModified: true }\n    }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ndb.<collection_name>.replaceOne() 方法替换除 _id 属性外的所有属性, 其<update>参数应为一个全新的文档.\n\ndb.inventory.replaceOne(\n    { item: "paper" },\n    { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 40 } ] }\n)\n\n\n1\n2\n3\n4\n\n\n> 修改前： { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" }\n> \n> 修改完后： { "item" : "paper", "instock" : [ { "warehouse" : "A", "qty" : 60 }, { "warehouse" : "B", "qty" : 40 } ] }\n\n批量修改\n\n// 默认会修改第一条\ndb.document.update({ userid: "30", { $set {username: "guest"} } })\n\n// 修改所有符合条件的数据\ndb.document.update( { userid: "30", { $set {username: "guest"} } }, {multi: true} )\n\n\n1\n2\n3\n4\n5\n\n\n\n# 删除\n\n * 使用 db.collection.deleteMany() 方法删除所有匹配的文档.\n * 使用 db.collection.deleteOne() 方法删除单个匹配的文档.\n * db.collection.drop()\n * db.dropDatabase()\n\ndb.inventory.deleteMany( { qty : { $lt : 50 } } )\n\n\n1\n\n\n> Delete operations do not drop indexes, even if deleting all documents from a collection.\n> \n> 一般数据库中的数据都不会真正意义上的删除, 会添加一个字段, 用来表示这个数据是否被删除\n\n\n# 参考文章\n\n * https://zhenye-na.github.io/2020/01/27/intro-to-mongodb.html\n * https://www.pdai.tech/md/db/nosql-mongo/mongo-x-usage-1.html',normalizedContent:'# mongodb安装\n\n\n# 参考文档\n\n官网下载：https://www.mongodb.com/try/download/community\n\n官网文档：https://docs.mongodb.com/v3.6/administration/install-community/\n\n菜鸟教程：https://www.runoob.com/mongodb/mongodb-window-install.html\n\n\n# 以docker为例安装\n\n1、拉取镜像\n\ndocker pull mongo:latest\n\n\n1\n\n\n注意：有的服务器不支持新版本，会导致docker启动失败，具体原因看报错内容\n\n可选择其他版本（我使用的服务器5.0及以上版本都不可使）\n\ndocker pull mongo:4.4.8\n\n\n1\n\n\n2、创建和启动容器\n\n以 4.4.8 版本为例\n\ndocker run -d --restart=always  --name mymongo \\\n  -p 27017:27017 \\\n  -v /data/docker/mongodb:/data/db \\\n  mongo:4.4.8\n\n\n1\n2\n3\n4\n\n\ndocker run -d --restart=always --name mymongo \\\n  -p 27017:27017  \\\n  -e mongo_initdb_root_username=mymongoadmin \\\n  -e mongo_initdb_root_password=root123456 \\\n  -v /data/docker/mongodb:/data/db \\\n  mongo:4.4.8\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用账户密码启动的，需要给数据库创建用户权限：\n\ndb.createuser(\n    {\n        user:"admin",\n        pwd:"root123456",\n        roles:[\n            {role:"dbowner",db:"yygh_hosp"}\n        ]\n    }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n之后sping中mongodb地址改成：\n\nspring.data.mongodb.uri=mongodb://admin:root123456@ip:端口/yygh_hosp\n\n\n1\n\n\n角色权限说明(role)：\n\nbuilt-in roles（内置角色）：\n\n 1. 数据库用户角色：read、readwrite;\n 2. 数据库管理角色：dbadmin、dbowner、useradmin；\n 3. 集群管理角色：clusteradmin、clustermanager、clustermonitor、hostmanager；\n 4. 备份恢复角色：backup、restore；\n 5. 所有数据库角色：readanydatabase、readwriteanydatabase、useradminanydatabase、dbadminanydatabase\n 6. 超级用户角色：root\n\n> 这里还有几个角色间接或直接提供了系统超级用户的访问\n> \n> （dbowner 、useradmin、useradminanydatabase）\n\n之前学习 尚硅谷-尚医通项目 用到了mongodb\n\n我安装到了服务器上，没换端口地址且没设密码\n\n后来某一天，数据库让淦了，所有数据都没了，只剩下个勒索数据：\n\n\n\n翻译后：\n\n\n\n还好只是学习的测试数据，不然就完犊子了\n\n百度了一下参考了 mongodb 数据莫名其妙的没了 这篇文章，才知道数据库是被黑了\n\n\n# 连接和建库\n\n默认保留的数据库\n\n * admin: 从权限角度考虑, 这是 root 数据库, 如果将一个用户添加到这个数据库, 这个用户自动继承所有数据库的权限, 一些特定的服务器端命令也只能从这个数据库运行, 比如列出所有的数据库或者关闭服务器\n * local: 数据永远不会被复制, 可以用来存储限于本地的单台服务器的集合 (部署集群, 分片等)\n * config: mongo 用于分片设置时, config 数据库在内部使用, 用来保存分片的相关信息\n\n进入容器\n\ndocker exec -it mymongo /bin/bash \n\n\n1\n\n\n连接mongo\n\nmongo -u mymongoadmin -p root123456\n\n\n1\n\n\n基本操作：\n\n#查看所有数据库\nshow dbs\n#使用数据库，没有这个数据则自动创建\nuse testdb\n\n\n1\n2\n3\n4\n\n\n当 use testdb 的时候. testdb 其实存放在内存之中,\n\n当 testdb 中存在一个 document 之后, mongo 才会将这个数据库持久化到硬盘之中.\n\n\n# 文档基本 crud\n\n官方文档\n\nhttps://docs.mongodb.com/manual/crud/\n\n\n# 插入\n\n * 图例\n\nusers 为要插入的"表"\n\n\n\n#向集合中添加一个文档\ndb.inventory.insertone(\n   { item: "canvas", qty: 100, tags: ["cotton"], size: { h: 28, w: 35.5, uom: "cm" } }\n)\n#向集合中添加多个文档\ndb.inventory.insertmany([\n   { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },\n   { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },\n   { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }\n])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注：当我们向 inventory 中插入 document 文档时, 如果没有给文档指定 _id 属性, 那么数据库会为文档自动添加 _id field, 并且值类型是 objectid(blablabla), 就是文档的唯一标识, 类似于 relational database 里的 primary key\n\n这个数据库工具叫 navicat\n\n> “navicat”是一套可创建多个连接的数据库管理工具，用以方便管理 mysql、oracle、postgresql、sqlite、sql server、mariadb 和/或 mongodb 等不同类型的数据库，并支持管理某些云数据库，例如阿里云、‎腾讯云。\n\n\n\n>  * mongo 中的数字, 默认情况下是 double 类型, 如果要存整型, 必须使用函数 numberint(整型数字), 否则取出来就有问题了\n>  * 插入当前日期可以使用 new date()\n\n如果某条数据插入失败, 将会终止插入, 但已经插入成功的数据不会回滚掉. 因为批量插入由于数据较多容易出现失败, 因此, 可以使用 try catch 进行异常捕捉处理, 测试的时候可以不处理.如：\n\ntry {\n  db.comment.insertmany([\n    {"_id":"1","articleid":"100001","content":"我们不应该把清晨浪费在手机上, 健康很重要, 一杯温水幸福你我 他.","userid":"1002","nickname":"相忘于江湖","createdatetime":new date("2019-0805t22:08:15.522z"),"likenum":numberint(1000),"state":"1"},\n    {"_id":"2","articleid":"100001","content":"我夏天空腹喝凉开水, 冬天喝温开水","userid":"1005","nickname":"伊人憔 悴","createdatetime":new date("2019-08-05t23:58:51.485z"),"likenum":numberint(888),"state":"1"},\n    {"_id":"3","articleid":"100001","content":"我一直喝凉开水, 冬天夏天都喝.","userid":"1004","nickname":"杰克船 长","createdatetime":new date("2019-08-06t01:05:06.321z"),"likenum":numberint(666),"state":"1"},\n    {"_id":"4","articleid":"100001","content":"专家说不能空腹吃饭, 影响健康.","userid":"1003","nickname":"凯 撒","createdatetime":new date("2019-08-06t08:18:35.288z"),"likenum":numberint(2000),"state":"1"},\n    {"_id":"5","articleid":"100001","content":"研究表明, 刚烧开的水千万不能喝, 因为烫 嘴.","userid":"1003","nickname":"凯撒","createdatetime":new date("2019-0806t11:01:02.521z"),"likenum":numberint(3000),"state":"1"}\n\n]);\n\n} catch (e) {\n  print (e);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 查询\n\n\n\n * 使用 db.<collection_name>.find() 方法对集合进行查询, 接受一个 json 格式的查询条件. 返回的是一个数组\n * db.<collection_name>.findone() 查询集合中符合条件的第一个文档, 返回的是一个对象\n\n查询全部数据：\n\ndb.inventory.find()\n\n\n1\n\n * 数据准备：\n\n先删除之前的数据：\n\ndb.comment.deletemany({})\n\n\n1\n\n\n我们先往 comment 插入一些数据：\n\ndb.comment.insertmany([\n   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "a" },\n   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "a" },\n   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "d" },\n   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "d" },\n   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "a" }\n]);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 可以使用 $in 操作符表示：查看状态是 a 和 d 的\n\ndb.comment.find( { status: { $in: [ "a", "d" ] } } )\n\n\n1\n\n * 多个查询条件用逗号分隔, 表示 and 的关系\n\ndb.comment.find( { status: "a", qty: { $lt: 30 } } )\n\n\n1\n\n\n等价于sql : select * from comment where status = "a" and qty < 30\n\n * 使用 $or 操作符表示后边数组中的条件是or的关系\n\ndb.comment.find( { $or: [ { status: "a" }, { qty: { $lt: 30 } } ] } )\n\n\n1\n\n\n等价于sql : select * from inventory where status = "a" or qty < 30\n\n * 可以使用 pretty() 来帮助阅读\n\ndb.comment.find().pretty()\n\n\n1\n\n\n创建索引\n\ndb.posts.createindex({\n  { title : \'text\' }\n})\n\n// 文本搜索\n// will return document with title "post one"\n// if there is no more posts created\ndb.posts.find({\n  $text : {\n    $search : "\\"post o\\""\n  }\n}).pretty()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 更新\n\n\n\n * 使用 db.<collection_name>.updateone(<filter>, <update>, <options>) 方法修改一个匹配 <filter> 条件的文档\n * 使用 db.<collection_name>.updatemany(<filter>, <update>, <options>) 方法修改所有匹配 <filter> 条件的文档\n * 使用 db.<collection_name>.replaceone(<filter>, <update>, <options>) 方法替换一个匹配 <filter> 条件的文档\n * db.<collection_name>.update(查询对象, 新对象) 默认情况下会使用新对象替换旧对象\n\n其中 <filter> 参数与查询方法中的条件参数用法一致.\n\n如果需要修改指定的属性, 而不是替换需要用“修改操作符”来进行修改\n\n * $set 修改文档中的制定属性\n\n其中最常用的修改操作符即为$set和$unset,分别表示赋值和取消赋值.\n\n先加入一些数据：\n\ndb.inventory.insertmany( [\n   { item: "canvas", qty: 100, size: { h: 28, w: 35.5, uom: "cm" }, status: "a" },\n   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "a" },\n   { item: "mat", qty: 85, size: { h: 27.9, w: 35.5, uom: "cm" }, status: "a" },\n   { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "p" },\n   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "p" },\n   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "d" },\n   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "d" },\n   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "a" },\n   { item: "sketchbook", qty: 80, size: { h: 14, w: 21, uom: "cm" }, status: "a" },\n   { item: "sketch pad", qty: 95, size: { h: 22.85, w: 30.5, uom: "cm" }, status: "a" }\n] );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n更新数据：\n\ndb.inventory.updateone(\n    { item: "paper" },\n    {\n        $set: { "size.uom": "cm", status: "p" },\n        $currentdate: { lastmodified: true }\n    }\n)\n\ndb.inventory.updatemany(\n    { qty: { $lt: 50 } },\n    {\n        $set: { "size.uom": "in", status: "p" },\n        $currentdate: { lastmodified: true }\n    }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ndb.<collection_name>.replaceone() 方法替换除 _id 属性外的所有属性, 其<update>参数应为一个全新的文档.\n\ndb.inventory.replaceone(\n    { item: "paper" },\n    { item: "paper", instock: [ { warehouse: "a", qty: 60 }, { warehouse: "b", qty: 40 } ] }\n)\n\n\n1\n2\n3\n4\n\n\n> 修改前： { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "d" }\n> \n> 修改完后： { "item" : "paper", "instock" : [ { "warehouse" : "a", "qty" : 60 }, { "warehouse" : "b", "qty" : 40 } ] }\n\n批量修改\n\n// 默认会修改第一条\ndb.document.update({ userid: "30", { $set {username: "guest"} } })\n\n// 修改所有符合条件的数据\ndb.document.update( { userid: "30", { $set {username: "guest"} } }, {multi: true} )\n\n\n1\n2\n3\n4\n5\n\n\n\n# 删除\n\n * 使用 db.collection.deletemany() 方法删除所有匹配的文档.\n * 使用 db.collection.deleteone() 方法删除单个匹配的文档.\n * db.collection.drop()\n * db.dropdatabase()\n\ndb.inventory.deletemany( { qty : { $lt : 50 } } )\n\n\n1\n\n\n> delete operations do not drop indexes, even if deleting all documents from a collection.\n> \n> 一般数据库中的数据都不会真正意义上的删除, 会添加一个字段, 用来表示这个数据是否被删除\n\n\n# 参考文章\n\n * https://zhenye-na.github.io/2020/01/27/intro-to-mongodb.html\n * https://www.pdai.tech/md/db/nosql-mongo/mongo-x-usage-1.html',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"mybatis学习笔记",frontmatter:{title:"mybatis学习笔记",permalink:"/mybatis/study-note",date:"2021-05-09T09:53:35.000Z"},regularPath:"/04.%E6%A1%86%E6%9E%B6/01.mybatis/01.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"04.框架/01.mybatis/01.学习笔记.md",key:"v-ece34b10",path:"/mybatis/study-note/",headers:[{level:2,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:73},{level:3,title:"1.1、什么是Mybatis",slug:"_1-1、什么是mybatis",normalizedTitle:"1.1、什么是mybatis",charIndex:82},{level:3,title:"1.2、持久化",slug:"_1-2、持久化",normalizedTitle:"1.2、持久化",charIndex:814},{level:3,title:"1.3、持久层",slug:"_1-3、持久层",normalizedTitle:"1.3、持久层",charIndex:952},{level:3,title:"1.4 为什么需要Mybatis？",slug:"_1-4-为什么需要mybatis",normalizedTitle:"1.4 为什么需要mybatis？",charIndex:1021},{level:2,title:"2、第一个Mybatis程序",slug:"_2、第一个mybatis程序",normalizedTitle:"2、第一个mybatis程序",charIndex:1276},{level:3,title:"2.1、搭建环境",slug:"_2-1、搭建环境",normalizedTitle:"2.1、搭建环境",charIndex:1355},{level:3,title:"2.2、创建一个模块",slug:"_2-2、创建一个模块",normalizedTitle:"2.2、创建一个模块",charIndex:3590},{level:3,title:"2.3、编写代码",slug:"_2-3、编写代码",normalizedTitle:"2.3、编写代码",charIndex:5633},{level:3,title:"2.4、测试",slug:"_2-4、测试",normalizedTitle:"2.4、测试",charIndex:7710},{level:2,title:"3、CRUD",slug:"_3、crud",normalizedTitle:"3、crud",charIndex:8378},{level:3,title:"1、namespace",slug:"_1、namespace",normalizedTitle:"1、namespace",charIndex:8389},{level:3,title:"2、select",slug:"_2、select",normalizedTitle:"2、select",charIndex:8442},{level:3,title:"3、Insert",slug:"_3、insert",normalizedTitle:"3、insert",charIndex:9246},{level:3,title:"4、update",slug:"_4、update",normalizedTitle:"4、update",charIndex:9820},{level:3,title:"5、Delete",slug:"_5、delete",normalizedTitle:"5、delete",charIndex:9987},{level:3,title:"6、分析错误",slug:"_6、分析错误",normalizedTitle:"6、分析错误",charIndex:10161},{level:3,title:"7、万能Map",slug:"_7、万能map",normalizedTitle:"7、万能map",charIndex:10303},{level:3,title:"8、思考题",slug:"_8、思考题",normalizedTitle:"8、思考题",charIndex:11282},{level:2,title:"4、配置解析",slug:"_4、配置解析",normalizedTitle:"4、配置解析",charIndex:11523},{level:3,title:"1、核心配置文件",slug:"_1、核心配置文件",normalizedTitle:"1、核心配置文件",charIndex:11550},{level:3,title:"2、环境配置（environments）",slug:"_2、环境配置-environments",normalizedTitle:"2、环境配置（environments）",charIndex:11992},{level:3,title:"3、属性（properties）",slug:"_3、属性-properties",normalizedTitle:"3、属性（properties）",charIndex:12182},{level:3,title:"4、类型别名（typeAliases）",slug:"_4、类型别名-typealiases",normalizedTitle:"4、类型别名（typealiases）",charIndex:12728},{level:3,title:"5、设置",slug:"_5、设置",normalizedTitle:"5、设置",charIndex:13223},{level:3,title:"6、其他配置",slug:"_6、其他配置",normalizedTitle:"6、其他配置",charIndex:13281},{level:3,title:"7、映射器（mappers）",slug:"_7、映射器-mappers",normalizedTitle:"7、映射器（mappers）",charIndex:13412},{level:3,title:"8、生命周期和作用域",slug:"_8、生命周期和作用域",normalizedTitle:"8、生命周期和作用域",charIndex:14082},{level:2,title:"5、属性名和字段名配置",slug:"_5、属性名和字段名配置",normalizedTitle:"5、属性名和字段名配置",charIndex:14515},{level:3,title:"1、 问题",slug:"_1、-问题",normalizedTitle:"1、 问题",charIndex:14598},{level:3,title:"2、resultMap",slug:"_2、resultmap",normalizedTitle:"2、resultmap",charIndex:14994},{level:2,title:"6、日志",slug:"_6、日志",normalizedTitle:"6、日志",charIndex:15603},{level:3,title:"6.1、日志工厂",slug:"_6-1、日志工厂",normalizedTitle:"6.1、日志工厂",charIndex:15628},{level:3,title:"6.2、Log4j",slug:"_6-2、log4j",normalizedTitle:"6.2、log4j",charIndex:15981},{level:2,title:"7、分页",slug:"_7、分页",normalizedTitle:"7、分页",charIndex:18120},{level:3,title:"7.1、使用Limit分页",slug:"_7-1、使用limit分页",normalizedTitle:"7.1、使用limit分页",charIndex:18154},{level:3,title:"7.2、RowBounds分页",slug:"_7-2、rowbounds分页",normalizedTitle:"7.2、rowbounds分页",charIndex:19256},{level:3,title:"7.3、分页插件",slug:"_7-3、分页插件",normalizedTitle:"7.3、分页插件",charIndex:20131},{level:2,title:"8、使用注解开发",slug:"_8、使用注解开发",normalizedTitle:"8、使用注解开发",charIndex:20182},{level:3,title:"8.1、面向接口编程",slug:"_8-1、面向接口编程",normalizedTitle:"8.1、面向接口编程",charIndex:20211},{level:3,title:"8.2、使用注解开发",slug:"_8-2、使用注解开发",normalizedTitle:"8.2、使用注解开发",charIndex:20880},{level:3,title:"8.3、CRUD",slug:"_8-3、crud",normalizedTitle:"8.3、crud",charIndex:21213},{level:2,title:"9、Lombok",slug:"_9、lombok",normalizedTitle:"9、lombok",charIndex:22149},{level:2,title:"10、多对一处理",slug:"_10、多对一处理",normalizedTitle:"10、多对一处理",charIndex:23368},{level:3,title:"测试环境搭建",slug:"测试环境搭建",normalizedTitle:"测试环境搭建",charIndex:24601},{level:3,title:"按照查询嵌套处理",slug:"按照查询嵌套处理",normalizedTitle:"按照查询嵌套处理",charIndex:24745},{level:3,title:"按照结果嵌套处理",slug:"按照结果嵌套处理",normalizedTitle:"按照结果嵌套处理",charIndex:25380},{level:2,title:"11、一对多处理",slug:"_11、一对多处理",normalizedTitle:"11、一对多处理",charIndex:25915},{level:3,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:24603},{level:3,title:"按照查询嵌套处理",slug:"按照查询嵌套处理-2",normalizedTitle:"按照查询嵌套处理",charIndex:24745},{level:3,title:"按照结果嵌套处理",slug:"按照结果嵌套处理-2",normalizedTitle:"按照结果嵌套处理",charIndex:25380},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:27467},{level:2,title:"12、动态 SQL",slug:"_12、动态-sql",normalizedTitle:"12、动态 sql",charIndex:27779},{level:3,title:"搭建环境",slug:"搭建环境",normalizedTitle:"搭建环境",charIndex:1321},{level:3,title:"IF",slug:"if",normalizedTitle:"if",charIndex:29647},{level:3,title:"choose (when, otherwise)",slug:"choose-when-otherwise",normalizedTitle:"choose (when, otherwise)",charIndex:28012},{level:3,title:"trim (where,set)",slug:"trim-where-set",normalizedTitle:"trim (where,set)",charIndex:31336},{level:3,title:"SQL片段",slug:"sql片段",normalizedTitle:"sql片段",charIndex:32404},{level:3,title:"Foreach",slug:"foreach",normalizedTitle:"foreach",charIndex:33068},{level:2,title:"13、缓存",slug:"_13、缓存",normalizedTitle:"13、缓存",charIndex:34508},{level:3,title:"13.1、简介",slug:"_13-1、简介",normalizedTitle:"13.1、简介",charIndex:34534},{level:3,title:"13.2、Mybatis缓存",slug:"_13-2、mybatis缓存",normalizedTitle:"13.2、mybatis缓存",charIndex:34890},{level:3,title:"13.3、一级缓存",slug:"_13-3、一级缓存",normalizedTitle:"13.3、一级缓存",charIndex:35154},{level:3,title:"13.4、二级缓存",slug:"_13-4、二级缓存",normalizedTitle:"13.4、二级缓存",charIndex:35498},{level:3,title:"13.5、缓存原理",slug:"_13-5、缓存原理",normalizedTitle:"13.5、缓存原理",charIndex:36432},{level:3,title:"13.6、自定义缓存-ehcache",slug:"_13-6、自定义缓存-ehcache",normalizedTitle:"13.6、自定义缓存-ehcache",charIndex:36448}],headersStr:"1、简介 1.1、什么是Mybatis 1.2、持久化 1.3、持久层 1.4 为什么需要Mybatis？ 2、第一个Mybatis程序 2.1、搭建环境 2.2、创建一个模块 2.3、编写代码 2.4、测试 3、CRUD 1、namespace 2、select 3、Insert 4、update 5、Delete 6、分析错误 7、万能Map 8、思考题 4、配置解析 1、核心配置文件 2、环境配置（environments） 3、属性（properties） 4、类型别名（typeAliases） 5、设置 6、其他配置 7、映射器（mappers） 8、生命周期和作用域 5、属性名和字段名配置 1、 问题 2、resultMap 6、日志 6.1、日志工厂 6.2、Log4j 7、分页 7.1、使用Limit分页 7.2、RowBounds分页 7.3、分页插件 8、使用注解开发 8.1、面向接口编程 8.2、使用注解开发 8.3、CRUD 9、Lombok 10、多对一处理 测试环境搭建 按照查询嵌套处理 按照结果嵌套处理 11、一对多处理 环境搭建 按照查询嵌套处理 按照结果嵌套处理 小结 12、动态 SQL 搭建环境 IF choose (when, otherwise) trim (where,set) SQL片段 Foreach 13、缓存 13.1、简介 13.2、Mybatis缓存 13.3、一级缓存 13.4、二级缓存 13.5、缓存原理 13.6、自定义缓存-ehcache",content:'# Mybatis\n\n狂神mybatis视频教程：https://www.bilibili.com/video/BV1NE411Q7Nx\n\n\n# 1、简介\n\n\n# 1.1、什么是Mybatis\n\n\n\n * MyBatis 是一款优秀的持久层框架\n * 它支持定制化 SQL、存储过程以及高级映射。\n * MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n * MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n * MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。\n * 2013年11月迁移到Github。\n\n如何获得Mybatis？\n\n * maven仓库：\n   \n   \x3c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\x3e\n   <dependency>\n       <groupId>org.mybatis</groupId>\n       <artifactId>mybatis</artifactId>\n       <version>3.5.2</version>\n   </dependency>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * Github ： https://github.com/mybatis/mybatis-3/releases\n\n * 中文文档：https://mybatis.org/mybatis-3/zh/index.html\n\n\n# 1.2、持久化\n\n数据持久化\n\n * 持久化就是将程序的数据在持久状态和瞬时状态转化的过程\n * 内存：断电即失\n * 数据库(Jdbc)，io文件持久化。\n * 生活：冷藏. 罐头。\n\n为什么需要需要持久化？\n\n * 有一些对象，不能让他丢掉。\n\n * 内存太贵了\n\n\n# 1.3、持久层\n\nDao层，Service层，Controller层….\n\n * 完成持久化工作的代码块\n * 层界限十分明显。\n\n\n# 1.4 为什么需要Mybatis？\n\n * 帮助程序猿将数据存入到数据库中。\n * 方便\n * 传统的JDBC代码太复杂了。简化。框架。自动化。\n * 不用Mybatis也可以。更容易上手。 技术没有高低之分\n * 优点：\n   * 简单易学\n   * 灵活\n   * sql和代码的分离，提高了可维护性。\n   * 提供映射标签，支持对象与数据库的orm字段关系映射\n   * 提供对象关系映射标签，支持对象关系组建维护\n   * 提供xml标签，支持编写动态sql。\n\n最重要的一点：使用的人多！\n\n\n# 2、第一个Mybatis程序\n\n创建模块mybatis-01 代码文件如下：\n\n\n\n思路：搭建环境--\x3e导入Mybatis--\x3e编写代码--\x3e测试！\n\n\n# 2.1、搭建环境\n\n搭建数据库\n\nCREATE DATABASE `mybatis`;\n\nUSE `mybatis`;\n\nCREATE TABLE `user`(\n  `id` INT(20) NOT NULL PRIMARY KEY,\n  `name` VARCHAR(30) DEFAULT NULL,\n  `pwd` VARCHAR(30) DEFAULT NULL\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `user`(`id`,`name`,`pwd`) VALUES \n(1,\'狂神\',\'123456\'),\n(2,\'张三\',\'123456\'),\n(3,\'李四\',\'123890\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n新建项目\n\n 1. 新建一个普通的maven项目\n\n 2. 删除src目录\n\n 3. 导入maven依赖及静态文件导出配置\n    \n    \x3c!--导入依赖--\x3e\n    <dependencies>\n        \x3c!--mysql驱动--\x3e\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n        </dependency>\n        \x3c!--mybatis--\x3e\n        \x3c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\x3e\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.2</version>\n        </dependency>\n        \x3c!--junit--\x3e\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n    \n    \x3c!--在build中配置resources，来防止我们资源导出失败的问题--\x3e\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    \n\n注：若mysql驱动版本为8.x版本，需要配置mysql时区，还需更改驱动为com.mysql.cj.jdbc.Driver\n\n\n# 2.2、创建一个模块\n\n * 编写mybatis的核心配置文件\n   \n   在resources下添加mybatis-config.xml\n   \n   <?xml version="1.0" encoding="UTF-8" ?>\n   <!DOCTYPE configuration\n           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n           "http://mybatis.org/dtd/mybatis-3-config.dtd">\n   \n   <configuration>\n   \n       <environments default="development">\n           <environment id="development">\n               <transactionManager type="JDBC"/>\n               <dataSource type="POOLED">\n                   <property name="driver" value="com.mysql.jdbc.Driver"/>\n                   <property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8"/>\n                   <property name="username" value="root"/>\n                   <property name="password" value="123456"/>\n               </dataSource>\n           </environment>\n       </environments>\n   \n   </configuration>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   \n   如果要添加中文注释，把第一行的encoding="UTF-8"改成encoding="utf8"\n\n * 编写mybatis工具类\n   \n   public class MybatisUtils {\n       private static SqlSessionFactory sqlSessionFactory;\n   \n       static {\n           try {\n               //使用Mybatis第一步：获取sqlSessionFactory对象\n               String resource = "mybatis-config.xml";\n               InputStream inputStream = Resources.getResourceAsStream(resource);\n               sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n           } catch (IOException e) {\n               e.printStackTrace();\n           }\n   \n       }\n   \n       /**\n        * 既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。\n        * SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。\n        * @return SqlSession\n        */\n       public static SqlSession getSqlSession() {\n           return sqlSessionFactory.openSession();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 2.3、编写代码\n\n * 实体类\n   \n   //实体类\n   public class User {\n       private int id;\n       private String name;\n       private String pwd;\n   \n       public User() {\n       }\n   \n       public User(int id, String name, String pwd) {\n           this.id = id;\n           this.name = name;\n           this.pwd = pwd;\n       }\n   \n       public int getId() {\n           return id;\n       }\n   \n       public void setId(int id) {\n           this.id = id;\n       }\n   \n       public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public String getPwd() {\n           return pwd;\n       }\n   \n       public void setPwd(String pwd) {\n           this.pwd = pwd;\n       }\n   \n       @Override\n       public String toString() {\n           return "User{" +\n                   "id=" + id +\n                   ", name=\'" + name + \'\\\'\' +\n                   ", pwd=\'" + pwd + \'\\\'\' +\n                   \'}\';\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   \n\n * Dao接口\n   \n   public interface UserDao {\n        /**\n        * 执行sql，获取list合集\n        * @return\n        */\n       List<User> getUserList();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件\n   \n   UserMapper.xml\n   \n   <?xml version="1.0" encoding="utf8" ?>\n   <!DOCTYPE mapper\n           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n   \x3c!--namespace=绑定一个对应的Dao/Mapper接口--\x3e\n   <mapper namespace="com.oddfar.dao.UserMapper">\n   \n       \x3c!--select查询语句--\x3e\n       <select id="getUserList" resultType="com.oddfar.pojo.User">\n           select * from mybatis.user\n       </select>\n   \n   </mapper>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 2.4、测试\n\n核心配置文件中注册 mappers\n\n * junit测试\n   \n   @Test\n   public void test(){\n       //第一步：获得SqlSession对象\n       SqlSession sqlSession = MybatisUtils.getSqlSession();\n   \n   \n       //方式一：getMapper\n       UserDao userDao = sqlSession.getMapper(UserDao.class);\n       List<User> userList = userDao.getUserList();\n   \n       for (User user : userList) {\n           System.out.println(user);\n       }\n   \n   \n   \n       //关闭SqlSession\n       sqlSession.close();\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n你们可以能会遇到的问题：\n\n 1. 配置文件没有注册\n 2. 绑定接口错误。\n 3. 方法名不对\n 4. 返回类型不对\n 5. Maven导出资源问题\n\n\n# 3、CRUD\n\n\n# 1、namespace\n\nnamespace中的包名要和 Dao/mapper 接口的包名一致！\n\n\n# 2、select\n\n选择，查询语句;\n\n * id : 就是对应的namespace中的方法名；\n\n * resultType：Sql语句执行的返回值！\n\n * parameterType ： 参数类型！\n\n 1. 编写接口\n    \n    //根据ID查询用户\n    User getUserById(int id);\n    \n    \n    1\n    2\n    \n\n 2. 编写对应的mapper中的sql语句\n    \n    <select id="getUserById" parameterType="int" resultType="com.oddfar.pojo.User">\n            select * from mybatis.user where id = #{id}\n    </select>\n    \n    \n    1\n    2\n    3\n    \n\n 3. 测试\n    \n    @Test\n    public void getUserById() {\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n    \n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    \n        User user = mapper.getUserById(1);\n        System.out.println(user);\n    \n        sqlSession.close();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# 3、Insert\n\n\x3c!--对象中的属性，可以直接取出来--\x3e\n<insert id="addUser" parameterType="com.oddfar.pojo.User">\n    insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd});\n</insert>\n\n\n1\n2\n3\n4\n\n\n@Test\npublic void addUser() {\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int res = mapper.addUser(new User(4, "zhiyuan", "212313"));\n    if (res > 0) {\n        //提交事务\n        sqlSession.commit();\n        System.out.println("添加成功");\n    }\n    sqlSession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 4、update\n\n<update id="updateUser" parameterType="com.oddfar.pojo.User">\n    update mybatis.user set name=#{name},pwd=#{pwd}  where id = #{id} ;\n</update>\n\n\n1\n2\n3\n\n\n\n# 5、Delete\n\n<delete id="deleteUser" parameterType="int">\n    delete from mybatis.user where id = #{id};\n</delete>\n\n\n1\n2\n3\n\n\n注意点：\n\n * 增删改需要提交事务！\n   \n   sqlSession.commit();\n\n\n# 6、分析错误\n\n * 标签不要匹配错\n * resource 绑定mapper，需要使用路径！\n * 程序配置文件必须符合规范！\n * NullPointerException，没有注册到资源!\n * 输出的xml文件中存在中文乱码问题！\n * maven资源没有导出问题！\n\n\n# 7、万能Map\n\n假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！\n\n//万能的Map\nint addUser2(Map<String,Object> map);\n\n\n1\n2\n\n\n\x3c!--    用map集合的方式插入--\x3e\n<insert id="addUser2" parameterType="map">\n    insert into mybatis.user (id,name,pwd) values (#{userid},#{username},#{passWord});\n</insert>\n\n\n1\n2\n3\n4\n\n\n/**\n * 用map的形式插入数据\n */\n@Test\npublic void addUser2() {\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    Map<String,Object> map = new HashMap<String, Object>();\n    map.put("userid",5);\n    map.put("passWord","2222333");\n    map.put("username","map");\n\n    int res = mapper.addUser2(map);\n    if (res > 0) {\n        //提交事务\n        sqlSession.commit();\n        System.out.println("添加成功");\n    }\n    sqlSession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nMap传递参数，直接在sql中取出key即可！ 【parameterType="map"】\n\n对象传递参数，直接在sql中取对象的属性即可！【parameterType="Object"】\n\n只有一个基本类型参数的情况下，可以直接在sql中取到！\n\n多个参数用Map，或者注解！\n\n\n# 8、思考题\n\n模糊查询怎么写？\n\n有两种方式\n\n * Java代码执行的时候，传递通配符 % %\n\nList<User> userList = mapper.getUserLike("%李%");\n\n\n1\n\n\n这是我们指定查询"%李%"，如果放个参数获取，这种方式则不能避免sql注入问题\n\n * 在sql拼接中使用通配符！\n\nselect * from mybatis.user where name like "%"#{value}"%"\n\n\n1\n\n\n推荐使用这种方法\n\n\n# 4、配置解析\n\n创建模块mybatis-02\n\n\n# 1、核心配置文件\n\n * mybatis-config.xml\n\n * MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n   \n   configuration（配置）\n   properties（属性）\n   settings（设置）\n   typeAliases（类型别名）\n   typeHandlers（类型处理器）\n   objectFactory（对象工厂）\n   plugins（插件）\n   environments（环境配置）\n   environment（环境变量）\n   transactionManager（事务管理器）\n   dataSource（数据源）\n   databaseIdProvider（数据库厂商标识）\n   mappers（映射器）\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 2、环境配置（environments）\n\nMyBatis 可以配置成适应多种环境\n\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。\n\n如果要想再连接其它数据库，则需要重新再写个MybatisUtils工具类\n\n学会使用配置多套运行环境！\n\nMybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED\n\n\n# 3、属性（properties）\n\n我们可以通过properties属性来实现引用配置文件\n\n这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n\n\n\n编写一个配置文件db.properties\n\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&useUnicode=true&characterEncoding=UTF-8\nusername=root\npassword=123456\n\n\n1\n2\n3\n4\n\n\n在核心配置文件中映入\n\n\x3c!--引入外部配置文件--\x3e\n<properties resource="db.properties">\n    <property name="username" value="root"/>\n    <property name="pwd" value="11111"/>\n</properties>\n\n\n1\n2\n3\n4\n5\n\n * 可以直接引入外部文件\n * 可以在其中增加一些属性配置\n * 如果两个文件有同一个字段，优先使用外部配置文件的！\n\n\n# 4、类型别名（typeAliases）\n\n * 类型别名是为 Java 类型设置一个短的名字。‘\n * 存在的意义仅在于用来减少类完全限定名的冗余。\n\n\x3c!--可以给实体类起别名--\x3e\n<typeAliases>\n    <typeAlias type="com.oddfar.pojo.User" alias="User"/>\n</typeAliases>\n\n\n1\n2\n3\n4\n\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：\n\n扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！\n\n\x3c!--可以给实体类起别名--\x3e\n<typeAliases>\n    <package name="com.oddfar.pojo"/>\n</typeAliases>\n\n\n1\n2\n3\n4\n\n\n在实体类比较少的时候，使用第一种方式。\n\n如果实体类十分多，建议使用第二种。\n\n第一种可以自定义别名，第二种则不行（别名为文件名），如果非要改，需要在实体上增加注解\n\n@Alias("user")\npublic class User {}\n\n\n1\n2\n\n\n\n# 5、设置\n\n这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n\n\n\n\n\n\n# 6、其他配置\n\n * typeHandlers（类型处理器）\n * objectFactory（对象工厂）\n * plugins插件\n   * mybatis-generator-core\n   * mybatis-plus\n   * 通用mapper\n\n\n# 7、映射器（mappers）\n\nMapperRegistry：注册绑定我们的Mapper文件；\n\n方式一： 【推荐使用】\n\n\x3c!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--\x3e\n<mappers>\n    <mapper resource="com/oddfar/dao/UserMapper.xml"/>\n</mappers>\n\n\n1\n2\n3\n4\n\n\n方式二：使用class文件绑定注册\n\n\x3c!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--\x3e\n<mappers>\n    <mapper class="com.oddfar.dao.UserMapper"/>\n</mappers>\n\n\n1\n2\n3\n4\n\n\n注意点：\n\n * 接口和他的Mapper配置文件必须同名！\n * 接口和他的Mapper配置文件必须在同一个包下！\n\n方式三：使用扫描包进行注入绑定\n\n\x3c!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--\x3e\n<mappers>\n    <package name="com.oddfar.dao"/>\n</mappers>\n\n\n1\n2\n3\n4\n\n\n注意点：\n\n * 接口和他的Mapper配置文件必须同名！\n * 接口和他的Mapper配置文件必须在同一个包下！\n\n练习时间：\n\n * 将数据库配置文件外部引入\n * 实体类别名\n * 保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！\n\n\n# 8、生命周期和作用域\n\n\n\n生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\nSqlSessionFactoryBuilder：\n\n * 一旦创建了 SqlSessionFactory，就不再需要它了\n * 局部变量\n\nSqlSessionFactory：\n\n * 说白了就是可以想象为 ：数据库连接池\n * SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。\n * 因此 SqlSessionFactory 的最佳作用域是应用作用域。\n * 最简单的就是使用单例模式或者静态单例模式。\n\nSqlSession\n\n * 连接到连接池的一个请求！\n * SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n * 用完之后需要赶紧关闭，否则资源被占用！\n\n\n\n这里面的每一个Mapper，就代表一个具体的业务！\n\n\n# 5、属性名和字段名配置\n\n在UserMapper.xml文件中\n\n如果我们的sql语句中属性名和字段名不一样，则会查不到数据\n\n新建mybatis-03模块\n\n\n# 1、 问题\n\n数据库中的字段\n\n\n\n新建一个项目，拷贝之前的，测试实体类字段不一致的情况\n\npublic class User {\n    private int id;\n    private String name;\n    private String password;\n}\n\n\n1\n2\n3\n4\n5\n\n\n编写sql，测试出现问题\n\n\n\n解决方法有两种，一种起别名，一种resultMap（结果集映射）\n\n * 起别名\n   \n   <select id="getUserById" resultType="com.kuang.pojo.User">\n       select id,name,pwd as password from mybatis.user where id = #{id}\n   </select>\n   \n   \n   1\n   2\n   3\n   \n\n\n# 2、resultMap\n\n结果集映射\n\nid   name   pwd\nid   name   password\n\n\n1\n2\n\n\n\x3c!--结果集映射--\x3e\n<resultMap id="UserMap" type="User">\n    \x3c!--column数据库中的字段，property实体类中的属性--\x3e\n    <result column="id" property="id"/>\n    <result column="name" property="name"/>\n    <result column="pwd" property="password"/>\n</resultMap>\n\n<select id="getUserById" resultMap="UserMap">\n    select * from mybatis.user where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * resultMap 元素是 MyBatis 中最重要最强大的元素\n * ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。\n * ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。\n * 如果世界总是这么简单就好了。\n\n\n# 6、日志\n\n新建模块mybatis-04\n\n\n# 6.1、日志工厂\n\n如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！\n\n曾经：sout 、debug\n\n现在：日志工厂！\n\n\n\n * SLF4J\n\n * LOG4J 【掌握】\n\n * LOG4J2\n\n * JDK_LOGGING\n\n * COMMONS_LOGGING\n\n * STDOUT_LOGGING 【掌握】\n\n * NO_LOGGING\n\n在Mybatis中具体使用那个一日志实现，在设置中设定！\n\nSTDOUT_LOGGING标准日志输出\n\n在mybatis核心配置文件中，配置我们的日志！\n\n<settings>\n    <setting name="logImpl" value="STDOUT_LOGGING"/>\n</settings>\n\n\n1\n2\n3\n\n\n\n\n\n# 6.2、Log4j\n\n什么是Log4j？\n\n * Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件\n * 我们也可以控制每一条日志的输出格式；\n * 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n * 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n 1. 先导入log4j的包\n    \n    \x3c!-- https://mvnrepository.com/artifact/log4j/log4j --\x3e\n    <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>1.2.17</version>\n    </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. log4j.properties\n    \n    #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\n    log4j.rootLogger=DEBUG,console,file\n    \n    #控制台输出的相关设置\n    log4j.appender.console = org.apache.log4j.ConsoleAppender\n    log4j.appender.console.Target = System.out\n    log4j.appender.console.Threshold=DEBUG\n    log4j.appender.console.layout = org.apache.log4j.PatternLayout\n    log4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n    \n    #文件输出的相关设置\n    log4j.appender.file = org.apache.log4j.RollingFileAppender\n    log4j.appender.file.File=./log/kuang.log\n    log4j.appender.file.MaxFileSize=10mb\n    log4j.appender.file.Threshold=DEBUG\n    log4j.appender.file.layout=org.apache.log4j.PatternLayout\n    log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n    \n    #日志输出级别\n    log4j.logger.org.mybatis=DEBUG\n    log4j.logger.java.sql=DEBUG\n    log4j.logger.java.sql.Statement=DEBUG\n    log4j.logger.java.sql.ResultSet=DEBUG\n    log4j.logger.java.sql.PreparedStatement=DEBUG\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n\n 3. 配置log4j为日志的实现\n    \n    <settings>\n        <setting name="logImpl" value="LOG4J"/>\n    </settings>\n    \n    \n    1\n    2\n    3\n    \n\n 4. Log4j的使用！，直接测试运行刚才的查询\n    \n    \n\n简单使用\n\n 1. 在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger;\n\n 2. 日志对象，参数为当前类的class\n    \n    static Logger logger = Logger.getLogger(UserDaoTest.class);\n    \n    \n    1\n    \n\n 3. 日志级别\n    \n    logger.info("info:进入了testLog4j");\n    logger.debug("debug:进入了testLog4j");\n    logger.error("error:进入了testLog4j");\n    \n    \n    1\n    2\n    3\n    \n\n\n# 7、分页\n\n思考：为什么要分页？\n\n * 减少数据的处理量\n\n\n# 7.1、使用Limit分页\n\n语法：SELECT * from user limit startIndex,pageSize;\nSELECT * from user limit 3;  #[0,n]\n\n\n1\n2\n\n\n使用Mybatis实现分页，核心SQL\n\n 1. 接口\n    \n    //分页\n    List<User> getUserByLimit(Map<String,Integer> map);\n    \n    \n    1\n    2\n    \n\n 2. Mapper.xml\n    \n    \x3c!--//分页--\x3e\n    <select id="getUserByLimit" parameterType="map" resultMap="UserMap">\n        select * from  mybatis.user limit #{startIndex},#{pageSize}\n    </select>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 测试\n    \n    @Test\n    public void getUserByLimit(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    \n    HashMap<String, Integer> map = new HashMap<String, Integer>();\n        map.put("startIndex",1);\n        map.put("pageSize",2);\n    \n        List<User> userList =  mapper.getUserByLimit(map);\n        for (User user : userList) {\n        System.out.println(user);\n        }\n    \n        sqlSession.close();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n\n# 7.2、RowBounds分页\n\n不再使用SQL实现分页\n\n 1. 接口\n    \n    //分页2\n    List<User> getUserByRowBounds();\n    \n    \n    1\n    2\n    \n\n 2. mapper.xml\n    \n    \x3c!--分页2--\x3e\n    <select id="getUserByRowBounds" resultMap="UserMap">\n        select * from  mybatis.user\n    </select>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 测试\n    \n    @Test\n    public void getUserByRowBounds(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    \n    //RowBounds实现\n    RowBounds rowBounds = new RowBounds(1, 2);\n    \n    //通过Java代码层面实现分页\n    List<User> userList = sqlSession.selectList("com.kuang.dao.UserMapper.getUserByRowBounds",null,rowBounds);\n    \n        for (User user : userList) {\n        System.out.println(user);\n        }\n    \n        sqlSession.close();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 7.3、分页插件\n\n\n\n了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！\n\n\n# 8、使用注解开发\n\n对应模块mybaits-05\n\n\n# 8.1、面向接口编程\n\n大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程\n\n根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好\n\n在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；\n\n而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。\n\n关于接口的理解\n\n * 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。\n * 接口的本身反映了系统设计人员对系统的抽象理解。\n * 接口应有两类：\n   * 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；\n   * 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；\n * 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n\n三个面向区别\n\n * 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .\n * 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .\n * 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构\n\n\n# 8.2、使用注解开发\n\n 1. 注解在接口上实现\n    \n    @Select("select * from user")\n    List<User> getUsers();\n    \n    \n    1\n    2\n    \n\n 2. 需要再核心配置文件中绑定接口！\n    \n    \x3c!--绑定接口--\x3e\n    <mappers>\n        <mapper class="com.kuang.dao.UserMapper"/>\n    </mappers>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 测试\n\n本质：反射机制实现\n\n底层：动态代理！\n\n\n\nMybatis详细的执行流程！\n\n\n\n\n# 8.3、CRUD\n\n我们可以在工具类创建的时候实现自动提交事务！\n\npublic static SqlSession  getSqlSession(){\n    return sqlSessionFactory.openSession(true);\n}\n\n\n1\n2\n3\n\n\n编写接口，增加注解\n\npublic interface UserMapper {\n\n    @Select("select * from user")\n    List<User> getUsers();\n\n    // 方法存在多个参数，所有的参数前面必须加上 @Param("id")注解\n    @Select("select * from user where id = #{id}")\n    User getUserByID(@Param("id") int id);\n\n\n    @Insert("insert into user(id,name,pwd) values (#{id},#{name},#{password})")\n    int addUser(User user);\n\n    \n    @Update("update user set name=#{name},pwd=#{password} where id = #{id}")\n    int updateUser(User user);\n\n    \n    @Delete("delete from user where id = #{uid}")\n    int deleteUser(@Param("uid") int id);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n测试类\n\n【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】\n\n关于@Param() 注解\n\n * 基本类型的参数或者String类型，需要加上\n * 引用类型不需要加\n * 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！\n * 我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！\n\n#{} ${} 区别\n\n\n# 9、Lombok\n\n对应模块mybatis-06\n\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.\nNever write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n\n1\n2\n\n * java library\n * plugs\n * build tools\n * with one annotation your class\n\n使用步骤：\n\n 1. 在IDEA中安装Lombok插件！\n\n 2. 在项目中导入lombok的jar包\n    \n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n    </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 在实体类上加注解即可！\n    \n    @Data\n    @AllArgsConstructor\n    @NoArgsConstructor\n    \n    \n    1\n    2\n    3\n    \n\n@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger\n@Data\n@Builder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@SneakyThrows\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n说明：\n\n@Data：无参构造，get、set、tostring、hashcode，equals\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode\n@ToString\n@Getter\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 10、多对一处理\n\n对应模块mybatis-06\n\n多对一：\n\n\n\n * 多个学生，对应一个老师\n * 对于学生这边而言， 关联 .. 多个学生，关联一个老师 【多对一】\n * 对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】\n\n\n\npojo：\n\n@Data\npublic class Student {\n    private int id;\n    private String name;\n    private Teacher teacher;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n@Data\npublic class Teacher {\n    private int id;\n    private String name;\n}\n\n\n1\n2\n3\n4\n5\n\n\nSQL：\n\nCREATE TABLE `teacher` (\n  `id` INT(10) NOT NULL,\n  `name` VARCHAR(30) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, \'秦老师\'); \n\nCREATE TABLE `student` (\n  `id` INT(10) NOT NULL,\n  `name` VARCHAR(30) DEFAULT NULL,\n  `tid` INT(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `fktid` (`tid`),\n  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n\n\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (\'1\', \'小明\', \'1\'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (\'2\', \'小红\', \'1\'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (\'3\', \'小张\', \'1\'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (\'4\', \'小李\', \'1\'); \nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (\'5\', \'小王\', \'1\');\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 测试环境搭建\n\n 1. 导入lombok\n 2. 新建实体类 Teacher，Student\n 3. 建立Mapper接口\n 4. 建立Mapper.XML文件\n 5. 在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】\n 6. 测试查询是否能够成功！\n\n\n# 按照查询嵌套处理\n\n\x3c!--\n    思路:\n        1. 查询所有的学生信息\n        2. 根据查询出来的学生的tid，寻找对应的老师！  子查询\n    --\x3e\n\n<select id="getStudent" resultMap="StudentTeacher">\n    select * from student\n</select>\n\n<resultMap id="StudentTeacher" type="Student">\n    <result property="id" column="id"/>\n    <result property="name" column="name"/>\n    \x3c!--复杂的属性，我们需要单独处理 对象： association 集合： collection --\x3e\n    <association property="teacher" column="tid" javaType="Teacher" select="getTeacher"/>\n</resultMap>\n\n<select id="getTeacher" resultType="Teacher">\n    select * from teacher where id = #{id}\n</select>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 按照结果嵌套处理\n\n\x3c!--按照结果嵌套处理--\x3e\n<select id="getStudent2" resultMap="StudentTeacher2">\n    select s.id sid,s.name sname,t.name tname\n    from student s,teacher t\n    where s.tid = t.id;\n</select>\n\n<resultMap id="StudentTeacher2" type="Student">\n    <result property="id" column="sid"/>\n    <result property="name" column="sname"/>\n    <association property="teacher" javaType="Teacher">\n        <result property="name" column="tname"/>\n    </association>\n</resultMap>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n回顾Mysql 多对一查询方式：\n\n * 子查询\n * 联表查询\n\n\n# 11、一对多处理\n\n对应模块mybatis-07\n\n比如：一个老师拥有多个学生！\n\n对于老师而言，就是一对多的关系!\n\n\n# 环境搭建\n\n环境搭建，和刚才一样\n\n实体类\n\n@Data\npublic class Student {\n    private int id;\n    private String name;\n    private int tid;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n@Data\npublic class Teacher {\n    private int id;\n    private String name;\n    //一个老师拥有多个学生\n    private List<Student> students;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 按照查询嵌套处理\n\n<select id="getTeacher2" resultMap="TeacherStudent2">\n    select * from mybatis.teacher where id = #{tid}\n</select>\n\n<resultMap id="TeacherStudent2" type="Teacher">\n    <collection property="students" javaType="ArrayList" ofType="Student" select="getStudentByTeacherId" column="id"/>\n</resultMap>\n\n<select id="getStudentByTeacherId" resultType="Student">\n    select * from mybatis.student where tid = #{tid}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 按照结果嵌套处理\n\n\x3c!--按结果嵌套查询--\x3e\n<select id="getTeacher" resultMap="TeacherStudent">\n    select s.id sid, s.name sname, t.name tname,t.id tid\n    from student s,teacher t\n    where s.tid = t.id and t.id = #{tid}\n</select>\n\n<resultMap id="TeacherStudent" type="Teacher">\n    <result property="id" column="tid"/>\n    <result property="name" column="tname"/>\n    \x3c!--复杂的属性，我们需要单独处理 对象： association 集合： collection\n    javaType="" 指定属性的类型！\n    集合中的泛型信息，我们使用ofType获取\n    --\x3e\n    <collection property="students" ofType="Student">\n        <result property="id" column="sid"/>\n        <result property="name" column="sname"/>\n        <result property="tid" column="tid"/>\n    </collection>\n</resultMap>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 小结\n\n 1. 关联 - association 【多对一】\n 2. 集合 - collection 【一对多】\n 3. javaType & ofType\n    1. JavaType 用来指定实体类中属性的类型\n    2. ofType 用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！\n\n注意点：\n\n * 保证SQL的可读性，尽量保证通俗易懂\n * 注意一对多和多对一中，属性名和字段的问题！\n * 如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j\n\n慢SQL 1s 1000s\n\n面试高频\n\n * Mysql引擎\n * InnoDB底层原理\n * 索引\n * 索引优化！\n\n\n# 12、动态 SQL\n\n对应模块mybatis-08\n\n什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句\n\n利用动态 SQL 这一特性可以彻底摆脱这种痛苦。\n\n动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n\n1\n2\n3\n4\n\n\n\n# 搭建环境\n\nCREATE TABLE `blog` (\n  `id` varchar(50) NOT NULL COMMENT \'博客id\',\n  `title` varchar(100) NOT NULL COMMENT \'博客标题\',\n  `author` varchar(30) NOT NULL COMMENT \'博客作者\',\n  `create_time` datetime NOT NULL COMMENT \'创建时间\',\n  `views` int(30) NOT NULL COMMENT \'浏览量\'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建一个基础工程\n\n 1. 导包\n\n 2. 编写配置文件\n\n 3. 工具包\n    \n    //抑制警告\n    @SuppressWarnings("all")\n    public class IDutils {\n        public static String getId(){\n            return UUID.randomUUID().toString().replace("-","");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 编写实体类\n    \n    @Data\n    public class Blog {\n        private String id;\n        private String title;\n        private String author;\n        private Date createTime;\n        private int views;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n插入数据\n\n   @Test\n   public void addInitBlog(){\n       SqlSession sqlSession = MybatisUtils.getSqlSession();\n       BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n       Blog blog = new Blog(IDutils.getId(),"Mybatis如此简单","狂神说",new Date(),9999);\n       mapper.addBlog(blog);\n       blog = new Blog(IDutils.getId(),"Java如此简单","狂神说",new Date(),1000);\n       mapper.addBlog(blog);\n       blog = new Blog(IDutils.getId(),"Spring如此简单","狂神说",new Date(),9999);\n       mapper.addBlog(blog);\n       blog = new Blog(IDutils.getId(),"微服务如此简单","狂神说",new Date(),9999);\n       mapper.addBlog(blog);\n       sqlSession.close();\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 5. 编写实体类对应Mapper接口 和 Mapper.XML文件\n\n\n# IF\n\nxml\n\n<select id="queryBlogIF" parameterType="map" resultType="blog">\n    select * from mybatis.blog where 1=1\n    <if test="title != null">\n        and title = #{title}\n    </if>\n    <if test="author != null">\n        and author = #{author}\n    </if>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n代码：\n\n@Test\npublic void queryBlogIF() {\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n    HashMap map = new HashMap();\n//        map.put("title","Mybatis如此简单");\n    map.put("author","狂神说");\n    List<Blog> blogList = mapper.queryBlogIF(map);\n    for (Blog blog : blogList) {\n        System.out.println(blog);\n    }\n\n    sqlSession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# choose (when, otherwise)\n\n类似于java里的switch\n\n<select id="queryBlogChoose" parameterType="map" resultType="blog">\n    select * from mybatis.blog\n    <where>\n        <choose>\n            <when test="title != null">\n                title = #{title}\n            </when>\n            <when test="author != null">\n                and author = #{author}\n            </when>\n            <otherwise>\n                and views = #{views}\n            </otherwise>\n        </choose>\n    </where>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n代码\n\n@Test\npublic void queryBlogChoose(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n    HashMap map = new HashMap();\n    map.put("title","Mybatis如此简单2");\n//        map.put("author","狂神说");\n    map.put("id","5d3adbfea47b4493bc086cf8dbb8998a");\n     mapper.updateBlog(map);\n\n    sqlSession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# trim (where,set)\n\nselect * from mybatis.blog\n<where>\n    <if test="title != null">\n        title = #{title}\n    </if>\n    <if test="author != null">\n        and author = #{author}\n    </if>\n</where>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<update id="updateBlog" parameterType="map">\n    update mybatis.blog\n    <set>\n        <if test="title != null">\n            title = #{title},\n        </if>\n        <if test="author != null">\n            author = #{author}\n        </if>\n    </set>\n    where id = #{id}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n代码：\n\n@Test\npublic void updateBlog(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n    HashMap map = new HashMap();\n//        map.put("title","Mybatis如此简单");\n//        map.put("author","狂神说");\n    List<Blog> blogList = mapper.queryBlogChoose(map);\n    for (Blog blog : blogList) {\n        System.out.println(blog);\n    }\n    sqlSession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码\n\nif\n\nwhere ， set ， choose ，when\n\n\n# SQL片段\n\n有的时候，我们可能会将一些功能的部分抽取出来，方便复用！\n\n 1. 使用SQL标签抽取公共的部分\n    \n    <sql id="if-title-author">\n        <if test="title != null">\n            title = #{title}\n        </if>\n        <if test="author != null">\n            and author = #{author}\n        </if>\n    </sql>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 在需要使用的地方使用Include标签引用即可\n    \n    <select id="queryBlogIF" parameterType="map" resultType="blog">\n        select * from mybatis.blog\n        <where>\n            <include refid="if-title-author"></include>\n        </where>\n    </select>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n注意事项：\n\n * 最好基于单表来定义SQL片段！\n * 不要存在where标签\n\n\n# Foreach\n\nselect * from user where 1=1 and \n\n  <foreach item="id" collection="ids"\n      open="(" separator="or" close=")">\n        #{id}\n  </foreach>\n\n(id=1 or id=2 or id=3)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n\n\x3c!--\n        select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3)\n\n        我们现在传递一个万能的map ， 这map中可以存在一个集合！\n--\x3e\n<select id="queryBlogForeach" parameterType="map" resultType="blog">\n    select * from mybatis.blog\n\n    <where>\n        <foreach collection="ids" item="id" open="and (" close=")" separator="or">\n            id = #{id}\n        </foreach>\n    </where>\n\n</select>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n最后sql为： select * from mybatis.blog WHERE ( id = ? or id = ? or id = ? )\n\n代码：\n\n@Test\npublic void queryBlogForeach(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n    HashMap map = new HashMap();\n\n    ArrayList<String> ids = new ArrayList<String>();\n    ids.add("d97ca9c234df463e950f252d22fb5f85");\n    ids.add("4cfe16fcebb145f894b6ec9033f8ae33");\n    ids.add("5d3adbfea47b4493bc086cf8dbb8998a");\n\n    map.put("ids",ids);\n\n    List<Blog> blogList = mapper.queryBlogForeach(map);\n    for (Blog blog : blogList) {\n        System.out.println(blog);\n    }\n    sqlSession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了\n\n建议：\n\n * 现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！\n\n\n# 13、缓存\n\n对应模块mybatis-09\n\n\n# 13.1、简介\n\n我们每次查询数据的时候，是通过数据库查询。在数据需要大量查询时，我们就需要用到缓存，下载查询相同的时候，通过内存查询，不需要经过数据库，大大的节省的资源\n\n 1. 什么是缓存 [ Cache ]？\n    \n    * 存在内存中的临时数据。\n    * 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n\n 2. 为什么使用缓存？\n    \n    * 减少和数据库的交互次数，减少系统开销，提高系统效率。\n\n 3. 什么样的数据能使用缓存？\n    \n    * 经常查询并且不经常改变的数据。【可以使用缓存】\n\n我们再次查询相同数据的时候，直接走缓存，就不用走数据库了\n\n\n# 13.2、Mybatis缓存\n\n * MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n * MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n   \n   * 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）\n   \n   * 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\n   \n   * 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存\n\n\n# 13.3、一级缓存\n\n * 一级缓存也叫本地缓存： SqlSession\n   * 与数据库同一次会话期间查询到的数据会放在本地缓存中。\n   * 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；\n\n测试步骤：\n\n 1. 开启日志！\n 2. 测试在一个Sesion中查询两次相同记录\n 3. 查看日志输出\n\n\n\n缓存失效的情况：\n\n 1. 查询不同的东西\n\n 2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！\n    \n    \n\n 3. 查询不同的Mapper.xml\n\n 4. 手动清理缓存！\n    \n    \n\n小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！\n\n一级缓存就是一个Map。\n\n\n# 13.4、二级缓存\n\n * 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n * 基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n * 工作机制\n   * 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；\n   * 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；\n   * 新的会话查询信息，就可以从二级缓存中获取内容；\n   * 不同的mapper查出的数据会放在自己对应的缓存（map）中；\n\n步骤：\n\n 1. 开启全局缓存\n    \n    \x3c!--显示的开启全局缓存--\x3e\n    <setting name="cacheEnabled" value="true"/>\n    \n    \n    1\n    2\n    \n\n 2. 在要使用二级缓存的Mapper中开启\n    \n    \x3c!--在当前Mapper.xml中使用二级缓存--\x3e\n    <cache/>\n    \n    \n    1\n    2\n    \n    \n    也可以自定义参数\n    \n    \x3c!--在当前Mapper.xml中使用二级缓存--\x3e\n    <cache  eviction="FIFO"\n           flushInterval="60000"\n           size="512"\n           readOnly="true"/>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 测试\n    \n    1. 问题:我们需要将实体类序列化！否则就会报错！\n       \n       Caused by: java.io.NotSerializableException: com.kuang.pojo.User\n       \n       \n       1\n       \n\n小结：\n\n * 只要开启了二级缓存，在同一个Mapper下就有效\n * 所有的数据都会先放在一级缓存中；\n * 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！\n\n\n# 13.5、缓存原理\n\n\n\n\n# 13.6、自定义缓存-ehcache\n\nEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存\n\n\n1\n\n\n要在程序中使用ehcache，先要导包！\n\n\x3c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\x3e\n<dependency>\n    <groupId>org.mybatis.caches</groupId>\n    <artifactId>mybatis-ehcache</artifactId>\n    <version>1.1.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n在mapper中指定使用我们的ehcache缓存实现！\n\n\x3c!--在当前Mapper.xml中使用二级缓存--\x3e\n<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>\n\n\n1\n2\n\n\nehcache.xml\n\n<?xml version="1.0" encoding="UTF-8"?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"\n         updateCheck="false">\n    \x3c!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     --\x3e\n    <diskStore path="./tmpdir/Tmp_EhCache"/>\n    \n    <defaultCache\n            eternal="false"\n            maxElementsInMemory="10000"\n            overflowToDisk="false"\n            diskPersistent="false"\n            timeToIdleSeconds="1800"\n            timeToLiveSeconds="259200"\n            memoryStoreEvictionPolicy="LRU"/>\n \n    <cache\n            name="cloud_user"\n            eternal="false"\n            maxElementsInMemory="5000"\n            overflowToDisk="false"\n            diskPersistent="false"\n            timeToIdleSeconds="1800"\n            timeToLiveSeconds="1800"\n            memoryStoreEvictionPolicy="LRU"/>\n    \x3c!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     --\x3e\n    \x3c!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统当机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   --\x3e\n\n</ehcache>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n',normalizedContent:'# mybatis\n\n狂神mybatis视频教程：https://www.bilibili.com/video/bv1ne411q7nx\n\n\n# 1、简介\n\n\n# 1.1、什么是mybatis\n\n\n\n * mybatis 是一款优秀的持久层框架\n * 它支持定制化 sql、存储过程以及高级映射。\n * mybatis 避免了几乎所有的 jdbc 代码和手动设置参数以及获取结果集。\n * mybatis 可以使用简单的 xml 或注解来配置和映射原生类型、接口和 java 的 pojo（plain old java objects，普通老式 java 对象）为数据库中的记录。\n * mybatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为mybatis 。\n * 2013年11月迁移到github。\n\n如何获得mybatis？\n\n * maven仓库：\n   \n   \x3c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\x3e\n   <dependency>\n       <groupid>org.mybatis</groupid>\n       <artifactid>mybatis</artifactid>\n       <version>3.5.2</version>\n   </dependency>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * github ： https://github.com/mybatis/mybatis-3/releases\n\n * 中文文档：https://mybatis.org/mybatis-3/zh/index.html\n\n\n# 1.2、持久化\n\n数据持久化\n\n * 持久化就是将程序的数据在持久状态和瞬时状态转化的过程\n * 内存：断电即失\n * 数据库(jdbc)，io文件持久化。\n * 生活：冷藏. 罐头。\n\n为什么需要需要持久化？\n\n * 有一些对象，不能让他丢掉。\n\n * 内存太贵了\n\n\n# 1.3、持久层\n\ndao层，service层，controller层….\n\n * 完成持久化工作的代码块\n * 层界限十分明显。\n\n\n# 1.4 为什么需要mybatis？\n\n * 帮助程序猿将数据存入到数据库中。\n * 方便\n * 传统的jdbc代码太复杂了。简化。框架。自动化。\n * 不用mybatis也可以。更容易上手。 技术没有高低之分\n * 优点：\n   * 简单易学\n   * 灵活\n   * sql和代码的分离，提高了可维护性。\n   * 提供映射标签，支持对象与数据库的orm字段关系映射\n   * 提供对象关系映射标签，支持对象关系组建维护\n   * 提供xml标签，支持编写动态sql。\n\n最重要的一点：使用的人多！\n\n\n# 2、第一个mybatis程序\n\n创建模块mybatis-01 代码文件如下：\n\n\n\n思路：搭建环境--\x3e导入mybatis--\x3e编写代码--\x3e测试！\n\n\n# 2.1、搭建环境\n\n搭建数据库\n\ncreate database `mybatis`;\n\nuse `mybatis`;\n\ncreate table `user`(\n  `id` int(20) not null primary key,\n  `name` varchar(30) default null,\n  `pwd` varchar(30) default null\n)engine=innodb default charset=utf8;\n\ninsert into `user`(`id`,`name`,`pwd`) values \n(1,\'狂神\',\'123456\'),\n(2,\'张三\',\'123456\'),\n(3,\'李四\',\'123890\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n新建项目\n\n 1. 新建一个普通的maven项目\n\n 2. 删除src目录\n\n 3. 导入maven依赖及静态文件导出配置\n    \n    \x3c!--导入依赖--\x3e\n    <dependencies>\n        \x3c!--mysql驱动--\x3e\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n            <version>5.1.47</version>\n        </dependency>\n        \x3c!--mybatis--\x3e\n        \x3c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\x3e\n        <dependency>\n            <groupid>org.mybatis</groupid>\n            <artifactid>mybatis</artifactid>\n            <version>3.5.2</version>\n        </dependency>\n        \x3c!--junit--\x3e\n        <dependency>\n            <groupid>junit</groupid>\n            <artifactid>junit</artifactid>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n    \n    \x3c!--在build中配置resources，来防止我们资源导出失败的问题--\x3e\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    \n\n注：若mysql驱动版本为8.x版本，需要配置mysql时区，还需更改驱动为com.mysql.cj.jdbc.driver\n\n\n# 2.2、创建一个模块\n\n * 编写mybatis的核心配置文件\n   \n   在resources下添加mybatis-config.xml\n   \n   <?xml version="1.0" encoding="utf-8" ?>\n   <!doctype configuration\n           public "-//mybatis.org//dtd config 3.0//en"\n           "http://mybatis.org/dtd/mybatis-3-config.dtd">\n   \n   <configuration>\n   \n       <environments default="development">\n           <environment id="development">\n               <transactionmanager type="jdbc"/>\n               <datasource type="pooled">\n                   <property name="driver" value="com.mysql.jdbc.driver"/>\n                   <property name="url" value="jdbc:mysql://localhost:3306/mybatis?usessl=true&amp;useunicode=true&amp;characterencoding=utf-8"/>\n                   <property name="username" value="root"/>\n                   <property name="password" value="123456"/>\n               </datasource>\n           </environment>\n       </environments>\n   \n   </configuration>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   \n   如果要添加中文注释，把第一行的encoding="utf-8"改成encoding="utf8"\n\n * 编写mybatis工具类\n   \n   public class mybatisutils {\n       private static sqlsessionfactory sqlsessionfactory;\n   \n       static {\n           try {\n               //使用mybatis第一步：获取sqlsessionfactory对象\n               string resource = "mybatis-config.xml";\n               inputstream inputstream = resources.getresourceasstream(resource);\n               sqlsessionfactory = new sqlsessionfactorybuilder().build(inputstream);\n           } catch (ioexception e) {\n               e.printstacktrace();\n           }\n   \n       }\n   \n       /**\n        * 既然有了 sqlsessionfactory，顾名思义，我们就可以从中获得 sqlsession 的实例了。\n        * sqlsession 完全包含了面向数据库执行 sql 命令所需的所有方法。\n        * @return sqlsession\n        */\n       public static sqlsession getsqlsession() {\n           return sqlsessionfactory.opensession();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n\n\n# 2.3、编写代码\n\n * 实体类\n   \n   //实体类\n   public class user {\n       private int id;\n       private string name;\n       private string pwd;\n   \n       public user() {\n       }\n   \n       public user(int id, string name, string pwd) {\n           this.id = id;\n           this.name = name;\n           this.pwd = pwd;\n       }\n   \n       public int getid() {\n           return id;\n       }\n   \n       public void setid(int id) {\n           this.id = id;\n       }\n   \n       public string getname() {\n           return name;\n       }\n   \n       public void setname(string name) {\n           this.name = name;\n       }\n   \n       public string getpwd() {\n           return pwd;\n       }\n   \n       public void setpwd(string pwd) {\n           this.pwd = pwd;\n       }\n   \n       @override\n       public string tostring() {\n           return "user{" +\n                   "id=" + id +\n                   ", name=\'" + name + \'\\\'\' +\n                   ", pwd=\'" + pwd + \'\\\'\' +\n                   \'}\';\n       }\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   \n\n * dao接口\n   \n   public interface userdao {\n        /**\n        * 执行sql，获取list合集\n        * @return\n        */\n       list<user> getuserlist();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 接口实现类由原来的userdaoimpl转变为一个 mapper配置文件\n   \n   usermapper.xml\n   \n   <?xml version="1.0" encoding="utf8" ?>\n   <!doctype mapper\n           public "-//mybatis.org//dtd mapper 3.0//en"\n           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n   \x3c!--namespace=绑定一个对应的dao/mapper接口--\x3e\n   <mapper namespace="com.oddfar.dao.usermapper">\n   \n       \x3c!--select查询语句--\x3e\n       <select id="getuserlist" resulttype="com.oddfar.pojo.user">\n           select * from mybatis.user\n       </select>\n   \n   </mapper>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 2.4、测试\n\n核心配置文件中注册 mappers\n\n * junit测试\n   \n   @test\n   public void test(){\n       //第一步：获得sqlsession对象\n       sqlsession sqlsession = mybatisutils.getsqlsession();\n   \n   \n       //方式一：getmapper\n       userdao userdao = sqlsession.getmapper(userdao.class);\n       list<user> userlist = userdao.getuserlist();\n   \n       for (user user : userlist) {\n           system.out.println(user);\n       }\n   \n   \n   \n       //关闭sqlsession\n       sqlsession.close();\n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n你们可以能会遇到的问题：\n\n 1. 配置文件没有注册\n 2. 绑定接口错误。\n 3. 方法名不对\n 4. 返回类型不对\n 5. maven导出资源问题\n\n\n# 3、crud\n\n\n# 1、namespace\n\nnamespace中的包名要和 dao/mapper 接口的包名一致！\n\n\n# 2、select\n\n选择，查询语句;\n\n * id : 就是对应的namespace中的方法名；\n\n * resulttype：sql语句执行的返回值！\n\n * parametertype ： 参数类型！\n\n 1. 编写接口\n    \n    //根据id查询用户\n    user getuserbyid(int id);\n    \n    \n    1\n    2\n    \n\n 2. 编写对应的mapper中的sql语句\n    \n    <select id="getuserbyid" parametertype="int" resulttype="com.oddfar.pojo.user">\n            select * from mybatis.user where id = #{id}\n    </select>\n    \n    \n    1\n    2\n    3\n    \n\n 3. 测试\n    \n    @test\n    public void getuserbyid() {\n        sqlsession sqlsession = mybatisutils.getsqlsession();\n    \n        usermapper mapper = sqlsession.getmapper(usermapper.class);\n    \n        user user = mapper.getuserbyid(1);\n        system.out.println(user);\n    \n        sqlsession.close();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# 3、insert\n\n\x3c!--对象中的属性，可以直接取出来--\x3e\n<insert id="adduser" parametertype="com.oddfar.pojo.user">\n    insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd});\n</insert>\n\n\n1\n2\n3\n4\n\n\n@test\npublic void adduser() {\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n\n    usermapper mapper = sqlsession.getmapper(usermapper.class);\n    int res = mapper.adduser(new user(4, "zhiyuan", "212313"));\n    if (res > 0) {\n        //提交事务\n        sqlsession.commit();\n        system.out.println("添加成功");\n    }\n    sqlsession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 4、update\n\n<update id="updateuser" parametertype="com.oddfar.pojo.user">\n    update mybatis.user set name=#{name},pwd=#{pwd}  where id = #{id} ;\n</update>\n\n\n1\n2\n3\n\n\n\n# 5、delete\n\n<delete id="deleteuser" parametertype="int">\n    delete from mybatis.user where id = #{id};\n</delete>\n\n\n1\n2\n3\n\n\n注意点：\n\n * 增删改需要提交事务！\n   \n   sqlsession.commit();\n\n\n# 6、分析错误\n\n * 标签不要匹配错\n * resource 绑定mapper，需要使用路径！\n * 程序配置文件必须符合规范！\n * nullpointerexception，没有注册到资源!\n * 输出的xml文件中存在中文乱码问题！\n * maven资源没有导出问题！\n\n\n# 7、万能map\n\n假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用map！\n\n//万能的map\nint adduser2(map<string,object> map);\n\n\n1\n2\n\n\n\x3c!--    用map集合的方式插入--\x3e\n<insert id="adduser2" parametertype="map">\n    insert into mybatis.user (id,name,pwd) values (#{userid},#{username},#{password});\n</insert>\n\n\n1\n2\n3\n4\n\n\n/**\n * 用map的形式插入数据\n */\n@test\npublic void adduser2() {\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n\n    usermapper mapper = sqlsession.getmapper(usermapper.class);\n    map<string,object> map = new hashmap<string, object>();\n    map.put("userid",5);\n    map.put("password","2222333");\n    map.put("username","map");\n\n    int res = mapper.adduser2(map);\n    if (res > 0) {\n        //提交事务\n        sqlsession.commit();\n        system.out.println("添加成功");\n    }\n    sqlsession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nmap传递参数，直接在sql中取出key即可！ 【parametertype="map"】\n\n对象传递参数，直接在sql中取对象的属性即可！【parametertype="object"】\n\n只有一个基本类型参数的情况下，可以直接在sql中取到！\n\n多个参数用map，或者注解！\n\n\n# 8、思考题\n\n模糊查询怎么写？\n\n有两种方式\n\n * java代码执行的时候，传递通配符 % %\n\nlist<user> userlist = mapper.getuserlike("%李%");\n\n\n1\n\n\n这是我们指定查询"%李%"，如果放个参数获取，这种方式则不能避免sql注入问题\n\n * 在sql拼接中使用通配符！\n\nselect * from mybatis.user where name like "%"#{value}"%"\n\n\n1\n\n\n推荐使用这种方法\n\n\n# 4、配置解析\n\n创建模块mybatis-02\n\n\n# 1、核心配置文件\n\n * mybatis-config.xml\n\n * mybatis 的配置文件包含了会深深影响 mybatis 行为的设置和属性信息。\n   \n   configuration（配置）\n   properties（属性）\n   settings（设置）\n   typealiases（类型别名）\n   typehandlers（类型处理器）\n   objectfactory（对象工厂）\n   plugins（插件）\n   environments（环境配置）\n   environment（环境变量）\n   transactionmanager（事务管理器）\n   datasource（数据源）\n   databaseidprovider（数据库厂商标识）\n   mappers（映射器）\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 2、环境配置（environments）\n\nmybatis 可以配置成适应多种环境\n\n不过要记住：尽管可以配置多个环境，但每个 sqlsessionfactory 实例只能选择一种环境。\n\n如果要想再连接其它数据库，则需要重新再写个mybatisutils工具类\n\n学会使用配置多套运行环境！\n\nmybatis默认的事务管理器就是 jdbc ， 连接池 ： pooled\n\n\n# 3、属性（properties）\n\n我们可以通过properties属性来实现引用配置文件\n\n这些属性都是可外部配置且可动态替换的，既可以在典型的 java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n\n\n\n编写一个配置文件db.properties\n\ndriver=com.mysql.jdbc.driver\nurl=jdbc:mysql://localhost:3306/mybatis?usessl=true&useunicode=true&characterencoding=utf-8\nusername=root\npassword=123456\n\n\n1\n2\n3\n4\n\n\n在核心配置文件中映入\n\n\x3c!--引入外部配置文件--\x3e\n<properties resource="db.properties">\n    <property name="username" value="root"/>\n    <property name="pwd" value="11111"/>\n</properties>\n\n\n1\n2\n3\n4\n5\n\n * 可以直接引入外部文件\n * 可以在其中增加一些属性配置\n * 如果两个文件有同一个字段，优先使用外部配置文件的！\n\n\n# 4、类型别名（typealiases）\n\n * 类型别名是为 java 类型设置一个短的名字。‘\n * 存在的意义仅在于用来减少类完全限定名的冗余。\n\n\x3c!--可以给实体类起别名--\x3e\n<typealiases>\n    <typealias type="com.oddfar.pojo.user" alias="user"/>\n</typealiases>\n\n\n1\n2\n3\n4\n\n\n也可以指定一个包名，mybatis 会在包名下面搜索需要的 java bean，比如：\n\n扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！\n\n\x3c!--可以给实体类起别名--\x3e\n<typealiases>\n    <package name="com.oddfar.pojo"/>\n</typealiases>\n\n\n1\n2\n3\n4\n\n\n在实体类比较少的时候，使用第一种方式。\n\n如果实体类十分多，建议使用第二种。\n\n第一种可以自定义别名，第二种则不行（别名为文件名），如果非要改，需要在实体上增加注解\n\n@alias("user")\npublic class user {}\n\n\n1\n2\n\n\n\n# 5、设置\n\n这是 mybatis 中极为重要的调整设置，它们会改变 mybatis 的运行时行为。\n\n\n\n\n\n\n# 6、其他配置\n\n * typehandlers（类型处理器）\n * objectfactory（对象工厂）\n * plugins插件\n   * mybatis-generator-core\n   * mybatis-plus\n   * 通用mapper\n\n\n# 7、映射器（mappers）\n\nmapperregistry：注册绑定我们的mapper文件；\n\n方式一： 【推荐使用】\n\n\x3c!--每一个mapper.xml都需要在mybatis核心配置文件中注册！--\x3e\n<mappers>\n    <mapper resource="com/oddfar/dao/usermapper.xml"/>\n</mappers>\n\n\n1\n2\n3\n4\n\n\n方式二：使用class文件绑定注册\n\n\x3c!--每一个mapper.xml都需要在mybatis核心配置文件中注册！--\x3e\n<mappers>\n    <mapper class="com.oddfar.dao.usermapper"/>\n</mappers>\n\n\n1\n2\n3\n4\n\n\n注意点：\n\n * 接口和他的mapper配置文件必须同名！\n * 接口和他的mapper配置文件必须在同一个包下！\n\n方式三：使用扫描包进行注入绑定\n\n\x3c!--每一个mapper.xml都需要在mybatis核心配置文件中注册！--\x3e\n<mappers>\n    <package name="com.oddfar.dao"/>\n</mappers>\n\n\n1\n2\n3\n4\n\n\n注意点：\n\n * 接口和他的mapper配置文件必须同名！\n * 接口和他的mapper配置文件必须在同一个包下！\n\n练习时间：\n\n * 将数据库配置文件外部引入\n * 实体类别名\n * 保证usermapper 接口 和 usermapper .xml 改为一致！并且放在同一个包下！\n\n\n# 8、生命周期和作用域\n\n\n\n生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\nsqlsessionfactorybuilder：\n\n * 一旦创建了 sqlsessionfactory，就不再需要它了\n * 局部变量\n\nsqlsessionfactory：\n\n * 说白了就是可以想象为 ：数据库连接池\n * sqlsessionfactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。\n * 因此 sqlsessionfactory 的最佳作用域是应用作用域。\n * 最简单的就是使用单例模式或者静态单例模式。\n\nsqlsession\n\n * 连接到连接池的一个请求！\n * sqlsession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n * 用完之后需要赶紧关闭，否则资源被占用！\n\n\n\n这里面的每一个mapper，就代表一个具体的业务！\n\n\n# 5、属性名和字段名配置\n\n在usermapper.xml文件中\n\n如果我们的sql语句中属性名和字段名不一样，则会查不到数据\n\n新建mybatis-03模块\n\n\n# 1、 问题\n\n数据库中的字段\n\n\n\n新建一个项目，拷贝之前的，测试实体类字段不一致的情况\n\npublic class user {\n    private int id;\n    private string name;\n    private string password;\n}\n\n\n1\n2\n3\n4\n5\n\n\n编写sql，测试出现问题\n\n\n\n解决方法有两种，一种起别名，一种resultmap（结果集映射）\n\n * 起别名\n   \n   <select id="getuserbyid" resulttype="com.kuang.pojo.user">\n       select id,name,pwd as password from mybatis.user where id = #{id}\n   </select>\n   \n   \n   1\n   2\n   3\n   \n\n\n# 2、resultmap\n\n结果集映射\n\nid   name   pwd\nid   name   password\n\n\n1\n2\n\n\n\x3c!--结果集映射--\x3e\n<resultmap id="usermap" type="user">\n    \x3c!--column数据库中的字段，property实体类中的属性--\x3e\n    <result column="id" property="id"/>\n    <result column="name" property="name"/>\n    <result column="pwd" property="password"/>\n</resultmap>\n\n<select id="getuserbyid" resultmap="usermap">\n    select * from mybatis.user where id = #{id}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * resultmap 元素是 mybatis 中最重要最强大的元素\n * resultmap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。\n * resultmap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。\n * 如果世界总是这么简单就好了。\n\n\n# 6、日志\n\n新建模块mybatis-04\n\n\n# 6.1、日志工厂\n\n如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！\n\n曾经：sout 、debug\n\n现在：日志工厂！\n\n\n\n * slf4j\n\n * log4j 【掌握】\n\n * log4j2\n\n * jdk_logging\n\n * commons_logging\n\n * stdout_logging 【掌握】\n\n * no_logging\n\n在mybatis中具体使用那个一日志实现，在设置中设定！\n\nstdout_logging标准日志输出\n\n在mybatis核心配置文件中，配置我们的日志！\n\n<settings>\n    <setting name="logimpl" value="stdout_logging"/>\n</settings>\n\n\n1\n2\n3\n\n\n\n\n\n# 6.2、log4j\n\n什么是log4j？\n\n * log4j是apache的一个开源项目，通过使用log4j，我们可以控制日志信息输送的目的地是控制台、文件、gui组件\n * 我们也可以控制每一条日志的输出格式；\n * 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n * 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n 1. 先导入log4j的包\n    \n    \x3c!-- https://mvnrepository.com/artifact/log4j/log4j --\x3e\n    <dependency>\n        <groupid>log4j</groupid>\n        <artifactid>log4j</artifactid>\n        <version>1.2.17</version>\n    </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. log4j.properties\n    \n    #将等级为debug的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\n    log4j.rootlogger=debug,console,file\n    \n    #控制台输出的相关设置\n    log4j.appender.console = org.apache.log4j.consoleappender\n    log4j.appender.console.target = system.out\n    log4j.appender.console.threshold=debug\n    log4j.appender.console.layout = org.apache.log4j.patternlayout\n    log4j.appender.console.layout.conversionpattern=[%c]-%m%n\n    \n    #文件输出的相关设置\n    log4j.appender.file = org.apache.log4j.rollingfileappender\n    log4j.appender.file.file=./log/kuang.log\n    log4j.appender.file.maxfilesize=10mb\n    log4j.appender.file.threshold=debug\n    log4j.appender.file.layout=org.apache.log4j.patternlayout\n    log4j.appender.file.layout.conversionpattern=[%p][%d{yy-mm-dd}][%c]%m%n\n    \n    #日志输出级别\n    log4j.logger.org.mybatis=debug\n    log4j.logger.java.sql=debug\n    log4j.logger.java.sql.statement=debug\n    log4j.logger.java.sql.resultset=debug\n    log4j.logger.java.sql.preparedstatement=debug\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n\n 3. 配置log4j为日志的实现\n    \n    <settings>\n        <setting name="logimpl" value="log4j"/>\n    </settings>\n    \n    \n    1\n    2\n    3\n    \n\n 4. log4j的使用！，直接测试运行刚才的查询\n    \n    \n\n简单使用\n\n 1. 在要使用log4j 的类中，导入包 import org.apache.log4j.logger;\n\n 2. 日志对象，参数为当前类的class\n    \n    static logger logger = logger.getlogger(userdaotest.class);\n    \n    \n    1\n    \n\n 3. 日志级别\n    \n    logger.info("info:进入了testlog4j");\n    logger.debug("debug:进入了testlog4j");\n    logger.error("error:进入了testlog4j");\n    \n    \n    1\n    2\n    3\n    \n\n\n# 7、分页\n\n思考：为什么要分页？\n\n * 减少数据的处理量\n\n\n# 7.1、使用limit分页\n\n语法：select * from user limit startindex,pagesize;\nselect * from user limit 3;  #[0,n]\n\n\n1\n2\n\n\n使用mybatis实现分页，核心sql\n\n 1. 接口\n    \n    //分页\n    list<user> getuserbylimit(map<string,integer> map);\n    \n    \n    1\n    2\n    \n\n 2. mapper.xml\n    \n    \x3c!--//分页--\x3e\n    <select id="getuserbylimit" parametertype="map" resultmap="usermap">\n        select * from  mybatis.user limit #{startindex},#{pagesize}\n    </select>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 测试\n    \n    @test\n    public void getuserbylimit(){\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n    usermapper mapper = sqlsession.getmapper(usermapper.class);\n    \n    hashmap<string, integer> map = new hashmap<string, integer>();\n        map.put("startindex",1);\n        map.put("pagesize",2);\n    \n        list<user> userlist =  mapper.getuserbylimit(map);\n        for (user user : userlist) {\n        system.out.println(user);\n        }\n    \n        sqlsession.close();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n\n# 7.2、rowbounds分页\n\n不再使用sql实现分页\n\n 1. 接口\n    \n    //分页2\n    list<user> getuserbyrowbounds();\n    \n    \n    1\n    2\n    \n\n 2. mapper.xml\n    \n    \x3c!--分页2--\x3e\n    <select id="getuserbyrowbounds" resultmap="usermap">\n        select * from  mybatis.user\n    </select>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 测试\n    \n    @test\n    public void getuserbyrowbounds(){\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n    \n    //rowbounds实现\n    rowbounds rowbounds = new rowbounds(1, 2);\n    \n    //通过java代码层面实现分页\n    list<user> userlist = sqlsession.selectlist("com.kuang.dao.usermapper.getuserbyrowbounds",null,rowbounds);\n    \n        for (user user : userlist) {\n        system.out.println(user);\n        }\n    \n        sqlsession.close();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 7.3、分页插件\n\n\n\n了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！\n\n\n# 8、使用注解开发\n\n对应模块mybaits-05\n\n\n# 8.1、面向接口编程\n\n大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程\n\n根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好\n\n在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；\n\n而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。\n\n关于接口的理解\n\n * 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。\n * 接口的本身反映了系统设计人员对系统的抽象理解。\n * 接口应有两类：\n   * 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；\n   * 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；\n * 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n\n三个面向区别\n\n * 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .\n * 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .\n * 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构\n\n\n# 8.2、使用注解开发\n\n 1. 注解在接口上实现\n    \n    @select("select * from user")\n    list<user> getusers();\n    \n    \n    1\n    2\n    \n\n 2. 需要再核心配置文件中绑定接口！\n    \n    \x3c!--绑定接口--\x3e\n    <mappers>\n        <mapper class="com.kuang.dao.usermapper"/>\n    </mappers>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 测试\n\n本质：反射机制实现\n\n底层：动态代理！\n\n\n\nmybatis详细的执行流程！\n\n\n\n\n# 8.3、crud\n\n我们可以在工具类创建的时候实现自动提交事务！\n\npublic static sqlsession  getsqlsession(){\n    return sqlsessionfactory.opensession(true);\n}\n\n\n1\n2\n3\n\n\n编写接口，增加注解\n\npublic interface usermapper {\n\n    @select("select * from user")\n    list<user> getusers();\n\n    // 方法存在多个参数，所有的参数前面必须加上 @param("id")注解\n    @select("select * from user where id = #{id}")\n    user getuserbyid(@param("id") int id);\n\n\n    @insert("insert into user(id,name,pwd) values (#{id},#{name},#{password})")\n    int adduser(user user);\n\n    \n    @update("update user set name=#{name},pwd=#{password} where id = #{id}")\n    int updateuser(user user);\n\n    \n    @delete("delete from user where id = #{uid}")\n    int deleteuser(@param("uid") int id);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n测试类\n\n【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】\n\n关于@param() 注解\n\n * 基本类型的参数或者string类型，需要加上\n * 引用类型不需要加\n * 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！\n * 我们在sql中引用的就是我们这里的 @param() 中设定的属性名！\n\n#{} ${} 区别\n\n\n# 9、lombok\n\n对应模块mybatis-06\n\nproject lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.\nnever write another getter or equals method again, with one annotation your class has a fully featured builder, automate your logging variables, and much more.\n\n\n1\n2\n\n * java library\n * plugs\n * build tools\n * with one annotation your class\n\n使用步骤：\n\n 1. 在idea中安装lombok插件！\n\n 2. 在项目中导入lombok的jar包\n    \n    <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n        <version>1.18.10</version>\n    </dependency>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 在实体类上加注解即可！\n    \n    @data\n    @allargsconstructor\n    @noargsconstructor\n    \n    \n    1\n    2\n    3\n    \n\n@getter and @setter\n@fieldnameconstants\n@tostring\n@equalsandhashcode\n@allargsconstructor, @requiredargsconstructor and @noargsconstructor\n@log, @log4j, @log4j2, @slf4j, @xslf4j, @commonslog, @jbosslog, @flogger\n@data\n@builder\n@singular\n@delegate\n@value\n@accessors\n@wither\n@sneakythrows\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n说明：\n\n@data：无参构造，get、set、tostring、hashcode，equals\n@allargsconstructor\n@noargsconstructor\n@equalsandhashcode\n@tostring\n@getter\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 10、多对一处理\n\n对应模块mybatis-06\n\n多对一：\n\n\n\n * 多个学生，对应一个老师\n * 对于学生这边而言， 关联 .. 多个学生，关联一个老师 【多对一】\n * 对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】\n\n\n\npojo：\n\n@data\npublic class student {\n    private int id;\n    private string name;\n    private teacher teacher;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n@data\npublic class teacher {\n    private int id;\n    private string name;\n}\n\n\n1\n2\n3\n4\n5\n\n\nsql：\n\ncreate table `teacher` (\n  `id` int(10) not null,\n  `name` varchar(30) default null,\n  primary key (`id`)\n) engine=innodb default charset=utf8\n\ninsert into teacher(`id`, `name`) values (1, \'秦老师\'); \n\ncreate table `student` (\n  `id` int(10) not null,\n  `name` varchar(30) default null,\n  `tid` int(10) default null,\n  primary key (`id`),\n  key `fktid` (`tid`),\n  constraint `fktid` foreign key (`tid`) references `teacher` (`id`)\n) engine=innodb default charset=utf8\n\n\ninsert into `student` (`id`, `name`, `tid`) values (\'1\', \'小明\', \'1\'); \ninsert into `student` (`id`, `name`, `tid`) values (\'2\', \'小红\', \'1\'); \ninsert into `student` (`id`, `name`, `tid`) values (\'3\', \'小张\', \'1\'); \ninsert into `student` (`id`, `name`, `tid`) values (\'4\', \'小李\', \'1\'); \ninsert into `student` (`id`, `name`, `tid`) values (\'5\', \'小王\', \'1\');\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 测试环境搭建\n\n 1. 导入lombok\n 2. 新建实体类 teacher，student\n 3. 建立mapper接口\n 4. 建立mapper.xml文件\n 5. 在核心配置文件中绑定注册我们的mapper接口或者文件！【方式很多，随心选】\n 6. 测试查询是否能够成功！\n\n\n# 按照查询嵌套处理\n\n\x3c!--\n    思路:\n        1. 查询所有的学生信息\n        2. 根据查询出来的学生的tid，寻找对应的老师！  子查询\n    --\x3e\n\n<select id="getstudent" resultmap="studentteacher">\n    select * from student\n</select>\n\n<resultmap id="studentteacher" type="student">\n    <result property="id" column="id"/>\n    <result property="name" column="name"/>\n    \x3c!--复杂的属性，我们需要单独处理 对象： association 集合： collection --\x3e\n    <association property="teacher" column="tid" javatype="teacher" select="getteacher"/>\n</resultmap>\n\n<select id="getteacher" resulttype="teacher">\n    select * from teacher where id = #{id}\n</select>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 按照结果嵌套处理\n\n\x3c!--按照结果嵌套处理--\x3e\n<select id="getstudent2" resultmap="studentteacher2">\n    select s.id sid,s.name sname,t.name tname\n    from student s,teacher t\n    where s.tid = t.id;\n</select>\n\n<resultmap id="studentteacher2" type="student">\n    <result property="id" column="sid"/>\n    <result property="name" column="sname"/>\n    <association property="teacher" javatype="teacher">\n        <result property="name" column="tname"/>\n    </association>\n</resultmap>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n回顾mysql 多对一查询方式：\n\n * 子查询\n * 联表查询\n\n\n# 11、一对多处理\n\n对应模块mybatis-07\n\n比如：一个老师拥有多个学生！\n\n对于老师而言，就是一对多的关系!\n\n\n# 环境搭建\n\n环境搭建，和刚才一样\n\n实体类\n\n@data\npublic class student {\n    private int id;\n    private string name;\n    private int tid;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n@data\npublic class teacher {\n    private int id;\n    private string name;\n    //一个老师拥有多个学生\n    private list<student> students;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 按照查询嵌套处理\n\n<select id="getteacher2" resultmap="teacherstudent2">\n    select * from mybatis.teacher where id = #{tid}\n</select>\n\n<resultmap id="teacherstudent2" type="teacher">\n    <collection property="students" javatype="arraylist" oftype="student" select="getstudentbyteacherid" column="id"/>\n</resultmap>\n\n<select id="getstudentbyteacherid" resulttype="student">\n    select * from mybatis.student where tid = #{tid}\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 按照结果嵌套处理\n\n\x3c!--按结果嵌套查询--\x3e\n<select id="getteacher" resultmap="teacherstudent">\n    select s.id sid, s.name sname, t.name tname,t.id tid\n    from student s,teacher t\n    where s.tid = t.id and t.id = #{tid}\n</select>\n\n<resultmap id="teacherstudent" type="teacher">\n    <result property="id" column="tid"/>\n    <result property="name" column="tname"/>\n    \x3c!--复杂的属性，我们需要单独处理 对象： association 集合： collection\n    javatype="" 指定属性的类型！\n    集合中的泛型信息，我们使用oftype获取\n    --\x3e\n    <collection property="students" oftype="student">\n        <result property="id" column="sid"/>\n        <result property="name" column="sname"/>\n        <result property="tid" column="tid"/>\n    </collection>\n</resultmap>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 小结\n\n 1. 关联 - association 【多对一】\n 2. 集合 - collection 【一对多】\n 3. javatype & oftype\n    1. javatype 用来指定实体类中属性的类型\n    2. oftype 用来指定映射到list或者集合中的 pojo类型，泛型中的约束类型！\n\n注意点：\n\n * 保证sql的可读性，尽量保证通俗易懂\n * 注意一对多和多对一中，属性名和字段的问题！\n * 如果问题不好排查错误，可以使用日志 ， 建议使用 log4j\n\n慢sql 1s 1000s\n\n面试高频\n\n * mysql引擎\n * innodb底层原理\n * 索引\n * 索引优化！\n\n\n# 12、动态 sql\n\n对应模块mybatis-08\n\n什么是动态sql：动态sql就是指根据不同的条件生成不同的sql语句\n\n利用动态 sql 这一特性可以彻底摆脱这种痛苦。\n\n动态 sql 元素和 jstl 或基于类似 xml 的文本处理器相似。在 mybatis 之前的版本中，有很多元素需要花时间了解。mybatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。mybatis 采用功能强大的基于 ognl 的表达式来淘汰其它大部分元素。\n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n\n1\n2\n3\n4\n\n\n\n# 搭建环境\n\ncreate table `blog` (\n  `id` varchar(50) not null comment \'博客id\',\n  `title` varchar(100) not null comment \'博客标题\',\n  `author` varchar(30) not null comment \'博客作者\',\n  `create_time` datetime not null comment \'创建时间\',\n  `views` int(30) not null comment \'浏览量\'\n) engine=innodb default charset=utf8\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建一个基础工程\n\n 1. 导包\n\n 2. 编写配置文件\n\n 3. 工具包\n    \n    //抑制警告\n    @suppresswarnings("all")\n    public class idutils {\n        public static string getid(){\n            return uuid.randomuuid().tostring().replace("-","");\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 编写实体类\n    \n    @data\n    public class blog {\n        private string id;\n        private string title;\n        private string author;\n        private date createtime;\n        private int views;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n插入数据\n\n   @test\n   public void addinitblog(){\n       sqlsession sqlsession = mybatisutils.getsqlsession();\n       blogmapper mapper = sqlsession.getmapper(blogmapper.class);\n       blog blog = new blog(idutils.getid(),"mybatis如此简单","狂神说",new date(),9999);\n       mapper.addblog(blog);\n       blog = new blog(idutils.getid(),"java如此简单","狂神说",new date(),1000);\n       mapper.addblog(blog);\n       blog = new blog(idutils.getid(),"spring如此简单","狂神说",new date(),9999);\n       mapper.addblog(blog);\n       blog = new blog(idutils.getid(),"微服务如此简单","狂神说",new date(),9999);\n       mapper.addblog(blog);\n       sqlsession.close();\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 5. 编写实体类对应mapper接口 和 mapper.xml文件\n\n\n# if\n\nxml\n\n<select id="queryblogif" parametertype="map" resulttype="blog">\n    select * from mybatis.blog where 1=1\n    <if test="title != null">\n        and title = #{title}\n    </if>\n    <if test="author != null">\n        and author = #{author}\n    </if>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n代码：\n\n@test\npublic void queryblogif() {\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n    blogmapper mapper = sqlsession.getmapper(blogmapper.class);\n    hashmap map = new hashmap();\n//        map.put("title","mybatis如此简单");\n    map.put("author","狂神说");\n    list<blog> bloglist = mapper.queryblogif(map);\n    for (blog blog : bloglist) {\n        system.out.println(blog);\n    }\n\n    sqlsession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# choose (when, otherwise)\n\n类似于java里的switch\n\n<select id="queryblogchoose" parametertype="map" resulttype="blog">\n    select * from mybatis.blog\n    <where>\n        <choose>\n            <when test="title != null">\n                title = #{title}\n            </when>\n            <when test="author != null">\n                and author = #{author}\n            </when>\n            <otherwise>\n                and views = #{views}\n            </otherwise>\n        </choose>\n    </where>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n代码\n\n@test\npublic void queryblogchoose(){\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n    blogmapper mapper = sqlsession.getmapper(blogmapper.class);\n    hashmap map = new hashmap();\n    map.put("title","mybatis如此简单2");\n//        map.put("author","狂神说");\n    map.put("id","5d3adbfea47b4493bc086cf8dbb8998a");\n     mapper.updateblog(map);\n\n    sqlsession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# trim (where,set)\n\nselect * from mybatis.blog\n<where>\n    <if test="title != null">\n        title = #{title}\n    </if>\n    <if test="author != null">\n        and author = #{author}\n    </if>\n</where>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<update id="updateblog" parametertype="map">\n    update mybatis.blog\n    <set>\n        <if test="title != null">\n            title = #{title},\n        </if>\n        <if test="author != null">\n            author = #{author}\n        </if>\n    </set>\n    where id = #{id}\n</update>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n代码：\n\n@test\npublic void updateblog(){\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n    blogmapper mapper = sqlsession.getmapper(blogmapper.class);\n    hashmap map = new hashmap();\n//        map.put("title","mybatis如此简单");\n//        map.put("author","狂神说");\n    list<blog> bloglist = mapper.queryblogchoose(map);\n    for (blog blog : bloglist) {\n        system.out.println(blog);\n    }\n    sqlsession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n所谓的动态sql，本质还是sql语句 ， 只是我们可以在sql层面，去执行一个逻辑代码\n\nif\n\nwhere ， set ， choose ，when\n\n\n# sql片段\n\n有的时候，我们可能会将一些功能的部分抽取出来，方便复用！\n\n 1. 使用sql标签抽取公共的部分\n    \n    <sql id="if-title-author">\n        <if test="title != null">\n            title = #{title}\n        </if>\n        <if test="author != null">\n            and author = #{author}\n        </if>\n    </sql>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 在需要使用的地方使用include标签引用即可\n    \n    <select id="queryblogif" parametertype="map" resulttype="blog">\n        select * from mybatis.blog\n        <where>\n            <include refid="if-title-author"></include>\n        </where>\n    </select>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n注意事项：\n\n * 最好基于单表来定义sql片段！\n * 不要存在where标签\n\n\n# foreach\n\nselect * from user where 1=1 and \n\n  <foreach item="id" collection="ids"\n      open="(" separator="or" close=")">\n        #{id}\n  </foreach>\n\n(id=1 or id=2 or id=3)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n\n\x3c!--\n        select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3)\n\n        我们现在传递一个万能的map ， 这map中可以存在一个集合！\n--\x3e\n<select id="queryblogforeach" parametertype="map" resulttype="blog">\n    select * from mybatis.blog\n\n    <where>\n        <foreach collection="ids" item="id" open="and (" close=")" separator="or">\n            id = #{id}\n        </foreach>\n    </where>\n\n</select>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n最后sql为： select * from mybatis.blog where ( id = ? or id = ? or id = ? )\n\n代码：\n\n@test\npublic void queryblogforeach(){\n    sqlsession sqlsession = mybatisutils.getsqlsession();\n    blogmapper mapper = sqlsession.getmapper(blogmapper.class);\n    hashmap map = new hashmap();\n\n    arraylist<string> ids = new arraylist<string>();\n    ids.add("d97ca9c234df463e950f252d22fb5f85");\n    ids.add("4cfe16fcebb145f894b6ec9033f8ae33");\n    ids.add("5d3adbfea47b4493bc086cf8dbb8998a");\n\n    map.put("ids",ids);\n\n    list<blog> bloglist = mapper.queryblogforeach(map);\n    for (blog blog : bloglist) {\n        system.out.println(blog);\n    }\n    sqlsession.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n动态sql就是在拼接sql语句，我们只要保证sql的正确性，按照sql的格式，去排列组合就可以了\n\n建议：\n\n * 现在mysql中写出完整的sql,再对应的去修改成为我们的动态sql实现通用即可！\n\n\n# 13、缓存\n\n对应模块mybatis-09\n\n\n# 13.1、简介\n\n我们每次查询数据的时候，是通过数据库查询。在数据需要大量查询时，我们就需要用到缓存，下载查询相同的时候，通过内存查询，不需要经过数据库，大大的节省的资源\n\n 1. 什么是缓存 [ cache ]？\n    \n    * 存在内存中的临时数据。\n    * 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n\n 2. 为什么使用缓存？\n    \n    * 减少和数据库的交互次数，减少系统开销，提高系统效率。\n\n 3. 什么样的数据能使用缓存？\n    \n    * 经常查询并且不经常改变的数据。【可以使用缓存】\n\n我们再次查询相同数据的时候，直接走缓存，就不用走数据库了\n\n\n# 13.2、mybatis缓存\n\n * mybatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n * mybatis系统中默认定义了两级缓存：一级缓存和二级缓存\n   \n   * 默认情况下，只有一级缓存开启。（sqlsession级别的缓存，也称为本地缓存）\n   \n   * 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\n   \n   * 为了提高扩展性，mybatis定义了缓存接口cache。我们可以通过实现cache接口来自定义二级缓存\n\n\n# 13.3、一级缓存\n\n * 一级缓存也叫本地缓存： sqlsession\n   * 与数据库同一次会话期间查询到的数据会放在本地缓存中。\n   * 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；\n\n测试步骤：\n\n 1. 开启日志！\n 2. 测试在一个sesion中查询两次相同记录\n 3. 查看日志输出\n\n\n\n缓存失效的情况：\n\n 1. 查询不同的东西\n\n 2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！\n    \n    \n\n 3. 查询不同的mapper.xml\n\n 4. 手动清理缓存！\n    \n    \n\n小结：一级缓存默认是开启的，只在一次sqlsession中有效，也就是拿到连接到关闭连接这个区间段！\n\n一级缓存就是一个map。\n\n\n# 13.4、二级缓存\n\n * 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n * 基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n * 工作机制\n   * 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；\n   * 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；\n   * 新的会话查询信息，就可以从二级缓存中获取内容；\n   * 不同的mapper查出的数据会放在自己对应的缓存（map）中；\n\n步骤：\n\n 1. 开启全局缓存\n    \n    \x3c!--显示的开启全局缓存--\x3e\n    <setting name="cacheenabled" value="true"/>\n    \n    \n    1\n    2\n    \n\n 2. 在要使用二级缓存的mapper中开启\n    \n    \x3c!--在当前mapper.xml中使用二级缓存--\x3e\n    <cache/>\n    \n    \n    1\n    2\n    \n    \n    也可以自定义参数\n    \n    \x3c!--在当前mapper.xml中使用二级缓存--\x3e\n    <cache  eviction="fifo"\n           flushinterval="60000"\n           size="512"\n           readonly="true"/>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. 测试\n    \n    1. 问题:我们需要将实体类序列化！否则就会报错！\n       \n       caused by: java.io.notserializableexception: com.kuang.pojo.user\n       \n       \n       1\n       \n\n小结：\n\n * 只要开启了二级缓存，在同一个mapper下就有效\n * 所有的数据都会先放在一级缓存中；\n * 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！\n\n\n# 13.5、缓存原理\n\n\n\n\n# 13.6、自定义缓存-ehcache\n\nehcache是一种广泛使用的开源java分布式缓存。主要面向通用缓存\n\n\n1\n\n\n要在程序中使用ehcache，先要导包！\n\n\x3c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\x3e\n<dependency>\n    <groupid>org.mybatis.caches</groupid>\n    <artifactid>mybatis-ehcache</artifactid>\n    <version>1.1.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n在mapper中指定使用我们的ehcache缓存实现！\n\n\x3c!--在当前mapper.xml中使用二级缓存--\x3e\n<cache type="org.mybatis.caches.ehcache.ehcachecache"/>\n\n\n1\n2\n\n\nehcache.xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<ehcache xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:nonamespaceschemalocation="http://ehcache.org/ehcache.xsd"\n         updatecheck="false">\n    \x3c!--\n       diskstore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     --\x3e\n    <diskstore path="./tmpdir/tmp_ehcache"/>\n    \n    <defaultcache\n            eternal="false"\n            maxelementsinmemory="10000"\n            overflowtodisk="false"\n            diskpersistent="false"\n            timetoidleseconds="1800"\n            timetoliveseconds="259200"\n            memorystoreevictionpolicy="lru"/>\n \n    <cache\n            name="cloud_user"\n            eternal="false"\n            maxelementsinmemory="5000"\n            overflowtodisk="false"\n            diskpersistent="false"\n            timetoidleseconds="1800"\n            timetoliveseconds="1800"\n            memorystoreevictionpolicy="lru"/>\n    \x3c!--\n       defaultcache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     --\x3e\n    \x3c!--\n      name:缓存名称。\n      maxelementsinmemory:缓存最大数目\n      maxelementsondisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowtodisk:是否保存到磁盘，当系统当机时\n      timetoidleseconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timetoliveseconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskpersistent：是否缓存虚拟机重启期数据 whether the disk store persists between restarts of the virtual machine. the default value is false.\n      diskspoolbuffersizemb：这个参数设置diskstore（磁盘缓存）的缓存区大小。默认是30mb。每个cache都应该有自己的一个缓冲区。\n      diskexpirythreadintervalseconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memorystoreevictionpolicy：当达到maxelementsinmemory限制时，ehcache将会根据指定的策略去清理内存。默认策略是lru（最近最少使用）。你可以设置为fifo（先进先出）或是lfu（较少使用）。\n      clearonflush：内存数量最大时是否清除。\n      memorystoreevictionpolicy:可选策略有：lru（最近最少使用，默认策略）、fifo（先进先出）、lfu（最少访问次数）。\n      fifo，first in first out，这个是大家最熟的，先进先出。\n      lfu， less frequently used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      lru，least recently used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   --\x3e\n\n</ehcache>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"MongoDB - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.数据库/20.MongoDB",imgUrl:"/img/web.png",description:"MongoDB 目录页"}},title:"MongoDB - 知识体系",permalink:"/mongodb",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2021-09-12T23:27:14.000Z"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/20.MongoDB/00.Mongo%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5.html",relativePath:"03.数据库/20.MongoDB/00.Mongo - 目录页.md",key:"v-740e8b5b",path:"/mongodb/",headers:[{level:2,title:"学习资料",slug:"学习资料",normalizedTitle:"学习资料",charIndex:2},{level:3,title:"官网资料",slug:"官网资料",normalizedTitle:"官网资料",charIndex:11},{level:3,title:"入门系列",slug:"入门系列",normalizedTitle:"入门系列",charIndex:226}],headersStr:"学习资料 官网资料 入门系列",content:"# 学习资料\n\n\n# 官网资料\n\n> 最好的资料在官网。\n\n * MongoDB官网\n * MongoDB数据库文档\n * MongoDB 常用Shell\n * MongoDB CRUD\n * MongoDB 聚合\n * MongoDB 数据模型\n * MongoDB 事务\n * MongoDB 索引\n * MongoDB 安全\n * MongoDB 副本\n * MongoDB 分片\n * MongoDB 管理\n * MongoDB 存储\n\n\n# 入门系列\n\n * MongoDB菜鸟教程\n * MongoDB入门教程W3Cschool\n\n本站 MongoDB 笔记大部分参考以下网站\n\n * https://gitee.com/heguangchuan/rainmeter/tree/master/document/mongodb\n * 了解非关系型数据库 NoSQL - MongoDB | 安装使用以及 CRUD 操作\n * ♥MongoDB教程 - Mongo知识体系详解♥",normalizedContent:"# 学习资料\n\n\n# 官网资料\n\n> 最好的资料在官网。\n\n * mongodb官网\n * mongodb数据库文档\n * mongodb 常用shell\n * mongodb crud\n * mongodb 聚合\n * mongodb 数据模型\n * mongodb 事务\n * mongodb 索引\n * mongodb 安全\n * mongodb 副本\n * mongodb 分片\n * mongodb 管理\n * mongodb 存储\n\n\n# 入门系列\n\n * mongodb菜鸟教程\n * mongodb入门教程w3cschool\n\n本站 mongodb 笔记大部分参考以下网站\n\n * https://gitee.com/heguangchuan/rainmeter/tree/master/document/mongodb\n * 了解非关系型数据库 nosql - mongodb | 安装使用以及 crud 操作\n * ♥mongodb教程 - mongo知识体系详解♥",charsets:{cjk:!0},lastUpdated:"2021/09/12, 15:09:00",lastUpdatedTimestamp:1631461529e3},{title:"spring",frontmatter:{title:"spring",permalink:"/spring/",date:"2021-05-12T22:31:24.000Z"},regularPath:"/04.%E6%A1%86%E6%9E%B6/03.Spring/01.spring%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5.html",relativePath:"04.框架/03.Spring/01.spring - 目录页.md",key:"v-30cb5d4c",path:"/spring/",headersStr:null,content:"注意\n\nSpring，Spring Boot， Spring Cloud 等一些笔记，暂且没时间整理，后续可能会极大的丰富这个系列的笔记",normalizedContent:"注意\n\nspring，spring boot， spring cloud 等一些笔记，暂且没时间整理，后续可能会极大的丰富这个系列的笔记",charsets:{cjk:!0},lastUpdated:"2021/09/11, 2:09:00",lastUpdatedTimestamp:1631327124e3},{title:"mybatis-plus学习笔记",frontmatter:{title:"mybatis-plus学习笔记",permalink:"/mybatis-plus/study-note",date:"2021-05-09T13:35:32.000Z"},regularPath:"/04.%E6%A1%86%E6%9E%B6/02.mybatis-plus/01.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"04.框架/02.mybatis-plus/01.学习笔记.md",key:"v-6a747794",path:"/mybatis-plus/study-note/",headers:[{level:2,title:"概序",slug:"概序",normalizedTitle:"概序",charIndex:18},{level:2,title:"快速开始",slug:"快速开始",normalizedTitle:"快速开始",charIndex:24},{level:2,title:"配置日志",slug:"配置日志",normalizedTitle:"配置日志",charIndex:32},{level:2,title:"CRUD扩展",slug:"crud扩展",normalizedTitle:"crud扩展",charIndex:40},{level:3,title:"插入操作",slug:"插入操作",normalizedTitle:"插入操作",charIndex:52},{level:3,title:"主键生成策略",slug:"主键生成策略",normalizedTitle:"主键生成策略",charIndex:62},{level:3,title:"更新操作",slug:"更新操作",normalizedTitle:"更新操作",charIndex:74},{level:3,title:"自动填充",slug:"自动填充",normalizedTitle:"自动填充",charIndex:84},{level:3,title:"乐观锁",slug:"乐观锁",normalizedTitle:"乐观锁",charIndex:94},{level:3,title:"查询操作",slug:"查询操作",normalizedTitle:"查询操作",charIndex:103},{level:3,title:"分页查询",slug:"分页查询",normalizedTitle:"分页查询",charIndex:113},{level:3,title:"删除操作",slug:"删除操作",normalizedTitle:"删除操作",charIndex:123},{level:3,title:"逻辑删除",slug:"逻辑删除",normalizedTitle:"逻辑删除",charIndex:133},{level:3,title:"性能分析插件",slug:"性能分析插件",normalizedTitle:"性能分析插件",charIndex:143},{level:3,title:"条件构造器",slug:"条件构造器",normalizedTitle:"条件构造器",charIndex:155},{level:2,title:"代码自动生成器",slug:"代码自动生成器",normalizedTitle:"代码自动生成器",charIndex:164}],headersStr:"概序 快速开始 配置日志 CRUD扩展 插入操作 主键生成策略 更新操作 自动填充 乐观锁 查询操作 分页查询 删除操作 逻辑删除 性能分析插件 条件构造器 代码自动生成器",content:'# MyBatisPlus\n\n * 概序\n * 快速开始\n * 配置日志\n * CRUD扩展\n   * 插入操作\n   * 主键生成策略\n   * 更新操作\n   * 自动填充\n   * 乐观锁\n   * 查询操作\n   * 分页查询\n   * 删除操作\n   * 逻辑删除\n   * 性能分析插件\n   * 条件构造器\n * 代码自动生成器\n\n狂神mybatis-plus视频教程：https://www.bilibili.com/video/BV17E411N7KN\n\n\n# 概序\n\n原先写crud，需要在xml配置或注解中写sql语句，用了MyBatisPlus后，对单表进行crud无需再写sql语句\n\n简单的增删改查还行，不支持多表操作，一般不在公司里使用，适合个人快速开发和偷懒使用\n\n官网：https://baomidou.com/\n\n简介：简化mybatis，简化开发、提高写代码效率\n\n * 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n * 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作\n * 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求\n * 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\n * 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题\n * 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作\n * 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）\n * 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用\n * 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询\n * 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库\n * 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\n * 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n\n# 快速开始\n\n官网地址：https://mp.baomidou.com/guide/quick-start.html\n\n使用第三方组件：\n\n 1. 导入对应的依赖\n\n 2. 研究依赖如何配置\n\n 3. 代码如何编写\n\n 4. 提高扩展技术能力！\n\n步骤：\n\n1、创建数据库 mybatis_plus\n\n2、创建user表并插入数据\n\nDROP TABLE IF EXISTS user;\n\nCREATE TABLE user\n(\n\tid BIGINT(20) NOT NULL COMMENT \'主键ID\',\n\tname VARCHAR(30) NULL DEFAULT NULL COMMENT \'姓名\',\n\tage INT(11) NULL DEFAULT NULL COMMENT \'年龄\',\n\temail VARCHAR(50) NULL DEFAULT NULL COMMENT \'邮箱\',\n\tPRIMARY KEY (id)\n);\n\nDELETE FROM user;\n\nINSERT INTO user (id, name, age, email) VALUES\n(1, \'Jone\', 18, \'test1@baomidou.com\'),\n(2, \'Jack\', 20, \'test2@baomidou.com\'),\n(3, \'Tom\', 28, \'test3@baomidou.com\'),\n(4, \'Sandy\', 21, \'test4@baomidou.com\'),\n(5, \'Billie\', 24, \'test5@baomidou.com\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n3、编写项目，初始化项目！使用SpringBoot初始化！\n\n4、导入依赖\n\n\x3c!-- 数据库驱动 --\x3e\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n5、填写properties配置\n\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n\n1\n2\n3\n4\n\n\n6、填写测试类，读取数据库\n\n原先我们使用mybatis：pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller\n\n现在：\n\n * pojo类\n   \n   @Data\n   @NoArgsConstructor\n   @AllArgsConstructor\n   public class User {\n       private Long id;\n       private String name;\n       private Integer age;\n       private String email;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * mapper接口\n   \n   // 在对应的Mapper上面继承基本的类 BaseMapper\n   @Repository // 代表持久层\n   public interface UserMapper extends BaseMapper<User> {\n       // 所有的CRUD操作都已经编写完成了\n       // 你不需要像以前的配置一大堆文件了！\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * springboot启动类\n   \n   添加注解来扫描\n   \n   @MapperScan("com.oddfar.mapper")\n   \n   \n   1\n   \n\n * 测试类\n   \n   // 继承了BaseMapper，所有的方法都来自己父类\n   // 我们也可以编写自己的扩展方法！\n   @Autowired\n   private UserMapper userMapper;\n   \n   @Test\n   void contextLoads() {\n       // 参数是一个 Wrapper ，条件构造器，这里我们先不用，填写null\n       // 查询全部用户\n       List<User> users = userMapper.selectList(null);\n       users.forEach(System.out::println);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 配置日志\n\n我们所有的sql现在是不可见的，我们希望知道他是怎么执行的，所以我们必须要看日志！\n\n# 配置日志\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n\n\n1\n2\n\n\n\n# CRUD扩展\n\n创建controller包，编写UserController类\n\n\n# 插入操作\n\n@Test\nvoid addUser() {\n    User user = new User();\n    user.setName("zhiyuan");\n    user.setAge(3);\n    user.setEmail("123456@qq.com");\n\n    // 帮我们自动生成id\n    int result = userMapper.insert(user); \n    System.out.println(result); // 受影响的行数\n    System.out.println(user); // 发现，id会自动回填\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n数据库插入的id的默认值为：全局的唯一id\n\n\n# 主键生成策略\n\n> 默认 ID_WORKER 全局唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html\n\n雪花算法：\n\nsnowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！\n\n主键自增：\n\n实体类字段上 @TableId(type = IdType.AUTO)\n\n\n\n数据库id字段自增！\n\n\n\n关于注解的介绍：https://baomidou.com/guide/annotation.html#tableid\n\n\n# 更新操作\n\n    /**\n     * 更改一个用户\n     */\n    @Test\n    void testUpdate() {\n        User user = new User();\n        // 通过条件自动拼接动态sql\n        user.setId(5L);\n        user.setName("test");\n        user.setAge(5);\n        // 注意：updateById 但是参数是一个 对象！\n        int i = userMapper.updateById(user);\n        System.out.println(i);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n所有的sql都是自动帮你动态配置的！\n\n\n# 自动填充\n\n官网：https://baomidou.com/guide/auto-fill-metainfo.html\n\n创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！\n\n阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需 要自动化！\n\n方式一：数据库级别（工作中一般不允许你修改数据库）\n\n1、在表中新增字段 create_time, update_time\n\nALTER TABLE `mybatis_plus`.`user`\n  ADD COLUMN `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP NULL COMMENT \'创建时间\' AFTER `email`,\n  ADD COLUMN `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL COMMENT \'更新时间\' AFTER `create_time`;\n\n\n1\n2\n3\n\n\n\n\n默认：CURRENT_TIMESTAMP\n\n2、再次测试插入方法，我们需要先把实体类同步！\n\n方式二：代码级别\n\n1、删除数据库的默认值、更新操作！\n\n\n\n2、实体类字段属性上需要增加注解\n\n// 字段添加填充内容\n@TableField(fill = FieldFill.INSERT)\nprivate Date createTime;\n@TableField(fill = FieldFill.INSERT_UPDATE)\nprivate Date updateTime;\n\n\n1\n2\n3\n4\n5\n\n\n3、编写处理器来处理这个注解即可！\n\npackage com.oddfar.handler;\n\nimport com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n@Slf4j\n@Component // 一定不要忘记把处理器加到IOC容器中！\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    // 插入时的填充策略\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        log.info("start insert fill.....");\n        // setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject\n        this.setFieldValByName("createTime", new Date(), metaObject);\n        this.setFieldValByName("updateTime", new Date(), metaObject);\n    }\n\n    // 更新时的填充策略\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        log.info("start update fill.....");\n        this.setFieldValByName("updateTime", new Date(), metaObject);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n4、测试插入 ，测试更新、观察时间即可！\n\n\n# 乐观锁\n\n在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！\n\n> 乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试！\n> \n> 悲观锁：顾名思义十分悲观，他总是任务总是出现问题，无论干什么都会上锁！再去操作！\n\n当要更新一条记录的时候，希望这条记录没有被别人更新 乐观锁实现方式：\n\n乐观锁实现方式：\n\n * 取出记录，获取当前version\n * 更新时，带上这个version\n * 执行更新时，set version = new version where version = oldversion\n * 如果version不对，就更新失败\n\n测试一下mybatis-plus的乐观锁插件\n\n官方文档（必看）：https://baomidou.com/guide/interceptor.html\n\n有的方法会过期，具体操作以官方文档例子为主\n\n1、给数据库中增加version字段！\n\n\n\n2、我们实体类加对应的字段\n\n@Version //乐观锁Version注解\nprivate Integer version;\n\n\n1\n2\n\n\n3、注册组件\n\npackage com.oddfar.config;\n\nimport com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author zhiyuan\n * @date 2021/4/5 17:57\n */\n// 扫描我们的 mapper 文件夹\n@MapperScan("com.oddfar.mapper")\n@Configuration // 配置类\npublic class MyBatisPlusConfig {\n\n    // 注册乐观锁和分页插件(新版：3.4.0)\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor(){\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁插件\n        return interceptor;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n旧版如下：\n\n@Bean\npublic OptimisticLockerInterceptor OptimisticLockerInterceptor() {\n    return new OptimisticLockerInterceptor();\n}\n\n\n1\n2\n3\n4\n\n\n4、测试一下！\n\n/**\n * 测试乐观锁\n */\n@Test\npublic void testOptimisticLocker(){\n    // 1、查询用户信息\n    User user = userMapper.selectById(1L);\n\n    // 2、修改用户信息\n    user.setName("zhiyuan");\n    user.setEmail("123456@qq.com");\n    // 3、执行更新操作\n    userMapper.updateById(user);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们来模拟下\n\n// 测试乐观锁失败！多线程下\n@Test\npublic void testOptimisticLocker2(){\n    // 线程 1\n    User user = userMapper.selectById(1L);\n    user.setName("zhiyuan000000");\n    user.setEmail("000000000@qq.com");\n    // 模拟另外一个线程执行了插队操作\n    User user2 = userMapper.selectById(1L);\n    user2.setName("zhiyuan1111111");\n    user2.setEmail("111111111@qq.com");\n    userMapper.updateById(user2);\n    // 自旋锁来多次尝试提交！\n    userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n如果不加乐观锁，以上代码，name最后就是zhiyuan000000\n\n\n# 查询操作\n\n// 指定id查询\n@Test\npublic void testSelectById(){\n    User user = userMapper.selectById(1L);\n    System.out.println(user);\n}\n// 多个id批量查询！\n@Test\npublic void testSelectByBatchId(){\n    List<User> users = userMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L));\n    users.forEach(System.out::println);\n}\n// 多个where条件查询之一使用map操作\n@Test\npublic void testSelectByBatchIds(){\n    HashMap<String, Object> map = new HashMap<>();\n    // 自定义要查询\n    map.put("name","zhiyuan");\n    map.put("age",3);\n    List<User> users = userMapper.selectByMap(map);\n    users.forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 分页查询\n\n分页在网站使用的十分之多！\n\n1、原始的 limit 进行分页 2、pageHelper 第三方插件 3、MP其实也内置了分页插件！\n\nmybais-plus分页查询方法：\n\n1、配置拦截器组件即可\n\ninterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));//分页插件\n\n\n1\n\n\n旧版如下：\n\n//分页插件\n@Bean\npublic PaginationInterceptor paginationInterceptor() {\n    PaginationInterceptor paginationInterceptor = new PaginationInterceptor();\n    return paginationInterceptor;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、直接使用Page对象即可！\n\n/**\n * 测试分页查询\n */\n@Test\npublic void testPage() {\n    //参数一：当前页\n    //参数二：页面大小\n    Page<User> page = new Page<>(1, 5);\n    userMapper.selectPage(page, null);\n    page.getRecords().forEach(System.out::println);\n    System.out.println(page.getTotal());//总数量\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 删除操作\n\n// 通过id单个删除\n@Test\npublic void testDeleteById(){\n    userMapper.deleteById(1379026108137123842L);\n}\n// 通过id批量删除\n@Test\npublic void testDeleteBatchId(){\n   userMapper.deleteBatchIds(Arrays.asList(1379026108137123842L,1379026441420791810L));\n}\n// 通过map删除\n@Test\npublic void testDeleteMap(){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put("name","zhiyuan4");\n    userMapper.deleteByMap(map);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 逻辑删除\n\n官方文档：https://baomidou.com/guide/logic-delete.html\n\n物理删除 ：从数据库中直接移除\n\n逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ 比如一个系统，有管理员，操作员，用户等...... 设置数据库的时候，加个deleted字段，默认为0，代表数据存在 当用户或操作员要删除数据了，我们则把deleted赋值为1，表示数据已删除 这样管理员则可以在后台查询被删除的记录，防止数据的丢失，类似于回收站！\n\n方法如下：\n\n1、在数据表中增加一个 deleted 字段\n\n\n\n2、实体类中增加属性\n\n@TableLogic //逻辑删除\nprivate Integer deleted;\n\n\n1\n2\n\n\n3、配置\n\napplication.yml（properties也可以）\n\nmybatis-plus:\n  global-config:\n    db-config:\n      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)\n      logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n4、测试\n\n\n\n记录依旧在数据库，但是值确已经变化了！\n\n\n# 性能分析插件\n\n作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间。MP也提供性能分析插件，如果超过这个时间就停止运行，不过新版本已去掉这功能。\n\n推荐使用druid\n\n或者使用P6Spy：\n\n> SpringBoot - MyBatis-Plus使用详解18（结合P6Spy进行SQL性能分析）\n\n\n# 条件构造器\n\n官网文档：https://baomidou.com/guide/wrapper.html\n\nwrapper：十分重要： 我们写一些复杂的sql就可以使用它来替代！\n\n1、查询name不为空的用户，并且邮箱不为空的用户，年龄大于12\n\n@Test\nvoid contextLoads() {\n    //查询name不为空的用户，并且邮箱不为空的用户，年龄大于12\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper.isNotNull("name")\n            .isNotNull("email")\n            .ge("age", 12);\n    userMapper.selectList(wrapper).forEach(System.out::println); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、查询名字为zhiyuan2\n\n@Test\nvoid test2(){\n    //查询名字为zhiyuan2\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper.eq("name", "zhiyuan2");\n    User user = userMapper.selectOne(wrapper);\n    System.out.println(user);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n3、查询年龄在19到30岁之间的用户\n\n@Test\nvoid test3(){\n    //查询年龄在19到30岁之间的用户\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper.between("age", 19, 30); //区间\n    Integer count = userMapper.selectCount(wrapper);\n    System.out.println(count);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n4、查询name不包含t，邮箱以123开头\n\n * 例: notLike("name", "王")---\x3ename not like \'%王%\'\n * 例: likeRight("name", "王")---\x3ename like \'王%\'\n\n//模糊查询\n@Test\nvoid test4(){\n    //查询name不包含t，邮箱以123开头\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    wrapper.notLike("name", "t")\n            .likeRight("email", "123");\n    List<Map<String, Object>> maps = userMapper.selectMaps(wrapper);\n    maps.forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n5、子查询\n\n@Test\nvoid test5(){\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    //id 在子查询中查出来\n    wrapper.inSql("id", "select id from user where id < 3");\n    List<Object> objects = userMapper.selectObjs(wrapper);\n    objects.forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最后sql：\n\n> SELECT id,name,age,email,version,deleted,create_time,update_time FROM user WHERE deleted=0 AND (id IN (select id from user where id < 3))\n\n6、通过id进行排序--降序\n\n@Test\nvoid test6(){\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\n    //通过id进行排序--降序\n    wrapper.orderByDesc("id");\n    List<User> users = userMapper.selectList(wrapper);\n    users.forEach(System.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 代码自动生成器\n\ndao、pojo、service、controller都给我自己去编写完成！\n\nAutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。\n\n测试：\n\npublic class Code {\n    public static void main(String[] args) {\n        //需要构建一个 代码自动生成器 对象\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n        //配置策略\n\n        //1、全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty("user.dir");\n        gc.setOutputDir(projectPath + "/src/main/java");\n        gc.setAuthor("ChanV");\n        gc.setOpen(false);\n        gc.setFileOverride(false);  //是否覆盖\n        gc.setServiceName("%sService"); //去Service的I前缀\n        gc.setIdType(IdType.ID_WORKER);\n        gc.setDateType(DateType.ONLY_DATE);\n        gc.setSwagger2(true);\n        mpg.setGlobalConfig(gc);\n\n        //2、设置数据源\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl("jdbc:mysql://localhost:3306/mybatis-plus?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8");\n        dsc.setDriverName("com.mysql.cj.jdbc.Driver");\n        dsc.setUsername("root");\n        dsc.setPassword("root");\n        dsc.setDbType(DbType.MYSQL);\n        mpg.setDataSource(dsc);\n\n        //3、包的配置\n        PackageConfig pc = new PackageConfig();\n        pc.setModuleName("blog");\n        pc.setParent("com.chanv");\n        pc.setEntity("pojo");\n        pc.setMapper("mapper");\n        pc.setService("service");\n        pc.setController("controller");\n        mpg.setPackageInfo(pc);\n\n        //4、策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setInclude("user");    //设置要映射的表名\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n        strategy.setEntityLombokModel(true);    //自动lombok\n        strategy.setLogicDeleteFieldName("deleted");\n        //自动填充配置\n        TableFill createTime = new TableFill("create_time", FieldFill.INSERT);\n        TableFill updateTime = new TableFill("update_time", FieldFill.UPDATE);\n        ArrayList<TableFill> tableFills = new ArrayList<>();\n        tableFills.add(createTime);\n        tableFills.add(updateTime);\n        strategy.setTableFillList(tableFills);\n        //乐观锁\n        strategy.setVersionFieldName("version");\n        strategy.setRestControllerStyle(true);\n        strategy.setControllerMappingHyphenStyle(true);     //localhost:8080/hello_id_2\n        mpg.setStrategy(strategy);\n\n        mpg.execute();  //执行代码构造器\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n',normalizedContent:'# mybatisplus\n\n * 概序\n * 快速开始\n * 配置日志\n * crud扩展\n   * 插入操作\n   * 主键生成策略\n   * 更新操作\n   * 自动填充\n   * 乐观锁\n   * 查询操作\n   * 分页查询\n   * 删除操作\n   * 逻辑删除\n   * 性能分析插件\n   * 条件构造器\n * 代码自动生成器\n\n狂神mybatis-plus视频教程：https://www.bilibili.com/video/bv17e411n7kn\n\n\n# 概序\n\n原先写crud，需要在xml配置或注解中写sql语句，用了mybatisplus后，对单表进行crud无需再写sql语句\n\n简单的增删改查还行，不支持多表操作，一般不在公司里使用，适合个人快速开发和偷懒使用\n\n官网：https://baomidou.com/\n\n简介：简化mybatis，简化开发、提高写代码效率\n\n * 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n * 损耗小：启动即会自动注入基本 curd，性能基本无损耗，直接面向对象操作\n * 强大的 crud 操作：内置通用 mapper、通用 service，仅仅通过少量配置即可实现单表大部分 crud 操作，更有强大的条件构造器，满足各类使用需求\n * 支持 lambda 形式调用：通过 lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\n * 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 id 生成器 - sequence），可自由配置，完美解决主键问题\n * 支持 activerecord 模式：支持 activerecord 形式调用，实体类只需继承 model 类即可进行强大的 crud 操作\n * 支持自定义全局通用操作：支持全局通用方法注入（ write once, use anywhere ）\n * 内置代码生成器：采用代码或者 maven 插件可快速生成 mapper 、 model 、 service 、 controller 层代码，支持模板引擎，更有超多自定义配置等您来使用\n * 内置分页插件：基于 mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 list 查询\n * 分页插件支持多种数据库：支持 mysql、mariadb、oracle、db2、h2、hsql、sqlite、postgre、sqlserver 等多种数据库\n * 内置性能分析插件：可输出 sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\n * 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n\n# 快速开始\n\n官网地址：https://mp.baomidou.com/guide/quick-start.html\n\n使用第三方组件：\n\n 1. 导入对应的依赖\n\n 2. 研究依赖如何配置\n\n 3. 代码如何编写\n\n 4. 提高扩展技术能力！\n\n步骤：\n\n1、创建数据库 mybatis_plus\n\n2、创建user表并插入数据\n\ndrop table if exists user;\n\ncreate table user\n(\n\tid bigint(20) not null comment \'主键id\',\n\tname varchar(30) null default null comment \'姓名\',\n\tage int(11) null default null comment \'年龄\',\n\temail varchar(50) null default null comment \'邮箱\',\n\tprimary key (id)\n);\n\ndelete from user;\n\ninsert into user (id, name, age, email) values\n(1, \'jone\', 18, \'test1@baomidou.com\'),\n(2, \'jack\', 20, \'test2@baomidou.com\'),\n(3, \'tom\', 28, \'test3@baomidou.com\'),\n(4, \'sandy\', 21, \'test4@baomidou.com\'),\n(5, \'billie\', 24, \'test5@baomidou.com\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n3、编写项目，初始化项目！使用springboot初始化！\n\n4、导入依赖\n\n\x3c!-- 数据库驱动 --\x3e\n<dependency>\n    <groupid>mysql</groupid>\n    <artifactid>mysql-connector-java</artifactid>\n</dependency>\n<dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n</dependency>\n<dependency>\n    <groupid>com.baomidou</groupid>\n    <artifactid>mybatis-plus-boot-starter</artifactid>\n    <version>3.4.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n5、填写properties配置\n\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?usessl=false&useunicode=true&characterencoding=utf-8&servertimezone=gmt%2b8\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\n\n\n1\n2\n3\n4\n\n\n6、填写测试类，读取数据库\n\n原先我们使用mybatis：pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller\n\n现在：\n\n * pojo类\n   \n   @data\n   @noargsconstructor\n   @allargsconstructor\n   public class user {\n       private long id;\n       private string name;\n       private integer age;\n       private string email;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * mapper接口\n   \n   // 在对应的mapper上面继承基本的类 basemapper\n   @repository // 代表持久层\n   public interface usermapper extends basemapper<user> {\n       // 所有的crud操作都已经编写完成了\n       // 你不需要像以前的配置一大堆文件了！\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * springboot启动类\n   \n   添加注解来扫描\n   \n   @mapperscan("com.oddfar.mapper")\n   \n   \n   1\n   \n\n * 测试类\n   \n   // 继承了basemapper，所有的方法都来自己父类\n   // 我们也可以编写自己的扩展方法！\n   @autowired\n   private usermapper usermapper;\n   \n   @test\n   void contextloads() {\n       // 参数是一个 wrapper ，条件构造器，这里我们先不用，填写null\n       // 查询全部用户\n       list<user> users = usermapper.selectlist(null);\n       users.foreach(system.out::println);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 配置日志\n\n我们所有的sql现在是不可见的，我们希望知道他是怎么执行的，所以我们必须要看日志！\n\n# 配置日志\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.stdoutimpl\n\n\n1\n2\n\n\n\n# crud扩展\n\n创建controller包，编写usercontroller类\n\n\n# 插入操作\n\n@test\nvoid adduser() {\n    user user = new user();\n    user.setname("zhiyuan");\n    user.setage(3);\n    user.setemail("123456@qq.com");\n\n    // 帮我们自动生成id\n    int result = usermapper.insert(user); \n    system.out.println(result); // 受影响的行数\n    system.out.println(user); // 发现，id会自动回填\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n数据库插入的id的默认值为：全局的唯一id\n\n\n# 主键生成策略\n\n> 默认 id_worker 全局唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html\n\n雪花算法：\n\nsnowflake是twitter开源的分布式id生成算法，结果是一个long型的id。其核心思想是：使用41bit作为毫秒数，10bit作为机器的id（5个bit是数据中心，5个bit的机器id），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 id），最后还有一个符号位，永远是0。可以保证几乎全球唯一！\n\n主键自增：\n\n实体类字段上 @tableid(type = idtype.auto)\n\n\n\n数据库id字段自增！\n\n\n\n关于注解的介绍：https://baomidou.com/guide/annotation.html#tableid\n\n\n# 更新操作\n\n    /**\n     * 更改一个用户\n     */\n    @test\n    void testupdate() {\n        user user = new user();\n        // 通过条件自动拼接动态sql\n        user.setid(5l);\n        user.setname("test");\n        user.setage(5);\n        // 注意：updatebyid 但是参数是一个 对象！\n        int i = usermapper.updatebyid(user);\n        system.out.println(i);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n所有的sql都是自动帮你动态配置的！\n\n\n# 自动填充\n\n官网：https://baomidou.com/guide/auto-fill-metainfo.html\n\n创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！\n\n阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需 要自动化！\n\n方式一：数据库级别（工作中一般不允许你修改数据库）\n\n1、在表中新增字段 create_time, update_time\n\nalter table `mybatis_plus`.`user`\n  add column `create_time` datetime default current_timestamp null comment \'创建时间\' after `email`,\n  add column `update_time` datetime default current_timestamp on update current_timestamp null comment \'更新时间\' after `create_time`;\n\n\n1\n2\n3\n\n\n\n\n默认：current_timestamp\n\n2、再次测试插入方法，我们需要先把实体类同步！\n\n方式二：代码级别\n\n1、删除数据库的默认值、更新操作！\n\n\n\n2、实体类字段属性上需要增加注解\n\n// 字段添加填充内容\n@tablefield(fill = fieldfill.insert)\nprivate date createtime;\n@tablefield(fill = fieldfill.insert_update)\nprivate date updatetime;\n\n\n1\n2\n3\n4\n5\n\n\n3、编写处理器来处理这个注解即可！\n\npackage com.oddfar.handler;\n\nimport com.baomidou.mybatisplus.core.handlers.metaobjecthandler;\nimport lombok.extern.slf4j.slf4j;\nimport org.apache.ibatis.reflection.metaobject;\nimport org.springframework.stereotype.component;\n\nimport java.util.date;\n\n@slf4j\n@component // 一定不要忘记把处理器加到ioc容器中！\npublic class mymetaobjecthandler implements metaobjecthandler {\n    // 插入时的填充策略\n    @override\n    public void insertfill(metaobject metaobject) {\n        log.info("start insert fill.....");\n        // setfieldvalbyname(string fieldname, object fieldval, metaobject metaobject\n        this.setfieldvalbyname("createtime", new date(), metaobject);\n        this.setfieldvalbyname("updatetime", new date(), metaobject);\n    }\n\n    // 更新时的填充策略\n    @override\n    public void updatefill(metaobject metaobject) {\n        log.info("start update fill.....");\n        this.setfieldvalbyname("updatetime", new date(), metaobject);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n4、测试插入 ，测试更新、观察时间即可！\n\n\n# 乐观锁\n\n在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！\n\n> 乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试！\n> \n> 悲观锁：顾名思义十分悲观，他总是任务总是出现问题，无论干什么都会上锁！再去操作！\n\n当要更新一条记录的时候，希望这条记录没有被别人更新 乐观锁实现方式：\n\n乐观锁实现方式：\n\n * 取出记录，获取当前version\n * 更新时，带上这个version\n * 执行更新时，set version = new version where version = oldversion\n * 如果version不对，就更新失败\n\n测试一下mybatis-plus的乐观锁插件\n\n官方文档（必看）：https://baomidou.com/guide/interceptor.html\n\n有的方法会过期，具体操作以官方文档例子为主\n\n1、给数据库中增加version字段！\n\n\n\n2、我们实体类加对应的字段\n\n@version //乐观锁version注解\nprivate integer version;\n\n\n1\n2\n\n\n3、注册组件\n\npackage com.oddfar.config;\n\nimport com.baomidou.mybatisplus.extension.plugins.mybatisplusinterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.inner.optimisticlockerinnerinterceptor;\nimport org.mybatis.spring.annotation.mapperscan;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\n/**\n * @author zhiyuan\n * @date 2021/4/5 17:57\n */\n// 扫描我们的 mapper 文件夹\n@mapperscan("com.oddfar.mapper")\n@configuration // 配置类\npublic class mybatisplusconfig {\n\n    // 注册乐观锁和分页插件(新版：3.4.0)\n    @bean\n    public mybatisplusinterceptor mybatisplusinterceptor(){\n        mybatisplusinterceptor interceptor = new mybatisplusinterceptor();\n        interceptor.addinnerinterceptor(new optimisticlockerinnerinterceptor()); // 乐观锁插件\n        return interceptor;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n旧版如下：\n\n@bean\npublic optimisticlockerinterceptor optimisticlockerinterceptor() {\n    return new optimisticlockerinterceptor();\n}\n\n\n1\n2\n3\n4\n\n\n4、测试一下！\n\n/**\n * 测试乐观锁\n */\n@test\npublic void testoptimisticlocker(){\n    // 1、查询用户信息\n    user user = usermapper.selectbyid(1l);\n\n    // 2、修改用户信息\n    user.setname("zhiyuan");\n    user.setemail("123456@qq.com");\n    // 3、执行更新操作\n    usermapper.updatebyid(user);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们来模拟下\n\n// 测试乐观锁失败！多线程下\n@test\npublic void testoptimisticlocker2(){\n    // 线程 1\n    user user = usermapper.selectbyid(1l);\n    user.setname("zhiyuan000000");\n    user.setemail("000000000@qq.com");\n    // 模拟另外一个线程执行了插队操作\n    user user2 = usermapper.selectbyid(1l);\n    user2.setname("zhiyuan1111111");\n    user2.setemail("111111111@qq.com");\n    usermapper.updatebyid(user2);\n    // 自旋锁来多次尝试提交！\n    usermapper.updatebyid(user); // 如果没有乐观锁就会覆盖插队线程的值！\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n如果不加乐观锁，以上代码，name最后就是zhiyuan000000\n\n\n# 查询操作\n\n// 指定id查询\n@test\npublic void testselectbyid(){\n    user user = usermapper.selectbyid(1l);\n    system.out.println(user);\n}\n// 多个id批量查询！\n@test\npublic void testselectbybatchid(){\n    list<user> users = usermapper.selectbatchids(arrays.aslist(1l, 2l, 3l));\n    users.foreach(system.out::println);\n}\n// 多个where条件查询之一使用map操作\n@test\npublic void testselectbybatchids(){\n    hashmap<string, object> map = new hashmap<>();\n    // 自定义要查询\n    map.put("name","zhiyuan");\n    map.put("age",3);\n    list<user> users = usermapper.selectbymap(map);\n    users.foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 分页查询\n\n分页在网站使用的十分之多！\n\n1、原始的 limit 进行分页 2、pagehelper 第三方插件 3、mp其实也内置了分页插件！\n\nmybais-plus分页查询方法：\n\n1、配置拦截器组件即可\n\ninterceptor.addinnerinterceptor(new paginationinnerinterceptor(dbtype.h2));//分页插件\n\n\n1\n\n\n旧版如下：\n\n//分页插件\n@bean\npublic paginationinterceptor paginationinterceptor() {\n    paginationinterceptor paginationinterceptor = new paginationinterceptor();\n    return paginationinterceptor;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、直接使用page对象即可！\n\n/**\n * 测试分页查询\n */\n@test\npublic void testpage() {\n    //参数一：当前页\n    //参数二：页面大小\n    page<user> page = new page<>(1, 5);\n    usermapper.selectpage(page, null);\n    page.getrecords().foreach(system.out::println);\n    system.out.println(page.gettotal());//总数量\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 删除操作\n\n// 通过id单个删除\n@test\npublic void testdeletebyid(){\n    usermapper.deletebyid(1379026108137123842l);\n}\n// 通过id批量删除\n@test\npublic void testdeletebatchid(){\n   usermapper.deletebatchids(arrays.aslist(1379026108137123842l,1379026441420791810l));\n}\n// 通过map删除\n@test\npublic void testdeletemap(){\n    hashmap<string, object> map = new hashmap<>();\n    map.put("name","zhiyuan4");\n    usermapper.deletebymap(map);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 逻辑删除\n\n官方文档：https://baomidou.com/guide/logic-delete.html\n\n物理删除 ：从数据库中直接移除\n\n逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ 比如一个系统，有管理员，操作员，用户等...... 设置数据库的时候，加个deleted字段，默认为0，代表数据存在 当用户或操作员要删除数据了，我们则把deleted赋值为1，表示数据已删除 这样管理员则可以在后台查询被删除的记录，防止数据的丢失，类似于回收站！\n\n方法如下：\n\n1、在数据表中增加一个 deleted 字段\n\n\n\n2、实体类中增加属性\n\n@tablelogic //逻辑删除\nprivate integer deleted;\n\n\n1\n2\n\n\n3、配置\n\napplication.yml（properties也可以）\n\nmybatis-plus:\n  global-config:\n    db-config:\n      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)\n      logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n4、测试\n\n\n\n记录依旧在数据库，但是值确已经变化了！\n\n\n# 性能分析插件\n\n作用：性能分析拦截器，用于输出每条 sql 语句及其执行时间。mp也提供性能分析插件，如果超过这个时间就停止运行，不过新版本已去掉这功能。\n\n推荐使用druid\n\n或者使用p6spy：\n\n> springboot - mybatis-plus使用详解18（结合p6spy进行sql性能分析）\n\n\n# 条件构造器\n\n官网文档：https://baomidou.com/guide/wrapper.html\n\nwrapper：十分重要： 我们写一些复杂的sql就可以使用它来替代！\n\n1、查询name不为空的用户，并且邮箱不为空的用户，年龄大于12\n\n@test\nvoid contextloads() {\n    //查询name不为空的用户，并且邮箱不为空的用户，年龄大于12\n    querywrapper<user> wrapper = new querywrapper<>();\n    wrapper.isnotnull("name")\n            .isnotnull("email")\n            .ge("age", 12);\n    usermapper.selectlist(wrapper).foreach(system.out::println); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、查询名字为zhiyuan2\n\n@test\nvoid test2(){\n    //查询名字为zhiyuan2\n    querywrapper<user> wrapper = new querywrapper<>();\n    wrapper.eq("name", "zhiyuan2");\n    user user = usermapper.selectone(wrapper);\n    system.out.println(user);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n3、查询年龄在19到30岁之间的用户\n\n@test\nvoid test3(){\n    //查询年龄在19到30岁之间的用户\n    querywrapper<user> wrapper = new querywrapper<>();\n    wrapper.between("age", 19, 30); //区间\n    integer count = usermapper.selectcount(wrapper);\n    system.out.println(count);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n4、查询name不包含t，邮箱以123开头\n\n * 例: notlike("name", "王")---\x3ename not like \'%王%\'\n * 例: likeright("name", "王")---\x3ename like \'王%\'\n\n//模糊查询\n@test\nvoid test4(){\n    //查询name不包含t，邮箱以123开头\n    querywrapper<user> wrapper = new querywrapper<>();\n    wrapper.notlike("name", "t")\n            .likeright("email", "123");\n    list<map<string, object>> maps = usermapper.selectmaps(wrapper);\n    maps.foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n5、子查询\n\n@test\nvoid test5(){\n    querywrapper<user> wrapper = new querywrapper<>();\n    //id 在子查询中查出来\n    wrapper.insql("id", "select id from user where id < 3");\n    list<object> objects = usermapper.selectobjs(wrapper);\n    objects.foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最后sql：\n\n> select id,name,age,email,version,deleted,create_time,update_time from user where deleted=0 and (id in (select id from user where id < 3))\n\n6、通过id进行排序--降序\n\n@test\nvoid test6(){\n    querywrapper<user> wrapper = new querywrapper<>();\n    //通过id进行排序--降序\n    wrapper.orderbydesc("id");\n    list<user> users = usermapper.selectlist(wrapper);\n    users.foreach(system.out::println);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 代码自动生成器\n\ndao、pojo、service、controller都给我自己去编写完成！\n\nautogenerator 是 mybatis-plus 的代码生成器，通过 autogenerator 可以快速生成 entity、mapper、mapper xml、service、controller 等各个模块的代码，极大的提升了开发效率。\n\n测试：\n\npublic class code {\n    public static void main(string[] args) {\n        //需要构建一个 代码自动生成器 对象\n        // 代码生成器\n        autogenerator mpg = new autogenerator();\n        //配置策略\n\n        //1、全局配置\n        globalconfig gc = new globalconfig();\n        string projectpath = system.getproperty("user.dir");\n        gc.setoutputdir(projectpath + "/src/main/java");\n        gc.setauthor("chanv");\n        gc.setopen(false);\n        gc.setfileoverride(false);  //是否覆盖\n        gc.setservicename("%sservice"); //去service的i前缀\n        gc.setidtype(idtype.id_worker);\n        gc.setdatetype(datetype.only_date);\n        gc.setswagger2(true);\n        mpg.setglobalconfig(gc);\n\n        //2、设置数据源\n        datasourceconfig dsc = new datasourceconfig();\n        dsc.seturl("jdbc:mysql://localhost:3306/mybatis-plus?usessl=false&useunicode=true&characterencoding=utf-8&servertimezone=gmt%2b8");\n        dsc.setdrivername("com.mysql.cj.jdbc.driver");\n        dsc.setusername("root");\n        dsc.setpassword("root");\n        dsc.setdbtype(dbtype.mysql);\n        mpg.setdatasource(dsc);\n\n        //3、包的配置\n        packageconfig pc = new packageconfig();\n        pc.setmodulename("blog");\n        pc.setparent("com.chanv");\n        pc.setentity("pojo");\n        pc.setmapper("mapper");\n        pc.setservice("service");\n        pc.setcontroller("controller");\n        mpg.setpackageinfo(pc);\n\n        //4、策略配置\n        strategyconfig strategy = new strategyconfig();\n        strategy.setinclude("user");    //设置要映射的表名\n        strategy.setnaming(namingstrategy.underline_to_camel);\n        strategy.setcolumnnaming(namingstrategy.underline_to_camel);\n        strategy.setentitylombokmodel(true);    //自动lombok\n        strategy.setlogicdeletefieldname("deleted");\n        //自动填充配置\n        tablefill createtime = new tablefill("create_time", fieldfill.insert);\n        tablefill updatetime = new tablefill("update_time", fieldfill.update);\n        arraylist<tablefill> tablefills = new arraylist<>();\n        tablefills.add(createtime);\n        tablefills.add(updatetime);\n        strategy.settablefilllist(tablefills);\n        //乐观锁\n        strategy.setversionfieldname("version");\n        strategy.setrestcontrollerstyle(true);\n        strategy.setcontrollermappinghyphenstyle(true);     //localhost:8080/hello_id_2\n        mpg.setstrategy(strategy);\n\n        mpg.execute();  //执行代码构造器\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.框架/20.RabbitMQ",imgUrl:"/img/web.png",description:"RabbitMQ目录页"}},title:"RabbitMQ - 知识体系",permalink:"/rabbitmq",article:!1,comment:!1,editLink:!1,date:"2021-06-29T18:13:10.000Z"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/01.RabbitMQ%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%20.html",relativePath:"04.框架/20.RabbitMQ/01.RabbitMQ知识体系 .md",key:"v-4fac6ad4",path:"/rabbitmq/",headers:[{level:2,title:"视频教程",slug:"视频教程",normalizedTitle:"视频教程",charIndex:2}],headersStr:"视频教程",content:"# 视频教程\n\n * 尚硅谷入门教程\n   \n   https://www.bilibili.com/video/BV1cb4y1o7zz\n\n学完之后觉得教程有点浅，不过对于其他入门教程，例如学相伴狂神的，个人建议还是看尚硅谷吧。",normalizedContent:"# 视频教程\n\n * 尚硅谷入门教程\n   \n   https://www.bilibili.com/video/bv1cb4y1o7zz\n\n学完之后觉得教程有点浅，不过对于其他入门教程，例如学相伴狂神的，个人建议还是看尚硅谷吧。",charsets:{cjk:!0},lastUpdated:"2021/09/15, 10:09:00",lastUpdatedTimestamp:1631702123e3},{title:"中间件介绍",frontmatter:{title:"中间件介绍",date:"2021-06-25T22:05:07.000Z",permalink:"/pages/e38dcb/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/02.%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%8B%E7%BB%8D.html",relativePath:"04.框架/20.RabbitMQ/02.中间件介绍.md",key:"v-220a90d1",path:"/pages/e38dcb/",headers:[{level:2,title:"什么是中间件",slug:"什么是中间件",normalizedTitle:"什么是中间件",charIndex:3},{level:2,title:"中间件技术及架构的概述",slug:"中间件技术及架构的概述",normalizedTitle:"中间件技术及架构的概述",charIndex:13},{level:2,title:"基于消息中间件的分布式系统的架构",slug:"基于消息中间件的分布式系统的架构",normalizedTitle:"基于消息中间件的分布式系统的架构",charIndex:28},{level:2,title:"视频教程",slug:"视频教程",normalizedTitle:"视频教程",charIndex:48}],headersStr:"什么是中间件 中间件技术及架构的概述 基于消息中间件的分布式系统的架构 视频教程",content:" * 什么是中间件\n * 中间件技术及架构的概述\n * 基于消息中间件的分布式系统的架构\n * 视频教程\n\n\n# 什么是中间件\n\nMiddleware\n\n> 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n> 为什么需要使用消息中间件\n\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n> 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件时位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：\n\n 1. 满足大量应用的需要\n 2. 运行于多种硬件和 OS平台\n 3. 支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互\n 4. 支持标准的协议\n 5. 支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n> 在项目中什么时候使用中间件技术\n\n在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和成本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。\n\n但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和经历去探讨和研究。\n\n\n# 中间件技术及架构的概述\n\n> 单体架构\n\n\n\n在企业开发当中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个工程中，如果其中的一个模块升级或者迭代发生一个很小的变动都会重新编译和重新部署项目。这种存在的问题是：\n\n 1. 耦合度太高\n 2. 不易维护\n 3. 服务器的成本高\n 4. 以及升级架构的复杂度也会增大\n\n这样就有后续的分布式架构系统。如下\n\n\n\n分布式系统：通俗一点，就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成\n\n和单体架构不同的是，单体架构是一个请求发起 jvm调度线程（确切的是 tomcat线程池）分配线程 Thread来处理请求直到释放，而分布式系统是：一个请求时由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就像建设一个小房子很快就能够搞定，如果你要建设一个鸟巢或者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展到后期的时候要去部署和思考的问题。我们也不难看出来：分布式架构系统存在的特点和问题如下：\n\n存在问题：\n\n 1. 学习成本高，技术栈过多\n 2. 运维成本和服务器成本增高\n 3. 人员的成本也会增高\n 4. 项目的负载度也会上升\n 5. 面临的错误和容错性也会成倍增加\n 6. 占用的服务器端口和通讯的选择的成本高\n 7. 安全性的考虑和因素逼迫可能选择 RMI/MQ相关的服务器端通讯\n\n好处：\n\n 1. 服务系统的独立，占用的服务器资源减少和占用的硬件成本减少\n    \n    确切的说是：可以合理的分配服务资源，不造成服务器资源的浪费\n\n 2. 系统的独立维护和部署，耦合度降低，可插拔性\n\n 3. 系统的架构和技术栈的选择可以变的灵活（而不是单纯地选择 java）\n\n 4. 弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态\n\n\n# 基于消息中间件的分布式系统的架构\n\n\n\n从上图中可以看出来，消息中间件的是\n\n 1. 利用可靠的消息传递机制进行系统和系统直接的通讯\n 2. 通过提供消息传递和消息的派对机制，它可以在分布式系统环境下扩展进程间的通讯\n\n> 消息中间件应用的场景\n\n 1. 跨系统数据传递\n 2. 高并发的流量削峰\n 3. 数据的并发和异步处理\n 4. 大数据分析与传递\n 5. 分布式事务\n\n比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10 W 的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行\n\n\n# 视频教程\n\n * 学相伴\n   \n   https://www.bilibili.com/video/BV1dX4y1V73G",normalizedContent:" * 什么是中间件\n * 中间件技术及架构的概述\n * 基于消息中间件的分布式系统的架构\n * 视频教程\n\n\n# 什么是中间件\n\nmiddleware\n\n> 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n> 为什么需要使用消息中间件\n\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n> 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件时位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：\n\n 1. 满足大量应用的需要\n 2. 运行于多种硬件和 os平台\n 3. 支持分布计算，提供跨网络、硬件和 os平台的透明性的应用或服务的交互\n 4. 支持标准的协议\n 5. 支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n> 在项目中什么时候使用中间件技术\n\n在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和成本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。\n\n但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和经历去探讨和研究。\n\n\n# 中间件技术及架构的概述\n\n> 单体架构\n\n\n\n在企业开发当中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个工程中，如果其中的一个模块升级或者迭代发生一个很小的变动都会重新编译和重新部署项目。这种存在的问题是：\n\n 1. 耦合度太高\n 2. 不易维护\n 3. 服务器的成本高\n 4. 以及升级架构的复杂度也会增大\n\n这样就有后续的分布式架构系统。如下\n\n\n\n分布式系统：通俗一点，就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成\n\n和单体架构不同的是，单体架构是一个请求发起 jvm调度线程（确切的是 tomcat线程池）分配线程 thread来处理请求直到释放，而分布式系统是：一个请求时由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就像建设一个小房子很快就能够搞定，如果你要建设一个鸟巢或者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展到后期的时候要去部署和思考的问题。我们也不难看出来：分布式架构系统存在的特点和问题如下：\n\n存在问题：\n\n 1. 学习成本高，技术栈过多\n 2. 运维成本和服务器成本增高\n 3. 人员的成本也会增高\n 4. 项目的负载度也会上升\n 5. 面临的错误和容错性也会成倍增加\n 6. 占用的服务器端口和通讯的选择的成本高\n 7. 安全性的考虑和因素逼迫可能选择 rmi/mq相关的服务器端通讯\n\n好处：\n\n 1. 服务系统的独立，占用的服务器资源减少和占用的硬件成本减少\n    \n    确切的说是：可以合理的分配服务资源，不造成服务器资源的浪费\n\n 2. 系统的独立维护和部署，耦合度降低，可插拔性\n\n 3. 系统的架构和技术栈的选择可以变的灵活（而不是单纯地选择 java）\n\n 4. 弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态\n\n\n# 基于消息中间件的分布式系统的架构\n\n\n\n从上图中可以看出来，消息中间件的是\n\n 1. 利用可靠的消息传递机制进行系统和系统直接的通讯\n 2. 通过提供消息传递和消息的派对机制，它可以在分布式系统环境下扩展进程间的通讯\n\n> 消息中间件应用的场景\n\n 1. 跨系统数据传递\n 2. 高并发的流量削峰\n 3. 数据的并发和异步处理\n 4. 大数据分析与传递\n 5. 分布式事务\n\n比如你有一个数据要进行迁移或者请求并发过多的时候，比如你有10 w 的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行\n\n\n# 视频教程\n\n * 学相伴\n   \n   https://www.bilibili.com/video/bv1dx4y1v73g",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"消息队列介绍",frontmatter:{title:"消息队列介绍",date:"2021-06-25T22:43:19.000Z",permalink:"/pages/2c91a1/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/04.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D.html",relativePath:"04.框架/20.RabbitMQ/04.消息队列介绍.md",key:"v-fb43fc32",path:"/pages/2c91a1/",headers:[{level:2,title:"MQ 的相关概念",slug:"mq-的相关概念",normalizedTitle:"mq 的相关概念",charIndex:3},{level:3,title:"什么是MQ",slug:"什么是mq",normalizedTitle:"什么是mq",charIndex:17},{level:3,title:"为什么要用MQ",slug:"为什么要用mq",normalizedTitle:"为什么要用mq",charIndex:28},{level:3,title:"MQ 的分类",slug:"mq-的分类",normalizedTitle:"mq 的分类",charIndex:41},{level:3,title:"MQ 的选择",slug:"mq-的选择",normalizedTitle:"mq 的选择",charIndex:53},{level:2,title:"RabbitMQ",slug:"rabbitmq",normalizedTitle:"rabbitmq",charIndex:63},{level:3,title:"RabbitMQ 的概念",slug:"rabbitmq-的概念",normalizedTitle:"rabbitmq 的概念",charIndex:77},{level:3,title:"四大核心概念",slug:"四大核心概念",normalizedTitle:"四大核心概念",charIndex:95},{level:3,title:"各个名词介绍",slug:"各个名词介绍",normalizedTitle:"各个名词介绍",charIndex:107}],headersStr:"MQ 的相关概念 什么是MQ 为什么要用MQ MQ 的分类 MQ 的选择 RabbitMQ RabbitMQ 的概念 四大核心概念 各个名词介绍",content:" * MQ 的相关概念\n   * 什么是MQ\n   * 为什么要用MQ\n   * MQ 的分类\n   * MQ 的选择\n * RabbitMQ\n   * RabbitMQ 的概念\n   * 四大核心概念\n   * 各个名词介绍\n\n\n# MQ 的相关概念\n\n\n# 什么是MQ\n\nMQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\n\n\n# 为什么要用MQ\n\n * 流量消峰\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n * 应用解耦\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n\n\n * 异步处理\n\n有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。\n\n以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。\n\n使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。\n\n\n\n\n# MQ 的分类\n\nActiveMQ\n\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据\n\n缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。\n\nKafka\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。\n\n优点：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n缺点：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢；\n\nRocketMQ\n\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。\n\n优点：单机吞吐量十万级,可用性非常高，分布式架构，消息可以做到 0 丢失,MQ 功能较为完善，还是分 布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ\n\n缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码\n\nRabbitMQ\n\n2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高\n\n官网更新：https://www.rabbitmq.com/news.html\n\n缺点：商业版需要收费,学习成本较高\n\n\n# MQ 的选择\n\n * Kafka\n\nKafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。\n\n尚硅谷官网 kafka 视频教程：http://www.gulixueyuan.com/course/330/tasks\n\n * RocketMQ\n\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n\n * RabbitMQ\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。\n\n\n# RabbitMQ\n\n\n# RabbitMQ 的概念\n\nRabbitMQ 是一个消息中间件：它接受并转发消息。\n\n你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。\n\nRabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。\n\n\n\n官网：https://www.rabbitmq.com/#features\n\n\n# 四大核心概念\n\n * 生产者\n   \n   产生数据发送消息的程序是生产者\n\n * 交换机\n   \n   交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\n\n * 队列\n   \n   队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\n\n * 消费者\n   \n   消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n\n\n# 各个名词介绍\n\n\n\n * Broker\n   \n   接收和分发消息的应用，RabbitMQ Server 就是 Message Broker\n\n * Virtual host\n   \n   出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等\n\n * Connection\n   \n   publisher／consumer 和 broker 之间的 TCP 连接\n\n * Channel\n   \n   如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销\n\n * Exchange\n   \n   message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)\n\n * Queue\n   \n   消息最终被送到这里等待 consumer 取走\n\n * Binding\n   \n   exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据",normalizedContent:" * mq 的相关概念\n   * 什么是mq\n   * 为什么要用mq\n   * mq 的分类\n   * mq 的选择\n * rabbitmq\n   * rabbitmq 的概念\n   * 四大核心概念\n   * 各个名词介绍\n\n\n# mq 的相关概念\n\n\n# 什么是mq\n\nmq(message queue)，从字面意思上看，本质是个队列，fifo 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，mq 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 mq 之后，消息发送上游只需要依赖 mq，不 用依赖其他服务。\n\n\n# 为什么要用mq\n\n * 流量消峰\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n * 应用解耦\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n\n\n * 异步处理\n\n有些服务间调用是异步的，例如 a 调用 b，b 需要花费很长时间执行，但是 a 需要知道 b 什么时候可以执行完。\n\n以前一般有两种方式，a 过一段时间去调用 b 的查询 api 查询。或者 a 提供一个 callback api， b 执行完之后调用 api 通知 a 服务。这两种方式都不是很优雅。\n\n使用消息总线，可以很方便解决这个问题， a 调用 b 服务后，只需要监听 b 处理完成的消息，当 b 处理完成后，会发送一条消息给 mq，mq 会将此消息转发给 a 服务。这样 a 服务既不用循环调用 b 的查询 api，也不用提供 callback api。同样b 服务也不用 做这些操作。a 服务还能及时的得到异步处理成功的消息。\n\n\n\n\n# mq 的分类\n\nactivemq\n\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据\n\n缺点：官方社区现在对 activemq 5.x 维护越来越少，高吞吐量场景较少使用。\n\nkafka\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 kafka，这款为大数据而生的消息中间件， 以其百万级 tps 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 linkedin，uber, twitter, netflix 等大公司所采纳。\n\n优点：性能卓越，单机写入 tps 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方kafka web 管理界面 kafka-manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 mq 功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n缺点：kafka 单机超过 64 个队列/分区，load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢；\n\nrocketmq\n\nrocketmq 出自阿里巴巴的开源产品，用 java 语言实现，在设计时参考了 kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。\n\n优点：单机吞吐量十万级,可用性非常高，分布式架构，消息可以做到 0 丢失,mq 功能较为完善，还是分 布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 mq\n\n缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在mq 核心中去实现 jms 等接口,有些系统要迁移需要修改大量代码\n\nrabbitmq\n\n2007 年发布，是一个在amqp(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，mq 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：python、ruby、.net、java、jms、c、php、actionscript、xmpp、stomp 等，支持 ajax 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高\n\n官网更新：https://www.rabbitmq.com/news.html\n\n缺点：商业版需要收费,学习成本较高\n\n\n# mq 的选择\n\n * kafka\n\nkafka 主要特点是基于pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。\n\n尚硅谷官网 kafka 视频教程：http://www.gulixueyuan.com/course/330/tasks\n\n * rocketmq\n\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。roketmq 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 rocketmq。\n\n * rabbitmq\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 rabbitmq。\n\n\n# rabbitmq\n\n\n# rabbitmq 的概念\n\nrabbitmq 是一个消息中间件：它接受并转发消息。\n\n你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 rabbitmq 是 一个快递站，一个快递员帮你传递快件。\n\nrabbitmq 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。\n\n\n\n官网：https://www.rabbitmq.com/#features\n\n\n# 四大核心概念\n\n * 生产者\n   \n   产生数据发送消息的程序是生产者\n\n * 交换机\n   \n   交换机是 rabbitmq 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\n\n * 队列\n   \n   队列是 rabbitmq 内部使用的一种数据结构，尽管消息流经 rabbitmq 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\n\n * 消费者\n   \n   消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n\n\n# 各个名词介绍\n\n\n\n * broker\n   \n   接收和分发消息的应用，rabbitmq server 就是 message broker\n\n * virtual host\n   \n   出于多租户和安全因素设计的，把 amqp 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 rabbitmq server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等\n\n * connection\n   \n   publisher／consumer 和 broker 之间的 tcp 连接\n\n * channel\n   \n   如果每一次访问 rabbitmq 都建立一个 connection，在消息量大的时候建立 tcp connection 的开销将是巨大的，效率也较低。channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，amqp method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。channel 作为轻量级的 connection 极大减少了操作系统建立 tcp connection 的开销\n\n * exchange\n   \n   message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)\n\n * queue\n   \n   消息最终被送到这里等待 consumer 取走\n\n * binding\n   \n   exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 安装",frontmatter:{title:"RabbitMQ - 安装",date:"2021-06-26T09:10:04.000Z",permalink:"/pages/f015b1/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/06.RabbitMQ%20-%20%E5%AE%89%E8%A3%85.html",relativePath:"04.框架/20.RabbitMQ/06.RabbitMQ - 安装.md",key:"v-1be5385e",path:"/pages/f015b1/",headers:[{level:2,title:"Linux安装",slug:"linux安装",normalizedTitle:"linux安装",charIndex:3},{level:3,title:"安装RabbitMQ",slug:"安装rabbitmq",normalizedTitle:"安装rabbitmq",charIndex:16},{level:3,title:"Web管理界面及授权操作",slug:"web管理界面及授权操作",normalizedTitle:"web管理界面及授权操作",charIndex:32},{level:2,title:"Docker 安装",slug:"docker-安装",normalizedTitle:"docker 安装",charIndex:48}],headersStr:"Linux安装 安装RabbitMQ Web管理界面及授权操作 Docker 安装",content:' * Linux安装\n   * 安装RabbitMQ\n   * Web管理界面及授权操作\n * Docker 安装\n\n\n# Linux安装\n\n\n# 安装RabbitMQ\n\n1、下载\n\n官网下载地址：https://www.rabbitmq.com/download.html\n\n这里我们选择的版本号（注意这两版本要求）\n\n * rabbitmq-server-3.8.8-1.el7.noarch.rpm\n   \n   GitHub：https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8\n   \n   加载下载：https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n * erlang-21.3.8.21-1.el7.x86_64.rpm\n   \n   官网：https://www.erlang-solutions.com/downloads/\n   \n   加速：https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm\n\nRed Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”\n\n2、安装\n\n上传到 /usr/local/software 目录下(如果没有 software 需要自己创建)\n\nrpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm\nyum install socat -y\nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n\n1\n2\n3\n\n\n3、启动\n\n# 启动服务\nsystemctl start rabbitmq-server\n# 查看服务状态\nsystemctl status rabbitmq-server\n# 开机自启动\nsystemctl enable rabbitmq-server\n# 停止服务\nsystemctl stop rabbitmq-server\n# 重启服务\nsystemctl restart rabbitmq-server\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Web管理界面及授权操作\n\n1、安装\n\n默认情况下，是没有安装web端的客户端插件，需要安装才可以生效\n\nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n\n\n安装完毕以后，重启服务即可\n\nsystemctl restart rabbitmq-server\n\n\n1\n\n\n访问 http://42.192.149.71:15672 ，用默认账号密码(guest)登录，出现权限问题\n\n默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户\n\n2、添加用户\n\n# 创建账号和密码\nrabbitmqctl add_user admin 123456\n\n# 设置用户角色\nrabbitmqctl set_user_tags admin administrator\n\n# 为用户添加资源权限\n# set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\nrabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"\n# 添加配置、写、读权限\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n用户级别：\n\n 1. administrator：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理\n 2. monitoring：监控者 登录控制台，查看所有信息\n 3. policymaker：策略制定者 登录控制台，指定策略\n 4. managment：普通管理员 登录控制台\n\n再次登录，用 admin 用户\n\n重置命令\n\n关闭应用的命令为：rabbitmqctl stop_app\n\n清除的命令为：rabbitmqctl reset\n\n重新启动命令为：rabbitmqctl start_app\n\n\n# Docker 安装\n\n官网：https://registry.hub.docker.com/_/rabbitmq/\n\ndocker run -id --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management\n\n\n1\n',normalizedContent:' * linux安装\n   * 安装rabbitmq\n   * web管理界面及授权操作\n * docker 安装\n\n\n# linux安装\n\n\n# 安装rabbitmq\n\n1、下载\n\n官网下载地址：https://www.rabbitmq.com/download.html\n\n这里我们选择的版本号（注意这两版本要求）\n\n * rabbitmq-server-3.8.8-1.el7.noarch.rpm\n   \n   github：https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8\n   \n   加载下载：https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n * erlang-21.3.8.21-1.el7.x86_64.rpm\n   \n   官网：https://www.erlang-solutions.com/downloads/\n   \n   加速：https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm\n\nred hat 8, centos 8 和 modern fedora 版本，把 “el7” 替换成 “el8”\n\n2、安装\n\n上传到 /usr/local/software 目录下(如果没有 software 需要自己创建)\n\nrpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm\nyum install socat -y\nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n\n1\n2\n3\n\n\n3、启动\n\n# 启动服务\nsystemctl start rabbitmq-server\n# 查看服务状态\nsystemctl status rabbitmq-server\n# 开机自启动\nsystemctl enable rabbitmq-server\n# 停止服务\nsystemctl stop rabbitmq-server\n# 重启服务\nsystemctl restart rabbitmq-server\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# web管理界面及授权操作\n\n1、安装\n\n默认情况下，是没有安装web端的客户端插件，需要安装才可以生效\n\nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n\n\n安装完毕以后，重启服务即可\n\nsystemctl restart rabbitmq-server\n\n\n1\n\n\n访问 http://42.192.149.71:15672 ，用默认账号密码(guest)登录，出现权限问题\n\n默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户\n\n2、添加用户\n\n# 创建账号和密码\nrabbitmqctl add_user admin 123456\n\n# 设置用户角色\nrabbitmqctl set_user_tags admin administrator\n\n# 为用户添加资源权限\n# set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\nrabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"\n# 添加配置、写、读权限\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n用户级别：\n\n 1. administrator：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理\n 2. monitoring：监控者 登录控制台，查看所有信息\n 3. policymaker：策略制定者 登录控制台，指定策略\n 4. managment：普通管理员 登录控制台\n\n再次登录，用 admin 用户\n\n重置命令\n\n关闭应用的命令为：rabbitmqctl stop_app\n\n清除的命令为：rabbitmqctl reset\n\n重新启动命令为：rabbitmqctl start_app\n\n\n# docker 安装\n\n官网：https://registry.hub.docker.com/_/rabbitmq/\n\ndocker run -id --name myrabbit -e rabbitmq_default_user=admin -e rabbitmq_default_pass=123456 -p 15672:15672 rabbitmq:3-management\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2021/09/15, 10:09:00",lastUpdatedTimestamp:1631702123e3},{title:"RabbitMQ - 发布确认",frontmatter:{title:"RabbitMQ - 发布确认",date:"2021-06-27T18:01:21.000Z",permalink:"/pages/ef9b33/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/10.RabbitMQ%20-%20%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4.html",relativePath:"04.框架/20.RabbitMQ/10.RabbitMQ - 发布确认.md",key:"v-ea04530c",path:"/pages/ef9b33/",headers:[{level:2,title:"发布确认逻辑",slug:"发布确认逻辑",normalizedTitle:"发布确认逻辑",charIndex:3},{level:2,title:"发布确认的策略",slug:"发布确认的策略",normalizedTitle:"发布确认的策略",charIndex:13},{level:3,title:"单个确认发布",slug:"单个确认发布",normalizedTitle:"单个确认发布",charIndex:26},{level:3,title:"批量确认发布",slug:"批量确认发布",normalizedTitle:"批量确认发布",charIndex:38},{level:3,title:"异步确认发布",slug:"异步确认发布",normalizedTitle:"异步确认发布",charIndex:50}],headersStr:"发布确认逻辑 发布确认的策略 单个确认发布 批量确认发布 异步确认发布",content:' * 发布确认逻辑\n * 发布确认的策略\n   * 单个确认发布\n   * 批量确认发布\n   * 异步确认发布\n\n\n# 发布确认逻辑\n\n生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\nconfirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n\n# 发布确认的策略\n\n开启发布确认的方法:\n\n发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法\n\n//开启发布确认\nchannel.confirmSelect();\n\n\n1\n2\n\n\n\n# 单个确认发布\n\n这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n\n这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n\n/**\n * 单个发送\n */\npublic static void publishMessageIndividually() throws Exception {\n    Channel channel = RabbitMqUtils.getChannel();\n    //队列声明\n    String queueName = UUID.randomUUID().toString();\n    channel.queueDeclare(queueName, true, false, false, null);\n    //开启发布确认\n    channel.confirmSelect();\n\n    long begin = System.currentTimeMillis();\n\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        String message = i + "";\n        channel.basicPublish("", queueName, null, message.getBytes());\n        //服务端返回 false 或超时时间内未返回，生产者可以消息重发\n        boolean flag = channel.waitForConfirms();\n        if (flag) {\n            System.out.println("消息发送成功");\n        }\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println("发布" + MESSAGE_COUNT + "个单独确认消息,耗时" + (end - begin) + "ms");\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 批量确认发布\n\n上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n\n/**\n * 批量\n */\npublic static void publishMessageBatch() throws Exception {\n    Channel channel = RabbitMqUtils.getChannel();\n    //队列声明\n    String queueName = UUID.randomUUID().toString();\n    channel.queueDeclare(queueName, true, false, false, null);\n    //开启发布确认\n    channel.confirmSelect();\n    //批量确认消息大小\n    int batchSize = 100;\n    //未确认消息个数\n    int outstandingMessageCount = 0;\n    long begin = System.currentTimeMillis();\n\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        String message = i + "";\n        channel.basicPublish("", queueName, null, message.getBytes());\n        outstandingMessageCount++;\n        if (outstandingMessageCount == batchSize) {\n            channel.waitForConfirms();\n            outstandingMessageCount = 0;\n        }\n    }\n    //为了确保还有剩余没有确认消息 再次确认\n    if (outstandingMessageCount > 0) {\n        channel.waitForConfirms();\n    }\n    long end = System.currentTimeMillis();\n    System.out.println("发布" + MESSAGE_COUNT + "个批量确认消息,耗时" + (end - begin) + "ms");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 异步确认发布\n\n异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。\n\n\n\n如何处理异步未确认消息?\n\n最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n\n以上 3 种发布确认速度对比 :\n\n * 单独发布消息\n   \n   同步等待确认，简单，但吞吐量非常有限。\n\n * 批量发布消息\n   \n   批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n\n * 异步处理\n   \n   最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些',normalizedContent:' * 发布确认逻辑\n * 发布确认的策略\n   * 单个确认发布\n   * 批量确认发布\n   * 异步确认发布\n\n\n# 发布确认逻辑\n\n生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 id(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 id)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\nconfirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果rabbitmq 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n\n# 发布确认的策略\n\n开启发布确认的方法:\n\n发布确认默认是没有开启的，如果要开启需要调用方法 confirmselect，每当你要想使用发布确认，都需要在 channel 上调用该方法\n\n//开启发布确认\nchannel.confirmselect();\n\n\n1\n2\n\n\n\n# 单个确认发布\n\n这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitforconfirmsordie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n\n这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n\n/**\n * 单个发送\n */\npublic static void publishmessageindividually() throws exception {\n    channel channel = rabbitmqutils.getchannel();\n    //队列声明\n    string queuename = uuid.randomuuid().tostring();\n    channel.queuedeclare(queuename, true, false, false, null);\n    //开启发布确认\n    channel.confirmselect();\n\n    long begin = system.currenttimemillis();\n\n    for (int i = 0; i < message_count; i++) {\n        string message = i + "";\n        channel.basicpublish("", queuename, null, message.getbytes());\n        //服务端返回 false 或超时时间内未返回，生产者可以消息重发\n        boolean flag = channel.waitforconfirms();\n        if (flag) {\n            system.out.println("消息发送成功");\n        }\n    }\n\n    long end = system.currenttimemillis();\n    system.out.println("发布" + message_count + "个单独确认消息,耗时" + (end - begin) + "ms");\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 批量确认发布\n\n上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n\n/**\n * 批量\n */\npublic static void publishmessagebatch() throws exception {\n    channel channel = rabbitmqutils.getchannel();\n    //队列声明\n    string queuename = uuid.randomuuid().tostring();\n    channel.queuedeclare(queuename, true, false, false, null);\n    //开启发布确认\n    channel.confirmselect();\n    //批量确认消息大小\n    int batchsize = 100;\n    //未确认消息个数\n    int outstandingmessagecount = 0;\n    long begin = system.currenttimemillis();\n\n    for (int i = 0; i < message_count; i++) {\n        string message = i + "";\n        channel.basicpublish("", queuename, null, message.getbytes());\n        outstandingmessagecount++;\n        if (outstandingmessagecount == batchsize) {\n            channel.waitforconfirms();\n            outstandingmessagecount = 0;\n        }\n    }\n    //为了确保还有剩余没有确认消息 再次确认\n    if (outstandingmessagecount > 0) {\n        channel.waitforconfirms();\n    }\n    long end = system.currenttimemillis();\n    system.out.println("发布" + message_count + "个批量确认消息,耗时" + (end - begin) + "ms");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 异步确认发布\n\n异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。\n\n\n\n如何处理异步未确认消息?\n\n最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 concurrentlinkedqueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n\n以上 3 种发布确认速度对比 :\n\n * 单独发布消息\n   \n   同步等待确认，简单，但吞吐量非常有限。\n\n * 批量发布消息\n   \n   批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n\n * 异步处理\n   \n   最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 交换机",frontmatter:{title:"RabbitMQ - 交换机",date:"2021-06-27T20:29:00.000Z",permalink:"/pages/c9c254/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/12.RabbitMQ%20-%20%E4%BA%A4%E6%8D%A2%E6%9C%BA.html",relativePath:"04.框架/20.RabbitMQ/12.RabbitMQ - 交换机.md",key:"v-32fb0c7e",path:"/pages/c9c254/",headers:[{level:2,title:"Exchanges",slug:"exchanges",normalizedTitle:"exchanges",charIndex:3},{level:2,title:"临时队列",slug:"临时队列",normalizedTitle:"临时队列",charIndex:16},{level:2,title:"绑定 bindings",slug:"绑定-bindings",normalizedTitle:"绑定 bindings",charIndex:24},{level:2,title:"Fanout exchange",slug:"fanout-exchange",normalizedTitle:"fanout exchange",charIndex:39},{level:3,title:"Fanout 介绍",slug:"fanout-介绍",normalizedTitle:"fanout 介绍",charIndex:60},{level:3,title:"Fanout 实战",slug:"fanout-实战",normalizedTitle:"fanout 实战",charIndex:75},{level:2,title:"Direct exchange",slug:"direct-exchange",normalizedTitle:"direct exchange",charIndex:88},{level:3,title:"Direct 介绍",slug:"direct-介绍",normalizedTitle:"direct 介绍",charIndex:109},{level:3,title:"多重绑定",slug:"多重绑定",normalizedTitle:"多重绑定",charIndex:124},{level:3,title:"Direct 实战",slug:"direct-实战",normalizedTitle:"direct 实战",charIndex:134},{level:2,title:"Topics exchange",slug:"topics-exchange",normalizedTitle:"topics exchange",charIndex:147},{level:3,title:"Topic 的介绍",slug:"topic-的介绍",normalizedTitle:"topic 的介绍",charIndex:168},{level:3,title:"Topic 匹配案例",slug:"topic-匹配案例",normalizedTitle:"topic 匹配案例",charIndex:183},{level:3,title:"Topic 实战",slug:"topic-实战",normalizedTitle:"topic 实战",charIndex:199}],headersStr:"Exchanges 临时队列 绑定 bindings Fanout exchange Fanout 介绍 Fanout 实战 Direct exchange Direct 介绍 多重绑定 Direct 实战 Topics exchange Topic 的介绍 Topic 匹配案例 Topic 实战",content:' * Exchanges\n * 临时队列\n * 绑定 bindings\n * Fanout exchange\n   * Fanout 介绍\n   * Fanout 实战\n * Direct exchange\n   * Direct 介绍\n   * 多重绑定\n   * Direct 实战\n * Topics exchange\n   * Topic 的介绍\n   * Topic 匹配案例\n   * Topic 实战\n\n在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”。\n\n\n# Exchanges\n\nRabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n\n相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n\n\nExchanges 的类型：\n\n直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)\n\n无名exchange：\n\n在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。\n\n\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话\n\n\n# 临时队列\n\n之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。\n\n每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n\n创建临时队列的方式如下:\n\nString queueName = channel.queueDeclare().getQueue();\n\n\n1\n\n\n\n\n\n# 绑定 bindings\n\n什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定\n\n\n\n\n\n\n# Fanout exchange\n\n\n# Fanout 介绍\n\nFanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型\n\n\n\n\n# Fanout 实战\n\n\n\nLogs 和临时队列的绑定关系如下图\n\n\n\n为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，\n\nReceiveLogs01 将接收到的消息打印在控制台\n\npackage com.oddfar.five;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * @author zhiyuan\n */\npublic class ReceiveLogs01 {\n    private static final String EXCHANGE_NAME = "logs";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        String queueName = channel.queueDeclare().getQueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, "");\n        System.out.println("等待接收消息,把接收到的消息打印在屏幕........... ");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            System.out.println("控制台打印接收到的消息" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nReceiveLogs02 把消息写出到文件\n\npublic class ReceiveLogs02 {\n    private static final String EXCHANGE_NAME = "logs";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        String queueName = channel.queueDeclare().getQueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, "");\n        System.out.println("等待接收消息,把接收到的消息写到文件........... ");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            File file = new File("D:\\\\test\\\\rabbitmq_info.txt");\n            FileUtils.writeStringToFile(file,message,"UTF-8");\n            System.out.println("数据写入文件成功");\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nEmitLog 发送消息给两个消费者接收：\n\npublic class EmitLog {\n    private static final String EXCHANGE_NAME = "logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 声明一个 exchange\n         * 1.exchange 的名称\n         * 2.exchange 的类型\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入信息");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8"));\n            System.out.println("生产者发出消息" + message);\n        }\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Direct exchange\n\n在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\n\n我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, "routingKey");\n\n绑定之后的意义由其交换类型决定。\n\n\n# Direct 介绍\n\n上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。\n\n\n\n在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.\n\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。\n\n\n# 多重绑定\n\n\n\n当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。\n\n\n# Direct 实战\n\n关系：\n\n\n\n交换机：\n\n\n\nc2：绑定disk，routingKey为error\n\nc1：绑定console，routingKey为info、warning\n\n1、\n\npackage com.oddfar.six;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * @author zhiyuan\n */\npublic class ReceiveLogsDirect01 {\n    private static final String EXCHANGE_NAME = "direct_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String queueName = "disk";\n        //队列声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "error");\n        System.out.println("等待接收消息...");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            message = "接收绑定键:" + delivery.getEnvelope().getRoutingKey() + ",消息:" + message;\n            System.out.println("error 消息已经接收：\\n" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n2、\n\npublic class ReceiveLogsDirect02 {\n    private static final String EXCHANGE_NAME = "direct_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        String queueName = "console";\n        //队列声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "info");\n        channel.queueBind(queueName, EXCHANGE_NAME, "warning");\n\n        System.out.println("等待接收消息...");\n\n        //发送回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            message = "接收绑定键:" + delivery.getEnvelope().getRoutingKey() + ",消息:" + message;\n            System.out.println("info和warning 消息已经接收：\\n" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n3、\n\npublic class EmitLogDirect {\n    private static final String EXCHANGE_NAME = "direct_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        //创建多个 bindingKey\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put("info", "普通 info 信息");\n        bindingKeyMap.put("warning", "警告 warning 信息");\n        bindingKeyMap.put("error", "错误 error 信息");\n        //debug 没有消费这接收这个消息 所有就丢失了\n        bindingKeyMap.put("debug", "调试 debug 信息");\n\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            //获取 key value\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes("UTF-8"));\n            System.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Topics exchange\n\n\n# Topic 的介绍\n\n在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。\n\n尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型\n\nTopic的要求\n\n发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词\n\n比如说："stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit".这种类型的。\n\n当然这个单词列表最多不能超过 255 个字节。\n\n在这个规则列表中，其中有两个替换符是大家需要注意的：\n\n * *(星号)可以代替一个单词\n * #(井号)可以替代零个或多个单词\n\n\n# Topic 匹配案例\n\n下图绑定关系如下\n\n\n\n * Q1--\x3e绑定的是\n   \n   * 中间带 orange 带 3 个单词的字符串 (*.orange.*)\n\n * Q2--\x3e绑定的是\n   \n   * 最后一个单词是 rabbit 的 3 个单词 (*.*.rabbit)\n   * 第一个单词是 lazy 的多个单词 (lazy.#)\n\n上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的\n\n例子                         说明\nquick.orange.rabbit        被队列 Q1Q2 接收到\nazy.orange.elephant        被队列 Q1Q2 接收到\nquick.orange.fox           被队列 Q1 接收到\nlazy.brown.fox             被队列 Q2 接收到\nlazy.pink.rabbit           虽然满足两个绑定但只被队列 Q2 接收一次\nquick.brown.fox            不匹配任何绑定不会被任何队列接收到会被丢弃\nquick.orange.male.rabbit   是四个单词不匹配任何绑定会被丢弃\nlazy.orange.male.rabbit    是四个单词但匹配 Q2\n\n注意：\n\n * 当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了\n * 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了\n\n\n# Topic 实战\n\n\n\n代码如下：\n\npackage com.oddfar.seven;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.BuiltinExchangeType;\nimport com.rabbitmq.client.Channel;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 发送端\n *\n * @author zhiyuan\n */\npublic class EmitLogTopic {\n    private static final String EXCHANGE_NAME = "topic_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n\n        /**\n         * Q1--\x3e绑定的是\n         *      中间带 orange 带 3 个单词的字符串(*.orange.*)\n         * Q2--\x3e绑定的是\n         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)\n         *      第一个单词是 lazy 的多个单词(lazy.#)\n         *\n         */\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put("quick.orange.rabbit", "被队列 Q1Q2 接收到");\n        bindingKeyMap.put("lazy.orange.elephant", "被队列 Q1Q2 接收到");\n        bindingKeyMap.put("quick.orange.fox", "被队列 Q1 接收到");\n        bindingKeyMap.put("lazy.brown.fox", "被队列 Q2 接收到");\n        bindingKeyMap.put("lazy.pink.rabbit", "虽然满足两个绑定但只被队列 Q2 接收一次");\n        bindingKeyMap.put("quick.brown.fox", "不匹配任何绑定不会被任何队列接收到会被丢弃");\n        bindingKeyMap.put("quick.orange.male.rabbit", "是四个单词不匹配任何绑定会被丢弃");\n        bindingKeyMap.put("lazy.orange.male.rabbit", "是四个单词但匹配 Q2");\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes("UTF-8"));\n            System.out.println("生产者发出消息：" + message);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\npublic class ReceiveLogsTopic01 {\n    private static final String EXCHANGE_NAME = "topic_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        //声明 Q1 队列与绑定关系\n        String queueName = "Q1";\n        //声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "*.orange.*");\n        System.out.println("等待接收消息........... ");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            System.out.println(" 接收队列:" + queueName + " 绑定键:" + delivery.getEnvelope().getRoutingKey() + ",消息:" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npublic class ReceiveLogsTopic02 {\n    private static final String EXCHANGE_NAME = "topic_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        //声明 Q2 队列与绑定关系\n        String queueName = "Q2";\n        //声明\n        channel.queueDeclare(queueName, false, false, false, null);\n        //绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "*.*.rabbit");\n        channel.queueBind(queueName, EXCHANGE_NAME, "lazy.#");\n\n        System.out.println("等待接收消息........... ");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            System.out.println(" 接收队列:" + queueName + " 绑定键:" + delivery.getEnvelope().getRoutingKey() + ",消息:" + message);\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',normalizedContent:' * exchanges\n * 临时队列\n * 绑定 bindings\n * fanout exchange\n   * fanout 介绍\n   * fanout 实战\n * direct exchange\n   * direct 介绍\n   * 多重绑定\n   * direct 实战\n * topics exchange\n   * topic 的介绍\n   * topic 匹配案例\n   * topic 实战\n\n在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”。\n\n\n# exchanges\n\nrabbitmq 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n\n相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n\n\nexchanges 的类型：\n\n直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)\n\n无名exchange：\n\n在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。\n\n\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingkey(bindingkey)绑定 key 指定的，如果它存在的话\n\n\n# 临时队列\n\n之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。\n\n每当我们连接到 rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n\n创建临时队列的方式如下:\n\nstring queuename = channel.queuedeclare().getqueue();\n\n\n1\n\n\n\n\n\n# 绑定 bindings\n\n什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 x 与 q1 和 q2 进行了绑定\n\n\n\n\n\n\n# fanout exchange\n\n\n# fanout 介绍\n\nfanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型\n\n\n\n\n# fanout 实战\n\n\n\nlogs 和临时队列的绑定关系如下图\n\n\n\n为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，\n\nreceivelogs01 将接收到的消息打印在控制台\n\npackage com.oddfar.five;\n\nimport com.oddfar.utils.rabbitmqutils;\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.delivercallback;\n\n/**\n * @author zhiyuan\n */\npublic class receivelogs01 {\n    private static final string exchange_name = "logs";\n\n    public static void main(string[] args) throws exception {\n\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, "fanout");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        string queuename = channel.queuedeclare().getqueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queuebind(queuename, exchange_name, "");\n        system.out.println("等待接收消息,把接收到的消息打印在屏幕........... ");\n\n        //发送回调\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            system.out.println("控制台打印接收到的消息" + message);\n        };\n        channel.basicconsume(queuename, true, delivercallback, consumertag -> {});\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nreceivelogs02 把消息写出到文件\n\npublic class receivelogs02 {\n    private static final string exchange_name = "logs";\n\n    public static void main(string[] args) throws exception {\n\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, "fanout");\n        /**\n         * 生成一个临时的队列 队列的名称是随机的\n         * 当消费者断开和该队列的连接时 队列自动删除\n         */\n        string queuename = channel.queuedeclare().getqueue();\n        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串\n        channel.queuebind(queuename, exchange_name, "");\n        system.out.println("等待接收消息,把接收到的消息写到文件........... ");\n\n        //发送回调\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            file file = new file("d:\\\\test\\\\rabbitmq_info.txt");\n            fileutils.writestringtofile(file,message,"utf-8");\n            system.out.println("数据写入文件成功");\n        };\n        channel.basicconsume(queuename, true, delivercallback, consumertag -> {});\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nemitlog 发送消息给两个消费者接收：\n\npublic class emitlog {\n    private static final string exchange_name = "logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        /**\n         * 声明一个 exchange\n         * 1.exchange 的名称\n         * 2.exchange 的类型\n         */\n        channel.exchangedeclare(exchange_name, "fanout");\n        scanner sc = new scanner(system.in);\n        system.out.println("请输入信息");\n        while (sc.hasnext()) {\n            string message = sc.nextline();\n            channel.basicpublish(exchange_name, "", null, message.getbytes("utf-8"));\n            system.out.println("生产者发出消息" + message);\n        }\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# direct exchange\n\n在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\n\n我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingkey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queuebind(queuename, exchange_name, "routingkey");\n\n绑定之后的意义由其交换类型决定。\n\n\n# direct 介绍\n\n上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingkey 队列中去。\n\n\n\n在上面这张图中，我们可以看到 x 绑定了两个队列，绑定类型是 direct。队列q1 绑定键为 orange， 队列 q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.\n\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 q1。绑定键为 blackgreen 和的消息会被发布到队列 q2，其他消息类型的消息将被丢弃。\n\n\n# 多重绑定\n\n\n\n当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。\n\n\n# direct 实战\n\n关系：\n\n\n\n交换机：\n\n\n\nc2：绑定disk，routingkey为error\n\nc1：绑定console，routingkey为info、warning\n\n1、\n\npackage com.oddfar.six;\n\nimport com.oddfar.utils.rabbitmqutils;\nimport com.rabbitmq.client.builtinexchangetype;\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.delivercallback;\n\n/**\n * @author zhiyuan\n */\npublic class receivelogsdirect01 {\n    private static final string exchange_name = "direct_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, builtinexchangetype.direct);\n\n        string queuename = "disk";\n        //队列声明\n        channel.queuedeclare(queuename, false, false, false, null);\n        //队列绑定\n        channel.queuebind(queuename, exchange_name, "error");\n        system.out.println("等待接收消息...");\n\n        //发送回调\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            message = "接收绑定键:" + delivery.getenvelope().getroutingkey() + ",消息:" + message;\n            system.out.println("error 消息已经接收：\\n" + message);\n        };\n        channel.basicconsume(queuename, true, delivercallback, consumertag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n2、\n\npublic class receivelogsdirect02 {\n    private static final string exchange_name = "direct_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, builtinexchangetype.direct);\n\n        string queuename = "console";\n        //队列声明\n        channel.queuedeclare(queuename, false, false, false, null);\n        //队列绑定\n        channel.queuebind(queuename, exchange_name, "info");\n        channel.queuebind(queuename, exchange_name, "warning");\n\n        system.out.println("等待接收消息...");\n\n        //发送回调\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            message = "接收绑定键:" + delivery.getenvelope().getroutingkey() + ",消息:" + message;\n            system.out.println("info和warning 消息已经接收：\\n" + message);\n        };\n        channel.basicconsume(queuename, true, delivercallback, consumertag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n3、\n\npublic class emitlogdirect {\n    private static final string exchange_name = "direct_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, builtinexchangetype.direct);\n\n        //创建多个 bindingkey\n        map<string, string> bindingkeymap = new hashmap<>();\n        bindingkeymap.put("info", "普通 info 信息");\n        bindingkeymap.put("warning", "警告 warning 信息");\n        bindingkeymap.put("error", "错误 error 信息");\n        //debug 没有消费这接收这个消息 所有就丢失了\n        bindingkeymap.put("debug", "调试 debug 信息");\n\n        for (map.entry<string, string> bindingkeyentry : bindingkeymap.entryset()) {\n            //获取 key value\n            string bindingkey = bindingkeyentry.getkey();\n            string message = bindingkeyentry.getvalue();\n\n            channel.basicpublish(exchange_name, bindingkey, null, message.getbytes("utf-8"));\n            system.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# topics exchange\n\n\n# topic 的介绍\n\n在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。\n\n尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型\n\ntopic的要求\n\n发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词\n\n比如说："stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit".这种类型的。\n\n当然这个单词列表最多不能超过 255 个字节。\n\n在这个规则列表中，其中有两个替换符是大家需要注意的：\n\n * *(星号)可以代替一个单词\n * #(井号)可以替代零个或多个单词\n\n\n# topic 匹配案例\n\n下图绑定关系如下\n\n\n\n * q1--\x3e绑定的是\n   \n   * 中间带 orange 带 3 个单词的字符串 (*.orange.*)\n\n * q2--\x3e绑定的是\n   \n   * 最后一个单词是 rabbit 的 3 个单词 (*.*.rabbit)\n   * 第一个单词是 lazy 的多个单词 (lazy.#)\n\n上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的\n\n例子                         说明\nquick.orange.rabbit        被队列 q1q2 接收到\nazy.orange.elephant        被队列 q1q2 接收到\nquick.orange.fox           被队列 q1 接收到\nlazy.brown.fox             被队列 q2 接收到\nlazy.pink.rabbit           虽然满足两个绑定但只被队列 q2 接收一次\nquick.brown.fox            不匹配任何绑定不会被任何队列接收到会被丢弃\nquick.orange.male.rabbit   是四个单词不匹配任何绑定会被丢弃\nlazy.orange.male.rabbit    是四个单词但匹配 q2\n\n注意：\n\n * 当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了\n * 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了\n\n\n# topic 实战\n\n\n\n代码如下：\n\npackage com.oddfar.seven;\n\nimport com.oddfar.utils.rabbitmqutils;\nimport com.rabbitmq.client.builtinexchangetype;\nimport com.rabbitmq.client.channel;\n\nimport java.util.hashmap;\nimport java.util.map;\n\n/**\n * 发送端\n *\n * @author zhiyuan\n */\npublic class emitlogtopic {\n    private static final string exchange_name = "topic_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n\n        /**\n         * q1--\x3e绑定的是\n         *      中间带 orange 带 3 个单词的字符串(*.orange.*)\n         * q2--\x3e绑定的是\n         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)\n         *      第一个单词是 lazy 的多个单词(lazy.#)\n         *\n         */\n        map<string, string> bindingkeymap = new hashmap<>();\n        bindingkeymap.put("quick.orange.rabbit", "被队列 q1q2 接收到");\n        bindingkeymap.put("lazy.orange.elephant", "被队列 q1q2 接收到");\n        bindingkeymap.put("quick.orange.fox", "被队列 q1 接收到");\n        bindingkeymap.put("lazy.brown.fox", "被队列 q2 接收到");\n        bindingkeymap.put("lazy.pink.rabbit", "虽然满足两个绑定但只被队列 q2 接收一次");\n        bindingkeymap.put("quick.brown.fox", "不匹配任何绑定不会被任何队列接收到会被丢弃");\n        bindingkeymap.put("quick.orange.male.rabbit", "是四个单词不匹配任何绑定会被丢弃");\n        bindingkeymap.put("lazy.orange.male.rabbit", "是四个单词但匹配 q2");\n        for (map.entry<string, string> bindingkeyentry : bindingkeymap.entryset()) {\n            string bindingkey = bindingkeyentry.getkey();\n            string message = bindingkeyentry.getvalue();\n\n            channel.basicpublish(exchange_name, bindingkey, null, message.getbytes("utf-8"));\n            system.out.println("生产者发出消息：" + message);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\npublic class receivelogstopic01 {\n    private static final string exchange_name = "topic_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n        //声明 q1 队列与绑定关系\n        string queuename = "q1";\n        //声明\n        channel.queuedeclare(queuename, false, false, false, null);\n        //绑定\n        channel.queuebind(queuename, exchange_name, "*.orange.*");\n        system.out.println("等待接收消息........... ");\n\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            system.out.println(" 接收队列:" + queuename + " 绑定键:" + delivery.getenvelope().getroutingkey() + ",消息:" + message);\n        };\n        channel.basicconsume(queuename, true, delivercallback, consumertag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npublic class receivelogstopic02 {\n    private static final string exchange_name = "topic_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n        //声明 q2 队列与绑定关系\n        string queuename = "q2";\n        //声明\n        channel.queuedeclare(queuename, false, false, false, null);\n        //绑定\n        channel.queuebind(queuename, exchange_name, "*.*.rabbit");\n        channel.queuebind(queuename, exchange_name, "lazy.#");\n\n        system.out.println("等待接收消息........... ");\n\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            system.out.println(" 接收队列:" + queuename + " 绑定键:" + delivery.getenvelope().getroutingkey() + ",消息:" + message);\n        };\n        channel.basicconsume(queuename, true, delivercallback, consumertag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 死信队列",frontmatter:{title:"RabbitMQ - 死信队列",date:"2021-06-28T08:56:07.000Z",permalink:"/pages/1477b8/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/14.RabbitMQ%20-%20%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97.html",relativePath:"04.框架/20.RabbitMQ/14.RabbitMQ - 死信队列.md",key:"v-1bb853fa",path:"/pages/1477b8/",headers:[{level:2,title:"死信的概念",slug:"死信的概念",normalizedTitle:"死信的概念",charIndex:3},{level:2,title:"死信的来源",slug:"死信的来源",normalizedTitle:"死信的来源",charIndex:12},{level:2,title:"死信实战",slug:"死信实战",normalizedTitle:"死信实战",charIndex:21},{level:3,title:"死信之TTl",slug:"死信之ttl",normalizedTitle:"死信之ttl",charIndex:31},{level:3,title:"死信之最大长度",slug:"死信之最大长度",normalizedTitle:"死信之最大长度",charIndex:43},{level:3,title:"死信之消息被拒",slug:"死信之消息被拒",normalizedTitle:"死信之消息被拒",charIndex:56}],headersStr:"死信的概念 死信的来源 死信实战 死信之TTl 死信之最大长度 死信之消息被拒",content:' * 死信的概念\n * 死信的来源\n * 死信实战\n   * 死信之TTl\n   * 死信之最大长度\n   * 死信之消息被拒\n\n\n# 死信的概念\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效\n\n\n# 死信的来源\n\n * 消息 TTL 过期\n   \n   TTL是Time To Live的缩写, 也就是生存时间\n\n * 队列达到最大长度\n   \n   队列满了，无法再添加数据到 mq 中\n\n * 消息被拒绝\n   \n   (basic.reject 或 basic.nack) 并且 requeue=false.\n\n\n# 死信实战\n\n\n\n\n# 死信之TTl\n\n消费者 C1 代码：\n\n/**\n * 死信队列 - 消费者01\n *\n * @author zhiyuan\n */\npublic class Consumer01 {\n\n    //普通交换机名称\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        //声明死信队列\n        String deadQueue = "dead-queue";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingKey）\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, "lisi");\n\n        //正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", DEAD_EXCHANGE);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "lisi");\n\n        //正常队列\n        String normalQueue = "normal-queue";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, "zhangsan");\n\n        System.out.println("等待接收消息........... ");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            System.out.println("Consumer01 接收到消息" + message);\n        };\n        channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -> {\n        });\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n生产者代码\n\npublic class Producer {\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n\n    public static void main(String[] argv) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //设置消息的 TTL 时间 10s\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();\n        //该信息是用作演示队列个数限制\n        for (int i = 1; i < 11; i++) {\n            String message = "info" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, "zhangsan", properties, message.getBytes());\n            System.out.println("生产者发送消息:" + message);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer\n\n\n\n消费者 C2 代码：\n\n以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息\n\npublic class Consumer02 {\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明交换机\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //声明队列\n        String deadQueue = "dead-queue";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, "lisi");\n\n        System.out.println("等待接收死信消息........... ");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            System.out.println("Consumer02 接收到消息" + message);\n        };\n        channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n\n# 死信之最大长度\n\n1、消息生产者代码去掉 TTL 属性\n\n\n\n2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**\n\n\n\n//设置正常队列的长度限制，例如发10个，4个则为死信\nparams.put("x-max-length",6);\n\n\n1\n2\n\n\n注意此时需要把原先队列删除 因为参数改变了\n\n3、C2 消费者代码不变(启动 C2 消费者)\n\n\n\n\n# 死信之消息被拒\n\n1、消息生产者代码同上生产者一致\n\n2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)\n\n拒收消息 "info5"\n\npublic class Consumer01 {\n\n    //普通交换机名称\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n    //死信交换机名称\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        //声明死信队列\n        String deadQueue = "dead-queue";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingKey）\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, "lisi");\n        \n        //正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", DEAD_EXCHANGE);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "lisi");\n//        //设置正常队列的长度限制，例如发10个，4个则为死信\n//        params.put("x-max-length",6);\n        \n        //正常队列\n        String normalQueue = "normal-queue";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, "zhangsan");\n\n        System.out.println("等待接收消息........... ");\n        \n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), "UTF-8");\n            if (message.equals("info5")) {\n                System.out.println("Consumer01 接收到消息" + message + "并拒绝签收该消息");\n                //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中\n                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);\n            } else {\n                System.out.println("Consumer01 接收到消息" + message);\n                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n            }\n\n        };\n        //开启手动应答\n        channel.basicConsume(normalQueue, false, deliverCallback, consumerTag -> {\n        });\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n\n3、C2 消费者代码不变\n\n启动消费者 1 然后再启动消费者 2\n\n',normalizedContent:' * 死信的概念\n * 死信的来源\n * 死信实战\n   * 死信之ttl\n   * 死信之最大长度\n   * 死信之消息被拒\n\n\n# 死信的概念\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 rabbitmq 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效\n\n\n# 死信的来源\n\n * 消息 ttl 过期\n   \n   ttl是time to live的缩写, 也就是生存时间\n\n * 队列达到最大长度\n   \n   队列满了，无法再添加数据到 mq 中\n\n * 消息被拒绝\n   \n   (basic.reject 或 basic.nack) 并且 requeue=false.\n\n\n# 死信实战\n\n\n\n\n# 死信之ttl\n\n消费者 c1 代码：\n\n/**\n * 死信队列 - 消费者01\n *\n * @author zhiyuan\n */\npublic class consumer01 {\n\n    //普通交换机名称\n    private static final string normal_exchange = "normal_exchange";\n    //死信交换机名称\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        channel.exchangedeclare(dead_exchange, builtinexchangetype.direct);\n\n        //声明死信队列\n        string deadqueue = "dead-queue";\n        channel.queuedeclare(deadqueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingkey）\n        channel.queuebind(deadqueue, dead_exchange, "lisi");\n\n        //正常队列绑定死信队列信息\n        map<string, object> params = new hashmap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", dead_exchange);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "lisi");\n\n        //正常队列\n        string normalqueue = "normal-queue";\n        channel.queuedeclare(normalqueue, false, false, false, params);\n        channel.queuebind(normalqueue, normal_exchange, "zhangsan");\n\n        system.out.println("等待接收消息........... ");\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            system.out.println("consumer01 接收到消息" + message);\n        };\n        channel.basicconsume(normalqueue, true, delivercallback, consumertag -> {\n        });\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n生产者代码\n\npublic class producer {\n    private static final string normal_exchange = "normal_exchange";\n\n    public static void main(string[] argv) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        //设置消息的 ttl 时间 10s\n        amqp.basicproperties properties = new amqp.basicproperties().builder().expiration("10000").build();\n        //该信息是用作演示队列个数限制\n        for (int i = 1; i < 11; i++) {\n            string message = "info" + i;\n            channel.basicpublish(normal_exchange, "zhangsan", properties, message.getbytes());\n            system.out.println("生产者发送消息:" + message);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n启动 c1 ，之后关闭消费者，模拟其接收不到消息。再启动 producer\n\n\n\n消费者 c2 代码：\n\n以上步骤完成后，启动 c2 消费者，它消费死信队列里面的消息\n\npublic class consumer02 {\n    //死信交换机名称\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        //声明交换机\n        channel.exchangedeclare(dead_exchange, builtinexchangetype.direct);\n        //声明队列\n        string deadqueue = "dead-queue";\n        channel.queuedeclare(deadqueue, false, false, false, null);\n        channel.queuebind(deadqueue, dead_exchange, "lisi");\n\n        system.out.println("等待接收死信消息........... ");\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            system.out.println("consumer02 接收到消息" + message);\n        };\n        channel.basicconsume(deadqueue, true, delivercallback, consumertag -> {\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n\n# 死信之最大长度\n\n1、消息生产者代码去掉 ttl 属性\n\n\n\n2、c1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**\n\n\n\n//设置正常队列的长度限制，例如发10个，4个则为死信\nparams.put("x-max-length",6);\n\n\n1\n2\n\n\n注意此时需要把原先队列删除 因为参数改变了\n\n3、c2 消费者代码不变(启动 c2 消费者)\n\n\n\n\n# 死信之消息被拒\n\n1、消息生产者代码同上生产者一致\n\n2、c1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)\n\n拒收消息 "info5"\n\npublic class consumer01 {\n\n    //普通交换机名称\n    private static final string normal_exchange = "normal_exchange";\n    //死信交换机名称\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        //声明死信和普通交换机 类型为 direct\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        channel.exchangedeclare(dead_exchange, builtinexchangetype.direct);\n\n        //声明死信队列\n        string deadqueue = "dead-queue";\n        channel.queuedeclare(deadqueue, false, false, false, null);\n        //死信队列绑定：队列、交换机、路由键（routingkey）\n        channel.queuebind(deadqueue, dead_exchange, "lisi");\n        \n        //正常队列绑定死信队列信息\n        map<string, object> params = new hashmap<>();\n        //正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", dead_exchange);\n        //正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "lisi");\n//        //设置正常队列的长度限制，例如发10个，4个则为死信\n//        params.put("x-max-length",6);\n        \n        //正常队列\n        string normalqueue = "normal-queue";\n        channel.queuedeclare(normalqueue, false, false, false, params);\n        channel.queuebind(normalqueue, normal_exchange, "zhangsan");\n\n        system.out.println("等待接收消息........... ");\n        \n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), "utf-8");\n            if (message.equals("info5")) {\n                system.out.println("consumer01 接收到消息" + message + "并拒绝签收该消息");\n                //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中\n                channel.basicreject(delivery.getenvelope().getdeliverytag(), false);\n            } else {\n                system.out.println("consumer01 接收到消息" + message);\n                channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n            }\n\n        };\n        //开启手动应答\n        channel.basicconsume(normalqueue, false, delivercallback, consumertag -> {\n        });\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n\n3、c2 消费者代码不变\n\n启动消费者 1 然后再启动消费者 2\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 简单案例",frontmatter:{title:"RabbitMQ - 简单案例",date:"2021-06-26T13:41:56.000Z",permalink:"/pages/95ce73/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/08.RabbitMQ%20-%20%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B.html",relativePath:"04.框架/20.RabbitMQ/08.RabbitMQ - 简单案例.md",key:"v-4eea68e0",path:"/pages/95ce73/",headers:[{level:2,title:"Hello world",slug:"hello-world",normalizedTitle:"hello world",charIndex:3},{level:2,title:"Work Queues",slug:"work-queues",normalizedTitle:"work queues",charIndex:18},{level:3,title:"轮训分发消息",slug:"轮训分发消息",normalizedTitle:"轮训分发消息",charIndex:35},{level:2,title:"消息应答",slug:"消息应答",normalizedTitle:"消息应答",charIndex:45},{level:3,title:"自动应答",slug:"自动应答",normalizedTitle:"自动应答",charIndex:55},{level:3,title:"手动消息应答的方法",slug:"手动消息应答的方法",normalizedTitle:"手动消息应答的方法",charIndex:65},{level:3,title:"消息自动重新入队",slug:"消息自动重新入队",normalizedTitle:"消息自动重新入队",charIndex:80},{level:3,title:"消息手动应答代码",slug:"消息手动应答代码",normalizedTitle:"消息手动应答代码",charIndex:94},{level:2,title:"RabbitMQ 持久化",slug:"rabbitmq-持久化",normalizedTitle:"rabbitmq 持久化",charIndex:106},{level:2,title:"不公平分发",slug:"不公平分发",normalizedTitle:"不公平分发",charIndex:122},{level:2,title:"预取值分发",slug:"预取值分发",normalizedTitle:"预取值分发",charIndex:131}],headersStr:"Hello world Work Queues 轮训分发消息 消息应答 自动应答 手动消息应答的方法 消息自动重新入队 消息手动应答代码 RabbitMQ 持久化 不公平分发 预取值分发",content:' * Hello world\n * Work Queues\n   * 轮训分发消息\n * 消息应答\n   * 自动应答\n   * 手动消息应答的方法\n   * 消息自动重新入队\n   * 消息手动应答代码\n * RabbitMQ 持久化\n * 不公平分发\n * 预取值分发\n\n\n# Hello world\n\n我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者\n\n在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区\n\n\n\n连接的时候，需要开启 5672 端口\n\n\n\n * 依赖\n\npom.xml\n\n\x3c!--指定 jdk 编译版本--\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <source>8</source>\n                <target>8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n<dependencies>\n    \x3c!--rabbitmq 依赖客户端--\x3e\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n    \x3c!--操作文件流的一个依赖--\x3e\n    <dependency>\n        <groupId>commons-io</groupId>\n        <artifactId>commons-io</artifactId>\n        <version>2.6</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 消息生产者\n\n发送消息\n\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\n/**\n * @author zhiyuan\n */\npublic class Producer {\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("42.192.149.71");\n        factory.setUsername("admin");\n        factory.setPassword("123456");\n        //channel 实现了自动 close 接口 自动关闭 不需要显示关闭\n        //创建连接\n        Connection connection = factory.newConnection();\n        //获取信道\n        Channel channel = connection.createChannel();\n        /**\n         * 生成一个队列\n         * 1.队列名称\n         * 2.队列里面的消息是否持久化 也就是是否用完就删除\n         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费\n         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除\n         * 5.其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        String message = "hello world";\n        /**\n         * 发送一个消息\n         * 1.发送到那个交换机\n         * 2.路由的 key 是哪个\n         * 3.其他的参数信息\n         * 4.发送消息的消息体\n         */\n        channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n        System.out.println("消息发送完毕");\n\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 消息消费者\n\n获取“生产者”发出的消息\n\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.*;\n\n/**\n * @author zhiyuan\n */\npublic class Consumer {\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("42.192.149.71");\n        factory.setUsername("admin");\n        factory.setPassword("123456");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n\n        System.out.println("等待接收消息.........");\n\n        //推送的消息如何进行消费的接口回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println("消息消费被中断");\n        };\n        /**\n         * 消费者消费消息 - 接受消息\n         * 1.消费哪个队列\n         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答\n         * 3.消费者未成功消费的回调\n         * 4.消息被取消时的回调\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# Work Queues\n\nWork Queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n\n# 轮训分发消息\n\n在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。\n\n1、抽取工具类\n\npackage com.oddfar.utils;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMqUtils {\n    //得到一个连接的 channel\n    public static Channel getChannel() throws Exception {\n        //创建一个连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("42.192.149.71");\n        factory.setUsername("admin");\n        factory.setPassword("123456");\n        Connection connection = factory.newConnection();\n        Channel channel = connection.createChannel();\n        return channel;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、启动两个工作线程来接受消息\n\npackage com.oddfar.two;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.CancelCallback;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * 这是一个工作线程，相当于之前的消费者\n *\n * @author zhiyuan\n */\npublic class Worker01 {\n\n    private static final String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //消息接受\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String receivedMessage = new String(delivery.getBody());\n            System.out.println("接收到消息:" + receivedMessage);\n        };\n        //消息被取消\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(consumerTag + "消费者取消消费接口回调逻辑");\n\n        };\n\n        System.out.println("C1 消费者启动等待消费.................. ");\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n选中 Allow multiple instances\n\n启动后\n\n\n\n3、启动一个发送消息线程\n\npublic class Task01 {\n    public static final String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n\n        Channel channel = RabbitMqUtils.getChannel();\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            System.out.println("消息发送完成：" + message);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 结果展示\n\n通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息\n\n\n\n\n# 消息应答\n\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\n\n为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。\n\n\n# 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。\n\n\n# 手动消息应答的方法\n\n * Channel.basicAck(用于肯定确认)\n   \n   RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\n\n * Channel.basicNack(用于否定确认)\n\n * Channel.basicReject(用于否定确认)\n   \n   与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了\n\nMultiple 的解释：\n\n手动应答的好处是可以批量应答并且减少网络拥堵\n\n\n\n * true 代表批量应答 channel 上未应答的消息\n   \n   比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n\n * false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n\n\n\n# 消息自动重新入队\n\n如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n\n\n\n# 消息手动应答代码\n\n默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n\n消费者在上面代码的基础上增加了以下内容\n\nchannel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n\n\n1\n\n\n消息生产者：\n\npackage com.oddfar.three;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.Channel;\n\nimport java.util.Scanner;\n\n/**\n * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费\n *\n * @author zhiyuan\n */\npublic class Task02 {\n    private static final String TASK_QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        //声明队列\n        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入信息");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            //发布消息\n            channel.basicPublish("", TASK_QUEUE_NAME, null, message.getBytes("UTF-8"));\n            System.out.println("生产者发出消息" + message);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n消费者 01：\n\npackage com.oddfar.three;\n\nimport com.oddfar.utils.RabbitMqUtils;\nimport com.rabbitmq.client.CancelCallback;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.DeliverCallback;\n\n/**\n * 消费者01\n *\n * @author zhiyuan\n */\npublic class Work03 {\n    private static final String TASK_QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        System.out.println("C1 等待接收消息处理时间较 短");\n\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("接收到消息:" + message);\n            /**\n             * 1.消息标记 tag\n             * 2.是否批量应答未应答消息\n             */\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n\n        CancelCallback cancelCallback = (s) -> {\n            System.out.println(s + "消费者取消消费接口回调逻辑");\n        };\n\n        //采用手动应答\n        boolean autoAck = false;\n        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n消费者 02：\n\n把时间改成30秒\n\n手动应答效果演示\n\n正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理\n\n\n\n在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了\n\n\n\n\n\n\n\n\n# RabbitMQ 持久化\n\n当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。\n\n队列如何实现持久化\n\n之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化\n\n//让队列持久化\nboolean durable = true;\n//声明队列\nchannel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null);\n\n\n1\n2\n3\n4\n\n\n注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误\n\n\n\n以下为控制台中持久化与非持久化队列的 UI 显示区、\n\n\n\n消息实现持久化\n\n需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性。\n\n\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。\n\n如果需要更强有力的持久化策略，参考后边课件发布确认章节。\n\n\n# 不公平分发\n\n在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。\n\n为了避免这种情况，在消费者中消费之前，我们可以设置参数 channel.basicQos(1);\n\n//不公平分发\nint prefetchCount = 1;\nchannel.basicQos(prefetchCount);\n//采用手动应答\nboolean autoAck = false;\nchannel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n\n意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。\n\n\n# 预取值分发\n\n带权的消息分发\n\n本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。\n\n该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。\n\n通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n\n预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n',normalizedContent:' * hello world\n * work queues\n   * 轮训分发消息\n * 消息应答\n   * 自动应答\n   * 手动消息应答的方法\n   * 消息自动重新入队\n   * 消息手动应答代码\n * rabbitmq 持久化\n * 不公平分发\n * 预取值分发\n\n\n# hello world\n\n我们将用 java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者\n\n在下图中，“ p” 是我们的生产者，“ c” 是我们的消费者。中间的框是一个队列 rabbitmq 代表使用者保留的消息缓冲区\n\n\n\n连接的时候，需要开启 5672 端口\n\n\n\n * 依赖\n\npom.xml\n\n\x3c!--指定 jdk 编译版本--\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.apache.maven.plugins</groupid>\n            <artifactid>maven-compiler-plugin</artifactid>\n            <configuration>\n                <source>8</source>\n                <target>8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n<dependencies>\n    \x3c!--rabbitmq 依赖客户端--\x3e\n    <dependency>\n        <groupid>com.rabbitmq</groupid>\n        <artifactid>amqp-client</artifactid>\n        <version>5.8.0</version>\n    </dependency>\n    \x3c!--操作文件流的一个依赖--\x3e\n    <dependency>\n        <groupid>commons-io</groupid>\n        <artifactid>commons-io</artifactid>\n        <version>2.6</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 消息生产者\n\n发送消息\n\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.connection;\nimport com.rabbitmq.client.connectionfactory;\n\n/**\n * @author zhiyuan\n */\npublic class producer {\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        //创建一个连接工厂\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("42.192.149.71");\n        factory.setusername("admin");\n        factory.setpassword("123456");\n        //channel 实现了自动 close 接口 自动关闭 不需要显示关闭\n        //创建连接\n        connection connection = factory.newconnection();\n        //获取信道\n        channel channel = connection.createchannel();\n        /**\n         * 生成一个队列\n         * 1.队列名称\n         * 2.队列里面的消息是否持久化 也就是是否用完就删除\n         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费\n         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除\n         * 5.其他参数\n         */\n        channel.queuedeclare(queue_name, false, false, false, null);\n        string message = "hello world";\n        /**\n         * 发送一个消息\n         * 1.发送到那个交换机\n         * 2.路由的 key 是哪个\n         * 3.其他的参数信息\n         * 4.发送消息的消息体\n         */\n        channel.basicpublish("", queue_name, null, message.getbytes());\n        system.out.println("消息发送完毕");\n\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 消息消费者\n\n获取“生产者”发出的消息\n\npackage com.oddfar.one;\n\nimport com.rabbitmq.client.*;\n\n/**\n * @author zhiyuan\n */\npublic class consumer {\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("42.192.149.71");\n        factory.setusername("admin");\n        factory.setpassword("123456");\n        connection connection = factory.newconnection();\n        channel channel = connection.createchannel();\n\n        system.out.println("等待接收消息.........");\n\n        //推送的消息如何进行消费的接口回调\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody());\n            system.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        cancelcallback cancelcallback = (consumertag) -> {\n            system.out.println("消息消费被中断");\n        };\n        /**\n         * 消费者消费消息 - 接受消息\n         * 1.消费哪个队列\n         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答\n         * 3.消费者未成功消费的回调\n         * 4.消息被取消时的回调\n         */\n        channel.basicconsume(queue_name, true, delivercallback, cancelcallback);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# work queues\n\nwork queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n\n# 轮训分发消息\n\n在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。\n\n1、抽取工具类\n\npackage com.oddfar.utils;\n\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.connection;\nimport com.rabbitmq.client.connectionfactory;\n\npublic class rabbitmqutils {\n    //得到一个连接的 channel\n    public static channel getchannel() throws exception {\n        //创建一个连接工厂\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("42.192.149.71");\n        factory.setusername("admin");\n        factory.setpassword("123456");\n        connection connection = factory.newconnection();\n        channel channel = connection.createchannel();\n        return channel;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、启动两个工作线程来接受消息\n\npackage com.oddfar.two;\n\nimport com.oddfar.utils.rabbitmqutils;\nimport com.rabbitmq.client.cancelcallback;\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.delivercallback;\n\n/**\n * 这是一个工作线程，相当于之前的消费者\n *\n * @author zhiyuan\n */\npublic class worker01 {\n\n    private static final string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n\n        channel channel = rabbitmqutils.getchannel();\n\n        //消息接受\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string receivedmessage = new string(delivery.getbody());\n            system.out.println("接收到消息:" + receivedmessage);\n        };\n        //消息被取消\n        cancelcallback cancelcallback = (consumertag) -> {\n            system.out.println(consumertag + "消费者取消消费接口回调逻辑");\n\n        };\n\n        system.out.println("c1 消费者启动等待消费.................. ");\n        channel.basicconsume(queue_name, true, delivercallback, cancelcallback);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n选中 allow multiple instances\n\n启动后\n\n\n\n3、启动一个发送消息线程\n\npublic class task01 {\n    public static final string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n\n        channel channel = rabbitmqutils.getchannel();\n\n        scanner scanner = new scanner(system.in);\n        while (scanner.hasnext()) {\n            string message = scanner.next();\n            channel.basicpublish("", queue_name, null, message.getbytes());\n            system.out.println("消息发送完成：" + message);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 结果展示\n\n通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息\n\n\n\n\n# 消息应答\n\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。rabbitmq 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\n\n为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。\n\n\n# 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。\n\n\n# 手动消息应答的方法\n\n * channel.basicack(用于肯定确认)\n   \n   rabbitmq 已知道该消息并且成功的处理消息，可以将其丢弃了\n\n * channel.basicnack(用于否定确认)\n\n * channel.basicreject(用于否定确认)\n   \n   与 channel.basicnack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了\n\nmultiple 的解释：\n\n手动应答的好处是可以批量应答并且减少网络拥堵\n\n\n\n * true 代表批量应答 channel 上未应答的消息\n   \n   比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n\n * false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n\n\n\n# 消息自动重新入队\n\n如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 tcp 连接丢失)，导致消息未发送 ack 确认，rabbitmq 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n\n\n\n# 消息手动应答代码\n\n默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n\n消费者在上面代码的基础上增加了以下内容\n\nchannel.basicack(delivery.getenvelope().getdeliverytag(), false);\n\n\n1\n\n\n消息生产者：\n\npackage com.oddfar.three;\n\nimport com.oddfar.utils.rabbitmqutils;\nimport com.rabbitmq.client.channel;\n\nimport java.util.scanner;\n\n/**\n * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费\n *\n * @author zhiyuan\n */\npublic class task02 {\n    private static final string task_queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        //声明队列\n        channel.queuedeclare(task_queue_name, false, false, false, null);\n        scanner sc = new scanner(system.in);\n        system.out.println("请输入信息");\n        while (sc.hasnext()) {\n            string message = sc.nextline();\n            //发布消息\n            channel.basicpublish("", task_queue_name, null, message.getbytes("utf-8"));\n            system.out.println("生产者发出消息" + message);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n消费者 01：\n\npackage com.oddfar.three;\n\nimport com.oddfar.utils.rabbitmqutils;\nimport com.rabbitmq.client.cancelcallback;\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.delivercallback;\n\n/**\n * 消费者01\n *\n * @author zhiyuan\n */\npublic class work03 {\n    private static final string task_queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        system.out.println("c1 等待接收消息处理时间较 短");\n\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody());\n            try {\n                thread.sleep(1000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("接收到消息:" + message);\n            /**\n             * 1.消息标记 tag\n             * 2.是否批量应答未应答消息\n             */\n            channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n        };\n\n        cancelcallback cancelcallback = (s) -> {\n            system.out.println(s + "消费者取消消费接口回调逻辑");\n        };\n\n        //采用手动应答\n        boolean autoack = false;\n        channel.basicconsume(task_queue_name, autoack, delivercallback, cancelcallback);\n\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n消费者 02：\n\n把时间改成30秒\n\n手动应答效果演示\n\n正常情况下消息发送方发送两个消息 c1 和 c2 分别接收到消息并进行处理\n\n\n\n在发送者发送消息 dd，发出消息之后的把 c2 消费者停掉，按理说该 c2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 c2 还没有执行 ack 代码的时候，c2 被停掉了， 此时会看到消息被 c1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 c1 处理了\n\n\n\n\n\n\n\n\n# rabbitmq 持久化\n\n当 rabbitmq 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 rabbitmq 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。\n\n队列如何实现持久化\n\n之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化\n\n//让队列持久化\nboolean durable = true;\n//声明队列\nchannel.queuedeclare(task_queue_name, durable, false, false, null);\n\n\n1\n2\n3\n4\n\n\n注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误\n\n\n\n以下为控制台中持久化与非持久化队列的 ui 显示区、\n\n\n\n消息实现持久化\n\n需要在消息生产者修改代码，messageproperties.persistent_text_plain 添加这个属性。\n\n\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 rabbitmq 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。\n\n如果需要更强有力的持久化策略，参考后边课件发布确认章节。\n\n\n# 不公平分发\n\n在最开始的时候我们学习到 rabbitmq 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 rabbitmq 并不知道这种情况它依然很公平的进行分发。\n\n为了避免这种情况，在消费者中消费之前，我们可以设置参数 channel.basicqos(1);\n\n//不公平分发\nint prefetchcount = 1;\nchannel.basicqos(prefetchcount);\n//采用手动应答\nboolean autoack = false;\nchannel.basicconsume(task_queue_name, autoack, delivercallback, cancelcallback);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n\n意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。\n\n\n# 预取值分发\n\n带权的消息分发\n\n本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。\n\n该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， rabbitmq 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时rabbitmq 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ack，rabbitmq 将会感知 这个情况到并再发送一条消息。消息应答和 qos 预取值对用户吞吐量有重大影响。\n\n通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 ram 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n\n预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 延迟队列",frontmatter:{title:"RabbitMQ - 延迟队列",date:"2021-06-28T10:38:11.000Z",permalink:"/pages/0a0086/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/16.RabbitMQ%20-%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.html",relativePath:"04.框架/20.RabbitMQ/16.RabbitMQ - 延迟队列.md",key:"v-aa511c30",path:"/pages/0a0086/",headers:[{level:2,title:"延迟队列介绍",slug:"延迟队列介绍",normalizedTitle:"延迟队列介绍",charIndex:3},{level:2,title:"RabbitMQ 中的 TTL",slug:"rabbitmq-中的-ttl",normalizedTitle:"rabbitmq 中的 ttl",charIndex:13},{level:2,title:"整合 springboot",slug:"整合-springboot",normalizedTitle:"整合 springboot",charIndex:32},{level:2,title:"队列 TTL",slug:"队列-ttl",normalizedTitle:"队列 ttl",charIndex:49},{level:2,title:"延时队列TTL优化",slug:"延时队列ttl优化",normalizedTitle:"延时队列ttl优化",charIndex:59},{level:2,title:"Rabbitmq 插件实现延迟队列",slug:"rabbitmq-插件实现延迟队列",normalizedTitle:"rabbitmq 插件实现延迟队列",charIndex:72},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:93}],headersStr:"延迟队列介绍 RabbitMQ 中的 TTL 整合 springboot 队列 TTL 延时队列TTL优化 Rabbitmq 插件实现延迟队列 总结",content:' * 延迟队列介绍\n * RabbitMQ 中的 TTL\n * 整合 springboot\n * 队列 TTL\n * 延时队列TTL优化\n * Rabbitmq 插件实现延迟队列\n * 总结\n\n\n# 延迟队列介绍\n\n * 延迟队列概念：\n\n延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。\n\n * 延迟队列使用场景：\n\n1.订单在十分钟之内未支付则自动取消 2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 3.用户注册成功后，如果三天内没有登陆则进行短信提醒。 4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。 5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？\n\n如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n\n\n\n# RabbitMQ 中的 TTL\n\nTTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n\n换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。\n\n * 队列设置TTL\n\n在创建队列的时候设置队列的“x-message-ttl”属性\n\n\n\n * 消息设置TTL\n\n是针对每条消息设置TTL\n\n\n\n两者的区别\n\n如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；\n\n另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n\n# 整合 springboot\n\n前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。\n\n1、创建一个空项目：\n\n\n\n2、添加依赖：\n\n<dependencies>\n   <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    \x3c!--RabbitMQ 依赖--\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>1.2.47</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    \x3c!--swagger--\x3e\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger2</artifactId>\n        <version>3.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger-ui</artifactId>\n        <version>3.0.0</version>\n    </dependency>\n    \x3c!--RabbitMQ 测试依赖--\x3e\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n3、修改配置文件\n\nspring.rabbitmq.host=42.192.149.71\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=123456\n\n\n1\n2\n3\n4\n\n\n4、添加Swagger 配置类\n\npackage com.oddfar.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket webApiConfig() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .groupName("webApi")\n                .apiInfo(webApiInfo())\n                .select()\n                .build();\n    }\n\n    private ApiInfo webApiInfo() {\n        return new ApiInfoBuilder()\n                .title("rabbitmq 接口文档")\n                .description("本文档描述了 rabbitmq 微服务接口定义")\n                .version("1.0")\n                .contact(new Contact("zhiyuan", "http://oddfar.com", "test@qq.com"))\n                .build();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 队列 TTL\n\n * 代码架构图\n\n创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：\n\n\n\n原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息\n\n1、配置文件类代码 ：\n\npackage com.oddfar.config;\n\nimport org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author zhiyuan\n */\n@Configuration\npublic class TtlQueueConfig {\n    public static final String X_EXCHANGE = "X";\n    public static final String QUEUE_A = "QA";\n    public static final String QUEUE_B = "QB";\n    //死信交换机\n    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";\n    //死信队列\n    public static final String DEAD_LETTER_QUEUE = "QD";\n\n    // 声明 xExchange\n    @Bean("xExchange")\n    public DirectExchange xExchange() {\n        return new DirectExchange(X_EXCHANGE);\n    }\n\n    // 声明 死信队列交换机\n    @Bean("yExchange")\n    public DirectExchange yExchange() {\n        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);\n    }\n\n    //声明队列 A ttl 为 10s 并绑定到对应的死信交换机\n    @Bean("queueA")\n    public Queue queueA() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        //声明队列的 TTL\n        args.put("x-message-ttl", 10000);\n        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();\n    }\n\n    // 声明队列 A 绑定 X 交换机\n    @Bean\n    public Binding queueaBindingX(@Qualifier("queueA") Queue queueA,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(queueA).to(xExchange).with("XA");\n    }\n\n    //声明队列 B ttl 为 40s 并绑定到对应的死信交换机\n    @Bean("queueB")\n    public Queue queueB() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        //声明队列的 TTL\n        args.put("x-message-ttl", 40000);\n        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();\n    }\n\n    //声明队列 B 绑定 X 交换机\n    @Bean\n    public Binding queuebBindingX(@Qualifier("queueB") Queue queue1B,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(queue1B).to(xExchange).with("XB");\n    }\n\n    //声明死信队列 QD\n    @Bean("queueD")\n    public Queue queueD() {\n        return new Queue(DEAD_LETTER_QUEUE);\n    }\n\n    //声明死信队列 QD 绑定关系\n    @Bean\n    public Binding deadLetterBindingQAD(@Qualifier("queueD") Queue queueD,\n                                        @Qualifier("yExchange") DirectExchange yExchange) {\n        return BindingBuilder.bind(queueD).to(yExchange).with("YD");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n2、消息生产者代码\n\npackage com.oddfar.contorller;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Date;\n\n/**\n * @author zhiyuan\n */\n@Slf4j\n@RequestMapping("ttl")\n@RestController\npublic class SendMsgController {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("sendMsg/{message}")\n    public void sendMsg(@PathVariable String message) {\n        log.info("当前时间：{},发送一条信息给两个 TTL 队列:{}", new Date(), message);\n        rabbitTemplate.convertAndSend("X", "XA", "消息来自 ttl 为 10S 的队列: " + message);\n        rabbitTemplate.convertAndSend("X", "XB", "消息来自 ttl 为 40S 的队列: " + message);\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n3、消息消费者代码\n\npackage com.oddfar.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.Date;\n\n/**\n * 消费者 - 死信队列\n * @author zhiyuan\n */\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = "QD")\n    public void receiveD(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info("当前时间：{},收到死信队列信息{}", new Date().toString(), msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n发起一个请求 http://localhost:8080/ttl/sendMsg/嘻嘻嘻\n\n\n\n第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。\n\n不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？\n\n\n# 延时队列TTL优化\n\n在这里新增了一个队列 QC,绑定关系如下,该队列不设置TTL 时间\n\n\n\n配置文件类代码：\n\n@Configuration\npublic class MsgTtlQueueConfig {\n    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";\n    public static final String QUEUE_C = "QC";\n\n    //声明队列 C 死信交换机\n    @Bean("queueC")\n    public Queue queueB() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        //没有声明 TTL 属性\n        return QueueBuilder.durable(QUEUE_C).withArguments(args).build();\n    }\n\n    //声明队列 B 绑定 X 交换机\n    @Bean\n    public Binding queuecBindingX(@Qualifier("queueC") Queue queueC,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(queueC).to(xExchange).with("XC");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n生产者代码：\n\n/**\n * 延时队列优化\n * @param message 消息\n * @param ttlTime 延时的毫秒\n */\n@GetMapping("sendExpirationMsg/{message}/{ttlTime}")\npublic void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {\n    rabbitTemplate.convertAndSend("X", "XC", message, correlationData -> {\n        correlationData.getMessageProperties().setExpiration(ttlTime);\n        return correlationData;\n    });\n    log.info("当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}", new Date(), ttlTime, message);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n发起请求\n\nhttp://localhost:8080/ttl/sendExpirationMsg/你好1/20000\n\nhttp://localhost:8080/ttl/sendExpirationMsg/你好2/2000\n\n\n\n看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“\n\n因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n\n这也就是为什么第二个延时2秒，却后执行。\n\n\n# Rabbitmq 插件实现延迟队列\n\n上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\n\n安装延时队列插件\n\n可去官网下载 rabbitmq_delayed_message_exchange 插件，放置到 RabbitMQ 的插件目录。\n\n进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ\n\n[root@VM-0-6-centos software]# ls\nerlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm\n#移动\ncp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins\n#安装\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\n#重启服务\nsystemctl restart rabbitmq-server\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n代码\n\n在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:\n\n\n\n1、配置文件类代码：\n\n在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n\n@Configuration\npublic class DelayedQueueConfig {\n    public static final String DELAYED_QUEUE_NAME = "delayed.queue";\n    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";\n    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";\n\n    @Bean\n    public Queue delayedQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    //自定义交换机 我们在这里定义的是一个延迟交换机\n    @Bean\n    public CustomExchange delayedExchange() {\n        Map<String, Object> args = new HashMap<>();\n        //自定义交换机的类型\n        args.put("x-delayed-type", "direct");\n        return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, args);\n    }\n\n    @Bean\n    public Binding bindingDelayedQueue(@Qualifier("delayedQueue") Queue queue,\n                                       @Qualifier("delayedExchange") CustomExchange delayedExchange) {\n        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n2、生产者代码\n\n@GetMapping("sendDelayMsg/{message}/{delayTime}")\npublic void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {\n    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,\n            correlationData -> {\n                correlationData.getMessageProperties().setDelay(delayTime);\n                return correlationData;\n            });\n    log.info(" 当 前 时 间 ： {}, 发 送 一 条 延 迟 {} 毫秒的信息给队列 delayed.queue:{}", new Date(), delayTime, message);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n3、消费者代码\n\n/**\n * 消费者 - 基于插件的延时队列\n *\n * @author zhiyuan\n */\n@Slf4j\n@ComponentScan\npublic class DelayQueueConsumer {\n\n    public static final String DELAYED_QUEUE_NAME = "delayed.queue";\n\n    @RabbitListener(queues = DELAYED_QUEUE_NAME)\n    public void receiveDelayedQueue(Message message) {\n        String msg = new String(message.getBody());\n        log.info("当前时间：{},收到延时队列的消息：{}", new Date().toString(), msg);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n发送请求：\n\n * http://localhost:8080/ttl/sendDelayMsg/hello1/20000\n * http://localhost:8080/ttl/sendDelayMsg/hello2/2000\n\n\n\n第二个消息被先消费掉了，符合预期\n\n\n# 总结\n\n延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。\n\n当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景',normalizedContent:' * 延迟队列介绍\n * rabbitmq 中的 ttl\n * 整合 springboot\n * 队列 ttl\n * 延时队列ttl优化\n * rabbitmq 插件实现延迟队列\n * 总结\n\n\n# 延迟队列介绍\n\n * 延迟队列概念：\n\n延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。\n\n * 延迟队列使用场景：\n\n1.订单在十分钟之内未支付则自动取消 2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 3.用户注册成功后，如果三天内没有登陆则进行短信提醒。 4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。 5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？\n\n如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n\n\n\n# rabbitmq 中的 ttl\n\nttl 是什么呢？ttl 是 rabbitmq 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n\n换句话说，如果一条消息设置了 ttl 属性或者进入了设置ttl 属性的队列，那么这条消息如果在 ttl 设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的ttl 和消息的 ttl，那么较小的那个值将会被使用，有两种方式设置 ttl。\n\n * 队列设置ttl\n\n在创建队列的时候设置队列的“x-message-ttl”属性\n\n\n\n * 消息设置ttl\n\n是针对每条消息设置ttl\n\n\n\n两者的区别\n\n如果设置了队列的 ttl 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；\n\n另外，还需要注意的一点是，如果不设置 ttl，表示消息永远不会过期，如果将 ttl 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n\n# 整合 springboot\n\n前一小节我们介绍了死信队列，刚刚又介绍了 ttl，至此利用 rabbitmq 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，ttl 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。\n\n1、创建一个空项目：\n\n\n\n2、添加依赖：\n\n<dependencies>\n   <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter</artifactid>\n    </dependency>\n    \x3c!--rabbitmq 依赖--\x3e\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-amqp</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-test</artifactid>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>fastjson</artifactid>\n        <version>1.2.47</version>\n    </dependency>\n    <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n    </dependency>\n    \x3c!--swagger--\x3e\n    <dependency>\n        <groupid>io.springfox</groupid>\n        <artifactid>springfox-swagger2</artifactid>\n        <version>3.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>io.springfox</groupid>\n        <artifactid>springfox-swagger-ui</artifactid>\n        <version>3.0.0</version>\n    </dependency>\n    \x3c!--rabbitmq 测试依赖--\x3e\n    <dependency>\n        <groupid>org.springframework.amqp</groupid>\n        <artifactid>spring-rabbit-test</artifactid>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n3、修改配置文件\n\nspring.rabbitmq.host=42.192.149.71\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=123456\n\n\n1\n2\n3\n4\n\n\n4、添加swagger 配置类\n\npackage com.oddfar.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport springfox.documentation.builders.apiinfobuilder;\nimport springfox.documentation.service.apiinfo;\nimport springfox.documentation.service.contact;\nimport springfox.documentation.spi.documentationtype;\nimport springfox.documentation.spring.web.plugins.docket;\nimport springfox.documentation.swagger2.annotations.enableswagger2;\n\n\n@configuration\n@enableswagger2\npublic class swaggerconfig {\n\n    @bean\n    public docket webapiconfig() {\n        return new docket(documentationtype.swagger_2)\n                .groupname("webapi")\n                .apiinfo(webapiinfo())\n                .select()\n                .build();\n    }\n\n    private apiinfo webapiinfo() {\n        return new apiinfobuilder()\n                .title("rabbitmq 接口文档")\n                .description("本文档描述了 rabbitmq 微服务接口定义")\n                .version("1.0")\n                .contact(new contact("zhiyuan", "http://oddfar.com", "test@qq.com"))\n                .build();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 队列 ttl\n\n * 代码架构图\n\n创建两个队列 qa 和 qb，两者队列 ttl 分别设置为 10s 和 40s，然后在创建一个交换机 x 和死信交 换机 y，它们的类型都是direct，创建一个死信队列 qd，它们的绑定关系如下：\n\n\n\n原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息\n\n1、配置文件类代码 ：\n\npackage com.oddfar.config;\n\nimport org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\nimport java.util.hashmap;\nimport java.util.map;\n\n/**\n * @author zhiyuan\n */\n@configuration\npublic class ttlqueueconfig {\n    public static final string x_exchange = "x";\n    public static final string queue_a = "qa";\n    public static final string queue_b = "qb";\n    //死信交换机\n    public static final string y_dead_letter_exchange = "y";\n    //死信队列\n    public static final string dead_letter_queue = "qd";\n\n    // 声明 xexchange\n    @bean("xexchange")\n    public directexchange xexchange() {\n        return new directexchange(x_exchange);\n    }\n\n    // 声明 死信队列交换机\n    @bean("yexchange")\n    public directexchange yexchange() {\n        return new directexchange(y_dead_letter_exchange);\n    }\n\n    //声明队列 a ttl 为 10s 并绑定到对应的死信交换机\n    @bean("queuea")\n    public queue queuea() {\n        map<string, object> args = new hashmap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        //声明队列的 ttl\n        args.put("x-message-ttl", 10000);\n        return queuebuilder.durable(queue_a).witharguments(args).build();\n    }\n\n    // 声明队列 a 绑定 x 交换机\n    @bean\n    public binding queueabindingx(@qualifier("queuea") queue queuea,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(queuea).to(xexchange).with("xa");\n    }\n\n    //声明队列 b ttl 为 40s 并绑定到对应的死信交换机\n    @bean("queueb")\n    public queue queueb() {\n        map<string, object> args = new hashmap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        //声明队列的 ttl\n        args.put("x-message-ttl", 40000);\n        return queuebuilder.durable(queue_b).witharguments(args).build();\n    }\n\n    //声明队列 b 绑定 x 交换机\n    @bean\n    public binding queuebbindingx(@qualifier("queueb") queue queue1b,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(queue1b).to(xexchange).with("xb");\n    }\n\n    //声明死信队列 qd\n    @bean("queued")\n    public queue queued() {\n        return new queue(dead_letter_queue);\n    }\n\n    //声明死信队列 qd 绑定关系\n    @bean\n    public binding deadletterbindingqad(@qualifier("queued") queue queued,\n                                        @qualifier("yexchange") directexchange yexchange) {\n        return bindingbuilder.bind(queued).to(yexchange).with("yd");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n2、消息生产者代码\n\npackage com.oddfar.contorller;\n\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.amqp.rabbit.core.rabbittemplate;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\nimport java.util.date;\n\n/**\n * @author zhiyuan\n */\n@slf4j\n@requestmapping("ttl")\n@restcontroller\npublic class sendmsgcontroller {\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("sendmsg/{message}")\n    public void sendmsg(@pathvariable string message) {\n        log.info("当前时间：{},发送一条信息给两个 ttl 队列:{}", new date(), message);\n        rabbittemplate.convertandsend("x", "xa", "消息来自 ttl 为 10s 的队列: " + message);\n        rabbittemplate.convertandsend("x", "xb", "消息来自 ttl 为 40s 的队列: " + message);\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n3、消息消费者代码\n\npackage com.oddfar.consumer;\n\nimport com.rabbitmq.client.channel;\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.amqp.core.message;\nimport org.springframework.amqp.rabbit.annotation.rabbitlistener;\nimport org.springframework.stereotype.component;\n\nimport java.io.ioexception;\nimport java.util.date;\n\n/**\n * 消费者 - 死信队列\n * @author zhiyuan\n */\n@slf4j\n@component\npublic class deadletterqueueconsumer {\n\n    @rabbitlistener(queues = "qd")\n    public void received(message message, channel channel) throws ioexception {\n        string msg = new string(message.getbody());\n        log.info("当前时间：{},收到死信队列信息{}", new date().tostring(), msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n发起一个请求 http://localhost:8080/ttl/sendmsg/嘻嘻嘻\n\n\n\n第一条消息在 10s 后变成了死信消息，然后被消费者消费掉，第二条消息在 40s 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。\n\n不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10s 和 40s 两个时间选项，如果需要一个小时后处理，那么就需要增加ttl 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？\n\n\n# 延时队列ttl优化\n\n在这里新增了一个队列 qc,绑定关系如下,该队列不设置ttl 时间\n\n\n\n配置文件类代码：\n\n@configuration\npublic class msgttlqueueconfig {\n    public static final string y_dead_letter_exchange = "y";\n    public static final string queue_c = "qc";\n\n    //声明队列 c 死信交换机\n    @bean("queuec")\n    public queue queueb() {\n        map<string, object> args = new hashmap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        //没有声明 ttl 属性\n        return queuebuilder.durable(queue_c).witharguments(args).build();\n    }\n\n    //声明队列 b 绑定 x 交换机\n    @bean\n    public binding queuecbindingx(@qualifier("queuec") queue queuec,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(queuec).to(xexchange).with("xc");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n生产者代码：\n\n/**\n * 延时队列优化\n * @param message 消息\n * @param ttltime 延时的毫秒\n */\n@getmapping("sendexpirationmsg/{message}/{ttltime}")\npublic void sendmsg(@pathvariable string message, @pathvariable string ttltime) {\n    rabbittemplate.convertandsend("x", "xc", message, correlationdata -> {\n        correlationdata.getmessageproperties().setexpiration(ttltime);\n        return correlationdata;\n    });\n    log.info("当前时间：{},发送一条时长{}毫秒 ttl 信息给队列 c:{}", new date(), ttltime, message);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n发起请求\n\nhttp://localhost:8080/ttl/sendexpirationmsg/你好1/20000\n\nhttp://localhost:8080/ttl/sendexpirationmsg/你好2/2000\n\n\n\n看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 ttl 的方式，消息可能并不会按时“死亡“\n\n因为 rabbitmq 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n\n这也就是为什么第二个延时2秒，却后执行。\n\n\n# rabbitmq 插件实现延迟队列\n\n上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 ttl，并使其在设置的ttl 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\n\n安装延时队列插件\n\n可去官网下载 rabbitmq_delayed_message_exchange 插件，放置到 rabbitmq 的插件目录。\n\n进入 rabbitmq 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 rabbitmq\n\n[root@vm-0-6-centos software]# ls\nerlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm\n#移动\ncp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins\n#安装\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\n#重启服务\nsystemctl restart rabbitmq-server\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n代码\n\n在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:\n\n\n\n1、配置文件类代码：\n\n在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n\n@configuration\npublic class delayedqueueconfig {\n    public static final string delayed_queue_name = "delayed.queue";\n    public static final string delayed_exchange_name = "delayed.exchange";\n    public static final string delayed_routing_key = "delayed.routingkey";\n\n    @bean\n    public queue delayedqueue() {\n        return new queue(delayed_queue_name);\n    }\n\n    //自定义交换机 我们在这里定义的是一个延迟交换机\n    @bean\n    public customexchange delayedexchange() {\n        map<string, object> args = new hashmap<>();\n        //自定义交换机的类型\n        args.put("x-delayed-type", "direct");\n        return new customexchange(delayed_exchange_name, "x-delayed-message", true, false, args);\n    }\n\n    @bean\n    public binding bindingdelayedqueue(@qualifier("delayedqueue") queue queue,\n                                       @qualifier("delayedexchange") customexchange delayedexchange) {\n        return bindingbuilder.bind(queue).to(delayedexchange).with(delayed_routing_key).noargs();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n2、生产者代码\n\n@getmapping("senddelaymsg/{message}/{delaytime}")\npublic void sendmsg(@pathvariable string message, @pathvariable integer delaytime) {\n    rabbittemplate.convertandsend(delayed_exchange_name, delayed_routing_key, message,\n            correlationdata -> {\n                correlationdata.getmessageproperties().setdelay(delaytime);\n                return correlationdata;\n            });\n    log.info(" 当 前 时 间 ： {}, 发 送 一 条 延 迟 {} 毫秒的信息给队列 delayed.queue:{}", new date(), delaytime, message);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n3、消费者代码\n\n/**\n * 消费者 - 基于插件的延时队列\n *\n * @author zhiyuan\n */\n@slf4j\n@componentscan\npublic class delayqueueconsumer {\n\n    public static final string delayed_queue_name = "delayed.queue";\n\n    @rabbitlistener(queues = delayed_queue_name)\n    public void receivedelayedqueue(message message) {\n        string msg = new string(message.getbody());\n        log.info("当前时间：{},收到延时队列的消息：{}", new date().tostring(), msg);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n发送请求：\n\n * http://localhost:8080/ttl/senddelaymsg/hello1/20000\n * http://localhost:8080/ttl/senddelaymsg/hello2/2000\n\n\n\n第二个消息被先消费掉了，符合预期\n\n\n# 总结\n\n延时队列在需要延时处理的场景下非常有用，使用 rabbitmq 来实现延时队列可以很好的利用 rabbitmq 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 rabbitmq 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。\n\n当然，延时队列还有很多其它选择，比如利用 java 的 delayqueue，利用 redis 的 zset，利用 quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 发布确认高级",frontmatter:{title:"RabbitMQ - 发布确认高级",date:"2021-06-29T13:06:08.000Z",permalink:"/pages/c94906/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/18.RabbitMQ%20-%20%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7.html",relativePath:"04.框架/20.RabbitMQ/18.RabbitMQ - 发布确认高级.md",key:"v-ec96f538",path:"/pages/c94906/",headers:[{level:2,title:"发布确认 springboot 版本",slug:"发布确认-springboot-版本",normalizedTitle:"发布确认 springboot 版本",charIndex:3},{level:2,title:"回退消息",slug:"回退消息",normalizedTitle:"回退消息",charIndex:25},{level:2,title:"备份交换机",slug:"备份交换机",normalizedTitle:"备份交换机",charIndex:33}],headersStr:"发布确认 springboot 版本 回退消息 备份交换机",content:' * 发布确认 springboot 版本\n * 回退消息\n * 备份交换机\n\n在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？\n\n\n# 发布确认 springboot 版本\n\n确认机制方案：\n\n\n\n代码架构图：\n\n\n\n在配置文件当中需要添加\n\nspring.rabbitmq.publisher-confirm-type=correlated\n\n\n1\n\n\n * NONE 值是禁用发布确认模式，是默认值\n\n * CORRELATED 值是发布消息成功到交换器后会触发回调方法\n\n * SIMPLE 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;\n\n代码\n\n1、添加配置类：\n\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n\n    //声明业务 Exchange\n    @Bean("confirmExchange")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n\n    // 声明确认队列\n    @Bean("confirmQueue")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    // 声明确认队列绑定关系\n    @Bean\n    public Binding queueBinding(@Qualifier("confirmQueue") Queue queue,\n                                @Qualifier("confirmExchange") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with("key1");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n2、消息生产者的回调接口\n\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback {\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : "";\n        if (ack) {\n            log.info("交换机已经收到 id 为:{}的消息", id);\n        } else {\n            log.info("交换机还未收到 id 为:{}消息，原因:{}", id, cause);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n3、消息生产者\n\n@RestController\n@RequestMapping("/confirm")\n@Slf4j\npublic class ProducerController {\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    @Autowired\n    private MyCallBack myCallBack;\n\n    //依赖注入 rabbitTemplate 之后再设置它的回调对象\n    @PostConstruct\n    public void init() {\n        rabbitTemplate.setConfirmCallback(myCallBack);\n    }\n    \n    /**\n     * 消息回调和退回\n     *\n     * @param message\n     */\n    @GetMapping("sendMessage/{message}")\n    public void sendMessage(@PathVariable String message) {\n\n        //指定消息 id 为 1\n        CorrelationData correlationData1 = new CorrelationData("1");\n        String routingKey = "key1";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);\n        log.info(routingKey + "发送消息内容:{}", message + routingKey);\n\n        CorrelationData correlationData2 = new CorrelationData("2");\n        routingKey = "key2";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);\n        log.info(routingKey + "发送消息内容:{}", message + routingKey);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n4、消息消费者\n\n@Component\n@Slf4j\npublic class ConfirmConsumer {\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n\n    @RabbitListener(queues = CONFIRM_QUEUE_NAME)\n    public void receiveMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.info("接受到队列 confirm.queue 消息:{}", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n访问： http://localhost:8080/confirm/sendMessage/你好\n\n结果分析：\n\n\n\n可以看到，发送了两条消息，第一条消息的 RoutingKey 为 "key1"，第二条消息的 RoutingKey 为 "key2"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n\n丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败\n\n\n# 回退消息\n\nMandatory 参数\n\nrabbitTemplate.setReturnsCallback(myCallBack);\n\n\n1\n\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。\n\n那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n\n1、修改配置\n\n#消息退回\nspring.rabbitmq.publisher-returns=true\n\n\n1\n2\n\n\n2、修改回调接口\n\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {\n\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : "";\n        if (ack) {\n            log.info("交换机已经收到 id 为:{}的消息", id);\n        } else {\n            log.info("交换机还未收到 id 为:{}消息，原因:{}", id, cause);\n        }\n    }\n\n    //当消息无法路由的时候的回调方法\n    @Override\n    public void returnedMessage(ReturnedMessage returned) {\n\n        log.error("消息：{}，被交换机 {} 退回，原因：{}，路由key：{},code:{}",\n                new String(returned.getMessage().getBody()), returned.getExchange(),\n                returned.getReplyText(), returned.getRoutingKey(),\n                returned.getReplyCode());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n低版本可能没有 RabbitTemplate.ReturnsCallback 请用 RabbitTemplate.ReturnCallback\n\n@Override\npublic void returnedMessage(Message message, int replyCode, String replyText, String\nexchange, String routingKey) {\n\tlog.info("消息:{}被服务器退回，退回原因:{}, 交换机是:{}, 路由 key:{}",new String(message.getBody()),replyText, exchange, routingKey);\n}\n\n\n1\n2\n3\n4\n5\n\n\n3、修改发送者 ProducerController\n\n//依赖注入 rabbitTemplate 之后再设置它的回调对象\n@PostConstruct\npublic void init() {\n    //消息回调\n    rabbitTemplate.setConfirmCallback(myCallBack);\n    /**\n     * true：交换机无法将消息进行路由时，会将该消息返回给生产者\n     * false：如果发现消息无法进行路由，则直接丢弃\n     */\n    rabbitTemplate.setMandatory(true);\n    //设置回退消息交给谁处理\n    rabbitTemplate.setReturnsCallback(myCallBack);\n  \t//RabbitMQ版本低的是 rabbitTemplate.setReturnCallback(myCallBack);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n访问： http://localhost:8080/confirm/sendMessage/你好\n\n结果分析：\n\n\n\n\n# 备份交换机\n\n有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？\n\n前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。\n\n什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n\n * 代码架构图\n\n\n\n1、修改配置类\n\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n    //关于备份的\n    public static final String BACKUP_EXCHANGE_NAME = "backup.exchange";\n    public static final String BACKUP_QUEUE_NAME = "backup.queue";\n    public static final String WARNING_QUEUE_NAME = "warning.queue";\n\n\n    /*\n    //声明业务 Exchange\n    @Bean("confirmExchange")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n    */\n\n    // 声明确认队列\n    @Bean("confirmQueue")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    // 声明确认队列绑定关系\n    @Bean\n    public Binding queueBinding(@Qualifier("confirmQueue") Queue queue,\n                                @Qualifier("confirmExchange") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with("key1");\n    }\n\n    //************************以下是关于备份的******************************\n\n    //声明备份 Exchange\n    @Bean("backupExchange")\n    public FanoutExchange backupExchange() {\n        return new FanoutExchange(BACKUP_EXCHANGE_NAME);\n    }\n\n    //声明确认 Exchange 交换机的备份交换机\n    @Bean("confirmExchange")\n    public DirectExchange confirmExchange() {\n        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)\n                .durable(true)\n                //设置该交换机的备份交换机\n                .withArgument("alternate-exchange", BACKUP_EXCHANGE_NAME);\n        return exchangeBuilder.build();\n    }\n\n\n    // 声明警告队列\n    @Bean("warningQueue")\n    public Queue warningQueue() {\n        return QueueBuilder.durable(WARNING_QUEUE_NAME).build();\n    }\n\n    // 声明报警队列绑定关系\n    @Bean\n    public Binding warningBinding(@Qualifier("warningQueue") Queue queue,\n                                  @Qualifier("backupExchange") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n\n    // 声明备份队列\n    @Bean("backQueue")\n    public Queue backQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();\n    }\n\n    // 声明备份队列绑定关系\n    @Bean\n    public Binding backupBinding(@Qualifier("backQueue") Queue queue,\n                                 @Qualifier("backupExchange") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n2、报警消费者\n\n@Component\n@Slf4j\npublic class WarningConsumer {\n    public static final String WARNING_QUEUE_NAME = "warning.queue";\n\n    @RabbitListener(queues = WARNING_QUEUE_NAME)\n    public void receiveWarningMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.error("报警发现不可路由消息：{}", msg);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n之前已写过 confirm.exchange 交换机，由于更改配置，需要删掉，不然会报错\n\n\n\n * 访问： http://localhost:8080/confirm/sendMessage/你好\n\n\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。',normalizedContent:' * 发布确认 springboot 版本\n * 回退消息\n * 备份交换机\n\n在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 rabbitmq 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 rabbitmq 的消息可靠投递呢？\n\n\n# 发布确认 springboot 版本\n\n确认机制方案：\n\n\n\n代码架构图：\n\n\n\n在配置文件当中需要添加\n\nspring.rabbitmq.publisher-confirm-type=correlated\n\n\n1\n\n\n * none 值是禁用发布确认模式，是默认值\n\n * correlated 值是发布消息成功到交换器后会触发回调方法\n\n * simple 值经测试有两种效果，其一效果和 correlated 值一样会触发回调方法，其二在发布消息成功后使用 rabbittemplate 调用 waitforconfirms 或 waitforconfirmsordie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitforconfirmsordie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;\n\n代码\n\n1、添加配置类：\n\n@configuration\npublic class confirmconfig {\n    public static final string confirm_exchange_name = "confirm.exchange";\n    public static final string confirm_queue_name = "confirm.queue";\n\n    //声明业务 exchange\n    @bean("confirmexchange")\n    public directexchange confirmexchange() {\n        return new directexchange(confirm_exchange_name);\n    }\n\n    // 声明确认队列\n    @bean("confirmqueue")\n    public queue confirmqueue() {\n        return queuebuilder.durable(confirm_queue_name).build();\n    }\n\n    // 声明确认队列绑定关系\n    @bean\n    public binding queuebinding(@qualifier("confirmqueue") queue queue,\n                                @qualifier("confirmexchange") directexchange exchange) {\n        return bindingbuilder.bind(queue).to(exchange).with("key1");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n2、消息生产者的回调接口\n\n@component\n@slf4j\npublic class mycallback implements rabbittemplate.confirmcallback {\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationdata 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @override\n    public void confirm(correlationdata correlationdata, boolean ack, string cause) {\n        string id = correlationdata != null ? correlationdata.getid() : "";\n        if (ack) {\n            log.info("交换机已经收到 id 为:{}的消息", id);\n        } else {\n            log.info("交换机还未收到 id 为:{}消息，原因:{}", id, cause);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n3、消息生产者\n\n@restcontroller\n@requestmapping("/confirm")\n@slf4j\npublic class producercontroller {\n    public static final string confirm_exchange_name = "confirm.exchange";\n    @autowired\n    private rabbittemplate rabbittemplate;\n    @autowired\n    private mycallback mycallback;\n\n    //依赖注入 rabbittemplate 之后再设置它的回调对象\n    @postconstruct\n    public void init() {\n        rabbittemplate.setconfirmcallback(mycallback);\n    }\n    \n    /**\n     * 消息回调和退回\n     *\n     * @param message\n     */\n    @getmapping("sendmessage/{message}")\n    public void sendmessage(@pathvariable string message) {\n\n        //指定消息 id 为 1\n        correlationdata correlationdata1 = new correlationdata("1");\n        string routingkey = "key1";\n        rabbittemplate.convertandsend(confirm_exchange_name, routingkey, message + routingkey, correlationdata1);\n        log.info(routingkey + "发送消息内容:{}", message + routingkey);\n\n        correlationdata correlationdata2 = new correlationdata("2");\n        routingkey = "key2";\n        rabbittemplate.convertandsend(confirm_exchange_name, routingkey, message + routingkey, correlationdata2);\n        log.info(routingkey + "发送消息内容:{}", message + routingkey);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n4、消息消费者\n\n@component\n@slf4j\npublic class confirmconsumer {\n    public static final string confirm_queue_name = "confirm.queue";\n\n    @rabbitlistener(queues = confirm_queue_name)\n    public void receivemsg(message message) {\n        string msg = new string(message.getbody());\n        log.info("接受到队列 confirm.queue 消息:{}", msg);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n访问： http://localhost:8080/confirm/sendmessage/你好\n\n结果分析：\n\n\n\n可以看到，发送了两条消息，第一条消息的 routingkey 为 "key1"，第二条消息的 routingkey 为 "key2"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 routingkey 与队列的 bindingkey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n\n丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败\n\n\n# 回退消息\n\nmandatory 参数\n\nrabbittemplate.setreturnscallback(mycallback);\n\n\n1\n\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。\n\n那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n\n1、修改配置\n\n#消息退回\nspring.rabbitmq.publisher-returns=true\n\n\n1\n2\n\n\n2、修改回调接口\n\n@component\n@slf4j\npublic class mycallback implements rabbittemplate.confirmcallback, rabbittemplate.returnscallback {\n\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationdata 消息相关数据\n     * @param ack             交换机是否收到消息\n     * @param cause           为收到消息的原因\n     */\n    @override\n    public void confirm(correlationdata correlationdata, boolean ack, string cause) {\n        string id = correlationdata != null ? correlationdata.getid() : "";\n        if (ack) {\n            log.info("交换机已经收到 id 为:{}的消息", id);\n        } else {\n            log.info("交换机还未收到 id 为:{}消息，原因:{}", id, cause);\n        }\n    }\n\n    //当消息无法路由的时候的回调方法\n    @override\n    public void returnedmessage(returnedmessage returned) {\n\n        log.error("消息：{}，被交换机 {} 退回，原因：{}，路由key：{},code:{}",\n                new string(returned.getmessage().getbody()), returned.getexchange(),\n                returned.getreplytext(), returned.getroutingkey(),\n                returned.getreplycode());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n低版本可能没有 rabbittemplate.returnscallback 请用 rabbittemplate.returncallback\n\n@override\npublic void returnedmessage(message message, int replycode, string replytext, string\nexchange, string routingkey) {\n\tlog.info("消息:{}被服务器退回，退回原因:{}, 交换机是:{}, 路由 key:{}",new string(message.getbody()),replytext, exchange, routingkey);\n}\n\n\n1\n2\n3\n4\n5\n\n\n3、修改发送者 producercontroller\n\n//依赖注入 rabbittemplate 之后再设置它的回调对象\n@postconstruct\npublic void init() {\n    //消息回调\n    rabbittemplate.setconfirmcallback(mycallback);\n    /**\n     * true：交换机无法将消息进行路由时，会将该消息返回给生产者\n     * false：如果发现消息无法进行路由，则直接丢弃\n     */\n    rabbittemplate.setmandatory(true);\n    //设置回退消息交给谁处理\n    rabbittemplate.setreturnscallback(mycallback);\n  \t//rabbitmq版本低的是 rabbittemplate.setreturncallback(mycallback);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n访问： http://localhost:8080/confirm/sendmessage/你好\n\n结果分析：\n\n\n\n\n# 备份交换机\n\n有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？\n\n前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 rabbitmq 中，有一种备份交换机的机制存在，可以很好的应对这个问题。\n\n什么是备份交换机呢？备份交换机可以理解为 rabbitmq 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n\n * 代码架构图\n\n\n\n1、修改配置类\n\n@configuration\npublic class confirmconfig {\n    public static final string confirm_exchange_name = "confirm.exchange";\n    public static final string confirm_queue_name = "confirm.queue";\n    //关于备份的\n    public static final string backup_exchange_name = "backup.exchange";\n    public static final string backup_queue_name = "backup.queue";\n    public static final string warning_queue_name = "warning.queue";\n\n\n    /*\n    //声明业务 exchange\n    @bean("confirmexchange")\n    public directexchange confirmexchange() {\n        return new directexchange(confirm_exchange_name);\n    }\n    */\n\n    // 声明确认队列\n    @bean("confirmqueue")\n    public queue confirmqueue() {\n        return queuebuilder.durable(confirm_queue_name).build();\n    }\n\n    // 声明确认队列绑定关系\n    @bean\n    public binding queuebinding(@qualifier("confirmqueue") queue queue,\n                                @qualifier("confirmexchange") directexchange exchange) {\n        return bindingbuilder.bind(queue).to(exchange).with("key1");\n    }\n\n    //************************以下是关于备份的******************************\n\n    //声明备份 exchange\n    @bean("backupexchange")\n    public fanoutexchange backupexchange() {\n        return new fanoutexchange(backup_exchange_name);\n    }\n\n    //声明确认 exchange 交换机的备份交换机\n    @bean("confirmexchange")\n    public directexchange confirmexchange() {\n        exchangebuilder exchangebuilder = exchangebuilder.directexchange(confirm_exchange_name)\n                .durable(true)\n                //设置该交换机的备份交换机\n                .withargument("alternate-exchange", backup_exchange_name);\n        return exchangebuilder.build();\n    }\n\n\n    // 声明警告队列\n    @bean("warningqueue")\n    public queue warningqueue() {\n        return queuebuilder.durable(warning_queue_name).build();\n    }\n\n    // 声明报警队列绑定关系\n    @bean\n    public binding warningbinding(@qualifier("warningqueue") queue queue,\n                                  @qualifier("backupexchange") fanoutexchange backupexchange) {\n        return bindingbuilder.bind(queue).to(backupexchange);\n    }\n\n    // 声明备份队列\n    @bean("backqueue")\n    public queue backqueue() {\n        return queuebuilder.durable(backup_queue_name).build();\n    }\n\n    // 声明备份队列绑定关系\n    @bean\n    public binding backupbinding(@qualifier("backqueue") queue queue,\n                                 @qualifier("backupexchange") fanoutexchange backupexchange) {\n        return bindingbuilder.bind(queue).to(backupexchange);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n2、报警消费者\n\n@component\n@slf4j\npublic class warningconsumer {\n    public static final string warning_queue_name = "warning.queue";\n\n    @rabbitlistener(queues = warning_queue_name)\n    public void receivewarningmsg(message message) {\n        string msg = new string(message.getbody());\n        log.error("报警发现不可路由消息：{}", msg);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n之前已写过 confirm.exchange 交换机，由于更改配置，需要删掉，不然会报错\n\n\n\n * 访问： http://localhost:8080/confirm/sendmessage/你好\n\n\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"RabbitMQ - 幂等性、优先级、惰性",frontmatter:{title:"RabbitMQ - 幂等性、优先级、惰性",date:"2021-06-29T16:04:11.000Z",permalink:"/pages/ee71b9/"},regularPath:"/04.%E6%A1%86%E6%9E%B6/20.RabbitMQ/20.RabbitMQ%20-%20%E5%B9%82%E7%AD%89%E6%80%A7%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E6%83%B0%E6%80%A7.html",relativePath:"04.框架/20.RabbitMQ/20.RabbitMQ - 幂等性、优先级、惰性.md",key:"v-c629ccf6",path:"/pages/ee71b9/",headers:[{level:2,title:"幂等性",slug:"幂等性",normalizedTitle:"幂等性",charIndex:3},{level:2,title:"优先级队列",slug:"优先级队列",normalizedTitle:"优先级队列",charIndex:10},{level:2,title:"惰性队列",slug:"惰性队列",normalizedTitle:"惰性队列",charIndex:19}],headersStr:"幂等性 优先级队列 惰性队列",content:' * 幂等性\n * 优先级队列\n * 惰性队列\n\n\n# 幂等性\n\n概念\n\n用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等\n\n消息重复消费\n\n消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n\n解决思路\n\nMQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。\n\n消费端的幂等性保障\n\n在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。\n\n业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现\n\n * 唯一ID+指纹码机制\n\n指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。\n\n * note Redis 原子性\n\n利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费\n\n\n# 优先级队列\n\n * 使用场景\n\n在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。\n\n但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。\n\n * 如何添加？\n\na.控制台页面添加\n\n\n\nb.队列中代码添加优先级\n\nMap<String, Object> params = new HashMap();\nparams.put("x-max-priority", 10);\nchannel.queueDeclare("hello", true, false, false, params);\n\n\n1\n2\n3\n\n\nc.消息中代码添加优先级\n\nAMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n\n\n1\n\n\n注意事项：\n\n要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序\n\n实战\n\n生产者：\n\npublic class PriorityProducer {\n    private static final String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //给消息赋予一个 priority 属性\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n\n        for (int i = 1; i < 11; i++) {\n            String message = "info" + i;\n            if (i == 5) {\n                channel.basicPublish("", QUEUE_NAME, properties, message.getBytes());\n            } else {\n                channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            }\n            System.out.println("发送消息完成:" + message);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n消费者：\n\npublic class PriorityConsumer {\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n\n        //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU\n        Map<String, Object> params = new HashMap();\n        params.put("x-max-priority", 10);\n        channel.queueDeclare(QUEUE_NAME, true, false, false, params);\n\n        //推送的消息如何进行消费的接口回调\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println("消息消费被中断");\n        };\n\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n\n# 惰性队列\n\n * 使用场景\n\nRabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n * 两种模式\n\n队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：\n\nMap<String, Object> args = new HashMap<String, Object>();\nargs.put("x-queue-mode", "lazy");\nchannel.queueDeclare("myqueue", false, false, false, args);\n\n\n1\n2\n3\n\n * 内存开销对比\n\n\n\n在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB',normalizedContent:' * 幂等性\n * 优先级队列\n * 惰性队列\n\n\n# 幂等性\n\n概念\n\n用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等\n\n消息重复消费\n\n消费者在消费 mq 中的消息时，mq 已把消息发送给消费者，消费者在给 mq 返回 ack 时网络中断， 故 mq 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n\n解决思路\n\nmq 消费者的幂等性的解决一般使用全局 id 或者写个唯一标识比如时间戳 或者 uuid 或者订单消费者消费 mq 中的消息也可利用 mq 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。\n\n消费端的幂等性保障\n\n在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。\n\n业界主流的幂等性有两种操作:a. 唯一 id+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现\n\n * 唯一id+指纹码机制\n\n指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。\n\n * note redis 原子性\n\n利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费\n\n\n# 优先级队列\n\n * 使用场景\n\n在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。\n\n但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 list 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 rabbitmq 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。\n\n * 如何添加？\n\na.控制台页面添加\n\n\n\nb.队列中代码添加优先级\n\nmap<string, object> params = new hashmap();\nparams.put("x-max-priority", 10);\nchannel.queuedeclare("hello", true, false, false, params);\n\n\n1\n2\n3\n\n\nc.消息中代码添加优先级\n\namqp.basicproperties properties = new amqp.basicproperties().builder().priority(10).build();\n\n\n1\n\n\n注意事项：\n\n要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序\n\n实战\n\n生产者：\n\npublic class priorityproducer {\n    private static final string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        //给消息赋予一个 priority 属性\n        amqp.basicproperties properties = new amqp.basicproperties().builder().priority(10).build();\n\n        for (int i = 1; i < 11; i++) {\n            string message = "info" + i;\n            if (i == 5) {\n                channel.basicpublish("", queue_name, properties, message.getbytes());\n            } else {\n                channel.basicpublish("", queue_name, null, message.getbytes());\n            }\n            system.out.println("发送消息完成:" + message);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n消费者：\n\npublic class priorityconsumer {\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n\n        //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 cpu\n        map<string, object> params = new hashmap();\n        params.put("x-max-priority", 10);\n        channel.queuedeclare(queue_name, true, false, false, params);\n\n        //推送的消息如何进行消费的接口回调\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody());\n            system.out.println(message);\n        };\n        //取消消费的一个回调接口 如在消费的时候队列被删除掉了\n        cancelcallback cancelcallback = (consumertag) -> {\n            system.out.println("消息消费被中断");\n        };\n\n        channel.basicconsume(queue_name, true, delivercallback, cancelcallback);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n\n# 惰性队列\n\n * 使用场景\n\nrabbitmq 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，当生产者将消息发送到 rabbitmq 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当rabbitmq 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 rabbitmq 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n * 两种模式\n\n队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queuedeclare 方法的时候在参数中设置，也可以通过 policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：\n\nmap<string, object> args = new hashmap<string, object>();\nargs.put("x-queue-mode", "lazy");\nchannel.queuedeclare("myqueue", false, false, false, args);\n\n\n1\n2\n3\n\n * 内存开销对比\n\n\n\n在发送 1 百万条消息，每条消息大概占 1kb 的情况下，普通队列占用内存是 1.2gb，而惰性队列仅仅 占用 1.5mb',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Git - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.工具部署/01.Git",imgUrl:"/img/web.png",description:"Git目录页"}},title:"Git - 知识体系",permalink:"/git",sidebar:!0,article:!1,comment:!1,editLink:!1,date:"2021-08-03T22:27:45.000Z"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/00.Git.html",relativePath:"05.工具部署/01.Git/00.Git.md",key:"v-2c3587d8",path:"/git/",headers:[{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:2}],headersStr:"教程",content:"# 教程\n\n新人推荐看尚硅谷的 Git 教程：5h打通Git全套教程丨2021最新IDEA版（涵盖GitHub\\Gitee码云\\GitLab）",normalizedContent:"# 教程\n\n新人推荐看尚硅谷的 git 教程：5h打通git全套教程丨2021最新idea版（涵盖github\\gitee码云\\gitlab）",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"Git - 简单提交",frontmatter:{title:"Git - 简单提交",date:"2021-05-15T08:36:23.000Z",permalink:"/pages/7d2d32/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/01.Git%E7%AE%80%E5%8D%95%E6%8F%90%E4%BA%A4.html",relativePath:"05.工具部署/01.Git/01.Git简单提交.md",key:"v-44326a4c",path:"/pages/7d2d32/",headers:[{level:2,title:"初始",slug:"初始",normalizedTitle:"初始",charIndex:44},{level:3,title:"安装Git",slug:"安装git",normalizedTitle:"安装git",charIndex:52},{level:3,title:"设置用户签名",slug:"设置用户签名",normalizedTitle:"设置用户签名",charIndex:63},{level:2,title:"提交到远程仓库",slug:"提交到远程仓库",normalizedTitle:"提交到远程仓库",charIndex:73}],headersStr:"初始 安装Git 设置用户签名 提交到远程仓库",content:'Table of Contents generated with DocToc\n\n * 初始\n   * 安装Git\n   * 设置用户签名\n * 提交到远程仓库\n * 教程\n\n\n# 初始\n\n\n# 安装Git\n\n官网： https://git-scm.com/\n\n下载慢可使用淘宝镜像下载：https://npm.taobao.org/mirrors/git-for-windows/\n\n下载完之后安装，一键默认即可\n\n\n# 设置用户签名\n\nGit 首次安装必须设置一下用户签名，否则无法提交代码\n\n基本语法：\n\ngit config --global user.name 用户名\ngit config --global user.email 邮箱\n\n\n1\n2\n\n\n签名作用：\n\n每次提交到远程时区分不同操作者，在每次的提交信息中能看到。\n\n在 C:\\Users\\用户名\\目录下 .gitconfig 文件查看配置信息\n\n\n# 提交到远程仓库\n\n 1. 创建远程仓库\n    \n    在 GitHub/Gitee 中创建仓库\n    \n    主分支一般设置为 master\n\n 2. 初始化本地库\n    \n    在本地仓库目录下，打开 Git Bash\n    \n    git init\n    \n    \n    1\n    \n    \n    项目文件夹下就会生成.git文件，这是一个隐藏文件。\n\n 3. 添加远程仓库地址\n    \n    git remote add origin https://github.com/oddfar/docs.git\n    \n    \n    1\n    \n    \n    把链接替换成自己的\n\n 4. 拉取远程仓库\n    \n    git  pull origin master\n    \n    \n    1\n    \n    \n    作用是拉取远程仓库的文件，拉取本地没有的文件和新更改的文件\n\n 5. 添加暂存区\n    \n    git add .\n    \n    \n    1\n    \n    \n    .把所有文件添加到暂存区\n    \n    添加指定文件：git add 文件名\n    \n    注意 add 后面有空格\n\n 6. 提交本地库\n    \n    git commit -m "日志信息"\n    \n    \n    1\n    \n    \n    将暂存区的文件提交到本地库\n    \n    使用 git status 查看状态\n\n 7. 同步到远程\n    \n    git push origin master\n    \n    \n    1\n    \n\n至此，已成功提交到远程。\n\n----------------------------------------\n\n也可以创建好远程仓库后，直接克隆到本地\n\ngit clone https://github.com/oddfar/docs.git\n\n\n1\n\n\n把本地代码，复制到下载的目录\n\n再从第五步开始提交到 GitHub\n\nhttps 在国内不太稳定，有时候链接不上，建议用 SSH 链接来对仓库进行管理',normalizedContent:'table of contents generated with doctoc\n\n * 初始\n   * 安装git\n   * 设置用户签名\n * 提交到远程仓库\n * 教程\n\n\n# 初始\n\n\n# 安装git\n\n官网： https://git-scm.com/\n\n下载慢可使用淘宝镜像下载：https://npm.taobao.org/mirrors/git-for-windows/\n\n下载完之后安装，一键默认即可\n\n\n# 设置用户签名\n\ngit 首次安装必须设置一下用户签名，否则无法提交代码\n\n基本语法：\n\ngit config --global user.name 用户名\ngit config --global user.email 邮箱\n\n\n1\n2\n\n\n签名作用：\n\n每次提交到远程时区分不同操作者，在每次的提交信息中能看到。\n\n在 c:\\users\\用户名\\目录下 .gitconfig 文件查看配置信息\n\n\n# 提交到远程仓库\n\n 1. 创建远程仓库\n    \n    在 github/gitee 中创建仓库\n    \n    主分支一般设置为 master\n\n 2. 初始化本地库\n    \n    在本地仓库目录下，打开 git bash\n    \n    git init\n    \n    \n    1\n    \n    \n    项目文件夹下就会生成.git文件，这是一个隐藏文件。\n\n 3. 添加远程仓库地址\n    \n    git remote add origin https://github.com/oddfar/docs.git\n    \n    \n    1\n    \n    \n    把链接替换成自己的\n\n 4. 拉取远程仓库\n    \n    git  pull origin master\n    \n    \n    1\n    \n    \n    作用是拉取远程仓库的文件，拉取本地没有的文件和新更改的文件\n\n 5. 添加暂存区\n    \n    git add .\n    \n    \n    1\n    \n    \n    .把所有文件添加到暂存区\n    \n    添加指定文件：git add 文件名\n    \n    注意 add 后面有空格\n\n 6. 提交本地库\n    \n    git commit -m "日志信息"\n    \n    \n    1\n    \n    \n    将暂存区的文件提交到本地库\n    \n    使用 git status 查看状态\n\n 7. 同步到远程\n    \n    git push origin master\n    \n    \n    1\n    \n\n至此，已成功提交到远程。\n\n----------------------------------------\n\n也可以创建好远程仓库后，直接克隆到本地\n\ngit clone https://github.com/oddfar/docs.git\n\n\n1\n\n\n把本地代码，复制到下载的目录\n\n再从第五步开始提交到 github\n\nhttps 在国内不太稳定，有时候链接不上，建议用 ssh 链接来对仓库进行管理',charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"Git - SSH免密登录",frontmatter:{title:"Git - SSH免密登录",date:"2021-05-20T13:05:16.000Z",permalink:"/pages/5747a6/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/02.SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95.html",relativePath:"05.工具部署/01.Git/02.SSH免密登录.md",key:"v-4e08f385",path:"/pages/5747a6/",headers:[{level:2,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:3},{level:2,title:"好处",slug:"好处",normalizedTitle:"好处",charIndex:9},{level:2,title:"别名",slug:"别名",normalizedTitle:"别名",charIndex:15}],headersStr:"步骤 好处 别名",content:" * 步骤\n * 好处\n * 别名\n\n\n# 步骤\n\n我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 实现免密码登录！\n\n进入 C:\\Users\\Administrator.ssh 目录生成公钥\n\nssh-keygen -t rsa\n\n\n1\n\n\n执行后会生成两个文件\n\n复制 id_rsa.pub 文件内容\n\nGitee：设置 ->SSH公钥\n\nGitHub：点击用户头像→Settings→SSH and GPG keys\n\n这俩平台 ssh 可设置同一个\n\n\n# 好处\n\nGitHub 服务器在国外，我们用 https 对仓库进行拉取、提交有时会链接不上，导致失败。\n\n\n\n这时我们可以用 ssh 对项目就行管理\n\n以 Gitee 为例：\n\n\n\n\n# 别名\n\n对于用 https 已经克隆在本地的仓库，我们可以加个“别名”来进行 SSH 链接\n\n1）基本语法\n\ngit remote -v 查看当前所有远程地址别名\n\ngit remote add 别名 远程地址\n\n2）案例\n\n我们提交到远程仓库的指令是：\n\ngit push 远程仓库地址 分支\n\n\n1\n\n\n这个地址可以是 https 也可以是 ssh\n\n但由于地址太长了，可以用“别名”代替地址！\n\n添加别名：\n\ngit remote add ssh git@github.com:oddfar/docs.git\n\n\n1\n\n\n推送到远程仓库：\n\ngit push ssh master\n\n\n1\n\n\n----------------------------------------\n\n我们 clone 项目，默认有个“别名” origin 指向我们 clone 时的远程仓库地址（https或ssh...）",normalizedContent:" * 步骤\n * 好处\n * 别名\n\n\n# 步骤\n\n我们可以看到远程仓库中还有一个 ssh 的地址，因此我们也可以使用 ssh 实现免密码登录！\n\n进入 c:\\users\\administrator.ssh 目录生成公钥\n\nssh-keygen -t rsa\n\n\n1\n\n\n执行后会生成两个文件\n\n复制 id_rsa.pub 文件内容\n\ngitee：设置 ->ssh公钥\n\ngithub：点击用户头像→settings→ssh and gpg keys\n\n这俩平台 ssh 可设置同一个\n\n\n# 好处\n\ngithub 服务器在国外，我们用 https 对仓库进行拉取、提交有时会链接不上，导致失败。\n\n\n\n这时我们可以用 ssh 对项目就行管理\n\n以 gitee 为例：\n\n\n\n\n# 别名\n\n对于用 https 已经克隆在本地的仓库，我们可以加个“别名”来进行 ssh 链接\n\n1）基本语法\n\ngit remote -v 查看当前所有远程地址别名\n\ngit remote add 别名 远程地址\n\n2）案例\n\n我们提交到远程仓库的指令是：\n\ngit push 远程仓库地址 分支\n\n\n1\n\n\n这个地址可以是 https 也可以是 ssh\n\n但由于地址太长了，可以用“别名”代替地址！\n\n添加别名：\n\ngit remote add ssh git@github.com:oddfar/docs.git\n\n\n1\n\n\n推送到远程仓库：\n\ngit push ssh master\n\n\n1\n\n\n----------------------------------------\n\n我们 clone 项目，默认有个“别名” origin 指向我们 clone 时的远程仓库地址（https或ssh...）",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"Git - Commit常用表情",frontmatter:{title:"Git - Commit常用表情",date:"2021-05-28T23:54:11.000Z",permalink:"/pages/fe0004/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/04.Git%20-%20Commit%E5%B8%B8%E7%94%A8%E8%A1%A8%E6%83%85.html",relativePath:"05.工具部署/01.Git/04.Git - Commit常用表情.md",key:"v-7eff31ac",path:"/pages/fe0004/",headers:[{level:2,title:"Git常用表情",slug:"git常用表情",normalizedTitle:"git常用表情",charIndex:3},{level:2,title:"MarkDown 常用表情",slug:"markdown-常用表情",normalizedTitle:"markdown 常用表情",charIndex:14},{level:3,title:"People",slug:"people",normalizedTitle:"people",charIndex:33},{level:3,title:"Nature",slug:"nature",normalizedTitle:"nature",charIndex:45},{level:3,title:"Objects",slug:"objects",normalizedTitle:"objects",charIndex:57},{level:3,title:"Places",slug:"places",normalizedTitle:"places",charIndex:70},{level:3,title:"Symbols",slug:"symbols",normalizedTitle:"symbols",charIndex:82},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:93}],headersStr:"Git常用表情 MarkDown 常用表情 People Nature Objects Places Symbols 参考链接",content:" * Git常用表情\n * MarkDown 常用表情\n   * People\n   * Nature\n   * Objects\n   * Places\n   * Symbols\n * 参考链接\n\n\n# Git常用表情\n\ngit commit 的时候，添加表情符号可以更好的表明本次提交的性质，也更有趣。\n\n常用表情符号如下：\n\nEMOJI        EMOJI代码                      COMMIT说明\n🎨 (调色板)     :art:                        改进代码结构/代码格式\n⚡️ (闪电)      :zap:                        提升性能\n🐎 (赛马)      :racehorse:                  提升性能\n🔥 (火焰)      :fire:                       移除代码或文件\n🐛 (bug)     :bug:                        修复 bug\n🚑 (急救车)     :ambulance:                  重要补丁\n✨ (火花)       :sparkles:                   引入新功能\n📝 (铅笔)      :pencil:                     撰写文档\n🚀 (火箭)      :rocket:                     部署功能\n💄 (口红)      :lipstick:                   更新 UI 和样式文件\n🎉 (庆祝)      :tada:                       初次提交\n✅ (白色复选框)    :white_check_mark:           增加测试\n🔒 (锁)       :lock:                       修复安全问题\n🍎 (苹果)      :apple:                      修复 macOS 下的问题\n🐧 (企鹅)      :penguin:                    修复 Linux 下的问题\n🏁 (旗帜)      :checked_flag:               修复 Windows 下的问题\n🔖 (书签)      :bookmark:                   发行/版本标签\n🚨 (警车灯)     :rotating_light:             移除 linter 警告\n🚧 (施工)      :construction:               工作进行中\n💚 (绿心)      :green_heart:                修复 CI 构建问题\n⬇️ (下降箭头)    :arrow_down:                 降级依赖\n⬆️ (上升箭头)    :arrow_up:                   升级依赖\n👷 (工人)      :construction_worker:        添加 CI 构建系统\n📈 (上升趋势图)   :chart_with_upwards_trend:   添加分析或跟踪代码\n🔨 (锤子)      :hammer:                     重大重构\n➖ (减号)       :heavy_minus_sign:           减少一个依赖\n🐳 (鲸鱼)      :whale:                      Docker 相关工作\n➕ (加号)       :heavy_plus_sign:            增加一个依赖\n🔧 (扳手)      :wrench:                     修改配置文件\n🌐 (地球)      :globe_with_meridians:       国际化与本地化\n✏️ (铅笔)      :pencil2:                    修复 typo\n\n\n# MarkDown 常用表情\n\n\n# People\n\n😄 :SMILE:                          😆 :LAUGHING:                       \n😊 :blush:                          😃 :smiley:                         ☺️ :relaxed:\n😏 :smirk:                          😍 :heart_eyes:                     😘 :kissing_heart:\n😚 :kissing_closed_eyes:            😳 :flushed:                        😌 :relieved:\n😆 :satisfied:                      😁 :grin:                           😉 :wink:\n😜 :stuck_out_tongue_winking_eye:   😝 :stuck_out_tongue_closed_eyes:   😀 :grinning:\n😗 :kissing:                        😙 :kissing_smiling_eyes:           😛 :stuck_out_tongue:\n😴 :sleeping:                       😟 :worried:                        😦 :frowning:\n😧 :anguished:                      😮 :open_mouth:                     😬 :grimacing:\n😕 :confused:                       😯 :hushed:                         😑 :expressionless:\n😒 :unamused:                       😅 :sweat_smile:                    😓 :sweat:\n😥 :disappointed_relieved:          😩 :weary:                          😔 :pensive:\n😞 :disappointed:                   😖 :confounded:                     😨 :fearful:\n😰 :cold_sweat:                     😣 :persevere:                      😢 :cry:\n😭 :sob:                            😂 :joy:                            😲 :astonished:\n😱 :scream:                         👿 :imp:                            😫 :tired_face:\n😠 :angry:                          😡 :rage:                           😤 :triumph:\n😪 :sleepy:                         😋 :yum:                            😷 :mask:\n😎 :sunglasses:                     😵 :dizzy_face:                     \n\n                                                               \n😈 :smiling_imp:                😐 :neutral_face:              😶 :no_mouth:\n😇 :innocent:                   👽 :alien:                     💛 :yellow_heart:\n💙 :blue_heart:                 💜 :purple_heart:              ❤️ :heart:\n💚 :green_heart:                💔 :broken_heart:              💓 :heartbeat:\n💗 :heartpulse:                 💕 :two_hearts:                💞 :revolving_hearts:\n💘 :cupid:                      💖 :sparkling_heart:           ✨ :sparkles:\n⭐️ :star:                       🌟 :star2:                     💫 :dizzy:\n💥 :boom:                       💥 :collision:                 💢 :anger:\n❗️ :exclamation:                ❓ :question:                   ❕ :grey_exclamation:\n❔ :grey_question:               💤 :zzz:                       💨 :dash:\n💦 :sweat_drops:                🎶 :notes:                     🎵 :musical_note:\n🔥 :fire:                       💩 :hankey:                    💩 :poop:\n💩 :shit:                       👍 :+1:                        👍 :thumbsup:\n👎 :-1:                         👎 :thumbsdown:                👌 :ok_hand:\n👊 :punch:                      👊 :facepunch:                 ✊ :fist:\n✌️ :v:                          👋 :wave:                      ✋ :hand:\n✋ :raised_hand:                 👐 :open_hands:                ☝️ :point_up:\n👇 :point_down:                 👈 :point_left:                👉 :point_right:\n🙌 :raised_hands:               🙏 :pray:                      👆 :point_up_2:\n👏 :clap:                       💪 :muscle:                    🤘 :metal:\n🖕 :fu:                         🚶 :walking:                   🏃 :runner:\n🏃 :running:                    👫 :couple:                    👪 :family:\n👬 :two_men_holding_hands:      👭 :two_women_holding_hands:   💃 :dancer:\n👯 :dancers:                    🙆 :ok_woman:                  🙅 :no_good:\n💁 :information_desk_person:    🙋 :raising_hand:              👰 :bride_with_veil:\n🙎 :person_with_pouting_face:   🙍 :person_frowning:           🙇 :bow:\n💏 :couplekiss:                 💑 :couple_with_heart:         💆 :massage:\n💇 :haircut:                    💅 :nail_care:                 👦 :boy:\n👧 :girl:                       👩 :woman:                     👨 :man:\n👶 :baby:                       👵 :older_woman:               👴 :older_man:\n👱 :person_with_blond_hair:     👲 :man_with_gua_pi_mao:       👳 :man_with_turban:\n👷 :construction_worker:        👮 :cop:                       👼 :angel:\n👸 :princess:                   😺 :smiley_cat:                😸 :smile_cat:\n😻 :heart_eyes_cat:             😽 :kissing_cat:               😼 :smirk_cat:\n🙀 :scream_cat:                 😿 :crying_cat_face:           😹 :joy_cat:\n😾 :pouting_cat:                👹 :japanese_ogre:             👺 :japanese_goblin:\n🙈 :see_no_evil:                🙉 :hear_no_evil:              🙊 :speak_no_evil:\n💂 :guardsman:                  💀 :skull:                     🐾 :feet:\n👄 :lips:                       💋 :kiss:                      💧 :droplet:\n👂 :ear:                        👀 :eyes:                      👃 :nose:\n👅 :tongue:                     💌 :love_letter:               👤 :bust_in_silhouette:\n👥 :busts_in_silhouette:        💬 :speech_balloon:            💭 :thought_balloon:\n\n\n# Nature\n\n☀️ :SUNNY:                          ☔️ :UMBRELLA:               ☁️ :CLOUD:\n❄️ :snowflake:                      ⛄️ :snowman:                ⚡️ :zap:\n🌀 :cyclone:                        🌁 :foggy:                  🌊 :ocean:\n🐱 :cat:                            🐶 :dog:                    🐭 :mouse:\n🐹 :hamster:                        🐰 :rabbit:                 🐺 :wolf:\n🐸 :frog:                           🐯 :tiger:                  🐨 :koala:\n🐻 :bear:                           🐷 :pig:                    🐽 :pig_nose:\n🐮 :cow:                            🐗 :boar:                   🐵 :monkey_face:\n🐒 :monkey:                         🐴 :horse:                  🐎 :racehorse:\n🐫 :camel:                          🐑 :sheep:                  🐘 :elephant:\n🐼 :panda_face:                     🐍 :snake:                  🐦 :bird:\n🐤 :baby_chick:                     🐥 :hatched_chick:          🐣 :hatching_chick:\n🐔 :chicken:                        🐧 :penguin:                🐢 :turtle:\n🐛 :bug:                            🐝 :honeybee:               🐜 :ant:\n🐞 :beetle:                         🐌 :snail:                  🐙 :octopus:\n🐠 :tropical_fish:                  🐟 :fish:                   🐳 :whale:\n🐋 :whale2:                         🐬 :dolphin:                🐄 :cow2:\n🐏 :ram:                            🐀 :rat:                    🐃 :water_buffalo:\n🐅 :tiger2:                         🐇 :rabbit2:                🐉 :dragon:\n🐐 :goat:                           🐓 :rooster:                🐕 :dog2:\n🐖 :pig2:                           🐁 :mouse2:                 🐂 :ox:\n🐲 :dragon_face:                    🐡 :blowfish:               🐊 :crocodile:\n🐪 :dromedary_camel:                🐆 :leopard:                🐈 :cat2:\n🐩 :poodle:                         🐾 :paw_prints:             💐 :bouquet:\n🌸 :cherry_blossom:                 🌷 :tulip:                  🍀 :four_leaf_clover:\n🌹 :rose:                           🌻 :sunflower:              🌺 :hibiscus:\n🍁 :maple_leaf:                     🍃 :leaves:                 🍂 :fallen_leaf:\n🌿 :herb:                           🍄 :mushroom:               🌵 :cactus:\n🌴 :palm_tree:                      🌲 :evergreen_tree:         🌳 :deciduous_tree:\n🌰 :chestnut:                       🌱 :seedling:               🌼 :blossom:\n🌾 :ear_of_rice:                    🐚 :shell:                  🌐 :globe_with_meridians:\n🌞 :sun_with_face:                  🌝 :full_moon_with_face:    🌚 :new_moon_with_face:\n🌑 :new_moon:                       🌒 :waxing_crescent_moon:   🌓 :first_quarter_moon:\n🌔 :waxing_gibbous_moon:            🌕 :full_moon:              🌖 :waning_gibbous_moon:\n🌗 :last_quarter_moon:              🌘 :waning_crescent_moon:   🌜 :last_quarter_moon_with_face:\n🌛 :first_quarter_moon_with_face:   🌔 :moon:                   🌍 :earth_africa:\n🌎 :earth_americas:                 🌏 :earth_asia:             🌋 :volcano:\n🌌 :milky_way:                      ⛅️ :partly_sunny:           \n\n\n# Objects\n\n🎍 :BAMBOO:                           💝 :GIFT_HEART:                   🎎 :DOLLS:\n🎒 :school_satchel:                   🎓 :mortar_board:                 🎏 :flags:\n🎆 :fireworks:                        🎇 :sparkler:                     🎐 :wind_chime:\n🎑 :rice_scene:                       🎃 :jack_o_lantern:               👻 :ghost:\n🎅 :santa:                            🎄 :christmas_tree:               🎁 :gift:\n🔔 :bell:                             🔕 :no_bell:                      🎋 :tanabata_tree:\n🎉 :tada:                             🎊 :confetti_ball:                🎈 :balloon:\n🔮 :crystal_ball:                     💿 :cd:                           📀 :dvd:\n💾 :floppy_disk:                      📷 :camera:                       📹 :video_camera:\n🎥 :movie_camera:                     💻 :computer:                     📺 :tv:\n📱 :iphone:                           ☎️ :phone:                        ☎️ :telephone:\n📞 :telephone_receiver:               📟 :pager:                        📠 :fax:\n💽 :minidisc:                         📼 :vhs:                          🔉 :sound:\n🔈 :speaker:                          🔇 :mute:                         📢 :loudspeaker:\n📣 :mega:                             ⌛️ :hourglass:                    ⏳ :hourglass_flowing_sand:\n⏰ :alarm_clock:                       ⌚️ :watch:                        📻 :radio:\n📡 :satellite:                        ➿ :loop:                          🔍 :mag:\n🔎 :mag_right:                        🔓 :unlock:                       🔒 :lock:\n🔏 :lock_with_ink_pen:                🔐 :closed_lock_with_key:         🔑 :key:\n💡 :bulb:                             🔦 :flashlight:                   🔆 :high_brightness:\n🔅 :low_brightness:                   🔌 :electric_plug:                🔋 :battery:\n📲 :calling:                          ✉️ :email:                        📫 :mailbox:\n📮 :postbox:                          🛀 :bath:                         🛁 :bathtub:\n🚿 :shower:                           🚽 :toilet:                       🔧 :wrench:\n🔩 :nut_and_bolt:                     🔨 :hammer:                       💺 :seat:\n💰 :moneybag:                         💴 :yen:                          💵 :dollar:\n💷 :pound:                            💶 :euro:                         💳 :credit_card:\n💸 :money_with_wings:                 📧 :e-mail:                       📥 :inbox_tray:\n📤 :outbox_tray:                      ✉️ :envelope:                     📨 :incoming_envelope:\n📯 :postal_horn:                      📪 :mailbox_closed:               📬 :mailbox_with_mail:\n📭 :mailbox_with_no_mail:             🚪 :door:                         🚬 :smoking:\n💣 :bomb:                             🔫 :gun:                          🔪 :hocho:\n💊 :pill:                             💉 :syringe:                      📄 :page_facing_up:\n📃 :page_with_curl:                   📑 :bookmark_tabs:                📊 :bar_chart:\n📈 :chart_with_upwards_trend:         📉 :chart_with_downwards_trend:   📜 :scroll:\n📋 :clipboard:                        📆 :calendar:                     📅 :date:\n📇 :card_index:                       📁 :file_folder:                  📂 :open_file_folder:\n✂️ :scissors:                         📌 :pushpin:                      📎 :paperclip:\n✒️ :black_nib:                        ✏️ :pencil2:                      📏 :straight_ruler:\n📐 :triangular_ruler:                 📕 :closed_book:                  📗 :green_book:\n📘 :blue_book:                        📙 :orange_book:                  📓 :notebook:\n📔 :notebook_with_decorative_cover:   📒 :ledger:                       📚 :books:\n🔖 :bookmark:                         📛 :name_badge:                   🔬 :microscope:\n🔭 :telescope:                        📰 :newspaper:                    🏈 :football:\n🏀 :basketball:                       ⚽️ :soccer:                       ⚾️ :baseball:\n🎾 :tennis:                           🎱 :8ball:                        🏉 :rugby_football:\n🎳 :bowling:                          ⛳️ :golf:                         🚵 :mountain_bicyclist:\n🚴 :bicyclist:                        🏇 :horse_racing:                 🏂 :snowboarder:\n🏊 :swimmer:                          🏄 :surfer:                       🎿 :ski:\n♠️ :spades:                           ♥️ :hearts:                       ♣️ :clubs:\n♦️ :diamonds:                         💎 :gem:                          💍 :ring:\n🏆 :trophy:                           🎼 :musical_score:                🎹 :musical_keyboard:\n🎻 :violin:                           👾 :space_invader:                🎮 :video_game:\n🃏 :black_joker:                      🎴 :flower_playing_cards:         🎲 :game_die:\n🎯 :dart:                             🀄️ :mahjong:                     🎬 :clapper:\n📝 :memo:                             📝 :pencil:                       📖 :book:\n🎨 :art:                              🎤 :microphone:                   🎧 :headphones:\n🎺 :trumpet:                          🎷 :saxophone:                    🎸 :guitar:\n👞 :shoe:                             👡 :sandal:                       👠 :high_heel:\n💄 :lipstick:                         👢 :boot:                         👕 :shirt:\n👕 :tshirt:                           👔 :necktie:                      👚 :womans_clothes:\n👗 :dress:                            🎽 :running_shirt_with_sash:      👖 :jeans:\n👘 :kimono:                           👙 :bikini:                       🎀 :ribbon:\n🎩 :tophat:                           👑 :crown:                        👒 :womans_hat:\n👞 :mans_shoe:                        🌂 :closed_umbrella:              💼 :briefcase:\n👜 :handbag:                          👝 :pouch:                        👛 :purse:\n👓 :eyeglasses:                       🎣 :fishing_pole_and_fish:        ☕️ :coffee:\n🍵 :tea:                              🍶 :sake:                         🍼 :baby_bottle:\n🍺 :beer:                             🍻 :beers:                        🍸 :cocktail:\n🍹 :tropical_drink:                   🍷 :wine_glass:                   🍴 :fork_and_knife:\n🍕 :pizza:                            🍔 :hamburger:                    🍟 :fries:\n🍗 :poultry_leg:                      🍖 :meat_on_bone:                 🍝 :spaghetti:\n🍛 :curry:                            🍤 :fried_shrimp:                 🍱 :bento:\n🍣 :sushi:                            🍥 :fish_cake:                    🍙 :rice_ball:\n🍘 :rice_cracker:                     🍚 :rice:                         🍜 :ramen:\n🍲 :stew:                             🍢 :oden:                         🍡 :dango:\n🥚 :egg:                              🍞 :bread:                        🍩 :doughnut:\n🍮 :custard:                          🍦 :icecream:                     🍨 :ice_cream:\n🍧 :shaved_ice:                       🎂 :birthday:                     🍰 :cake:\n🍪 :cookie:                           🍫 :chocolate_bar:                🍬 :candy:\n🍭 :lollipop:                         🍯 :honey_pot:                    🍎 :apple:\n🍏 :green_apple:                      🍊 :tangerine:                    🍋 :lemon:\n🍒 :cherries:                         🍇 :grapes:                       🍉 :watermelon:\n🍓 :strawberry:                       🍑 :peach:                        🍈 :melon:\n🍌 :banana:                           🍐 :pear:                         🍍 :pineapple:\n🍠 :sweet_potato:                     🍆 :eggplant:                     🍅 :tomato:\n🌽 :corn:                                                               \n\n\n# Places\n\n🏠 :HOUSE:                 🏡 :HOUSE_WITH_GARDEN:         🏫 :SCHOOL:\n🏢 :office:                🏣 :post_office:               🏥 :hospital:\n🏦 :bank:                  🏪 :convenience_store:         🏩 :love_hotel:\n🏨 :hotel:                 💒 :wedding:                   ⛪️ :church:\n🏬 :department_store:      🏤 :european_post_office:      🌇 :city_sunrise:\n🌆 :city_sunset:           🏯 :japanese_castle:           🏰 :european_castle:\n⛺️ :tent:                  🏭 :factory:                   🗼 :tokyo_tower:\n🗾 :japan:                 🗻 :mount_fuji:                🌄 :sunrise_over_mountains:\n🌅 :sunrise:               🌠 :stars:                     🗽 :statue_of_liberty:\n🌉 :bridge_at_night:       🎠 :carousel_horse:            🌈 :rainbow:\n🎡 :ferris_wheel:          ⛲️ :fountain:                  🎢 :roller_coaster:\n🚢 :ship:                  🚤 :speedboat:                 ⛵️ :boat:\n⛵️ :sailboat:              🚣 :rowboat:                   ⚓️ :anchor:\n🚀 :rocket:                ✈️ :airplane:                  🚁 :helicopter:\n🚂 :steam_locomotive:      🚊 :tram:                      🚞 :mountain_railway:\n🚲 :bike:                  🚡 :aerial_tramway:            🚟 :suspension_railway:\n🚠 :mountain_cableway:     🚜 :tractor:                   🚙 :blue_car:\n🚘 :oncoming_automobile:   🚗 :car:                       🚗 :red_car:\n🚕 :taxi:                  🚖 :oncoming_taxi:             🚛 :articulated_lorry:\n🚌 :bus:                   🚍 :oncoming_bus:              🚨 :rotating_light:\n🚓 :police_car:            🚔 :oncoming_police_car:       🚒 :fire_engine:\n🚑 :ambulance:             🚐 :minibus:                   🚚 :truck:\n🚋 :train:                 🚉 :station:                   🚆 :train2:\n🚅 :bullettrain_front:     🚄 :bullettrain_side:          🚈 :light_rail:\n🚝 :monorail:              🚃 :railway_car:               🚎 :trolleybus:\n🎫 :ticket:                ⛽️ :fuelpump:                  🚦 :vertical_traffic_light:\n🚥 :traffic_light:         ⚠️ :warning:                   🚧 :construction:\n🔰 :beginner:              🏧 :atm:                       🎰 :slot_machine:\n🚏 :busstop:               💈 :barber:                    ♨️ :hotsprings:\n🏁 :checkered_flag:        🎌 :crossed_flags:             🏮 :izakaya_lantern:\n🗿 :moyai:                 🎪 :circus_tent:               🎭 :performing_arts:\n📍 :round_pushpin:         🚩 :triangular_flag_on_post:   🇯🇵 :jp:\n🇰🇷 :kr:                  🇨🇳 :cn:                      🇺🇸 :us:\n🇫🇷 :fr:                  🇪🇸 :es:                      🇮🇹 :it:\n🇷🇺 :ru:                  🇬🇧 :gb:                      🇬🇧 :uk:\n🇩🇪 :de:                                                 \n\n\n# Symbols\n\n1️⃣ :ONE:                             2️⃣ :TWO:                        3️⃣ :THREE:\n4️⃣ :four:                            5️⃣ :five:                       6️⃣ :six:\n7️⃣ :seven:                           8️⃣ :eight:                      9️⃣ :nine:\n🔟 :keycap_ten:                       🔢 :1234:                        0️⃣ :zero:\n#️⃣ :hash:                            🔣 :symbols:                     ◀️ :arrow_backward:\n⬇️ :arrow_down:                       ▶️ :arrow_forward:               ⬅️ :arrow_left:\n🔠 :capital_abcd:                     🔡 :abcd:                        🔤 :abc:\n↙️ :arrow_lower_left:                 ↘️ :arrow_lower_right:           ➡️ :arrow_right:\n⬆️ :arrow_up:                         ↖️ :arrow_upper_left:            ↗️ :arrow_upper_right:\n⏬ :arrow_double_down:                 ⏫ :arrow_double_up:              🔽 :arrow_down_small:\n⤵️ :arrow_heading_down:               ⤴️ :arrow_heading_up:            ↩️:leftwards_arrow_with_hook:\n↪️ :arrow_right_hook:                 ↔️ :left_right_arrow:            ↕️ :arrow_up_down:\n🔼 :arrow_up_small:                   🔃 :arrows_clockwise:            🔄 :arrows_counterclockwise:\n⏪ :rewind:                            ⏩ :fast_forward:                 ℹ️ :information_source:\n🆗 :ok:                               🔀 :twisted_rightwards_arrows:   🔁 :repeat:\n🔂 :repeat_one:                       🆕 :new:                         🔝 :top:\n🆙 :up:                               🆒 :cool:                        🆓 :free:\n🆖 :ng:                               🎦 :cinema:                      🈁 :koko:\n📶 :signal_strength:                  🈹 :u5272:                       🈴 :u5408:\n🈺 :u55b6:                            🈯️ :u6307:                      🈷️ :u6708:\n🈶 :u6709:                            🈵 :u6e80:                       🈚️ :u7121:\n🈸 :u7533:                            🈳 :u7a7a:                       🈲 :u7981:\n🈂️ :sa:                              🚻 :restroom:                    🚹 :mens:\n🚺 :womens:                           🚼 :baby_symbol:                 🚭 :no_smoking:\n🅿️ :parking:                         ♿️ :wheelchair:                  🚇 :metro:\n🛄 :baggage_claim:                    🉑 :accept:                      🚾 :wc:\n🚰 :potable_water:                    🚮 :put_litter_in_its_place:     ㊙️ :secret:\n㊗️ :congratulations:                  Ⓜ️ :m:                           🛂 :passport_control:\n🛅 :left_luggage:                     🛃 :customs:                     🉐 :ideograph_advantage:\n🆑 :cl:                               🆘 :sos:                         🆔 :id:\n🚫 :no_entry_sign:                    🔞 :underage:                    📵 :no_mobile_phones:\n🚯 :do_not_litter:                    🚱 :non-potable_water:           🚳 :no_bicycles:\n🚷 :no_pedestrians:                   🚸 :children_crossing:           ⛔️ :no_entry:\n✳️ :eight_spoked_asterisk:            ✴️ :eight_pointed_black_star:    💟 :heart_decoration:\n🆚 :vs:                               📳 :vibration_mode:              📴 :mobile_phone_off:\n💹 :chart:                            💱 :currency_exchange:           ♈️ :aries:\n♉️ :taurus:                           ♊️ :gemini:                      ♋️ :cancer:\n♌️ :leo:                              ♍️ :virgo:                       ♎️ :libra:\n♏️ :scorpius:                         ♐️ :sagittarius:                 ♑️ :capricorn:\n♒️ :aquarius:                         ♓️ :pisces:                      ⛎ :ophiuchus:\n🔯 :six_pointed_star:                 ❎:negative_squared_cross_mark:   🅰️ :a:\n🅱️ :b:                               🆎 :ab:                          🅾️ :o2:\n💠:diamond_shape_with_a_dot_inside:   ♻️ :recycle:                     🔚 :end:\n🔛 :on:                               🔜 :soon:                        🕐 :clock1:\n🕜 :clock130:                         🕙 :clock10:                     🕥 :clock1030:\n🕚 :clock11:                          🕦 :clock1130:                   🕛 :clock12:\n🕧 :clock1230:                        🕑 :clock2:                      🕝 :clock230:\n🕒 :clock3:                           🕞 :clock330:                    🕓 :clock4:\n🕟 :clock430:                         🕔 :clock5:                      🕠 :clock530:\n🕕 :clock6:                           🕡 :clock630:                    🕖 :clock7:\n🕢 :clock730:                         🕗 :clock8:                      🕣 :clock830:\n🕘 :clock9:                           🕤 :clock930:                    💲 :heavy_dollar_sign:\n©️ :copyright:                        ®️ :registered:                  ™️ :tm:\n❌ :x:                                 ❗️ :heavy_exclamation_mark:      ‼️ :bangbang:\n⁉️ :interrobang:                      ⭕️ :o:                           ✖️ :heavy_multiplication_x:\n➕ :heavy_plus_sign:                   ➖ :heavy_minus_sign:             ➗ :heavy_division_sign:\n💮 :white_flower:                     💯 :100:                         ✔️ :heavy_check_mark:\n☑️ :ballot_box_with_check:            🔘 :radio_button:                🔗 :link:\n➰ :curly_loop:                        〰️ :wavy_dash:                   〽️ :part_alternation_mark:\n✅ :white_check_mark:                  🔲 :black_square_button:         🔳 :white_square_button:\n⚫️ :black_circle:                     ⚪️ :white_circle:                🔴 :red_circle:\n🔵 :large_blue_circle:                🔷 :large_blue_diamond:          🔶 :large_orange_diamond:\n🔹 :small_blue_diamond:               🔸 :small_orange_diamond:        🔺 :small_red_triangle:\n🔻 :small_red_triangle_down:          🔱 :trident:                     \n\n\n# 参考链接\n\n * https://www.kuangstudy.com/bbs/1363014604904587265\n * https://blog.csdn.net/u011583927/article/details/104094284",normalizedContent:" * git常用表情\n * markdown 常用表情\n   * people\n   * nature\n   * objects\n   * places\n   * symbols\n * 参考链接\n\n\n# git常用表情\n\ngit commit 的时候，添加表情符号可以更好的表明本次提交的性质，也更有趣。\n\n常用表情符号如下：\n\nemoji        emoji代码                      commit说明\n🎨 (调色板)     :art:                        改进代码结构/代码格式\n⚡️ (闪电)      :zap:                        提升性能\n🐎 (赛马)      :racehorse:                  提升性能\n🔥 (火焰)      :fire:                       移除代码或文件\n🐛 (bug)     :bug:                        修复 bug\n🚑 (急救车)     :ambulance:                  重要补丁\n✨ (火花)       :sparkles:                   引入新功能\n📝 (铅笔)      :pencil:                     撰写文档\n🚀 (火箭)      :rocket:                     部署功能\n💄 (口红)      :lipstick:                   更新 ui 和样式文件\n🎉 (庆祝)      :tada:                       初次提交\n✅ (白色复选框)    :white_check_mark:           增加测试\n🔒 (锁)       :lock:                       修复安全问题\n🍎 (苹果)      :apple:                      修复 macos 下的问题\n🐧 (企鹅)      :penguin:                    修复 linux 下的问题\n🏁 (旗帜)      :checked_flag:               修复 windows 下的问题\n🔖 (书签)      :bookmark:                   发行/版本标签\n🚨 (警车灯)     :rotating_light:             移除 linter 警告\n🚧 (施工)      :construction:               工作进行中\n💚 (绿心)      :green_heart:                修复 ci 构建问题\n⬇️ (下降箭头)    :arrow_down:                 降级依赖\n⬆️ (上升箭头)    :arrow_up:                   升级依赖\n👷 (工人)      :construction_worker:        添加 ci 构建系统\n📈 (上升趋势图)   :chart_with_upwards_trend:   添加分析或跟踪代码\n🔨 (锤子)      :hammer:                     重大重构\n➖ (减号)       :heavy_minus_sign:           减少一个依赖\n🐳 (鲸鱼)      :whale:                      docker 相关工作\n➕ (加号)       :heavy_plus_sign:            增加一个依赖\n🔧 (扳手)      :wrench:                     修改配置文件\n🌐 (地球)      :globe_with_meridians:       国际化与本地化\n✏️ (铅笔)      :pencil2:                    修复 typo\n\n\n# markdown 常用表情\n\n\n# people\n\n😄 :smile:                          😆 :laughing:                       \n😊 :blush:                          😃 :smiley:                         ☺️ :relaxed:\n😏 :smirk:                          😍 :heart_eyes:                     😘 :kissing_heart:\n😚 :kissing_closed_eyes:            😳 :flushed:                        😌 :relieved:\n😆 :satisfied:                      😁 :grin:                           😉 :wink:\n😜 :stuck_out_tongue_winking_eye:   😝 :stuck_out_tongue_closed_eyes:   😀 :grinning:\n😗 :kissing:                        😙 :kissing_smiling_eyes:           😛 :stuck_out_tongue:\n😴 :sleeping:                       😟 :worried:                        😦 :frowning:\n😧 :anguished:                      😮 :open_mouth:                     😬 :grimacing:\n😕 :confused:                       😯 :hushed:                         😑 :expressionless:\n😒 :unamused:                       😅 :sweat_smile:                    😓 :sweat:\n😥 :disappointed_relieved:          😩 :weary:                          😔 :pensive:\n😞 :disappointed:                   😖 :confounded:                     😨 :fearful:\n😰 :cold_sweat:                     😣 :persevere:                      😢 :cry:\n😭 :sob:                            😂 :joy:                            😲 :astonished:\n😱 :scream:                         👿 :imp:                            😫 :tired_face:\n😠 :angry:                          😡 :rage:                           😤 :triumph:\n😪 :sleepy:                         😋 :yum:                            😷 :mask:\n😎 :sunglasses:                     😵 :dizzy_face:                     \n\n                                                               \n😈 :smiling_imp:                😐 :neutral_face:              😶 :no_mouth:\n😇 :innocent:                   👽 :alien:                     💛 :yellow_heart:\n💙 :blue_heart:                 💜 :purple_heart:              ❤️ :heart:\n💚 :green_heart:                💔 :broken_heart:              💓 :heartbeat:\n💗 :heartpulse:                 💕 :two_hearts:                💞 :revolving_hearts:\n💘 :cupid:                      💖 :sparkling_heart:           ✨ :sparkles:\n⭐️ :star:                       🌟 :star2:                     💫 :dizzy:\n💥 :boom:                       💥 :collision:                 💢 :anger:\n❗️ :exclamation:                ❓ :question:                   ❕ :grey_exclamation:\n❔ :grey_question:               💤 :zzz:                       💨 :dash:\n💦 :sweat_drops:                🎶 :notes:                     🎵 :musical_note:\n🔥 :fire:                       💩 :hankey:                    💩 :poop:\n💩 :shit:                       👍 :+1:                        👍 :thumbsup:\n👎 :-1:                         👎 :thumbsdown:                👌 :ok_hand:\n👊 :punch:                      👊 :facepunch:                 ✊ :fist:\n✌️ :v:                          👋 :wave:                      ✋ :hand:\n✋ :raised_hand:                 👐 :open_hands:                ☝️ :point_up:\n👇 :point_down:                 👈 :point_left:                👉 :point_right:\n🙌 :raised_hands:               🙏 :pray:                      👆 :point_up_2:\n👏 :clap:                       💪 :muscle:                    🤘 :metal:\n🖕 :fu:                         🚶 :walking:                   🏃 :runner:\n🏃 :running:                    👫 :couple:                    👪 :family:\n👬 :two_men_holding_hands:      👭 :two_women_holding_hands:   💃 :dancer:\n👯 :dancers:                    🙆 :ok_woman:                  🙅 :no_good:\n💁 :information_desk_person:    🙋 :raising_hand:              👰 :bride_with_veil:\n🙎 :person_with_pouting_face:   🙍 :person_frowning:           🙇 :bow:\n💏 :couplekiss:                 💑 :couple_with_heart:         💆 :massage:\n💇 :haircut:                    💅 :nail_care:                 👦 :boy:\n👧 :girl:                       👩 :woman:                     👨 :man:\n👶 :baby:                       👵 :older_woman:               👴 :older_man:\n👱 :person_with_blond_hair:     👲 :man_with_gua_pi_mao:       👳 :man_with_turban:\n👷 :construction_worker:        👮 :cop:                       👼 :angel:\n👸 :princess:                   😺 :smiley_cat:                😸 :smile_cat:\n😻 :heart_eyes_cat:             😽 :kissing_cat:               😼 :smirk_cat:\n🙀 :scream_cat:                 😿 :crying_cat_face:           😹 :joy_cat:\n😾 :pouting_cat:                👹 :japanese_ogre:             👺 :japanese_goblin:\n🙈 :see_no_evil:                🙉 :hear_no_evil:              🙊 :speak_no_evil:\n💂 :guardsman:                  💀 :skull:                     🐾 :feet:\n👄 :lips:                       💋 :kiss:                      💧 :droplet:\n👂 :ear:                        👀 :eyes:                      👃 :nose:\n👅 :tongue:                     💌 :love_letter:               👤 :bust_in_silhouette:\n👥 :busts_in_silhouette:        💬 :speech_balloon:            💭 :thought_balloon:\n\n\n# nature\n\n☀️ :sunny:                          ☔️ :umbrella:               ☁️ :cloud:\n❄️ :snowflake:                      ⛄️ :snowman:                ⚡️ :zap:\n🌀 :cyclone:                        🌁 :foggy:                  🌊 :ocean:\n🐱 :cat:                            🐶 :dog:                    🐭 :mouse:\n🐹 :hamster:                        🐰 :rabbit:                 🐺 :wolf:\n🐸 :frog:                           🐯 :tiger:                  🐨 :koala:\n🐻 :bear:                           🐷 :pig:                    🐽 :pig_nose:\n🐮 :cow:                            🐗 :boar:                   🐵 :monkey_face:\n🐒 :monkey:                         🐴 :horse:                  🐎 :racehorse:\n🐫 :camel:                          🐑 :sheep:                  🐘 :elephant:\n🐼 :panda_face:                     🐍 :snake:                  🐦 :bird:\n🐤 :baby_chick:                     🐥 :hatched_chick:          🐣 :hatching_chick:\n🐔 :chicken:                        🐧 :penguin:                🐢 :turtle:\n🐛 :bug:                            🐝 :honeybee:               🐜 :ant:\n🐞 :beetle:                         🐌 :snail:                  🐙 :octopus:\n🐠 :tropical_fish:                  🐟 :fish:                   🐳 :whale:\n🐋 :whale2:                         🐬 :dolphin:                🐄 :cow2:\n🐏 :ram:                            🐀 :rat:                    🐃 :water_buffalo:\n🐅 :tiger2:                         🐇 :rabbit2:                🐉 :dragon:\n🐐 :goat:                           🐓 :rooster:                🐕 :dog2:\n🐖 :pig2:                           🐁 :mouse2:                 🐂 :ox:\n🐲 :dragon_face:                    🐡 :blowfish:               🐊 :crocodile:\n🐪 :dromedary_camel:                🐆 :leopard:                🐈 :cat2:\n🐩 :poodle:                         🐾 :paw_prints:             💐 :bouquet:\n🌸 :cherry_blossom:                 🌷 :tulip:                  🍀 :four_leaf_clover:\n🌹 :rose:                           🌻 :sunflower:              🌺 :hibiscus:\n🍁 :maple_leaf:                     🍃 :leaves:                 🍂 :fallen_leaf:\n🌿 :herb:                           🍄 :mushroom:               🌵 :cactus:\n🌴 :palm_tree:                      🌲 :evergreen_tree:         🌳 :deciduous_tree:\n🌰 :chestnut:                       🌱 :seedling:               🌼 :blossom:\n🌾 :ear_of_rice:                    🐚 :shell:                  🌐 :globe_with_meridians:\n🌞 :sun_with_face:                  🌝 :full_moon_with_face:    🌚 :new_moon_with_face:\n🌑 :new_moon:                       🌒 :waxing_crescent_moon:   🌓 :first_quarter_moon:\n🌔 :waxing_gibbous_moon:            🌕 :full_moon:              🌖 :waning_gibbous_moon:\n🌗 :last_quarter_moon:              🌘 :waning_crescent_moon:   🌜 :last_quarter_moon_with_face:\n🌛 :first_quarter_moon_with_face:   🌔 :moon:                   🌍 :earth_africa:\n🌎 :earth_americas:                 🌏 :earth_asia:             🌋 :volcano:\n🌌 :milky_way:                      ⛅️ :partly_sunny:           \n\n\n# objects\n\n🎍 :bamboo:                           💝 :gift_heart:                   🎎 :dolls:\n🎒 :school_satchel:                   🎓 :mortar_board:                 🎏 :flags:\n🎆 :fireworks:                        🎇 :sparkler:                     🎐 :wind_chime:\n🎑 :rice_scene:                       🎃 :jack_o_lantern:               👻 :ghost:\n🎅 :santa:                            🎄 :christmas_tree:               🎁 :gift:\n🔔 :bell:                             🔕 :no_bell:                      🎋 :tanabata_tree:\n🎉 :tada:                             🎊 :confetti_ball:                🎈 :balloon:\n🔮 :crystal_ball:                     💿 :cd:                           📀 :dvd:\n💾 :floppy_disk:                      📷 :camera:                       📹 :video_camera:\n🎥 :movie_camera:                     💻 :computer:                     📺 :tv:\n📱 :iphone:                           ☎️ :phone:                        ☎️ :telephone:\n📞 :telephone_receiver:               📟 :pager:                        📠 :fax:\n💽 :minidisc:                         📼 :vhs:                          🔉 :sound:\n🔈 :speaker:                          🔇 :mute:                         📢 :loudspeaker:\n📣 :mega:                             ⌛️ :hourglass:                    ⏳ :hourglass_flowing_sand:\n⏰ :alarm_clock:                       ⌚️ :watch:                        📻 :radio:\n📡 :satellite:                        ➿ :loop:                          🔍 :mag:\n🔎 :mag_right:                        🔓 :unlock:                       🔒 :lock:\n🔏 :lock_with_ink_pen:                🔐 :closed_lock_with_key:         🔑 :key:\n💡 :bulb:                             🔦 :flashlight:                   🔆 :high_brightness:\n🔅 :low_brightness:                   🔌 :electric_plug:                🔋 :battery:\n📲 :calling:                          ✉️ :email:                        📫 :mailbox:\n📮 :postbox:                          🛀 :bath:                         🛁 :bathtub:\n🚿 :shower:                           🚽 :toilet:                       🔧 :wrench:\n🔩 :nut_and_bolt:                     🔨 :hammer:                       💺 :seat:\n💰 :moneybag:                         💴 :yen:                          💵 :dollar:\n💷 :pound:                            💶 :euro:                         💳 :credit_card:\n💸 :money_with_wings:                 📧 :e-mail:                       📥 :inbox_tray:\n📤 :outbox_tray:                      ✉️ :envelope:                     📨 :incoming_envelope:\n📯 :postal_horn:                      📪 :mailbox_closed:               📬 :mailbox_with_mail:\n📭 :mailbox_with_no_mail:             🚪 :door:                         🚬 :smoking:\n💣 :bomb:                             🔫 :gun:                          🔪 :hocho:\n💊 :pill:                             💉 :syringe:                      📄 :page_facing_up:\n📃 :page_with_curl:                   📑 :bookmark_tabs:                📊 :bar_chart:\n📈 :chart_with_upwards_trend:         📉 :chart_with_downwards_trend:   📜 :scroll:\n📋 :clipboard:                        📆 :calendar:                     📅 :date:\n📇 :card_index:                       📁 :file_folder:                  📂 :open_file_folder:\n✂️ :scissors:                         📌 :pushpin:                      📎 :paperclip:\n✒️ :black_nib:                        ✏️ :pencil2:                      📏 :straight_ruler:\n📐 :triangular_ruler:                 📕 :closed_book:                  📗 :green_book:\n📘 :blue_book:                        📙 :orange_book:                  📓 :notebook:\n📔 :notebook_with_decorative_cover:   📒 :ledger:                       📚 :books:\n🔖 :bookmark:                         📛 :name_badge:                   🔬 :microscope:\n🔭 :telescope:                        📰 :newspaper:                    🏈 :football:\n🏀 :basketball:                       ⚽️ :soccer:                       ⚾️ :baseball:\n🎾 :tennis:                           🎱 :8ball:                        🏉 :rugby_football:\n🎳 :bowling:                          ⛳️ :golf:                         🚵 :mountain_bicyclist:\n🚴 :bicyclist:                        🏇 :horse_racing:                 🏂 :snowboarder:\n🏊 :swimmer:                          🏄 :surfer:                       🎿 :ski:\n♠️ :spades:                           ♥️ :hearts:                       ♣️ :clubs:\n♦️ :diamonds:                         💎 :gem:                          💍 :ring:\n🏆 :trophy:                           🎼 :musical_score:                🎹 :musical_keyboard:\n🎻 :violin:                           👾 :space_invader:                🎮 :video_game:\n🃏 :black_joker:                      🎴 :flower_playing_cards:         🎲 :game_die:\n🎯 :dart:                             🀄️ :mahjong:                     🎬 :clapper:\n📝 :memo:                             📝 :pencil:                       📖 :book:\n🎨 :art:                              🎤 :microphone:                   🎧 :headphones:\n🎺 :trumpet:                          🎷 :saxophone:                    🎸 :guitar:\n👞 :shoe:                             👡 :sandal:                       👠 :high_heel:\n💄 :lipstick:                         👢 :boot:                         👕 :shirt:\n👕 :tshirt:                           👔 :necktie:                      👚 :womans_clothes:\n👗 :dress:                            🎽 :running_shirt_with_sash:      👖 :jeans:\n👘 :kimono:                           👙 :bikini:                       🎀 :ribbon:\n🎩 :tophat:                           👑 :crown:                        👒 :womans_hat:\n👞 :mans_shoe:                        🌂 :closed_umbrella:              💼 :briefcase:\n👜 :handbag:                          👝 :pouch:                        👛 :purse:\n👓 :eyeglasses:                       🎣 :fishing_pole_and_fish:        ☕️ :coffee:\n🍵 :tea:                              🍶 :sake:                         🍼 :baby_bottle:\n🍺 :beer:                             🍻 :beers:                        🍸 :cocktail:\n🍹 :tropical_drink:                   🍷 :wine_glass:                   🍴 :fork_and_knife:\n🍕 :pizza:                            🍔 :hamburger:                    🍟 :fries:\n🍗 :poultry_leg:                      🍖 :meat_on_bone:                 🍝 :spaghetti:\n🍛 :curry:                            🍤 :fried_shrimp:                 🍱 :bento:\n🍣 :sushi:                            🍥 :fish_cake:                    🍙 :rice_ball:\n🍘 :rice_cracker:                     🍚 :rice:                         🍜 :ramen:\n🍲 :stew:                             🍢 :oden:                         🍡 :dango:\n🥚 :egg:                              🍞 :bread:                        🍩 :doughnut:\n🍮 :custard:                          🍦 :icecream:                     🍨 :ice_cream:\n🍧 :shaved_ice:                       🎂 :birthday:                     🍰 :cake:\n🍪 :cookie:                           🍫 :chocolate_bar:                🍬 :candy:\n🍭 :lollipop:                         🍯 :honey_pot:                    🍎 :apple:\n🍏 :green_apple:                      🍊 :tangerine:                    🍋 :lemon:\n🍒 :cherries:                         🍇 :grapes:                       🍉 :watermelon:\n🍓 :strawberry:                       🍑 :peach:                        🍈 :melon:\n🍌 :banana:                           🍐 :pear:                         🍍 :pineapple:\n🍠 :sweet_potato:                     🍆 :eggplant:                     🍅 :tomato:\n🌽 :corn:                                                               \n\n\n# places\n\n🏠 :house:                 🏡 :house_with_garden:         🏫 :school:\n🏢 :office:                🏣 :post_office:               🏥 :hospital:\n🏦 :bank:                  🏪 :convenience_store:         🏩 :love_hotel:\n🏨 :hotel:                 💒 :wedding:                   ⛪️ :church:\n🏬 :department_store:      🏤 :european_post_office:      🌇 :city_sunrise:\n🌆 :city_sunset:           🏯 :japanese_castle:           🏰 :european_castle:\n⛺️ :tent:                  🏭 :factory:                   🗼 :tokyo_tower:\n🗾 :japan:                 🗻 :mount_fuji:                🌄 :sunrise_over_mountains:\n🌅 :sunrise:               🌠 :stars:                     🗽 :statue_of_liberty:\n🌉 :bridge_at_night:       🎠 :carousel_horse:            🌈 :rainbow:\n🎡 :ferris_wheel:          ⛲️ :fountain:                  🎢 :roller_coaster:\n🚢 :ship:                  🚤 :speedboat:                 ⛵️ :boat:\n⛵️ :sailboat:              🚣 :rowboat:                   ⚓️ :anchor:\n🚀 :rocket:                ✈️ :airplane:                  🚁 :helicopter:\n🚂 :steam_locomotive:      🚊 :tram:                      🚞 :mountain_railway:\n🚲 :bike:                  🚡 :aerial_tramway:            🚟 :suspension_railway:\n🚠 :mountain_cableway:     🚜 :tractor:                   🚙 :blue_car:\n🚘 :oncoming_automobile:   🚗 :car:                       🚗 :red_car:\n🚕 :taxi:                  🚖 :oncoming_taxi:             🚛 :articulated_lorry:\n🚌 :bus:                   🚍 :oncoming_bus:              🚨 :rotating_light:\n🚓 :police_car:            🚔 :oncoming_police_car:       🚒 :fire_engine:\n🚑 :ambulance:             🚐 :minibus:                   🚚 :truck:\n🚋 :train:                 🚉 :station:                   🚆 :train2:\n🚅 :bullettrain_front:     🚄 :bullettrain_side:          🚈 :light_rail:\n🚝 :monorail:              🚃 :railway_car:               🚎 :trolleybus:\n🎫 :ticket:                ⛽️ :fuelpump:                  🚦 :vertical_traffic_light:\n🚥 :traffic_light:         ⚠️ :warning:                   🚧 :construction:\n🔰 :beginner:              🏧 :atm:                       🎰 :slot_machine:\n🚏 :busstop:               💈 :barber:                    ♨️ :hotsprings:\n🏁 :checkered_flag:        🎌 :crossed_flags:             🏮 :izakaya_lantern:\n🗿 :moyai:                 🎪 :circus_tent:               🎭 :performing_arts:\n📍 :round_pushpin:         🚩 :triangular_flag_on_post:   🇯🇵 :jp:\n🇰🇷 :kr:                  🇨🇳 :cn:                      🇺🇸 :us:\n🇫🇷 :fr:                  🇪🇸 :es:                      🇮🇹 :it:\n🇷🇺 :ru:                  🇬🇧 :gb:                      🇬🇧 :uk:\n🇩🇪 :de:                                                 \n\n\n# symbols\n\n1️⃣ :one:                             2️⃣ :two:                        3️⃣ :three:\n4️⃣ :four:                            5️⃣ :five:                       6️⃣ :six:\n7️⃣ :seven:                           8️⃣ :eight:                      9️⃣ :nine:\n🔟 :keycap_ten:                       🔢 :1234:                        0️⃣ :zero:\n#️⃣ :hash:                            🔣 :symbols:                     ◀️ :arrow_backward:\n⬇️ :arrow_down:                       ▶️ :arrow_forward:               ⬅️ :arrow_left:\n🔠 :capital_abcd:                     🔡 :abcd:                        🔤 :abc:\n↙️ :arrow_lower_left:                 ↘️ :arrow_lower_right:           ➡️ :arrow_right:\n⬆️ :arrow_up:                         ↖️ :arrow_upper_left:            ↗️ :arrow_upper_right:\n⏬ :arrow_double_down:                 ⏫ :arrow_double_up:              🔽 :arrow_down_small:\n⤵️ :arrow_heading_down:               ⤴️ :arrow_heading_up:            ↩️:leftwards_arrow_with_hook:\n↪️ :arrow_right_hook:                 ↔️ :left_right_arrow:            ↕️ :arrow_up_down:\n🔼 :arrow_up_small:                   🔃 :arrows_clockwise:            🔄 :arrows_counterclockwise:\n⏪ :rewind:                            ⏩ :fast_forward:                 ℹ️ :information_source:\n🆗 :ok:                               🔀 :twisted_rightwards_arrows:   🔁 :repeat:\n🔂 :repeat_one:                       🆕 :new:                         🔝 :top:\n🆙 :up:                               🆒 :cool:                        🆓 :free:\n🆖 :ng:                               🎦 :cinema:                      🈁 :koko:\n📶 :signal_strength:                  🈹 :u5272:                       🈴 :u5408:\n🈺 :u55b6:                            🈯️ :u6307:                      🈷️ :u6708:\n🈶 :u6709:                            🈵 :u6e80:                       🈚️ :u7121:\n🈸 :u7533:                            🈳 :u7a7a:                       🈲 :u7981:\n🈂️ :sa:                              🚻 :restroom:                    🚹 :mens:\n🚺 :womens:                           🚼 :baby_symbol:                 🚭 :no_smoking:\n🅿️ :parking:                         ♿️ :wheelchair:                  🚇 :metro:\n🛄 :baggage_claim:                    🉑 :accept:                      🚾 :wc:\n🚰 :potable_water:                    🚮 :put_litter_in_its_place:     ㊙️ :secret:\n㊗️ :congratulations:                  ⓜ️ :m:                           🛂 :passport_control:\n🛅 :left_luggage:                     🛃 :customs:                     🉐 :ideograph_advantage:\n🆑 :cl:                               🆘 :sos:                         🆔 :id:\n🚫 :no_entry_sign:                    🔞 :underage:                    📵 :no_mobile_phones:\n🚯 :do_not_litter:                    🚱 :non-potable_water:           🚳 :no_bicycles:\n🚷 :no_pedestrians:                   🚸 :children_crossing:           ⛔️ :no_entry:\n✳️ :eight_spoked_asterisk:            ✴️ :eight_pointed_black_star:    💟 :heart_decoration:\n🆚 :vs:                               📳 :vibration_mode:              📴 :mobile_phone_off:\n💹 :chart:                            💱 :currency_exchange:           ♈️ :aries:\n♉️ :taurus:                           ♊️ :gemini:                      ♋️ :cancer:\n♌️ :leo:                              ♍️ :virgo:                       ♎️ :libra:\n♏️ :scorpius:                         ♐️ :sagittarius:                 ♑️ :capricorn:\n♒️ :aquarius:                         ♓️ :pisces:                      ⛎ :ophiuchus:\n🔯 :six_pointed_star:                 ❎:negative_squared_cross_mark:   🅰️ :a:\n🅱️ :b:                               🆎 :ab:                          🅾️ :o2:\n💠:diamond_shape_with_a_dot_inside:   ♻️ :recycle:                     🔚 :end:\n🔛 :on:                               🔜 :soon:                        🕐 :clock1:\n🕜 :clock130:                         🕙 :clock10:                     🕥 :clock1030:\n🕚 :clock11:                          🕦 :clock1130:                   🕛 :clock12:\n🕧 :clock1230:                        🕑 :clock2:                      🕝 :clock230:\n🕒 :clock3:                           🕞 :clock330:                    🕓 :clock4:\n🕟 :clock430:                         🕔 :clock5:                      🕠 :clock530:\n🕕 :clock6:                           🕡 :clock630:                    🕖 :clock7:\n🕢 :clock730:                         🕗 :clock8:                      🕣 :clock830:\n🕘 :clock9:                           🕤 :clock930:                    💲 :heavy_dollar_sign:\n©️ :copyright:                        ®️ :registered:                  ™️ :tm:\n❌ :x:                                 ❗️ :heavy_exclamation_mark:      ‼️ :bangbang:\n⁉️ :interrobang:                      ⭕️ :o:                           ✖️ :heavy_multiplication_x:\n➕ :heavy_plus_sign:                   ➖ :heavy_minus_sign:             ➗ :heavy_division_sign:\n💮 :white_flower:                     💯 :100:                         ✔️ :heavy_check_mark:\n☑️ :ballot_box_with_check:            🔘 :radio_button:                🔗 :link:\n➰ :curly_loop:                        〰️ :wavy_dash:                   〽️ :part_alternation_mark:\n✅ :white_check_mark:                  🔲 :black_square_button:         🔳 :white_square_button:\n⚫️ :black_circle:                     ⚪️ :white_circle:                🔴 :red_circle:\n🔵 :large_blue_circle:                🔷 :large_blue_diamond:          🔶 :large_orange_diamond:\n🔹 :small_blue_diamond:               🔸 :small_orange_diamond:        🔺 :small_red_triangle:\n🔻 :small_red_triangle_down:          🔱 :trident:                     \n\n\n# 参考链接\n\n * https://www.kuangstudy.com/bbs/1363014604904587265\n * https://blog.csdn.net/u011583927/article/details/104094284",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"Git - 删除提交记录",frontmatter:{title:"Git - 删除提交记录",date:"2021-05-15T08:39:07.000Z",permalink:"/pages/81663b/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/05.Git%E5%88%A0%E9%99%A4%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.html",relativePath:"05.工具部署/01.Git/05.Git删除提交记录.md",key:"v-b7c7369a",path:"/pages/81663b/",headers:[{level:2,title:"删除所有记录",slug:"删除所有记录",normalizedTitle:"删除所有记录",charIndex:3},{level:2,title:"删除上次记录",slug:"删除上次记录",normalizedTitle:"删除上次记录",charIndex:13},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:23}],headersStr:"删除所有记录 删除上次记录 参考资料",content:' * 删除所有记录\n * 删除上次记录\n * 参考资料\n\n\n# 删除所有记录\n\n不小心把密码或其他敏感信息提交到git，想清空所有commit信息记录，就像形成一个全新的仓库，且代码不变。\n\n 1. 切换到新的分支\n    \n    git checkout --orphan latest_branch\n    \n    \n    1\n    \n\n 2. 缓存所有文件（除了.gitignore中声名排除的）\n    \n    git add -A\n    \n    \n    1\n    \n\n 3. 提交跟踪过的文件\n    \n    git commit -am "commit message"\n    \n    \n    1\n    \n\n 4. 删除master分支\n    \n    git branch -D master\n    \n    \n    1\n    \n\n 5. 重命名当前分支为master\n    \n    git branch -m master\n    \n    \n    1\n    \n\n 6. 提交到远程master分支\n    \n    git push -f origin master\n    \n    \n    1\n    \n\n以上是删除所有提交记录，那么如何修改内容覆盖上次记录呢？\n\n\n# 删除上次记录\n\n如你只是想修改上次提交的代码，做一次更完美的commit，可以这样\n\n（1）git reset commitId，(注：不要带--hard)到上个版本\n\n（2）git stash，暂存修改\n\n（3）git push --force, 强制push,远程的最新的一次commit被删除\n\n（4）git stash pop，释放暂存的修改，开始修改代码\n\n（5）git add . -> git commit -m "massage" -> git push\n\n\n# 参考资料\n\n * https://my.oschina.net/18y/blog/3064211\n * https://segmentfault.com/q/1010000002898735',normalizedContent:' * 删除所有记录\n * 删除上次记录\n * 参考资料\n\n\n# 删除所有记录\n\n不小心把密码或其他敏感信息提交到git，想清空所有commit信息记录，就像形成一个全新的仓库，且代码不变。\n\n 1. 切换到新的分支\n    \n    git checkout --orphan latest_branch\n    \n    \n    1\n    \n\n 2. 缓存所有文件（除了.gitignore中声名排除的）\n    \n    git add -a\n    \n    \n    1\n    \n\n 3. 提交跟踪过的文件\n    \n    git commit -am "commit message"\n    \n    \n    1\n    \n\n 4. 删除master分支\n    \n    git branch -d master\n    \n    \n    1\n    \n\n 5. 重命名当前分支为master\n    \n    git branch -m master\n    \n    \n    1\n    \n\n 6. 提交到远程master分支\n    \n    git push -f origin master\n    \n    \n    1\n    \n\n以上是删除所有提交记录，那么如何修改内容覆盖上次记录呢？\n\n\n# 删除上次记录\n\n如你只是想修改上次提交的代码，做一次更完美的commit，可以这样\n\n（1）git reset commitid，(注：不要带--hard)到上个版本\n\n（2）git stash，暂存修改\n\n（3）git push --force, 强制push,远程的最新的一次commit被删除\n\n（4）git stash pop，释放暂存的修改，开始修改代码\n\n（5）git add . -> git commit -m "massage" -> git push\n\n\n# 参考资料\n\n * https://my.oschina.net/18y/blog/3064211\n * https://segmentfault.com/q/1010000002898735',charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"Git - DS_Store",frontmatter:{title:"Git - DS_Store",date:"2023-02-17T22:46:45.000Z",permalink:"/pages/0fc313/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/06.DS_Store.html",relativePath:"05.工具部署/01.Git/06.DS_Store.md",key:"v-636ce848",path:"/pages/0fc313/",headers:[{level:2,title:".DS_Store 是什么",slug:"ds-store-是什么",normalizedTitle:".ds_store 是什么",charIndex:3},{level:2,title:"删除 .DS_Store",slug:"删除-ds-store",normalizedTitle:"删除 .ds_store",charIndex:20}],headersStr:".DS_Store 是什么 删除 .DS_Store",content:" * .DS_Store 是什么\n * 删除 .DS_Store\n\n\n\n\n# .DS_Store 是什么\n\n使用 Mac 的用户可能会注意到，系统经常会自动在每个目录生成一个隐藏的 .DS_Store 文件。.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。\n\n\n# 删除 .DS_Store\n\n如果你的项目中还没有自动生成的 .DS_Store 文件，那么直接将 .DS_Store 加入到 .gitignore 文件就可以了。\n\n.DS_Store \n*/.DS_Store\n\n\n1\n2\n\n\n如果你的项目中已经存在 .DS_Store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下：\n\n#删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store\nfind . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch\n\n\n1\n2\n",normalizedContent:" * .ds_store 是什么\n * 删除 .ds_store\n\n\n\n\n# .ds_store 是什么\n\n使用 mac 的用户可能会注意到，系统经常会自动在每个目录生成一个隐藏的 .ds_store 文件。.ds_store(英文全称 desktop services store)是一种由苹果公司的mac os x操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 windows 下的 desktop.ini。\n\n\n# 删除 .ds_store\n\n如果你的项目中还没有自动生成的 .ds_store 文件，那么直接将 .ds_store 加入到 .gitignore 文件就可以了。\n\n.ds_store \n*/.ds_store\n\n\n1\n2\n\n\n如果你的项目中已经存在 .ds_store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下：\n\n#删除项目中的所有.ds_store。这会跳过不在项目中的 .ds_store\nfind . -name .ds_store -print0 | xargs -0 git rm -f --ignore-unmatch\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 14:02:00",lastUpdatedTimestamp:1676645619e3},{title:"Docker - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.工具部署/10.Docker",imgUrl:"/img/web.png",description:"Docker目录页"}},title:"Docker - 知识体系",permalink:"/docker",article:!1,comment:!1,editLink:!1,date:"2021-08-02T13:57:27.000Z"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/01.Docker.html",relativePath:"05.工具部署/10.Docker/01.Docker.md",key:"v-36da3e34",path:"/docker/",headersStr:null,content:"bilibili 搜 Docker\n\n狂神：https://www.bilibili.com/video/BV1og4y1q7M4",normalizedContent:"bilibili 搜 docker\n\n狂神：https://www.bilibili.com/video/bv1og4y1q7m4",charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - 安装",frontmatter:{title:"Docker - 安装",date:"2021-06-02T23:33:02.000Z",permalink:"/pages/fc0548/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/04.Docker%20-%20%E5%AE%89%E8%A3%85.html",relativePath:"05.工具部署/10.Docker/04.Docker - 安装.md",key:"v-6461f3c1",path:"/pages/fc0548/",headers:[{level:2,title:"环境说明",slug:"环境说明",normalizedTitle:"环境说明",charIndex:3},{level:2,title:"安装步骤",slug:"安装步骤",normalizedTitle:"安装步骤",charIndex:11},{level:2,title:"阿里云镜像加速",slug:"阿里云镜像加速",normalizedTitle:"阿里云镜像加速",charIndex:19}],headersStr:"环境说明 安装步骤 阿里云镜像加速",content:' * 环境说明\n * 安装步骤\n * 阿里云镜像加速\n\n\n# 环境说明\n\n我们使用的是 CentOS 7 (64-bit)\n\nDocker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。\n\n查看自己的内核：\n\n用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型 等）。\n\nuname -r\n\n\n1\n\n\n查看版本信息：\n\ncat /etc/os-release\n\n\n1\n\n\n\n# 安装步骤\n\n官网安装参考手册：https://docs.docker.com/engine/install/centos/\n\n 1. yum安装gcc相关环境（需要确保虚拟机可以上外网 ）\n    \n    yum -y install gcc\n    yum -y install gcc-c++\n    \n    \n    1\n    2\n    \n\n 2. 卸载旧版本\n    \n    sudo yum remove docker \\\n                      docker-client \\\n                      docker-client-latest \\\n                      docker-common \\\n                      docker-latest \\\n                      docker-latest-logrotate \\\n                      docker-logrotate \\\n                      docker-engine\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 安装需要的软件包\n    \n    sudo yum install -y yum-utils\n    \n    \n    1\n    \n\n 4. 设置镜像仓库\n    \n    官网（国外）：\n    \n    sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo\n    \n    \n    1\n    2\n    3\n    \n    \n    阿里云（推荐）：\n    \n    sudo yum-config-manager \\\n        --add-repo \\\n        http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \n    \n    1\n    2\n    3\n    \n\n 5. 更新yum软件包索引\n    \n    yum makecache fast\n    \n    \n    1\n    \n\n 6. 安装 Docker CE\n    \n    yum install docker-ce docker-ce-cli containerd.io\n    \n    \n    1\n    \n\n 7. 启动 Docker\n    \n    systemctl start docker\n    \n    \n    1\n    \n    \n    至此，已经安装完\n\n常用命令：\n\n# 启动docker\nsystemctl start docker\n# 停止dokcer\nsystemctl stop docker\n# 查看docker状态\nsystemctl status docker \n# 重启docker\nsystemctl restart docker\n# 设置docker 开机自启\nsystemctl enable docker\n# 设置docker 开机不自启\nsystemctl disable docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * 查看版本\n   \n   docker version\n   \n   \n   1\n   \n\n * 查看安装的镜像\n   \n   docker images\n   \n   \n   1\n   \n\n * 测试运行hello\n   \n   docker run hello-world\n   \n   \n   1\n   \n\n卸载docker\n\nsystemctl stop docker\nyum -y remove docker-ce docker-ce-cli containerd.io\nrm -rf /var/lib/docker\n\n\n1\n2\n3\n\n\n\n# 阿里云镜像加速\n\n介绍：https://www.aliyun.com/product/acr\n\n查看自己的镜像加速器并配置\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  "registry-mirrors": ["https://cbl6xdl3.mirror.aliyuncs.com"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n\n\n> 测试 HelloWorld\n\n启动hello-world\n\ndocker run hello-world\n\n\n1\n\n\nrun干了什么？\n\n',normalizedContent:' * 环境说明\n * 安装步骤\n * 阿里云镜像加速\n\n\n# 环境说明\n\n我们使用的是 centos 7 (64-bit)\n\ndocker 运行在 centos 7 上，要求系统为64位、系统内核版本为 3.10 以上。\n\n查看自己的内核：\n\n用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型 等）。\n\nuname -r\n\n\n1\n\n\n查看版本信息：\n\ncat /etc/os-release\n\n\n1\n\n\n\n# 安装步骤\n\n官网安装参考手册：https://docs.docker.com/engine/install/centos/\n\n 1. yum安装gcc相关环境（需要确保虚拟机可以上外网 ）\n    \n    yum -y install gcc\n    yum -y install gcc-c++\n    \n    \n    1\n    2\n    \n\n 2. 卸载旧版本\n    \n    sudo yum remove docker \\\n                      docker-client \\\n                      docker-client-latest \\\n                      docker-common \\\n                      docker-latest \\\n                      docker-latest-logrotate \\\n                      docker-logrotate \\\n                      docker-engine\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. 安装需要的软件包\n    \n    sudo yum install -y yum-utils\n    \n    \n    1\n    \n\n 4. 设置镜像仓库\n    \n    官网（国外）：\n    \n    sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo\n    \n    \n    1\n    2\n    3\n    \n    \n    阿里云（推荐）：\n    \n    sudo yum-config-manager \\\n        --add-repo \\\n        http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \n    \n    1\n    2\n    3\n    \n\n 5. 更新yum软件包索引\n    \n    yum makecache fast\n    \n    \n    1\n    \n\n 6. 安装 docker ce\n    \n    yum install docker-ce docker-ce-cli containerd.io\n    \n    \n    1\n    \n\n 7. 启动 docker\n    \n    systemctl start docker\n    \n    \n    1\n    \n    \n    至此，已经安装完\n\n常用命令：\n\n# 启动docker\nsystemctl start docker\n# 停止dokcer\nsystemctl stop docker\n# 查看docker状态\nsystemctl status docker \n# 重启docker\nsystemctl restart docker\n# 设置docker 开机自启\nsystemctl enable docker\n# 设置docker 开机不自启\nsystemctl disable docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * 查看版本\n   \n   docker version\n   \n   \n   1\n   \n\n * 查看安装的镜像\n   \n   docker images\n   \n   \n   1\n   \n\n * 测试运行hello\n   \n   docker run hello-world\n   \n   \n   1\n   \n\n卸载docker\n\nsystemctl stop docker\nyum -y remove docker-ce docker-ce-cli containerd.io\nrm -rf /var/lib/docker\n\n\n1\n2\n3\n\n\n\n# 阿里云镜像加速\n\n介绍：https://www.aliyun.com/product/acr\n\n查看自己的镜像加速器并配置\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'eof\'\n{\n  "registry-mirrors": ["https://cbl6xdl3.mirror.aliyuncs.com"]\n}\neof\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n\n\n> 测试 helloworld\n\n启动hello-world\n\ndocker run hello-world\n\n\n1\n\n\nrun干了什么？\n\n',charsets:{cjk:!0},lastUpdated:"2023/12/24, 7:12:00",lastUpdatedTimestamp:1703403105e3},{title:"Docker - 概述",frontmatter:{title:"Docker - 概述",date:"2021-05-28T23:41:35.000Z",permalink:"/pages/09f2eb/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/02.Docker%20-%20%E6%A6%82%E8%BF%B0.html",relativePath:"05.工具部署/10.Docker/02.Docker - 概述.md",key:"v-87e4ba86",path:"/pages/09f2eb/",headers:[{level:2,title:"学习资源",slug:"学习资源",normalizedTitle:"学习资源",charIndex:9},{level:2,title:"历史",slug:"历史",normalizedTitle:"历史",charIndex:17},{level:2,title:"什么是虚拟化技术",slug:"什么是虚拟化技术",normalizedTitle:"什么是虚拟化技术",charIndex:23},{level:3,title:"什么是虚拟化",slug:"什么是虚拟化",normalizedTitle:"什么是虚拟化",charIndex:23},{level:3,title:"虚拟化技术分类",slug:"虚拟化技术分类",normalizedTitle:"虚拟化技术分类",charIndex:49},{level:4,title:"硬件虚拟化",slug:"硬件虚拟化",normalizedTitle:"硬件虚拟化",charIndex:64},{level:4,title:"软件虚拟化",slug:"软件虚拟化",normalizedTitle:"软件虚拟化",charIndex:77},{level:3,title:"几种虚拟化技术",slug:"几种虚拟化技术",normalizedTitle:"几种虚拟化技术",charIndex:88},{level:2,title:"Docker虚拟化",slug:"docker虚拟化",normalizedTitle:"docker虚拟化",charIndex:99},{level:3,title:"什么是Docker？",slug:"什么是docker",normalizedTitle:"什么是docker？",charIndex:114},{level:3,title:"Docker能干什么？",slug:"docker能干什么",normalizedTitle:"docker能干什么？",charIndex:130},{level:3,title:"Docker的基本组成",slug:"docker的基本组成",normalizedTitle:"docker的基本组成",charIndex:147},{level:2,title:"Docker和虚拟机的区别？",slug:"docker和虚拟机的区别",normalizedTitle:"docker和虚拟机的区别？",charIndex:162},{level:3,title:"基本对比",slug:"基本对比",normalizedTitle:"基本对比",charIndex:182},{level:3,title:"虚拟技术对比",slug:"虚拟技术对比",normalizedTitle:"虚拟技术对比",charIndex:192},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:202}],headersStr:"学习资源 历史 什么是虚拟化技术 什么是虚拟化 虚拟化技术分类 硬件虚拟化 软件虚拟化 几种虚拟化技术 Docker虚拟化 什么是Docker？ Docker能干什么？ Docker的基本组成 Docker和虚拟机的区别？ 基本对比 虚拟技术对比 参考文章",content:'# 概述\n\n * 学习资源\n * 历史\n * 什么是虚拟化技术\n   * 什么是虚拟化\n   * 虚拟化技术分类\n     * 硬件虚拟化\n     * 软件虚拟化\n   * 几种虚拟化技术\n * Docker虚拟化\n   * 什么是Docker？\n   * Docker能干什么？\n   * Docker的基本组成\n * Docker和虚拟机的区别？\n   * 基本对比\n   * 虚拟技术对比\n * 参考文章\n\n\n# 学习资源\n\n最好的资源在官网!\n\nDocker官方：\n\n * Docker 官方主页: https://www.docker.com\n\n * Docker 官方博客: https://blog.docker.com\n\n * Docker 官方文档: https://docs.docker.com\n\n * Docker Store: https://store.docker.com\n\n * Docker Cloud: https://cloud.docker.com\n\n * Docker Hub: https://hub.docker.com\n\n视频教程：\n\n * bilibili 搜 Docker\n   \n   狂神：https://www.bilibili.com/video/BV1og4y1q7M4\n\n\n# 历史\n\n2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。\n\n这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。\n\n后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。\n\nDocker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n\n2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。 不开则已，一开惊人。\n\n越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。\n\nDocker的人气迅速攀升，速度之快，令人瞠目结舌。\n\n开源当月，Docker 0.1 版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0 版本正式发布。\n\n此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。\n\nDocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n\n在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是VMWare和OpenStack。\n\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是相互隔离的，互不影响。\n\n虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于轻量级的虚拟化。\n\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。\n\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。\n\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\n> docker 理念\n\nDocker是基于Go语言实现的云开源项目。\n\nDocker的主要目标是“Build，Ship and Run Any App , Anywhere”，也就是通过对应用组件的封装、分 发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。\n\nLinux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需 要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。\n\n\n# 什么是虚拟化技术\n\n\n# 什么是虚拟化\n\n在计算机技术中，虚拟化（Virtualization）是一种资源管理技术。它是将计算机的各种实体资源，如：服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用更好的方式来利用这些资源。\n\n虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。\n\n\n# 虚拟化技术分类\n\n从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。\n\n# 硬件虚拟化\n\n硬件虚拟化就是硬件物理平台本身提供了对特殊指令的截获和重定向的支持。支持虚拟化的硬件，也是一些基于硬件实现软件虚拟化技术的关键。在基于硬件实现软件虚拟化的技术中，在硬件是实现虚拟化的基础，硬件(主要是CPU)会为虚拟化软件提供支持，从而实现硬件资源的虚拟化。\n\n支持虚拟化的硬件有：\n\n * Intel-VT-(Intel Virtualization Technology)，Intel公司为解决纯软件虚拟化解决方案在可靠性、安全性和性能上的不足而引进的技术。它可以让一个CPU工作起来像多个CPU在并行运行，从而使得在一部电脑内同时运行多个操作系统成为可能\n * AMD-V-(AMD Virtualization)，是AMD公司的虚拟化技术。它是对x86处理器系统架构的一组硬件扩展和硬件辅助虚拟化技术，可以简化纯软件的虚拟化解决方案，改进VMM（虚拟机监视器）的设计，更充分地利用硬件资源，提高服务器和数据中心的虚拟化效率\n\n# 软件虚拟化\n\n软件虚拟化就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。在软件虚拟化技术中，有些技术不需要硬件支持，如：QEMU；而有些软件虚拟化技术，则依赖硬件支持，如：VMware、KVM。\n\n对软件虚拟化进行细分，又可以分为以下几类：\n\n * 完全虚拟化：（Full Virtualization）虚拟机模拟完整的底层硬件环境和特权指令的执行过程，使客户机操作系统可以独立运行。支持完全虚拟化的软件有：Parallels Workstation、VirtualBox、Virtual Iron、Oracle VM、Virtual PC、Virtual Server、Hyper-V、VMware Workstation、QEMU等\n * 硬件辅助虚拟化：（Hardware-assisted Virtualization）是指通过硬件辅助支持模拟运行环境，使客户机操作系统可以独立运行，实现完全虚拟化的功能。支持硬件辅助虚拟化的软件有：Linux KVM、VMware Workstation、VMware Fusion、Virtual PC、Xen、VirtualBox、Parallels Workstation等\n * 部分虚拟化：（Partial Virtualization）只针对部分硬件资源进行虚拟化，虚拟机模拟部分底层硬件环境，特别是地址空间。这样的环境支持资源共享和线程独立，但是不允许建立独立的客户机操作系统。\n * 平行虚拟化：（Para-Virtualization）虚拟机不需要模拟硬件，而是将部分硬件接口以软件的形式提供给客户机操作系统。如：早期的Xen。\n * 操作系统层虚拟化：（OS-level virtualization）这种技术将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。这个软件实例，也被称为是一个容器（containers）、虚拟引擎（Virtualization engine）、虚拟专用服务器（virtual private servers）。每个容器的进程是独立的，对于使用者来说，就像是在使用自己的专用服务器。 Docker容器技术就是属于操作系统层虚拟化的范畴。\n\n\n# 几种虚拟化技术\n\n虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。在虚拟化的发展过程中，出现过以下主要虚拟化技术或产品：\n\n * Xen - 由剑桥大学开发的，一款开源的虚拟机监视器。采用ICA协议，它通过一种叫做准虚拟化的技术来获取高性能，甚至在一些与传统虚拟技术极度不友好的架构上（如：x86），Xen也有极佳的表现。Xen属于半虚拟化的技术，所以其性能损失非常小。Xen没有指令翻译，其或者使用使能理解和翻译虚拟操作系统发出的未修改指令的CPU（即：完全虚拟化）；或者修改操作系统，使它发出的指令最优化，便于在虚拟化环境中执行（即：准虚拟化）。\n * KVM - KVM是一个Linux kernel模块，可以使用modprobe来加载KVM，加载后还需要通过其他工具创建虚拟机。KVM是一个全虚拟化的解决方案，但需要CPU支持虚拟化功能。相比Xen来说，KVM可以更加方便的整合进Linux内核，但它还需要其它虚拟化软件（如：QEMU）才能实现虚拟化功能。\n * LXC - 即：Linux Container，Linux容器，是一种轻量级的虚拟化的手段。它可以提供轻量级的虚拟化，以隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。容器会有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。\n * OpenVZ - 是SWsoft公司开发的开源软件，是该公司Virtuozzo软件的基础产品，是基于Linux平台的操作系统级服务器虚拟化解决方案。通过OpenVZ，可以在单个物理服务器上创建多个相互隔离的虚拟专用服务器(VPS)并以最大的效率共享硬件和管理资源。其上运行虚拟服务器被称为VPS（Virtual Private Serve），每个VPS的运行环境和独立服务器完全一致。OpenVZ基于Linux系统内核及作业系统提供操作系统级虚拟化，在虚拟化过程中资源消耗非常小，官方宣称约1-2%。\n * Hyper-V - 是微软件推出的一种虚拟化技术，可以采用半虚拟化或全虚拟的方式创建虚拟机。虽然它可以创建Windows或Linux操作系统，但其本身只能运行在Windows系统下，使用范围较为有限。\n * Oracle VM - Oracle推出的服务器虚拟化软件，基于开源的Xen技术，包括Oracle VM Server和Oracle VM Manager两部分。\n * VMWare - 是一家非常出名虚拟化软件公司，其产品涵盖服务器、桌面等各种虚拟化领域，如：VMware Workstation - 是一款桌面虚拟机软件，可以在一台实体机器上模拟完整的网络环境，并可运行多个Windows、DOS、Linux或Mac系统，是非常好的开发、测试、部署解决方案。从技术角度来说，VMware Workstation是一款完全虚拟化产品，可借助硬件辅助在不修改用户操作系统的情况下完整虚拟化操作系统。\n * VMware ESX Server - 是一款适用于任何系统环境的企业级的虚拟机软件，可以认为是VMware Server的升级版。相比VMware Workstation来说，其功能更加强大，可以用于构建高伸缩和高可靠企业级服务器，并可实现远程管理、高级资源管理控制等高级功能。\n\n\n# Docker虚拟化\n\n\n# 什么是Docker？\n\nDocker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker基于LXC来实现类似VM的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同VM等虚拟化的方式不同，LXC不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。\n\nDocker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。\n\nDocker借助Linux的内核特性，如：控制组（Control Group）、命名空间（Namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。\n\n\n# Docker能干什么？\n\n * 简化配置\n\n这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。\n\n * 代码流水线（Code Pipeline）管理\n\n前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。\n\n * 提高开发效率\n\n这就带来了一些额外的好处：Docker能提升开发者的开发效率。详细一点的例子，可以参考Aater在DevOpsDays Austin 2014大会或者是DockerCon上的演讲。\n\n不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。\n\n理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。\n\n * 隔离应用\n\n有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。\n\n我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考Steve Yege的这篇论文，文中将Google和亚马逊做了比较。\n\n * 整合服务器 正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。\n * 调适能力\n\nDocker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。\n\n * 多租户\n\n另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。\n\n使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。\n\n * 快速部署\n\n在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。\n\n你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。\n\n\n# Docker的基本组成\n\n仓库，镜像，容器的关系（这是官网的图）\n\n\n\n * 镜像（image）\n\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很 多容器。 就好似 Java 中的 类和对象，类就是镜像，容器就是对象！\n\n * 容器（container）：\n\nDocker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。\n\n它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。\n\n可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等） 和运行在其中的应用程序\n\n容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。\n\n * 仓库（repository）：\n\n仓库（Repository）是集中存放镜像文件的场所。\n\n仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓 库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n\n仓库分为公开仓库（Public）和私有仓库（Private）两种形式\n\n最大的公开仓库是 Docker Hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括阿里云 、网易云 等\n\n小结：\n\nDocker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个 可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生 成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。 同一个 image 文件，可以生成多个同时运行的容器实例。\n\nimage 文件生成的容器实例，本身也是一个文件，称为镜像文件\n\n一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例， 也就是我们的容器\n\n至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来 就可以了。\n\n\n# Docker和虚拟机的区别？\n\n> 虚拟机Virtual Machine与容器化技术（代表Docker）都是虚拟化技术，两者的区别在于虚拟化的程度不同。\n\n\n# 基本对比\n\n\n\n * 虚拟机\n   * 基础设施（Infrastructure）。它可以是你的个人电脑，数据中心的服务器，或者是云主机。\n   * 主操作系统（Host Operating System）。你的个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。\n   * 虚拟机管理系统（Hypervisor）。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。\n   * 操作系统（Guest Operating System）。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。\n   * 各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。\n * Docker容器\n   * 主操作系统（Host Operating System）。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法"运行"Docker。\n   * Docker守护进程（Docker Daemon）。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。\n   * 各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。\n   * 应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。\n\n虚拟机是在物理资源层面实现的隔离，相对于虚拟机，Docker是你APP层面实现的隔离，并且省去了虚拟机操作系统（Guest OS）），从而节省了一部分的系统资源；Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。\n\n虚拟机与容器docker的区别，在于vm多了一层guest OS，虚拟机的Hypervisor会对硬件资源也进行虚拟化，而容器Docker会直接使用宿主机的硬件资源。\n\n下面我们采用形象的比喻区分两者的隔离级别：\n\n * 服务器：比作一个大型的仓管基地，包含场地与零散的货物——相当于各种服务器资源。\n * 虚拟机技术：比作仓库，拥有独立的空间堆放各种货物或集装箱，仓库之间完全独立——仓库相当于各种系统，独立的应用系统和操作系统。\n * Docker：比作集装箱，操作各种货物的打包——将各种应用程序和他们所依赖的运行环境打包成标准的容器，容器之间隔离。\n\n\n# 虚拟技术对比\n\n * 隔离性\n\n在于隔离性上面，由于vm对操作系统也进行了虚拟化，隔离的更加彻底。而Docker共享宿主机的操作系统，隔离性较差。\n\n * 运行效率\n\n由于vm的隔离操作，导致生成虚拟机的速率大大低于容器Docker生成的速度，因为Docker直接利用宿主机的系统内核。比如openstack能够以10台/min的速度创建虚拟机，而docker可以做到在几秒钟之内创建大量容器，它们的启动速度是在数量级上的差距。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。\n\n * 资源利用率\n\n在资源利用率上虚拟机由于隔离更彻底，因此利用率也会相对较低。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。比如对于本次实验的平台，实际的CPU架构是2块物理CPU。\n\n\n# 参考文章\n\n推荐浏览以下网站：\n\n * Java 全栈知识体系\n   \n   https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html',normalizedContent:'# 概述\n\n * 学习资源\n * 历史\n * 什么是虚拟化技术\n   * 什么是虚拟化\n   * 虚拟化技术分类\n     * 硬件虚拟化\n     * 软件虚拟化\n   * 几种虚拟化技术\n * docker虚拟化\n   * 什么是docker？\n   * docker能干什么？\n   * docker的基本组成\n * docker和虚拟机的区别？\n   * 基本对比\n   * 虚拟技术对比\n * 参考文章\n\n\n# 学习资源\n\n最好的资源在官网!\n\ndocker官方：\n\n * docker 官方主页: https://www.docker.com\n\n * docker 官方博客: https://blog.docker.com\n\n * docker 官方文档: https://docs.docker.com\n\n * docker store: https://store.docker.com\n\n * docker cloud: https://cloud.docker.com\n\n * docker hub: https://hub.docker.com\n\n视频教程：\n\n * bilibili 搜 docker\n   \n   狂神：https://www.bilibili.com/video/bv1og4y1q7m4\n\n\n# 历史\n\n2010年，几个搞it的年轻人，在美国旧金山成立了一家名叫“dotcloud”的公司。\n\n这家公司主要提供基于paas的云计算技术服务。具体来说，是和lxc有关的容器技术。\n\n后来，dotcloud公司将自己的容器技术进行了简化和标准化，并命名为——docker。\n\ndocker技术诞生之后，并没有引起行业的关注。而dotcloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n\n2013年3月，dotcloud公司的创始人之一，docker之父，28岁的solomon hykes正式决定，将docker项目开源。 不开则已，一开惊人。\n\n越来越多的it工程师发现了docker的优点，然后蜂拥而至，加入docker开源社区。\n\ndocker的人气迅速攀升，速度之快，令人瞠目结舌。\n\n开源当月，docker 0.1 版本发布。此后的每一个月，docker都会发布一个版本。到2014年6月9日，docker 1.0 版本正式发布。\n\n此时的docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像google、微软、amazon、vmware这样的巨头，都对它青睐有加，表示将全力支持。\n\ndocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n\n在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是vmware和openstack。\n\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开qq。如果你愿意，你可以变出好几个“子电脑”，里面都开上qq。“子电脑”和“子电脑”之间，是相互隔离的，互不影响。\n\n虚拟机属于虚拟化技术。而docker这样的容器技术，也是虚拟化技术，属于轻量级的虚拟化。\n\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如vmware）。\n\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个docker容器）。此外，它占的空间很小，虚拟机一般要几gb到几十gb的空间，而容器只需要mb级甚至kb级。\n\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\n> docker 理念\n\ndocker是基于go语言实现的云开源项目。\n\ndocker的主要目标是“build，ship and run any app , anywhere”，也就是通过对应用组件的封装、分 发、部署、运行等生命周期的管理，使用户的app（可以是一个web应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。\n\nlinux 容器技术的出现就解决了这样一个问题，而 docker 就是在它的基础上发展过来的。将应用运行在 docker 容器上面，而 docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需 要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。\n\n\n# 什么是虚拟化技术\n\n\n# 什么是虚拟化\n\n在计算机技术中，虚拟化（virtualization）是一种资源管理技术。它是将计算机的各种实体资源，如：服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用更好的方式来利用这些资源。\n\n虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。\n\n\n# 虚拟化技术分类\n\n从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。\n\n# 硬件虚拟化\n\n硬件虚拟化就是硬件物理平台本身提供了对特殊指令的截获和重定向的支持。支持虚拟化的硬件，也是一些基于硬件实现软件虚拟化技术的关键。在基于硬件实现软件虚拟化的技术中，在硬件是实现虚拟化的基础，硬件(主要是cpu)会为虚拟化软件提供支持，从而实现硬件资源的虚拟化。\n\n支持虚拟化的硬件有：\n\n * intel-vt-(intel virtualization technology)，intel公司为解决纯软件虚拟化解决方案在可靠性、安全性和性能上的不足而引进的技术。它可以让一个cpu工作起来像多个cpu在并行运行，从而使得在一部电脑内同时运行多个操作系统成为可能\n * amd-v-(amd virtualization)，是amd公司的虚拟化技术。它是对x86处理器系统架构的一组硬件扩展和硬件辅助虚拟化技术，可以简化纯软件的虚拟化解决方案，改进vmm（虚拟机监视器）的设计，更充分地利用硬件资源，提高服务器和数据中心的虚拟化效率\n\n# 软件虚拟化\n\n软件虚拟化就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。在软件虚拟化技术中，有些技术不需要硬件支持，如：qemu；而有些软件虚拟化技术，则依赖硬件支持，如：vmware、kvm。\n\n对软件虚拟化进行细分，又可以分为以下几类：\n\n * 完全虚拟化：（full virtualization）虚拟机模拟完整的底层硬件环境和特权指令的执行过程，使客户机操作系统可以独立运行。支持完全虚拟化的软件有：parallels workstation、virtualbox、virtual iron、oracle vm、virtual pc、virtual server、hyper-v、vmware workstation、qemu等\n * 硬件辅助虚拟化：（hardware-assisted virtualization）是指通过硬件辅助支持模拟运行环境，使客户机操作系统可以独立运行，实现完全虚拟化的功能。支持硬件辅助虚拟化的软件有：linux kvm、vmware workstation、vmware fusion、virtual pc、xen、virtualbox、parallels workstation等\n * 部分虚拟化：（partial virtualization）只针对部分硬件资源进行虚拟化，虚拟机模拟部分底层硬件环境，特别是地址空间。这样的环境支持资源共享和线程独立，但是不允许建立独立的客户机操作系统。\n * 平行虚拟化：（para-virtualization）虚拟机不需要模拟硬件，而是将部分硬件接口以软件的形式提供给客户机操作系统。如：早期的xen。\n * 操作系统层虚拟化：（os-level virtualization）这种技术将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。这个软件实例，也被称为是一个容器（containers）、虚拟引擎（virtualization engine）、虚拟专用服务器（virtual private servers）。每个容器的进程是独立的，对于使用者来说，就像是在使用自己的专用服务器。 docker容器技术就是属于操作系统层虚拟化的范畴。\n\n\n# 几种虚拟化技术\n\n虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。在虚拟化的发展过程中，出现过以下主要虚拟化技术或产品：\n\n * xen - 由剑桥大学开发的，一款开源的虚拟机监视器。采用ica协议，它通过一种叫做准虚拟化的技术来获取高性能，甚至在一些与传统虚拟技术极度不友好的架构上（如：x86），xen也有极佳的表现。xen属于半虚拟化的技术，所以其性能损失非常小。xen没有指令翻译，其或者使用使能理解和翻译虚拟操作系统发出的未修改指令的cpu（即：完全虚拟化）；或者修改操作系统，使它发出的指令最优化，便于在虚拟化环境中执行（即：准虚拟化）。\n * kvm - kvm是一个linux kernel模块，可以使用modprobe来加载kvm，加载后还需要通过其他工具创建虚拟机。kvm是一个全虚拟化的解决方案，但需要cpu支持虚拟化功能。相比xen来说，kvm可以更加方便的整合进linux内核，但它还需要其它虚拟化软件（如：qemu）才能实现虚拟化功能。\n * lxc - 即：linux container，linux容器，是一种轻量级的虚拟化的手段。它可以提供轻量级的虚拟化，以隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。容器会有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。\n * openvz - 是swsoft公司开发的开源软件，是该公司virtuozzo软件的基础产品，是基于linux平台的操作系统级服务器虚拟化解决方案。通过openvz，可以在单个物理服务器上创建多个相互隔离的虚拟专用服务器(vps)并以最大的效率共享硬件和管理资源。其上运行虚拟服务器被称为vps（virtual private serve），每个vps的运行环境和独立服务器完全一致。openvz基于linux系统内核及作业系统提供操作系统级虚拟化，在虚拟化过程中资源消耗非常小，官方宣称约1-2%。\n * hyper-v - 是微软件推出的一种虚拟化技术，可以采用半虚拟化或全虚拟的方式创建虚拟机。虽然它可以创建windows或linux操作系统，但其本身只能运行在windows系统下，使用范围较为有限。\n * oracle vm - oracle推出的服务器虚拟化软件，基于开源的xen技术，包括oracle vm server和oracle vm manager两部分。\n * vmware - 是一家非常出名虚拟化软件公司，其产品涵盖服务器、桌面等各种虚拟化领域，如：vmware workstation - 是一款桌面虚拟机软件，可以在一台实体机器上模拟完整的网络环境，并可运行多个windows、dos、linux或mac系统，是非常好的开发、测试、部署解决方案。从技术角度来说，vmware workstation是一款完全虚拟化产品，可借助硬件辅助在不修改用户操作系统的情况下完整虚拟化操作系统。\n * vmware esx server - 是一款适用于任何系统环境的企业级的虚拟机软件，可以认为是vmware server的升级版。相比vmware workstation来说，其功能更加强大，可以用于构建高伸缩和高可靠企业级服务器，并可实现远程管理、高级资源管理控制等高级功能。\n\n\n# docker虚拟化\n\n\n# 什么是docker？\n\ndocker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 linux 发行版本的机器上。docker基于lxc来实现类似vm的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同vm等虚拟化的方式不同，lxc不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。\n\ndocker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。\n\ndocker借助linux的内核特性，如：控制组（control group）、命名空间（namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。\n\n\n# docker能干什么？\n\n * 简化配置\n\n这是docker公司宣传的docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。\n\n * 代码流水线（code pipeline）管理\n\n前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。\n\n * 提高开发效率\n\n这就带来了一些额外的好处：docker能提升开发者的开发效率。详细一点的例子，可以参考aater在devopsdays austin 2014大会或者是dockercon上的演讲。\n\n不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。\n\n理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在docker可以轻易的让几十个服务在docker中跑起来。\n\n * 隔离应用\n\n有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。\n\n我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考steve yege的这篇论文，文中将google和亚马逊做了比较。\n\n * 整合服务器 正如通过虚拟机来整合多个应用，docker隔离应用的能力使得docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，docker可以比虚拟机提供更好的服务器整合解决方案。\n * 调适能力\n\ndocker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试bug。你可以在《docker拯救世界》的文章中找到这一点的例证。\n\n * 多租户\n\n另外一个docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为iot（物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。\n\n使用docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于docker环境的启动速度和其高效的diff命令。\n\n * 快速部署\n\n在虚拟机之前，引入新的硬件资源需要消耗几天的时间。docker的虚拟化技术将这个时间降到了几分钟，docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是google和facebook都看重的特性。\n\n你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用docker并进行有效的资源分配可以提高资源的利用率。\n\n\n# docker的基本组成\n\n仓库，镜像，容器的关系（这是官网的图）\n\n\n\n * 镜像（image）\n\ndocker 镜像（image）就是一个只读的模板。镜像可以用来创建 docker 容器，一个镜像可以创建很 多容器。 就好似 java 中的 类和对象，类就是镜像，容器就是对象！\n\n * 容器（container）：\n\ndocker 利用容器（container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。\n\n它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。\n\n可以把容器看做是一个简易版的 linux 环境（包括root用户权限、进程空间、用户空间和网络空间等） 和运行在其中的应用程序\n\n容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。\n\n * 仓库（repository）：\n\n仓库（repository）是集中存放镜像文件的场所。\n\n仓库(repository)和仓库注册服务器（registry）是有区别的。仓库注册服务器上往往存放着多个仓 库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n\n仓库分为公开仓库（public）和私有仓库（private）两种形式\n\n最大的公开仓库是 docker hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括阿里云 、网易云 等\n\n小结：\n\ndocker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个 可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生 成 docker 容器。image 文件可以看作是容器的模板。docker 根据 image 文件生成容器的实例。 同一个 image 文件，可以生成多个同时运行的容器实例。\n\nimage 文件生成的容器实例，本身也是一个文件，称为镜像文件\n\n一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例， 也就是我们的容器\n\n至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来 就可以了。\n\n\n# docker和虚拟机的区别？\n\n> 虚拟机virtual machine与容器化技术（代表docker）都是虚拟化技术，两者的区别在于虚拟化的程度不同。\n\n\n# 基本对比\n\n\n\n * 虚拟机\n   * 基础设施（infrastructure）。它可以是你的个人电脑，数据中心的服务器，或者是云主机。\n   * 主操作系统（host operating system）。你的个人电脑之上，运行的可能是macos，windows或者某个linux发行版。\n   * 虚拟机管理系统（hypervisor）。利用hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的hypervisor有支持macos的hyperkit，支持windows的hyper-v以及支持linux的kvm。类型2的hypervisor有virtualbox和vmware。\n   * 操作系统（guest operating system）。假设你需要运行3个相互隔离的应用，则需要使用hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700mb，这就意味着它们将占用2.1gb的磁盘空间。更糟糕的是，它们还会消耗很多cpu和内存。\n   * 各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接postgresql的话，则需要安装libpq-dev；如果你使用ruby的话，应该需要安装gems；如果使用其他编程语言，比如python或者node.js，都会需要安装对应的依赖库。\n * docker容器\n   * 主操作系统（host operating system）。所有主流的linux发行版都可以运行docker。对于macos和windows，也有一些办法"运行"docker。\n   * docker守护进程（docker daemon）。docker守护进程取代了hypervisor，它是运行在操作系统之上的后台进程，负责管理docker容器。\n   * 各种依赖。对于docker，应用的所有依赖都打包在docker镜像中，docker容器是基于docker镜像创建的。\n   * 应用。应用的源代码与它的依赖都打包在docker镜像中，不同的应用需要不同的docker镜像。不同的应用运行在不同的docker容器中，它们是相互隔离的。\n\n虚拟机是在物理资源层面实现的隔离，相对于虚拟机，docker是你app层面实现的隔离，并且省去了虚拟机操作系统（guest os）），从而节省了一部分的系统资源；docker守护进程可以直接与主操作系统进行通信，为各个docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，docker可以节省大量的磁盘空间以及其他系统资源。\n\n虚拟机与容器docker的区别，在于vm多了一层guest os，虚拟机的hypervisor会对硬件资源也进行虚拟化，而容器docker会直接使用宿主机的硬件资源。\n\n下面我们采用形象的比喻区分两者的隔离级别：\n\n * 服务器：比作一个大型的仓管基地，包含场地与零散的货物——相当于各种服务器资源。\n * 虚拟机技术：比作仓库，拥有独立的空间堆放各种货物或集装箱，仓库之间完全独立——仓库相当于各种系统，独立的应用系统和操作系统。\n * docker：比作集装箱，操作各种货物的打包——将各种应用程序和他们所依赖的运行环境打包成标准的容器，容器之间隔离。\n\n\n# 虚拟技术对比\n\n * 隔离性\n\n在于隔离性上面，由于vm对操作系统也进行了虚拟化，隔离的更加彻底。而docker共享宿主机的操作系统，隔离性较差。\n\n * 运行效率\n\n由于vm的隔离操作，导致生成虚拟机的速率大大低于容器docker生成的速度，因为docker直接利用宿主机的系统内核。比如openstack能够以10台/min的速度创建虚拟机，而docker可以做到在几秒钟之内创建大量容器，它们的启动速度是在数量级上的差距。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在hypervisor虚拟的cpu上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。\n\n * 资源利用率\n\n在资源利用率上虚拟机由于隔离更彻底，因此利用率也会相对较低。\n\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在hypervisor虚拟的cpu上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。比如对于本次实验的平台，实际的cpu架构是2块物理cpu。\n\n\n# 参考文章\n\n推荐浏览以下网站：\n\n * java 全栈知识体系\n   \n   https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - 常用命令",frontmatter:{title:"Docker - 常用命令",date:"2021-06-03T16:11:38.000Z",permalink:"/pages/a25911/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/06.Docker%20-%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"05.工具部署/10.Docker/06.Docker - 常用命令.md",key:"v-76ebdf26",path:"/pages/a25911/",headers:[{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3},{level:2,title:"镜像命令",slug:"镜像命令",normalizedTitle:"镜像命令",charIndex:11},{level:3,title:"docker images",slug:"docker-images",normalizedTitle:"docker images",charIndex:21},{level:3,title:"docker search",slug:"docker-search",normalizedTitle:"docker search",charIndex:40},{level:3,title:"docker pull",slug:"docker-pull",normalizedTitle:"docker pull",charIndex:59},{level:3,title:"docker rmi",slug:"docker-rmi",normalizedTitle:"docker rmi",charIndex:76},{level:2,title:"容器命令",slug:"容器命令",normalizedTitle:"容器命令",charIndex:90},{level:3,title:"容器启动",slug:"容器启动",normalizedTitle:"容器启动",charIndex:100},{level:3,title:"容器查看",slug:"容器查看",normalizedTitle:"容器查看",charIndex:110},{level:3,title:"退出容器",slug:"退出容器",normalizedTitle:"退出容器",charIndex:120},{level:3,title:"启动停止容器",slug:"启动停止容器",normalizedTitle:"启动停止容器",charIndex:130},{level:3,title:"删除容器",slug:"删除容器",normalizedTitle:"删除容器",charIndex:142},{level:3,title:"容器再启动",slug:"容器再启动",normalizedTitle:"容器再启动",charIndex:152},{level:3,title:"后台启动容器",slug:"后台启动容器",normalizedTitle:"后台启动容器",charIndex:163},{level:3,title:"清理停止的容器",slug:"清理停止的容器",normalizedTitle:"清理停止的容器",charIndex:175},{level:3,title:"查看日志",slug:"查看日志",normalizedTitle:"查看日志",charIndex:188},{level:3,title:"进入正在运行的容器",slug:"进入正在运行的容器",normalizedTitle:"进入正在运行的容器",charIndex:198},{level:3,title:"容器内拷贝文件到主机上",slug:"容器内拷贝文件到主机上",normalizedTitle:"容器内拷贝文件到主机上",charIndex:213},{level:2,title:"常用命令总结",slug:"常用命令总结",normalizedTitle:"常用命令总结",charIndex:228}],headersStr:"帮助命令 镜像命令 docker images docker search docker pull docker rmi 容器命令 容器启动 容器查看 退出容器 启动停止容器 删除容器 容器再启动 后台启动容器 清理停止的容器 查看日志 进入正在运行的容器 容器内拷贝文件到主机上 常用命令总结",content:' * 帮助命令\n * 镜像命令\n   * docker images\n   * docker search\n   * docker pull\n   * docker rmi\n * 容器命令\n   * 容器启动\n   * 容器查看\n   * 退出容器\n   * 启动停止容器\n   * 删除容器\n   * 容器再启动\n   * 后台启动容器\n   * 清理停止的容器\n   * 查看日志\n   * 进入正在运行的容器\n   * 容器内拷贝文件到主机上\n * 常用命令总结\n\n\n# 帮助命令\n\ndocker version # 显示 Docker 版本信息。\ndocker info # 显示 Docker 系统信息，包括镜像和容器数。\ndocker --help # 帮助\n\n\n1\n2\n3\n\n\n\n# 镜像命令\n\n\n# docker images\n\n列出本地主机上的镜像\n\n\n\n解释：\n\n * REPOSITORY 镜像的仓库源\n\n * TAG 镜像的标签\n\n * IMAGE ID 镜像的ID\n\n * CREATED 镜像创建时间\n\n * SIZE 镜像大小\n\n同一个仓库源可以有多个 TAG，代表这个仓库源的不同版本，我们使用 REPOSITORY:TAG 定义不同的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！\n\n\n# docker search\n\n搜索镜像：\n\ndocker search 某个镜像的名称 对应DockerHub仓库中的镜像\n\ndocker search mysql\n\n\n1\n\n\n可选项：\n\n列出收藏数不小于指定值的镜像，例如\n\ndocker search mysql --filter=stars=1000\n\n\n1\n\n\n\n\n * NAME: 镜像仓库源的名称\n * DESCRIPTION: 镜像的描述\n * OFFICIAL: 是否 docker 官方发布\n * STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n * AUTOMATED: 自动构建。\n\n也通过Docker Hub 进行查找\n\n比如https://hub.docker.com/search?q=mysql&type=image\n\n\n# docker pull\n\n下载镜像\n\n不写tag，默认是latest\n\ndocker pull mysql\n\n\n1\n\n\n指定版本下载\n\ndocker pull mysql:5.7\n\n\n1\n\n\n\n# docker rmi\n\n删除镜像\n\ndocker rmi -f 镜像id # 删除单个\ndocker rmi -f 镜像名:tag 镜像名:tag # 删除多个\n\n\n1\n2\n\n\n删除全部\n\ndocker rmi -f $(docker images -qa)\n\n\n1\n\n\n\n# 容器命令\n\n有镜像才能创建容器，我们这里使用 centos 的镜像来测试，就是虚拟一个 centos ！\n\ndocker pull centos\n\n\n1\n\n\n\n# 容器启动\n\ndocker run [OPTIONS] IMAGE [COMMAND][ARG...]\n\n\n1\n\n\n常用参数说明\n\n参数              说明\n--name="Name"   给容器指定一个名字\n                之后再对容器操作，可以用这个name，相当于“别名”\n-d              后台方式运行容器，并返回容器的id！\n-i              以交互模式运行容器，通过和 -t 一起使用\n-t              给容器重新分配一个终端，通常和 -i 一起使用\n-P              随机端口映射（大写）\n-p              指定端口映射（小写），一般可以有四种写法\n\n查看镜像：\n\n\n\n启动一个容器，使用centos进行用交互模式启动容器，在容器内执行/bin/bash命令！\n\ndocker run -it centos /bin/bash\n\n\n1\n\n\n\n\n退出容器：\n\n\n\n\n# 容器查看\n\ndocker ps [OPTIONS]\n\n\n1\n\n\n常用参数说明\n\n参数     说明\n-a     列出当前所有正在运行的容器 + 历史运行过的容器\n-l     显示最近创建的容器\n-n=?   显示最近n个创建的容器\n-q     静默模式，只显示容器编号。\n\n\n# 退出容器\n\n指令         说明\nexit       容器停止退出\nctrl+P+Q   容器不停止退出\n\n\n# 启动停止容器\n\n指令                             说明\ndocker start (容器id or 容器名)     启动容器\ndocker restart (容器id or 容器名)   重启容器\ndocker stop (容器id or 容器名)      停止容器\ndocker kill (容器id or 容器名)      强制停止容器\n\n\n# 删除容器\n\n指令                                说明\ndocker rm 容器id                    删除指定容器\ndocker rm -f $(docker ps -a -q)   删除所有容器\ndocker ps -a -q|xargs docker rm   删除所有容器\n\n\n# 容器再启动\n\n * 命令\n   \n   docker start id/name\n   \n   \n   1\n   \n\n启动之前停止关闭的容器\n\n\n# 后台启动容器\n\ndocker run -d 容器名\n\n\n1\n\n\n启动centos，使用后台方式启动，例如：\n\ndocker run -d centos\n\n\n1\n\n\n问题： 使用docker ps 查看，发现容器已经退出了！\n\n解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命 令，就会自动退出。\n\n比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。\n\n\n# 清理停止的容器\n\n清理停止的容器:\n\ndocker container prune\n\n\n1\n\n\n\n\n\n# 查看日志\n\ndocker logs -f -t --tail 容器id\n\n\n1\n\n\n例子：我们启动 centos，并编写一段脚本来测试玩玩！最后查看日志\n\ndocker run -d centos /bin/sh -c "while true;do echo hello;sleep 1;done"\n\n\n1\n\n\n\n\n查看日志：\n\ndocker logs 容器id\n\n\n1\n\n\n参数       说明\n-t       显示时间戳\n-f       打印最新的日志\n--tail   数字显示多少条！\n\ndocker logs -tf --tail 10 87f5e5a2954e\n\n\n1\n\n\n\n\n * 停止运行\n\ndocker stop 87f5e5a2954e\n\n\n1\n\n\n\n\n * 查看正在运行容器的进程信息\n\ndocker top 容器id\n\n\n1\n\n * 查看容器/镜像的元数据\n\ndocker inspect 容器id\n\n\n1\n\n\n\n\n\n# 进入正在运行的容器\n\n命令一：\n\ndocker exec -it 容器id bashShell\n\n\n1\n\n\n例如：\n\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n[root@VM-0-6-centos ~]# docker run -d centos /bin/sh -c "while true;do echo hello;sleep 1;done"\na9b967bdbc870bb039b69c76ddc3d3ce6aa87d57c51a8040e32224fb45576b28\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES\na9b967bdbc87   centos    "/bin/sh -c \'while t…"   8 seconds ago   Up 7 seconds             upbeat_haibt\n[root@VM-0-6-centos ~]# docker exec -it a9b967bdbc87 /bin/bash\n[root@a9b967bdbc87 /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 10:01 ?        00:00:00 /bin/sh -c while true;do echo hello;sleep 1;done\nroot        37     0  0 10:02 pts/0    00:00:00 /bin/bash\nroot        59     1  0 10:02 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1\nroot        60    37  0 10:02 pts/0    00:00:00 ps -ef\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n退出容器终端，不会导致容器的停止\n\n[root@a9b967bdbc87 /]# exit\nexit\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES\na9b967bdbc87   centos    "/bin/sh -c \'while t…"   7 minutes ago   Up 7 minutes             upbeat_haibt\n\n\n1\n2\n3\n4\n5\n\n\n命令二：\n\ndocker attach 容器id\n\n\n1\n\n\n测试：\n\n[root@VM-0-6-centos ~]# docker images\nREPOSITORY    TAG       IMAGE ID       CREATED        SIZE\nhello-world   latest    d1165f221234   2 months ago   13.3kB\ncentos        latest    300e315adb2f   5 months ago   209MB\n[root@VM-0-6-centos ~]# docker  run -it -d  centos /bin/bash\n7f9ead6f906b3c691d29866236414e1808d194462ed0839c8ee5c947d731ed57\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES\n7f9ead6f906b   centos    "/bin/bash"   10 seconds ago   Up 9 seconds             nervous_mcclintock\n[root@VM-0-6-centos ~]# docker attach 7f9ead6f906b\n[root@7f9ead6f906b /]# echo "hello"\nhello\n[root@7f9ead6f906b /]# exit\nexit\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n[root@VM-0-6-centos ~]# \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n区别 ：\n\n * exec 是在容器中打开新的终端，并且可以启动新的进程\n\n * attach 直接进入容器启动命令的终端，不会启动新的进程\n\n推荐大家使用 docker exec 命令，\n\n\n# 容器内拷贝文件到主机上\n\ndocker cp 容器id:容器内路径 目的主机路径\n\n\n1\n\n\n例如：\n\ndocker cp 7f9ead6f906b:/home/f1 /home\n\n\n1\n\n\n\n# 常用命令总结\n\n\n\n命令        官方说明                                                           解释\nattach    Attach local standard input, output, and error streams to a    当前 shell 下 attach 连接指定运行镜像\n          running container\nbuild     Build an image from a Dockerfile                               通过 Dockerfile 定制镜像\ncommit    Create a new image from a container\'s changes                  提交当前容器为新的镜像\ncp        Copy files/folders between a container and the local           从容器中拷贝指定文件或者目录到宿主机中\n          filesystem\ncreate    Create a new container                                         创建一个新的容器，同 run，但不启动容器\ndiff      Inspect changes to files or directories on a container\'s       查看 docker 容器变化\n          filesystem\nevents    Get real time events from the server                           从 docker 服务获取容 器实时事件\nexec      Run a command in a running container                           在已存在的容器上运行命令\nexport    Export a container\'s filesystem as a tar archive               导出容器的内 容流作为一个 tar 归档文件[对应 import ]\nhistory   Show the history of an image                                   展示一个镜像形成历史\nimages    List images                                                    列出系统当前镜像\nimport    Import the contents from a tarball to create a filesystem      从 tar包中的内容创建一个新的文件系统映像[对应export]\n          image\ninfo      Display system-wide information                                显示系统相关信息\ninspect   Return low-level information on Docker objects                 查看容器详细信息\nkill      Kill one or more running containers                            杀掉 指定 docker 容器\nload      Load an image from a tar archive or STDIN                      从一个 tar 包中加载一 个镜像[对应 save]\nlogin     Log in to a Docker registry                                    登陆一个 docker 源服务器\nlogout    Log out from a Docker registry                                 从当前 Docker registry 退出\nlogs      Fetch the logs of a container                                  输出当前容器日志信息\npause     Pause all processes within one or more containers              暂停容器\nport      List port mappings or a specific mapping for the container     查看映射端口对应的容器内部源端口\nps        List containers                                                列出容器列表\npull      Pull an image or a repository from a registry                  从docker镜像源服务器拉取指定镜像或者库镜像\npush      Push an image or a repository to a registry                    推送指定镜像或者库镜像至docker源服务器\nrename    Rename a container                                             给一个容器改名\nrestart   Restart one or more containers                                 重启运行的容器\nrm        Remove one or more containers                                  移除一个或者多个容器\nrmi       Remove one or more images                                      移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\nrun       Run a command in a new container                               创建一个新的容器并运行 一个命令\nsave      Save one or more images to a tar archive (streamed to STDOUT   保存一个镜像为一个 tar 包[对应 load]\n          by default)\nsearch    Search the Docker Hub for images                               在 docker hub 中搜 索镜像\nstart     Start one or more stopped containers                           启动容器\nstats     Display a live stream of container(s) resource usage           显示容器资源使用统计信息的实时信息\n          statistics\nstop      Stop one or more running containers                            停止容器\ntag       Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE          给源中镜像打标签\ntop       Display the running processes of a container                   查看容器中运行的进程信 息\nunpause   Unpause all processes within one or more containers            取消暂停容器\nupdate    Update configuration of one or more containers                 更新容器配置\nversion   Show the Docker version information                            查看 docker 版本号\nwait      Block until one or more containers stop, then print their      截取容器停止时的退出状态值\n          exit codes',normalizedContent:' * 帮助命令\n * 镜像命令\n   * docker images\n   * docker search\n   * docker pull\n   * docker rmi\n * 容器命令\n   * 容器启动\n   * 容器查看\n   * 退出容器\n   * 启动停止容器\n   * 删除容器\n   * 容器再启动\n   * 后台启动容器\n   * 清理停止的容器\n   * 查看日志\n   * 进入正在运行的容器\n   * 容器内拷贝文件到主机上\n * 常用命令总结\n\n\n# 帮助命令\n\ndocker version # 显示 docker 版本信息。\ndocker info # 显示 docker 系统信息，包括镜像和容器数。\ndocker --help # 帮助\n\n\n1\n2\n3\n\n\n\n# 镜像命令\n\n\n# docker images\n\n列出本地主机上的镜像\n\n\n\n解释：\n\n * repository 镜像的仓库源\n\n * tag 镜像的标签\n\n * image id 镜像的id\n\n * created 镜像创建时间\n\n * size 镜像大小\n\n同一个仓库源可以有多个 tag，代表这个仓库源的不同版本，我们使用 repository:tag 定义不同的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！\n\n\n# docker search\n\n搜索镜像：\n\ndocker search 某个镜像的名称 对应dockerhub仓库中的镜像\n\ndocker search mysql\n\n\n1\n\n\n可选项：\n\n列出收藏数不小于指定值的镜像，例如\n\ndocker search mysql --filter=stars=1000\n\n\n1\n\n\n\n\n * name: 镜像仓库源的名称\n * description: 镜像的描述\n * official: 是否 docker 官方发布\n * stars: 类似 github 里面的 star，表示点赞、喜欢的意思。\n * automated: 自动构建。\n\n也通过docker hub 进行查找\n\n比如https://hub.docker.com/search?q=mysql&type=image\n\n\n# docker pull\n\n下载镜像\n\n不写tag，默认是latest\n\ndocker pull mysql\n\n\n1\n\n\n指定版本下载\n\ndocker pull mysql:5.7\n\n\n1\n\n\n\n# docker rmi\n\n删除镜像\n\ndocker rmi -f 镜像id # 删除单个\ndocker rmi -f 镜像名:tag 镜像名:tag # 删除多个\n\n\n1\n2\n\n\n删除全部\n\ndocker rmi -f $(docker images -qa)\n\n\n1\n\n\n\n# 容器命令\n\n有镜像才能创建容器，我们这里使用 centos 的镜像来测试，就是虚拟一个 centos ！\n\ndocker pull centos\n\n\n1\n\n\n\n# 容器启动\n\ndocker run [options] image [command][arg...]\n\n\n1\n\n\n常用参数说明\n\n参数              说明\n--name="name"   给容器指定一个名字\n                之后再对容器操作，可以用这个name，相当于“别名”\n-d              后台方式运行容器，并返回容器的id！\n-i              以交互模式运行容器，通过和 -t 一起使用\n-t              给容器重新分配一个终端，通常和 -i 一起使用\n-p              随机端口映射（大写）\n-p              指定端口映射（小写），一般可以有四种写法\n\n查看镜像：\n\n\n\n启动一个容器，使用centos进行用交互模式启动容器，在容器内执行/bin/bash命令！\n\ndocker run -it centos /bin/bash\n\n\n1\n\n\n\n\n退出容器：\n\n\n\n\n# 容器查看\n\ndocker ps [options]\n\n\n1\n\n\n常用参数说明\n\n参数     说明\n-a     列出当前所有正在运行的容器 + 历史运行过的容器\n-l     显示最近创建的容器\n-n=?   显示最近n个创建的容器\n-q     静默模式，只显示容器编号。\n\n\n# 退出容器\n\n指令         说明\nexit       容器停止退出\nctrl+p+q   容器不停止退出\n\n\n# 启动停止容器\n\n指令                             说明\ndocker start (容器id or 容器名)     启动容器\ndocker restart (容器id or 容器名)   重启容器\ndocker stop (容器id or 容器名)      停止容器\ndocker kill (容器id or 容器名)      强制停止容器\n\n\n# 删除容器\n\n指令                                说明\ndocker rm 容器id                    删除指定容器\ndocker rm -f $(docker ps -a -q)   删除所有容器\ndocker ps -a -q|xargs docker rm   删除所有容器\n\n\n# 容器再启动\n\n * 命令\n   \n   docker start id/name\n   \n   \n   1\n   \n\n启动之前停止关闭的容器\n\n\n# 后台启动容器\n\ndocker run -d 容器名\n\n\n1\n\n\n启动centos，使用后台方式启动，例如：\n\ndocker run -d centos\n\n\n1\n\n\n问题： 使用docker ps 查看，发现容器已经退出了！\n\n解释：docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命 令，就会自动退出。\n\n比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。\n\n\n# 清理停止的容器\n\n清理停止的容器:\n\ndocker container prune\n\n\n1\n\n\n\n\n\n# 查看日志\n\ndocker logs -f -t --tail 容器id\n\n\n1\n\n\n例子：我们启动 centos，并编写一段脚本来测试玩玩！最后查看日志\n\ndocker run -d centos /bin/sh -c "while true;do echo hello;sleep 1;done"\n\n\n1\n\n\n\n\n查看日志：\n\ndocker logs 容器id\n\n\n1\n\n\n参数       说明\n-t       显示时间戳\n-f       打印最新的日志\n--tail   数字显示多少条！\n\ndocker logs -tf --tail 10 87f5e5a2954e\n\n\n1\n\n\n\n\n * 停止运行\n\ndocker stop 87f5e5a2954e\n\n\n1\n\n\n\n\n * 查看正在运行容器的进程信息\n\ndocker top 容器id\n\n\n1\n\n * 查看容器/镜像的元数据\n\ndocker inspect 容器id\n\n\n1\n\n\n\n\n\n# 进入正在运行的容器\n\n命令一：\n\ndocker exec -it 容器id bashshell\n\n\n1\n\n\n例如：\n\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command   created   status    ports     names\n[root@vm-0-6-centos ~]# docker run -d centos /bin/sh -c "while true;do echo hello;sleep 1;done"\na9b967bdbc870bb039b69c76ddc3d3ce6aa87d57c51a8040e32224fb45576b28\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command                  created         status         ports     names\na9b967bdbc87   centos    "/bin/sh -c \'while t…"   8 seconds ago   up 7 seconds             upbeat_haibt\n[root@vm-0-6-centos ~]# docker exec -it a9b967bdbc87 /bin/bash\n[root@a9b967bdbc87 /]# ps -ef\nuid        pid  ppid  c stime tty          time cmd\nroot         1     0  0 10:01 ?        00:00:00 /bin/sh -c while true;do echo hello;sleep 1;done\nroot        37     0  0 10:02 pts/0    00:00:00 /bin/bash\nroot        59     1  0 10:02 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1\nroot        60    37  0 10:02 pts/0    00:00:00 ps -ef\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n退出容器终端，不会导致容器的停止\n\n[root@a9b967bdbc87 /]# exit\nexit\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command                  created         status         ports     names\na9b967bdbc87   centos    "/bin/sh -c \'while t…"   7 minutes ago   up 7 minutes             upbeat_haibt\n\n\n1\n2\n3\n4\n5\n\n\n命令二：\n\ndocker attach 容器id\n\n\n1\n\n\n测试：\n\n[root@vm-0-6-centos ~]# docker images\nrepository    tag       image id       created        size\nhello-world   latest    d1165f221234   2 months ago   13.3kb\ncentos        latest    300e315adb2f   5 months ago   209mb\n[root@vm-0-6-centos ~]# docker  run -it -d  centos /bin/bash\n7f9ead6f906b3c691d29866236414e1808d194462ed0839c8ee5c947d731ed57\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command       created          status         ports     names\n7f9ead6f906b   centos    "/bin/bash"   10 seconds ago   up 9 seconds             nervous_mcclintock\n[root@vm-0-6-centos ~]# docker attach 7f9ead6f906b\n[root@7f9ead6f906b /]# echo "hello"\nhello\n[root@7f9ead6f906b /]# exit\nexit\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command   created   status    ports     names\n[root@vm-0-6-centos ~]# \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n区别 ：\n\n * exec 是在容器中打开新的终端，并且可以启动新的进程\n\n * attach 直接进入容器启动命令的终端，不会启动新的进程\n\n推荐大家使用 docker exec 命令，\n\n\n# 容器内拷贝文件到主机上\n\ndocker cp 容器id:容器内路径 目的主机路径\n\n\n1\n\n\n例如：\n\ndocker cp 7f9ead6f906b:/home/f1 /home\n\n\n1\n\n\n\n# 常用命令总结\n\n\n\n命令        官方说明                                                           解释\nattach    attach local standard input, output, and error streams to a    当前 shell 下 attach 连接指定运行镜像\n          running container\nbuild     build an image from a dockerfile                               通过 dockerfile 定制镜像\ncommit    create a new image from a container\'s changes                  提交当前容器为新的镜像\ncp        copy files/folders between a container and the local           从容器中拷贝指定文件或者目录到宿主机中\n          filesystem\ncreate    create a new container                                         创建一个新的容器，同 run，但不启动容器\ndiff      inspect changes to files or directories on a container\'s       查看 docker 容器变化\n          filesystem\nevents    get real time events from the server                           从 docker 服务获取容 器实时事件\nexec      run a command in a running container                           在已存在的容器上运行命令\nexport    export a container\'s filesystem as a tar archive               导出容器的内 容流作为一个 tar 归档文件[对应 import ]\nhistory   show the history of an image                                   展示一个镜像形成历史\nimages    list images                                                    列出系统当前镜像\nimport    import the contents from a tarball to create a filesystem      从 tar包中的内容创建一个新的文件系统映像[对应export]\n          image\ninfo      display system-wide information                                显示系统相关信息\ninspect   return low-level information on docker objects                 查看容器详细信息\nkill      kill one or more running containers                            杀掉 指定 docker 容器\nload      load an image from a tar archive or stdin                      从一个 tar 包中加载一 个镜像[对应 save]\nlogin     log in to a docker registry                                    登陆一个 docker 源服务器\nlogout    log out from a docker registry                                 从当前 docker registry 退出\nlogs      fetch the logs of a container                                  输出当前容器日志信息\npause     pause all processes within one or more containers              暂停容器\nport      list port mappings or a specific mapping for the container     查看映射端口对应的容器内部源端口\nps        list containers                                                列出容器列表\npull      pull an image or a repository from a registry                  从docker镜像源服务器拉取指定镜像或者库镜像\npush      push an image or a repository to a registry                    推送指定镜像或者库镜像至docker源服务器\nrename    rename a container                                             给一个容器改名\nrestart   restart one or more containers                                 重启运行的容器\nrm        remove one or more containers                                  移除一个或者多个容器\nrmi       remove one or more images                                      移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\nrun       run a command in a new container                               创建一个新的容器并运行 一个命令\nsave      save one or more images to a tar archive (streamed to stdout   保存一个镜像为一个 tar 包[对应 load]\n          by default)\nsearch    search the docker hub for images                               在 docker hub 中搜 索镜像\nstart     start one or more stopped containers                           启动容器\nstats     display a live stream of container(s) resource usage           显示容器资源使用统计信息的实时信息\n          statistics\nstop      stop one or more running containers                            停止容器\ntag       create a tag target_image that refers to source_image          给源中镜像打标签\ntop       display the running processes of a container                   查看容器中运行的进程信 息\nunpause   unpause all processes within one or more containers            取消暂停容器\nupdate    update configuration of one or more containers                 更新容器配置\nversion   show the docker version information                            查看 docker 版本号\nwait      block until one or more containers stop, then print their      截取容器停止时的退出状态值\n          exit codes',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"GitHub - 提速",frontmatter:{title:"GitHub - 提速",date:"2021-05-20T13:48:11.000Z",permalink:"/pages/90bb76/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/01.Git/11.GitHub%E6%8F%90%E9%80%9F.html",relativePath:"05.工具部署/01.Git/11.GitHub提速.md",key:"v-586d11fa",path:"/pages/90bb76/",headers:[{level:2,title:"GitHub 镜像访问",slug:"github-镜像访问",normalizedTitle:"github 镜像访问",charIndex:3},{level:2,title:"GitHub 文件加速",slug:"github-文件加速",normalizedTitle:"github 文件加速",charIndex:18},{level:2,title:"GitHub 仓库快速下载",slug:"github-仓库快速下载",normalizedTitle:"github 仓库快速下载",charIndex:33},{level:2,title:"GitHub + Jsdelivr",slug:"github-jsdelivr",normalizedTitle:"github + jsdelivr",charIndex:50}],headersStr:"GitHub 镜像访问 GitHub 文件加速 GitHub 仓库快速下载 GitHub + Jsdelivr",content:" * GitHub 镜像访问\n * GitHub 文件加速\n * GitHub 仓库快速下载\n * GitHub + Jsdelivr\n\n\n# GitHub 镜像访问\n\n两个最常用的镜像地址：\n\n * https://github.com.cnpmjs.org\n * https://hub.fastgit.org\n\n网站的内容跟 GitHub 是完整同步，可在网站访问浏览\n\n不推荐登录账户。\n\n\n# GitHub 文件加速\n\n * https://ghproxy.com/\n\n * https://gh.api.99988866.xyz/\n\n * https://gitmirror.com/\n\n\n# GitHub 仓库快速下载\n\n建议 Gitee 导入 GitHub 的仓库，用 Gitee 下载\n\n\n# GitHub + Jsdelivr\n\n我们在 GitHub 上的图片不可访问，可使用 Jsdelivr 进行加速访问，不只是图片\n\n简单使用：\n\n> https://cdn.jsdelivr.net/gh/用户名/仓库名/文件路径\n\n详情访问官网",normalizedContent:" * github 镜像访问\n * github 文件加速\n * github 仓库快速下载\n * github + jsdelivr\n\n\n# github 镜像访问\n\n两个最常用的镜像地址：\n\n * https://github.com.cnpmjs.org\n * https://hub.fastgit.org\n\n网站的内容跟 github 是完整同步，可在网站访问浏览\n\n不推荐登录账户。\n\n\n# github 文件加速\n\n * https://ghproxy.com/\n\n * https://gh.api.99988866.xyz/\n\n * https://gitmirror.com/\n\n\n# github 仓库快速下载\n\n建议 gitee 导入 github 的仓库，用 gitee 下载\n\n\n# github + jsdelivr\n\n我们在 github 上的图片不可访问，可使用 jsdelivr 进行加速访问，不只是图片\n\n简单使用：\n\n> https://cdn.jsdelivr.net/gh/用户名/仓库名/文件路径\n\n详情访问官网",charsets:{cjk:!0},lastUpdated:"2023/07/08, 2:07:00",lastUpdatedTimestamp:1688782833e3},{title:"Docker - 可视化",frontmatter:{title:"Docker - 可视化",date:"2021-06-04T13:36:42.000Z",permalink:"/pages/4e8ad2/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/08.Docker%20-%20%E5%8F%AF%E8%A7%86%E5%8C%96.html",relativePath:"05.工具部署/10.Docker/08.Docker - 可视化.md",key:"v-2fed92e6",path:"/pages/4e8ad2/",headers:[{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:3},{level:3,title:"安装nginx",slug:"安装nginx",normalizedTitle:"安装nginx",charIndex:11},{level:3,title:"安装tomcat",slug:"安装tomcat",normalizedTitle:"安装tomcat",charIndex:24},{level:3,title:"部署ElasticSearch",slug:"部署elasticsearch",normalizedTitle:"部署elasticsearch",charIndex:38},{level:2,title:"可视化",slug:"可视化",normalizedTitle:"可视化",charIndex:57}],headersStr:"练习 安装nginx 安装tomcat 部署ElasticSearch 可视化",content:' * 练习\n   * 安装nginx\n   * 安装tomcat\n   * 部署ElasticSearch\n * 可视化\n\n\n# 练习\n\n\n# 安装nginx\n\n拉取镜像：\n\n$ docker pull nginx\n\n\n1\n\n\n\n\n启动容器：\n\n-d 后台启动\n\ndocker run -d --name mynginx -p 3500:80 nginx\n\n\n1\n\n\n\n\n进入容器：\n\n[root@VM-0-6-centos ~]# docker exec -it mynginx /bin/bash\n# 寻找nginx\nroot@511741b161de:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\nroot@511741b161de:/# cd /usr/share/nginx\nroot@511741b161de:/usr/share/nginx# ls\nhtml\nroot@511741b161de:/usr/share/nginx# cd html\nroot@511741b161de:/usr/share/nginx/html# ls\n50x.html  index.html\n#可看到之前访问的内容是 index.html\nroot@511741b161de:/usr/share/nginx/html# cat index.html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>Welcome to nginx!</h1>\n<p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.</p>\n\n<p>For online documentation and support please refer to\n<a href="http://nginx.org/">nginx.org</a>.<br/>\nCommercial support is available at\n<a href="http://nginx.com/">nginx.com</a>.</p>\n\n<p><em>Thank you for using nginx.</em></p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 安装tomcat\n\n在 docker hub 官网搜索 tomcat：https://hub.docker.com/_/tomcat\n\n翻到下面有教程\n\n\n\ndocker run -it --rm tomcat:9.0\n\n\n1\n\n\n * -it ：交互模式\n\n * --rm：容器启动成功并退出以后容器就自动移除，一般在测试情况下使用！\n\n1、下载tomcat镜像：\n\ndocker pull tomcat\n\n\n1\n\n\n2、启动\n\ndocker run -d -p 8080:8080 --name tomcat9 tomcat\n\n\n1\n\n\n3、进入tomcat\n\ndocker exec -it tomcat9 /bin/bash\n\n\n1\n\n\n进入后发现，webapps 里什么也没有\n\nroot@a1801a340333:/usr/local/tomcat# ls\nBUILDING.txt  CONTRIBUTING.md  LICENSE\tNOTICE\tREADME.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work\nroot@a1801a340333:/usr/local/tomcat# cd webapps\nroot@a1801a340333:/usr/local/tomcat/webapps# ls\nroot@a1801a340333:/usr/local/tomcat/webapps# \n\n\n1\n2\n3\n4\n5\n\n\n若部署一个 jsp 网站，需要把文件复制到容器里，非常麻烦。\n\n我们可以通过“数据卷”技术，将容器内文件和我们 Linux 文件进行映射挂载。\n\n\n# 部署ElasticSearch\n\n官网：https://hub.docker.com/_/elasticsearch\n\n1、启动：\n\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\n\n\n1\n\n\n2、查看状态\n\n * docker stats 容器id\n   \n   查看容器的cpu内存和网络状态\n\n查看下cpu状态 ，发现占用的很大\n\n\n\n3、增加上内存限制启动\n\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2\n\n\n1\n\n\n启动时，报错：名字已经存在\n\n\n\n可通过指令删除\n\n * docker rm name_of_the_docker_container\n\ndocker rm elasticsearch\n\n\n1\n\n\n我们可通过 docker ps -a 显示所有容器信息\n\n再次启动后，发现内存变小了\n\n\n\n访问成功：\n\n[root@VM-0-6-centos ~]# curl localhost:9200\n{\n  "name" : "d49fb1463f0a",\n  "cluster_name" : "docker-cluster",\n  "cluster_uuid" : "ycGNdXS0TpC2lcOfIFlPkQ",\n  "version" : {\n    "number" : "7.6.2",\n    "build_flavor" : "default",\n    "build_type" : "docker",\n    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",\n    "build_date" : "2020-03-26T06:34:37.794943Z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.4.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "You Know, for Search"\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n关于名字的作用：\n\n以后我们想启动上次配置的 ElasticSearch，用 docker start 容器名字 即可，不需要在重新配置\n\n[root@VM-0-6-centos ~]# docker start elasticsearch\nelasticsearch\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE                 COMMAND                  CREATED             STATUS         PORTS                                                                                  NAMES\nd49fb1463f0a   elasticsearch:7.6.2   "/usr/local/bin/dock…"   About an hour ago   Up 5 seconds   0.0.0.0:9200->9200/tcp, :::9200->9200/tcp, 0.0.0.0:9300->9300/tcp, :::9300->9300/tcp   elasticsearch\n[root@VM-0-6-centos ~]# \n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果我们要使用 kibana , 如果配置连接上我们的es呢？网络该如何配置呢？\n\n\n\n\n# 可视化\n\nPortainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷 的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和 服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。\n\n如果仅有一个docker宿主机，则可使用单机版运行，Portainer单机版运行十分简单，只需要一条语句即可启动容器，来管理该机器上的 docker 镜像、容器等数据。\n\n * 安装并运行Portainer：\n\ndocker run -d -p 8088:9000 \\\n--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n\n\n1\n2\n\n * 访问：\n\nhttp://IP:8088\n\n首次加载比较慢，且登陆需要注册用户，给admin用户设置密码：\n\n\n\n单机版这里选择local即可，选择完毕，点击Connect即可连接到本地docker：\n\n',normalizedContent:' * 练习\n   * 安装nginx\n   * 安装tomcat\n   * 部署elasticsearch\n * 可视化\n\n\n# 练习\n\n\n# 安装nginx\n\n拉取镜像：\n\n$ docker pull nginx\n\n\n1\n\n\n\n\n启动容器：\n\n-d 后台启动\n\ndocker run -d --name mynginx -p 3500:80 nginx\n\n\n1\n\n\n\n\n进入容器：\n\n[root@vm-0-6-centos ~]# docker exec -it mynginx /bin/bash\n# 寻找nginx\nroot@511741b161de:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\nroot@511741b161de:/# cd /usr/share/nginx\nroot@511741b161de:/usr/share/nginx# ls\nhtml\nroot@511741b161de:/usr/share/nginx# cd html\nroot@511741b161de:/usr/share/nginx/html# ls\n50x.html  index.html\n#可看到之前访问的内容是 index.html\nroot@511741b161de:/usr/share/nginx/html# cat index.html\n<!doctype html>\n<html>\n<head>\n<title>welcome to nginx!</title>\n<style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: tahoma, verdana, arial, sans-serif;\n    }\n</style>\n</head>\n<body>\n<h1>welcome to nginx!</h1>\n<p>if you see this page, the nginx web server is successfully installed and\nworking. further configuration is required.</p>\n\n<p>for online documentation and support please refer to\n<a href="http://nginx.org/">nginx.org</a>.<br/>\ncommercial support is available at\n<a href="http://nginx.com/">nginx.com</a>.</p>\n\n<p><em>thank you for using nginx.</em></p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 安装tomcat\n\n在 docker hub 官网搜索 tomcat：https://hub.docker.com/_/tomcat\n\n翻到下面有教程\n\n\n\ndocker run -it --rm tomcat:9.0\n\n\n1\n\n\n * -it ：交互模式\n\n * --rm：容器启动成功并退出以后容器就自动移除，一般在测试情况下使用！\n\n1、下载tomcat镜像：\n\ndocker pull tomcat\n\n\n1\n\n\n2、启动\n\ndocker run -d -p 8080:8080 --name tomcat9 tomcat\n\n\n1\n\n\n3、进入tomcat\n\ndocker exec -it tomcat9 /bin/bash\n\n\n1\n\n\n进入后发现，webapps 里什么也没有\n\nroot@a1801a340333:/usr/local/tomcat# ls\nbuilding.txt  contributing.md  license\tnotice\treadme.md  release-notes  running.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work\nroot@a1801a340333:/usr/local/tomcat# cd webapps\nroot@a1801a340333:/usr/local/tomcat/webapps# ls\nroot@a1801a340333:/usr/local/tomcat/webapps# \n\n\n1\n2\n3\n4\n5\n\n\n若部署一个 jsp 网站，需要把文件复制到容器里，非常麻烦。\n\n我们可以通过“数据卷”技术，将容器内文件和我们 linux 文件进行映射挂载。\n\n\n# 部署elasticsearch\n\n官网：https://hub.docker.com/_/elasticsearch\n\n1、启动：\n\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\n\n\n1\n\n\n2、查看状态\n\n * docker stats 容器id\n   \n   查看容器的cpu内存和网络状态\n\n查看下cpu状态 ，发现占用的很大\n\n\n\n3、增加上内存限制启动\n\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e es_java_opts="-xms64m -xmx512m" elasticsearch:7.6.2\n\n\n1\n\n\n启动时，报错：名字已经存在\n\n\n\n可通过指令删除\n\n * docker rm name_of_the_docker_container\n\ndocker rm elasticsearch\n\n\n1\n\n\n我们可通过 docker ps -a 显示所有容器信息\n\n再次启动后，发现内存变小了\n\n\n\n访问成功：\n\n[root@vm-0-6-centos ~]# curl localhost:9200\n{\n  "name" : "d49fb1463f0a",\n  "cluster_name" : "docker-cluster",\n  "cluster_uuid" : "ycgndxs0tpc2lcofiflpkq",\n  "version" : {\n    "number" : "7.6.2",\n    "build_flavor" : "default",\n    "build_type" : "docker",\n    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",\n    "build_date" : "2020-03-26t06:34:37.794943z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.4.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "you know, for search"\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n关于名字的作用：\n\n以后我们想启动上次配置的 elasticsearch，用 docker start 容器名字 即可，不需要在重新配置\n\n[root@vm-0-6-centos ~]# docker start elasticsearch\nelasticsearch\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image                 command                  created             status         ports                                                                                  names\nd49fb1463f0a   elasticsearch:7.6.2   "/usr/local/bin/dock…"   about an hour ago   up 5 seconds   0.0.0.0:9200->9200/tcp, :::9200->9200/tcp, 0.0.0.0:9300->9300/tcp, :::9300->9300/tcp   elasticsearch\n[root@vm-0-6-centos ~]# \n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果我们要使用 kibana , 如果配置连接上我们的es呢？网络该如何配置呢？\n\n\n\n\n# 可视化\n\nportainer是docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷 的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、swarm集群和 服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。\n\n如果仅有一个docker宿主机，则可使用单机版运行，portainer单机版运行十分简单，只需要一条语句即可启动容器，来管理该机器上的 docker 镜像、容器等数据。\n\n * 安装并运行portainer：\n\ndocker run -d -p 8088:9000 \\\n--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n\n\n1\n2\n\n * 访问：\n\nhttp://ip:8088\n\n首次加载比较慢，且登陆需要注册用户，给admin用户设置密码：\n\n\n\n单机版这里选择local即可，选择完毕，点击connect即可连接到本地docker：\n\n',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - 镜像和仓库",frontmatter:{title:"Docker - 镜像和仓库",date:"2021-06-04T16:45:01.000Z",permalink:"/pages/982fe2/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/10.Docker%20-%20%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93.html",relativePath:"05.工具部署/10.Docker/10.Docker - 镜像和仓库.md",key:"v-c7c7b8ea",path:"/pages/982fe2/",headers:[{level:2,title:"Docker 镜像",slug:"docker-镜像",normalizedTitle:"docker 镜像",charIndex:3},{level:3,title:"Docker镜像加载原理",slug:"docker镜像加载原理",normalizedTitle:"docker镜像加载原理",charIndex:18},{level:3,title:"分层理解",slug:"分层理解",normalizedTitle:"分层理解",charIndex:36},{level:3,title:"提交镜像",slug:"提交镜像",normalizedTitle:"提交镜像",charIndex:46},{level:2,title:"Docker 仓库",slug:"docker-仓库",normalizedTitle:"docker 仓库",charIndex:54},{level:3,title:"DockerHub",slug:"dockerhub",normalizedTitle:"dockerhub",charIndex:69},{level:3,title:"阿里云镜像服务",slug:"阿里云镜像服务",normalizedTitle:"阿里云镜像服务",charIndex:84}],headersStr:"Docker 镜像 Docker镜像加载原理 分层理解 提交镜像 Docker 仓库 DockerHub 阿里云镜像服务",content:' * Docker 镜像\n   * Docker镜像加载原理\n   * 分层理解\n   * 提交镜像\n * Docker 仓库\n   * DockerHub\n   * 阿里云镜像服务\n\n\n# Docker 镜像\n\n镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含 运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\n\n\n# Docker镜像加载原理\n\nUnionFS （联合文件系统）\n\nUnionFS 是一种分层、轻量级并且高性能的文件系统， 它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录\n\nDocker镜像加载原理\n\ndocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\n\n典型的Linux文件系统由bootfs和rootfs两部分组成\n\nbootfs(boot file system)主要包含 bootloader 和 kernel , bootloader 主要是引导加载 kernel, Linux 刚启动时会加载bootfs文件系统，在Docker镜像的最底层是 bootfs。这一层与我们典型的 Linux/Unix 系统是 一样的，包含boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。\n\nrootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。\n\n\n\n平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？\n\n\n\n对于一个精简的系统，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就可以了。由此可见对于不同的 linux 发行版, bootfs 基本是一 致的, rootfs 会有差别, 因此不同的发行版可以公用 bootfs。\n\n\n# 分层理解\n\n我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！\n\n为什么Docker镜像要采用这种分层的结构呢？\n\n最大的好处，莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。\n\n查看镜像分层的方式可以通过 docker image inspect命令！\n\ndocker image inspect tomcat:latest\n\n\n1\n\n\n\n\n所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。\n\n举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。\n\n该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。\n\n\n\n在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了 一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。\n\n\n\n上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。\n\n下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。\n\n\n\n这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。\n\nDocker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统 一的文件系统。\n\nLinux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。\n\nDocker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW。\n\n下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。\n\n\n\n特点：\n\nDocker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！\n\n这一层就是我们通常说的容器层，容器之下的都叫镜像层！\n\n\n# 提交镜像\n\ndocker commit 从容器创建一个新的镜像。\n\n * 语法：\n   \n   docker commit -m="提交的描述信息" -a="作者" 容器id 要创建的目标镜像名:[标签名]\n   \n   \n   1\n   \n\n测试\n\n1、从Docker Hub 下载 tomcat 镜像到本地并运行\n\n-it 交互终端 -p 端口映射\n\ndocker run -it -p 8080:8080 tomcat\n\n\n1\n\n\n2、访问地址\n\n\n\ndocker启动官方tomcat镜像的容器，发现404是因为使用了加速器，而加速器里的 tomcat的webapps下没有root等文件！\n\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                                       NAMES\na8b6aff64fa3   tomcat    "catalina.sh run"   8 minutes ago   Up 8 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   silly_feynman\n[root@VM-0-6-centos ~]# docker exec -it a8b6aff64fa3 /bin/bash\nroot@a8b6aff64fa3:/usr/local/tomcat# ls\nBUILDING.txt  CONTRIBUTING.md  LICENSE\tNOTICE\tREADME.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work\n\n\n1\n2\n3\n4\n5\n6\n\n\n进入 tomcat 查看 cd 到 webapps 下发现全部空的，反而有个 webapps.dist 里有对应文件\n\nroot@a8b6aff64fa3:/usr/local/tomcat# cd webapps.dist\nroot@a8b6aff64fa3:/usr/local/tomcat/webapps.dist# ls\nROOT  docs  examples  host-manager  manager\n\n\n1\n2\n3\n\n\n我们可以 cp -r 复制文件到webapps下！\n\nroot@a8b6aff64fa3:/usr/local/tomcat# cp -r webapps.dist/* webapps\nroot@a8b6aff64fa3:/usr/local/tomcat# cd webapps\nroot@a8b6aff64fa3:/usr/local/tomcat/webapps# ls\nROOT  docs  examples  host-manager  manager\n\n\n1\n2\n3\n4\n\n\n此时再次访问，则不是404\n\n**3、提交修改后的镜像为 tomcat02 **\n\n下次则可以直接启动这个\n\n注意：commit的时候，容器的名字不能有大写，否则报错：invalid reference format\n\n[root@VM-0-6-centos ~]# docker ps -l\nCONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                       NAMES\na8b6aff64fa3   tomcat    "catalina.sh run"   16 minutes ago   Up 16 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   silly_feynman\n##提交镜像\n[root@VM-0-6-centos ~]# docker commit -a="zhiyuan" -m="new tomcat" a8b6aff64fa3 tomcat02:1.1\nsha256:620813976effbc8a7e36398a9b801891d1654dea37a50927b36a950ffe21a63b\n[root@VM-0-6-centos ~]# docker images\nREPOSITORY            TAG       IMAGE ID       CREATED         SIZE\ntomcat02              1.1       620813976eff   8 seconds ago   672MB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n停止后再启动看看，首页可访问\n\n[root@VM-0-6-centos ~]# docker stop a8b6aff64fa3\na8b6aff64fa3\n[root@VM-0-6-centos ~]# docker run -it -p 8080:8080 tomcat02:1.1\n\n\n1\n2\n3\n\n\n\n# Docker 仓库\n\n\n# DockerHub\n\n注册dockerhub https://hub.docker.com/signup\n\n1、登录\n\ndocker login -u oddfar\n\n\n1\n\n\n2、将镜像发布出去\n\n[root@VM-0-6-centos logs]# docker push hello-world\nUsing default tag: latest\nThe push refers to repository [docker.io/library/hello-world]\nf22b99068db9: Layer already exists \nerrors:\ndenied: requested access to the resource is denied\nunauthorized: authentication required\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n错误：请求的资源访问被拒绝\n\n问题：本地镜像名无帐号信息，解决加 tag 即可\n\n[root@VM-0-6-centos logs]# docker images\nREPOSITORY            TAG       IMAGE ID       CREATED             SIZE\nhello-world           latest    d1165f221234   3 months ago        13.3kB\n[root@VM-0-6-centos logs]# docker tag d1165f221234 oddfar/hello-world:1.0\n\n\n1\n2\n3\n4\n\n\noddfar 是我的用户名\n\n3、再次push\n\n[root@VM-0-6-centos logs]# docker push oddfar/hello-world:1.0\n\n\n1\n\n\n访问：https://hub.docker.com/ 可看到提交的镜像\n\n\n\n\n# 阿里云镜像服务\n\n登录阿里云 -> 找到容器镜像服务 -> 创建命名空间 -> 创建镜像仓库\n\n点击进入这个镜像仓库，可以看到所有的信息\n\n\n\n指令：\n\n\n\n测试：推送 hello-world\n\n[root@VM-0-6-centos ~]# docker login --username=a_zhiyuan registry.cn-hangzhou.aliyuncs.com\n[root@VM-0-6-centos ~]# docker tag d1165f221234 registry.cn-hangzhou.aliyuncs.com/zhiyuan/study:1.0\n[root@VM-0-6-centos ~]# docker push registry.cn-hangzhou.aliyuncs.com/zhiyuan/study:1.0\n\n\n1\n2\n3\n\n\n提交成功\n\n',normalizedContent:' * docker 镜像\n   * docker镜像加载原理\n   * 分层理解\n   * 提交镜像\n * docker 仓库\n   * dockerhub\n   * 阿里云镜像服务\n\n\n# docker 镜像\n\n镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含 运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\n\n\n# docker镜像加载原理\n\nunionfs （联合文件系统）\n\nunionfs 是一种分层、轻量级并且高性能的文件系统， 它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。union 文件系统是 docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录\n\ndocker镜像加载原理\n\ndocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统unionfs。\n\n典型的linux文件系统由bootfs和rootfs两部分组成\n\nbootfs(boot file system)主要包含 bootloader 和 kernel , bootloader 主要是引导加载 kernel, linux 刚启动时会加载bootfs文件系统，在docker镜像的最底层是 bootfs。这一层与我们典型的 linux/unix 系统是 一样的，包含boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。\n\nrootfs (root file system) ，在bootfs之上。包含的就是典型 linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如ubuntu，centos等等。\n\n\n\n平时我们安装进虚拟机的centos都是好几个g，为什么docker这里才200m？\n\n\n\n对于一个精简的系统，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供 rootfs 就可以了。由此可见对于不同的 linux 发行版, bootfs 基本是一 致的, rootfs 会有差别, 因此不同的发行版可以公用 bootfs。\n\n\n# 分层理解\n\n我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！\n\n为什么docker镜像要采用这种分层的结构呢？\n\n最大的好处，莫过于是资源共享了！比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。\n\n查看镜像分层的方式可以通过 docker image inspect命令！\n\ndocker image inspect tomcat:latest\n\n\n1\n\n\n\n\n所有的 docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。\n\n举一个简单的例子，假如基于 ubuntu linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。\n\n该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。\n\n\n\n在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了 一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。\n\n\n\n上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。\n\n下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。\n\n\n\n这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。\n\ndocker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统 一的文件系统。\n\nlinux 上可用的存储引擎有 aufs、overlay2、device mapper、btrfs 以及 zfs。顾名思义，每种存储引擎都基于 linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。\n\ndocker 在 windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 ntfs 文件系统之上实现了分层和 cow。\n\n下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。\n\n\n\n特点：\n\ndocker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！\n\n这一层就是我们通常说的容器层，容器之下的都叫镜像层！\n\n\n# 提交镜像\n\ndocker commit 从容器创建一个新的镜像。\n\n * 语法：\n   \n   docker commit -m="提交的描述信息" -a="作者" 容器id 要创建的目标镜像名:[标签名]\n   \n   \n   1\n   \n\n测试\n\n1、从docker hub 下载 tomcat 镜像到本地并运行\n\n-it 交互终端 -p 端口映射\n\ndocker run -it -p 8080:8080 tomcat\n\n\n1\n\n\n2、访问地址\n\n\n\ndocker启动官方tomcat镜像的容器，发现404是因为使用了加速器，而加速器里的 tomcat的webapps下没有root等文件！\n\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command             created         status         ports                                       names\na8b6aff64fa3   tomcat    "catalina.sh run"   8 minutes ago   up 8 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   silly_feynman\n[root@vm-0-6-centos ~]# docker exec -it a8b6aff64fa3 /bin/bash\nroot@a8b6aff64fa3:/usr/local/tomcat# ls\nbuilding.txt  contributing.md  license\tnotice\treadme.md  release-notes  running.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work\n\n\n1\n2\n3\n4\n5\n6\n\n\n进入 tomcat 查看 cd 到 webapps 下发现全部空的，反而有个 webapps.dist 里有对应文件\n\nroot@a8b6aff64fa3:/usr/local/tomcat# cd webapps.dist\nroot@a8b6aff64fa3:/usr/local/tomcat/webapps.dist# ls\nroot  docs  examples  host-manager  manager\n\n\n1\n2\n3\n\n\n我们可以 cp -r 复制文件到webapps下！\n\nroot@a8b6aff64fa3:/usr/local/tomcat# cp -r webapps.dist/* webapps\nroot@a8b6aff64fa3:/usr/local/tomcat# cd webapps\nroot@a8b6aff64fa3:/usr/local/tomcat/webapps# ls\nroot  docs  examples  host-manager  manager\n\n\n1\n2\n3\n4\n\n\n此时再次访问，则不是404\n\n**3、提交修改后的镜像为 tomcat02 **\n\n下次则可以直接启动这个\n\n注意：commit的时候，容器的名字不能有大写，否则报错：invalid reference format\n\n[root@vm-0-6-centos ~]# docker ps -l\ncontainer id   image     command             created          status          ports                                       names\na8b6aff64fa3   tomcat    "catalina.sh run"   16 minutes ago   up 16 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   silly_feynman\n##提交镜像\n[root@vm-0-6-centos ~]# docker commit -a="zhiyuan" -m="new tomcat" a8b6aff64fa3 tomcat02:1.1\nsha256:620813976effbc8a7e36398a9b801891d1654dea37a50927b36a950ffe21a63b\n[root@vm-0-6-centos ~]# docker images\nrepository            tag       image id       created         size\ntomcat02              1.1       620813976eff   8 seconds ago   672mb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n停止后再启动看看，首页可访问\n\n[root@vm-0-6-centos ~]# docker stop a8b6aff64fa3\na8b6aff64fa3\n[root@vm-0-6-centos ~]# docker run -it -p 8080:8080 tomcat02:1.1\n\n\n1\n2\n3\n\n\n\n# docker 仓库\n\n\n# dockerhub\n\n注册dockerhub https://hub.docker.com/signup\n\n1、登录\n\ndocker login -u oddfar\n\n\n1\n\n\n2、将镜像发布出去\n\n[root@vm-0-6-centos logs]# docker push hello-world\nusing default tag: latest\nthe push refers to repository [docker.io/library/hello-world]\nf22b99068db9: layer already exists \nerrors:\ndenied: requested access to the resource is denied\nunauthorized: authentication required\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n错误：请求的资源访问被拒绝\n\n问题：本地镜像名无帐号信息，解决加 tag 即可\n\n[root@vm-0-6-centos logs]# docker images\nrepository            tag       image id       created             size\nhello-world           latest    d1165f221234   3 months ago        13.3kb\n[root@vm-0-6-centos logs]# docker tag d1165f221234 oddfar/hello-world:1.0\n\n\n1\n2\n3\n4\n\n\noddfar 是我的用户名\n\n3、再次push\n\n[root@vm-0-6-centos logs]# docker push oddfar/hello-world:1.0\n\n\n1\n\n\n访问：https://hub.docker.com/ 可看到提交的镜像\n\n\n\n\n# 阿里云镜像服务\n\n登录阿里云 -> 找到容器镜像服务 -> 创建命名空间 -> 创建镜像仓库\n\n点击进入这个镜像仓库，可以看到所有的信息\n\n\n\n指令：\n\n\n\n测试：推送 hello-world\n\n[root@vm-0-6-centos ~]# docker login --username=a_zhiyuan registry.cn-hangzhou.aliyuncs.com\n[root@vm-0-6-centos ~]# docker tag d1165f221234 registry.cn-hangzhou.aliyuncs.com/zhiyuan/study:1.0\n[root@vm-0-6-centos ~]# docker push registry.cn-hangzhou.aliyuncs.com/zhiyuan/study:1.0\n\n\n1\n2\n3\n\n\n提交成功\n\n',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - 网络",frontmatter:{title:"Docker - 网络",date:"2021-06-14T23:42:55.000Z",permalink:"/pages/3b9d4b/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/16.Docker%20-%20%E7%BD%91%E7%BB%9C.html",relativePath:"05.工具部署/10.Docker/16.Docker - 网络.md",key:"v-635d5f8d",path:"/pages/3b9d4b/",headers:[{level:2,title:"理解Docker0",slug:"理解docker0",normalizedTitle:"理解docker0",charIndex:3},{level:2,title:"Link参数",slug:"link参数",normalizedTitle:"link参数",charIndex:16},{level:2,title:"自定义网络",slug:"自定义网络",normalizedTitle:"自定义网络",charIndex:26},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:37},{level:3,title:"自定义网卡",slug:"自定义网卡",normalizedTitle:"自定义网卡",charIndex:47},{level:3,title:"网络连通",slug:"网络连通",normalizedTitle:"网络连通",charIndex:58},{level:2,title:"部署 Redis 集群",slug:"部署-redis-集群",normalizedTitle:"部署 redis 集群",charIndex:66}],headersStr:"理解Docker0 Link参数 自定义网络 基本概念 自定义网卡 网络连通 部署 Redis 集群",content:' * 理解Docker0\n * Link参数\n * 自定义网络\n   * 基本概念\n   * 自定义网卡\n   * 网络连通\n * 部署 Redis 集群\n\n\n# 理解Docker0\n\n查看本地ip ip addr\n\n[root@VM-0-6-centos ~]# ip addr\n#本机回环地址\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n#阿里云的私有IP\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 52:54:00:9a:88:4d brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.6/20 brd 172.17.15.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5054:ff:fe9a:884d/64 scope link \n       valid_lft forever preferred_lft forever\n# docker网桥\n3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default \n    link/ether 02:42:d1:ba:72:7a brd ff:ff:ff:ff:ff:ff\n    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:d1ff:feba:727a/64 scope link \n       valid_lft forever preferred_lft forever\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nDocker 是如何处理容器网络访问的？\n\n我们之前安装ES的时候，留过一个问题，就是安装Kibana的问题，Kibana得指定ES的地址！或者我们实际场景中，我们开发了很多微服务项目，那些微服务项目都要连接数据库，需要指定数据库的url地址，通过ip。但是我们用Docker管理的话，假设数据库出问题了，我们重新启动运行一个，这个时候数据库的地址就会发生变化，docker会给每个容器都分配一个ip，且容器和容器之间是可以互相访问的。 我们可以测试下容器之间能不能ping通过。\n\n[root@VM-0-6-centos ~]# docker run -d -P --name tomcat01 tomcat\n# 查看tomcat01的ip地址，docker会给每个容器都分配一个ip！\n[root@VM-0-6-centos ~]#  docker exec -it tomcat01 ip addr\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n24: eth0@if25: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n# 可以ping通！\n[root@VM-0-6-centos ~]# ping 172.18.0.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n原因\n\n每一个安装了 Docker 的 linux 主机都有一个 docker0 的虚拟网卡。这是个桥接网卡，使用了 veth-pair 技术！\n\n * 再次查看主机的 ip addr ：本来有三个网络，启动tomcat容器之后，会多了一个网络！\n\n * 每启动一个容器，linux主机就会多了一个虚拟网卡。\n   \n   #启动一个tomcat01，主机的ip地址多了个  25: veth2b7cb71@if24\n   #然后我们在tomcat01容器中查看容器的ip  24: eth0@if25\n   \n   #我们再启动一个tomcat02观察\n   [root@VM-0-6-centos ~]# docker run -d -P --name tomcat02 tomcat\n   \n   # 然后发现linux主机上又多了一个网卡\t27: veth4d2bd95@if26\n   # 我们看下tomcat02的容器内ip地址是\t  26: eth0@if27\n   [root@VM-0-6-centos ~]# docker exec -it tomcat02 ip addr\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   可以发现：只要启动一个容器，就有一对网卡\n   \n   veth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。\n   \n   正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备！\n   \n   “Bridge、OVS 之间的连接”，“Docker 容器之间的连接” 等等，以此构建出非常复杂的虚拟网络结构，比如 OpenStack Neutron。\n\n * 我们来测试下 tomcat01 和 tomcat02 容器间是否可以互相 ping 通\n   \n   [root@VM-0-6-centos ~]# docker exec -it tomcat02 ping 172.18.0.2\n   PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.\n   64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.095 ms\n   \n   \n   1\n   2\n   3\n   \n   \n   所以：容器和容器之间是可以互相访问的。\n   \n   结论：tomcat1 和 tomcat2 共用一个路由器。是的，他们使用的一个，就是docker0。任何一个容器启动默认都是 docker0 网络。 docker 默认会给容器分配一个可用 ip 。\n\n小结\n\nDocker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据 Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网 关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接 通信。\n\n\n\nDocker 容器网络就很好的利用了 Linux 虚拟网络技术，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫 veth pair）；\n\nDocker 中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为Linux是在内核中进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容器系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。\n\n\n# Link参数\n\n思考一个场景，我们编写一个微服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们能不能使用服务名访问呢？\n\n就像 jdbc:mysql://mysql:3306，这样的话哪怕 mysql 重启，我们也不需要修改配置了！\n\ndocker提供了 --link 的操作！\n\n# 我们使用tomcat02，直接通过容器名ping,不使用ip\n[root@VM-0-6-centos ~]# docker exec -it tomcat02 ping tomcat01\n# ping 不通\nping: tomcat01: Name or service not known\n\n#我们再启动一个tomcat03，但是启动的时候连接tomcat02\n[root@VM-0-6-centos ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat\n80ed9c4e1f9428598a91c727ed13b7d0534d86d569855d4fb8739baabe5d6b91\n\n#这个时候，我们就可以使用tomcat03 ping通 tomcat02 了\n[root@VM-0-6-centos ~]#  docker exec -it tomcat03 ping tomcat02\nPING tomcat02 (172.18.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.092 ms\n\n# tomcat3 ping不通 tomcat1\n[root@VM-0-6-centos ~]# docker exec -it tomcat03 ping tomcat01\nping: tomcat01: Name or service not known\n# tomcat2 ping不通 tomcat3 反向也ping不通\n[root@VM-0-6-centos ~]# docker exec -it tomcat02 ping tomcat03\nping: tomcat03: Name or service not known\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这是为什么呢？\n\n#进入tomcat03中查看下host配置文件\n[root@VM-0-6-centos ~]# docker exec -it tomcat03 cat /etc/hosts\n127.0.0.1\tlocalhost\n::1\tlocalhost ip6-localhost ip6-loopback\nfe00::0\tip6-localnet\nff00::0\tip6-mcastprefix\nff02::1\tip6-allnodes\nff02::2\tip6-allrouters\n#发现tomcat2直接被写在这里\n172.18.0.3\ttomcat02 cff25f666b32\n172.18.0.4\t80ed9c4e1f94\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n所以这里其实就是配置了一个 hosts 地址而已！\n\n原因：--link 的时候，直接把需要 link 的主机的域名和 ip 直接配置到了 hosts 文件中了\n\n--link 早都过时了，我们不推荐使用！我们可以使用自定义网络的方式\n\n\n# 自定义网络\n\n\n# 基本概念\n\n指令列表\n\n[root@VM-0-6-centos ~]# docker network --help\n\nUsage:  docker network COMMAND\n\nManage networks\n\nCommands:\n  connect     Connect a container to a network\n  create      Create a network\n  disconnect  Disconnect a container from a network\n  inspect     Display detailed information on one or more networks\n  ls          List networks\n  prune       Remove all unused networks\n  rm          Remove one or more networks\n\nRun \'docker network COMMAND --help\' for more information on a command.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n查看所有网络\n\n[root@VM-0-6-centos ~]# docker network ls\nNETWORK ID     NAME      DRIVER    SCOPE\n4b873066daf7   bridge    bridge    local\n86da632adad6   elastic   bridge    local\n64b606f257e7   host      host      local\n34ab4fdb73c0   none      null      local\n\n\n1\n2\n3\n4\n5\n6\n\n\n所有网路模式\n\n网络模式           配置                         说明\nbridge模式       --net=bridge               默认值，在 Docker 网桥 docker0 上为容器创建新的网络栈\nnone模式         --net=none                 不配置网络，用户可以稍后进入容器，自行配置\ncontainer 模式   -- net=container:name/id   容器和另外一个容器共享Network namespace。\n                                          kubernetes中的pod就是多个容器共享一个Network namespace。\nhost模式         --net=host                 容器和宿主机共享Network namespace\n用户自定义          --net=自定义网络                用户自己使用network相关命令定义网络，创建容器的 时候可以指定为自己定义的网络，就像 elastic\n\n查看一个具体的网络的详细信息\n\n[root@VM-0-6-centos ~]# docker network inspect 4b873066daf7\n[\n    {\n        "Name": "bridge",\n        "Id": "4b873066daf7eca3fd7a79ce17b46dff17a89368cb7f43d01c88dd9ee08d9407",\n        "Created": "2021-06-11T18:42:36.937993641+08:00",\n        "Scope": "local",\n        "Driver": "bridge",\n        "EnableIPv6": false,\n        "IPAM": {\n            "Driver": "default",\n            "Options": null,\n            "Config": [\n                {\n                //默认 docker0 是管理这个子网范围内的。0~16，\n                //也就是 255*255，去掉0个255，我们有65534可以分配的ip\n                //所以 docker0 网络默认可以支持创建6万多个容器ip不重复\n                    "Subnet": "172.18.0.0/16",\n                    "Gateway": "172.18.0.1"\n                }\n            ]\n        },\n        "Internal": false,\n        "Attachable": false,\n        "Ingress": false,\n        "ConfigFrom": {\n            "Network": ""\n        },\n        "ConfigOnly": false,\n        "Containers": {\n            "220fac5f16f3cf7f2619131502cb6bb4004f334c3b501a0ceff8804c361cf027": {\n                "Name": "tomcat01",\n                "EndpointID": "d54c9b71aff1843c3a1609de8eaa85785ebddd8a419ea5fae346fb538568946f",\n                "MacAddress": "02:42:ac:12:00:02",\n                "IPv4Address": "172.18.0.2/16",\n                "IPv6Address": ""\n            },\n            "80ed9c4e1f9428598a91c727ed13b7d0534d86d569855d4fb8739baabe5d6b91": {\n                "Name": "tomcat03",\n                "EndpointID": "a6dd8dd8ba2b5b341cbed8318a2463a4e28f1059cc848504a409fbf75ae21f4f",\n                "MacAddress": "02:42:ac:12:00:04",\n                "IPv4Address": "172.18.0.4/16",\n                "IPv6Address": ""\n            },\n            "cff25f666b32df808923a51e14f2f2686fc9aff161e07c188c28ce15d0b38401": {\n                "Name": "tomcat02",\n                "EndpointID": "b5b18a038166b64a0308cc4a506f543b92d35b9fc50f5758f8d5daccc1df87bd",\n                "MacAddress": "02:42:ac:12:00:03",\n                "IPv4Address": "172.18.0.3/16",\n                "IPv6Address": ""\n            }\n        },\n        "Options": {\n            "com.docker.network.bridge.default_bridge": "true",\n            "com.docker.network.bridge.enable_icc": "true",\n            "com.docker.network.bridge.enable_ip_masquerade": "true",\n            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",\n            "com.docker.network.bridge.name": "docker0",\n            "com.docker.network.driver.mtu": "1500"\n        },\n        "Labels": {}\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 自定义网卡\n\n1、先删除之前创建的 tomcat 镜像以及容器\n\n2、创建容器\n\n但是我们知道默认创建的容器都是 docker0 网卡的\n\n#默认我们不配置网络，也就相当于默认值 --net bridge 使用的docker0\ndocker run -d -P --name tomcat01 --net bridge tomcat\n\n\n1\n2\n\n\ndocker0网络的特点\n\n 1. 它是默认的\n\n 2. 域名访问不通\n\n 3. --link 域名通了，但是删了又不行\n\n3、我们可以让容器创建的时候使用自定义网络\n\n自定义创建的默认default "bridge" 一个网络\n\ndocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n\n\n1\n\n\n[root@VM-0-6-centos ~]# docker network ls\nNETWORK ID     NAME      DRIVER    SCOPE\n4b873066daf7   bridge    bridge    local\n64b606f257e7   host      host      local\n7f9fbfea6931   mynet     bridge    local\n34ab4fdb73c0   none      null      local\n\n\n1\n2\n3\n4\n5\n6\n\n\n[root@VM-0-6-centos ~]# docker network inspect mynet\n[\n    {\n        "Name": "mynet",\n        "Id": "7f9fbfea6931271e917c7a932c47d05f311f2fe6f1e694b95e4ef3fcf060446e",\n        "Created": "2021-06-16T15:56:58.841772626+08:00",\n        "Scope": "local",\n        "Driver": "bridge",\n        "EnableIPv6": false,\n        "IPAM": {\n            "Driver": "default",\n            "Options": {},\n            "Config": [\n                {\n                    "Subnet": "192.168.0.0/16",\n                    "Gateway": "192.168.0.1"\n                }\n            ]\n        },\n        "Internal": false,\n        "Attachable": false,\n        "Ingress": false,\n        "ConfigFrom": {\n            "Network": ""\n        },\n        "ConfigOnly": false,\n        "Containers": {},\n        "Options": {},\n        "Labels": {}\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n我们来启动两个容器测试，使用自己的 mynet\n\ndocker run -d -P --name tomcat-net-01 --net mynet tomcat\ndocker run -d -P --name tomcat-net-02 --net mynet tomcat\n\n\n1\n2\n\n\n来测试ping容器名和ip试试\n\n# 都可以ping通\n[root@VM-0-6-centos ~]# docker exec -it tomcat-net-01 ping 192.168.0.3\nPING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.\n64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.118 ms\n[root@VM-0-6-centos ~]# docker exec -it tomcat-net-01 ping tomcat-net-02\nPING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.059 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n发现，我们自定义的网络docker都已经帮我们维护好了对应的关系\n\n所以我们平时都可以这样使用网络，不使用 --link 效果一样，所有东西实时维护好，直接域名 ping 通。\n\n\n# 网络连通\n\ndocker0和自定义网络肯定不通，我们使用自定义网络的好处就是网络隔离：\n\n大家公司项目部署的业务都非常多，假设我们有一个商城，我们会有订单业务（操作不同数据），会有 订单业务购物车业务（操作不同缓存）。如果在一个网络下，有的程序猿的恶意代码就不能防止了，所 以我们就在部署的时候网络隔离，创建两个桥接网卡，比如订单业务（里面的数据库，redis，mq，全部业务都在 order-net 网络下）其他业务在其他网络。\n\n那关键的问题来了，如何让 tomcat-net-01 访问 tomcat1？\n\n\n\n# 启动默认的容器，在docker0网络下\ndocker run -d -P --name tomcat01 tomcat\ndocker run -d -P --name tomcat02 tomcat\n\n\n1\n2\n3\n\n\n有个命令 connect 用来连接网络\n\n# 我们来测试一下！打通mynet-docker0\n[root@VM-0-6-centos ~]# docker network connect mynet tomcat01\n[root@VM-0-6-centos ~]# docker network inspect mynet\n[\n    {\n        "Name": "mynet",\n        "Id": "7f9fbfea6931271e917c7a932c47d05f311f2fe6f1e694b95e4ef3fcf060446e",\n        "Created": "2021-06-16T15:56:58.841772626+08:00",\n        "Scope": "local",\n        "Driver": "bridge",\n        "EnableIPv6": false,\n        "IPAM": {\n            "Driver": "default",\n            "Options": {},\n            "Config": [\n                {\n                    "Subnet": "192.168.0.0/16",\n                    "Gateway": "192.168.0.1"\n                }\n            ]\n        },\n        "Internal": false,\n        "Attachable": false,\n        "Ingress": false,\n        "ConfigFrom": {\n            "Network": ""\n        },\n        "ConfigOnly": false,\n        "Containers": {\n            "52395d45d1fcad0170da201db471ea6ac75c25c9f7d91d10b6260dce2739fd54": {\n                "Name": "tomcat-net-01",\n                "EndpointID": "3c1aea820c4276b0d0dbe249ebd6f43547baceb7c3e774f8ee4b61b0e4b0b11f",\n                "MacAddress": "02:42:c0:a8:00:02",\n                "IPv4Address": "192.168.0.2/16",\n                "IPv6Address": ""\n            },\n            //发现我们的tomcat01就进来这里了\n            "c159a99201d5b3f0f6be065d562c1a0e6439b316084361937f9eda9a22e997ab": {\n                "Name": "tomcat01",\n                "EndpointID": "e11948dcd704e50b8008ee41546ff7c9f506b636f41fb6e6697081fd9d398dc5",\n                "MacAddress": "02:42:c0:a8:00:04",\n                "IPv4Address": "192.168.0.4/16",\n                "IPv6Address": ""\n            },\n            "f2106d157b5ea6c5bdb87e04b9dc18be2b2e25a41d61e25851ea0afbf1e9ea39": {\n                "Name": "tomcat-net-02",\n                "EndpointID": "3cb8b199df4fca69e1a6428ae0536ff3291f9215f8b9d9303a2ec3402bdc704f",\n                "MacAddress": "02:42:c0:a8:00:03",\n                "IPv4Address": "192.168.0.3/16",\n                "IPv6Address": ""\n            }\n        },\n        "Options": {},\n        "Labels": {}\n    }\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\ntomcat01 可以ping通了\n\n[root@VM-0-6-centos ~]# docker exec -it tomcat01 ping tomcat-net-01\nPING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.075 ms\n\n\n1\n2\n3\n\n\ntomcat02 依旧ping不通，大家应该就理解了\n\n[root@VM-0-6-centos ~]#  docker exec -it tomcat02 ping tomcat-net-01\nping: tomcat-net-01: Name or service not known\n\n\n1\n2\n\n\n结论：如果要跨网络操作别人，就需要使用 docker network connect [OPTIONS] NETWORK CONTAINER 连接\n\n\n# 部署 Redis 集群\n\n创建网卡\n\ndocker network create redis --subnet 172.38.0.0/16\n\n\n1\n\n\n通过脚本创建六个redis配置\n\nfor port in $(seq 1 6); \\\ndo \\\nmkdir -p /mydata/redis/node-${port}/conf\ntouch /mydata/redis/node-${port}/conf/redis.conf\ncat << EOF >/mydata/redis/node-${port}/conf/redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\nEOF\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n启动6个容器\n\nfor port in $(seq 1 6); \\\ndo \\\n\ndocker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\\n-v /mydata/redis/node-${port}/data:/data \\\n-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \\\n\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n进入一个redis，注意这里是 sh命令\n\ndocker exec -it redis-1 /bin/sh\n\n\n1\n\n\n创建集群\n\nredis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n\n\n1\n\n\n连接集群\n\nredis-cli -c\n\n\n1\n\n\n# 查看集群信息\ncluster info\n# 查看节点\ncluster nodes\n\n\n1\n2\n3\n4\n\n\n此时，六个 redis 已搭建好\n\n测试集群\n\n先 set 一个数据\n\n127.0.0.1:6379> set name zhiyuan\n-> Redirected to slot [5798] located at 172.38.0.12:6379\nOK\n172.38.0.12:6379> get name\n"zhiyuan"\n\n\n1\n2\n3\n4\n5\n\n\n停止到存值的容器 redis-1\n\n然后再次 get name，发现依旧可以获取值\n\n查看节点，发现高可用完全没问题',normalizedContent:' * 理解docker0\n * link参数\n * 自定义网络\n   * 基本概念\n   * 自定义网卡\n   * 网络连通\n * 部署 redis 集群\n\n\n# 理解docker0\n\n查看本地ip ip addr\n\n[root@vm-0-6-centos ~]# ip addr\n#本机回环地址\n1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state unknown group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n#阿里云的私有ip\n2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state up group default qlen 1000\n    link/ether 52:54:00:9a:88:4d brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.6/20 brd 172.17.15.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5054:ff:fe9a:884d/64 scope link \n       valid_lft forever preferred_lft forever\n# docker网桥\n3: docker0: <no-carrier,broadcast,multicast,up> mtu 1500 qdisc noqueue state down group default \n    link/ether 02:42:d1:ba:72:7a brd ff:ff:ff:ff:ff:ff\n    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:d1ff:feba:727a/64 scope link \n       valid_lft forever preferred_lft forever\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\ndocker 是如何处理容器网络访问的？\n\n我们之前安装es的时候，留过一个问题，就是安装kibana的问题，kibana得指定es的地址！或者我们实际场景中，我们开发了很多微服务项目，那些微服务项目都要连接数据库，需要指定数据库的url地址，通过ip。但是我们用docker管理的话，假设数据库出问题了，我们重新启动运行一个，这个时候数据库的地址就会发生变化，docker会给每个容器都分配一个ip，且容器和容器之间是可以互相访问的。 我们可以测试下容器之间能不能ping通过。\n\n[root@vm-0-6-centos ~]# docker run -d -p --name tomcat01 tomcat\n# 查看tomcat01的ip地址，docker会给每个容器都分配一个ip！\n[root@vm-0-6-centos ~]#  docker exec -it tomcat01 ip addr\n1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state unknown group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n24: eth0@if25: <broadcast,multicast,up,lower_up> mtu 1500 qdisc noqueue state up group default \n    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n# 可以ping通！\n[root@vm-0-6-centos ~]# ping 172.18.0.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n原因\n\n每一个安装了 docker 的 linux 主机都有一个 docker0 的虚拟网卡。这是个桥接网卡，使用了 veth-pair 技术！\n\n * 再次查看主机的 ip addr ：本来有三个网络，启动tomcat容器之后，会多了一个网络！\n\n * 每启动一个容器，linux主机就会多了一个虚拟网卡。\n   \n   #启动一个tomcat01，主机的ip地址多了个  25: veth2b7cb71@if24\n   #然后我们在tomcat01容器中查看容器的ip  24: eth0@if25\n   \n   #我们再启动一个tomcat02观察\n   [root@vm-0-6-centos ~]# docker run -d -p --name tomcat02 tomcat\n   \n   # 然后发现linux主机上又多了一个网卡\t27: veth4d2bd95@if26\n   # 我们看下tomcat02的容器内ip地址是\t  26: eth0@if27\n   [root@vm-0-6-centos ~]# docker exec -it tomcat02 ip addr\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   可以发现：只要启动一个容器，就有一对网卡\n   \n   veth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。\n   \n   正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备！\n   \n   “bridge、ovs 之间的连接”，“docker 容器之间的连接” 等等，以此构建出非常复杂的虚拟网络结构，比如 openstack neutron。\n\n * 我们来测试下 tomcat01 和 tomcat02 容器间是否可以互相 ping 通\n   \n   [root@vm-0-6-centos ~]# docker exec -it tomcat02 ping 172.18.0.2\n   ping 172.18.0.2 (172.18.0.2) 56(84) bytes of data.\n   64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.095 ms\n   \n   \n   1\n   2\n   3\n   \n   \n   所以：容器和容器之间是可以互相访问的。\n   \n   结论：tomcat1 和 tomcat2 共用一个路由器。是的，他们使用的一个，就是docker0。任何一个容器启动默认都是 docker0 网络。 docker 默认会给容器分配一个可用 ip 。\n\n小结\n\ndocker使用linux桥接，在宿主机虚拟一个docker容器网桥(docker0)，docker启动一个容器时会根据 docker网桥的网段分配给容器一个ip地址，称为container-ip，同时docker网桥是每个容器的默认网 关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的container-ip直接 通信。\n\n\n\ndocker 容器网络就很好的利用了 linux 虚拟网络技术，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫 veth pair）；\n\ndocker 中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为linux是在内核中进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容器系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。\n\n\n# link参数\n\n思考一个场景，我们编写一个微服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们能不能使用服务名访问呢？\n\n就像 jdbc:mysql://mysql:3306，这样的话哪怕 mysql 重启，我们也不需要修改配置了！\n\ndocker提供了 --link 的操作！\n\n# 我们使用tomcat02，直接通过容器名ping,不使用ip\n[root@vm-0-6-centos ~]# docker exec -it tomcat02 ping tomcat01\n# ping 不通\nping: tomcat01: name or service not known\n\n#我们再启动一个tomcat03，但是启动的时候连接tomcat02\n[root@vm-0-6-centos ~]# docker run -d -p --name tomcat03 --link tomcat02 tomcat\n80ed9c4e1f9428598a91c727ed13b7d0534d86d569855d4fb8739baabe5d6b91\n\n#这个时候，我们就可以使用tomcat03 ping通 tomcat02 了\n[root@vm-0-6-centos ~]#  docker exec -it tomcat03 ping tomcat02\nping tomcat02 (172.18.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.092 ms\n\n# tomcat3 ping不通 tomcat1\n[root@vm-0-6-centos ~]# docker exec -it tomcat03 ping tomcat01\nping: tomcat01: name or service not known\n# tomcat2 ping不通 tomcat3 反向也ping不通\n[root@vm-0-6-centos ~]# docker exec -it tomcat02 ping tomcat03\nping: tomcat03: name or service not known\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这是为什么呢？\n\n#进入tomcat03中查看下host配置文件\n[root@vm-0-6-centos ~]# docker exec -it tomcat03 cat /etc/hosts\n127.0.0.1\tlocalhost\n::1\tlocalhost ip6-localhost ip6-loopback\nfe00::0\tip6-localnet\nff00::0\tip6-mcastprefix\nff02::1\tip6-allnodes\nff02::2\tip6-allrouters\n#发现tomcat2直接被写在这里\n172.18.0.3\ttomcat02 cff25f666b32\n172.18.0.4\t80ed9c4e1f94\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n所以这里其实就是配置了一个 hosts 地址而已！\n\n原因：--link 的时候，直接把需要 link 的主机的域名和 ip 直接配置到了 hosts 文件中了\n\n--link 早都过时了，我们不推荐使用！我们可以使用自定义网络的方式\n\n\n# 自定义网络\n\n\n# 基本概念\n\n指令列表\n\n[root@vm-0-6-centos ~]# docker network --help\n\nusage:  docker network command\n\nmanage networks\n\ncommands:\n  connect     connect a container to a network\n  create      create a network\n  disconnect  disconnect a container from a network\n  inspect     display detailed information on one or more networks\n  ls          list networks\n  prune       remove all unused networks\n  rm          remove one or more networks\n\nrun \'docker network command --help\' for more information on a command.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n查看所有网络\n\n[root@vm-0-6-centos ~]# docker network ls\nnetwork id     name      driver    scope\n4b873066daf7   bridge    bridge    local\n86da632adad6   elastic   bridge    local\n64b606f257e7   host      host      local\n34ab4fdb73c0   none      null      local\n\n\n1\n2\n3\n4\n5\n6\n\n\n所有网路模式\n\n网络模式           配置                         说明\nbridge模式       --net=bridge               默认值，在 docker 网桥 docker0 上为容器创建新的网络栈\nnone模式         --net=none                 不配置网络，用户可以稍后进入容器，自行配置\ncontainer 模式   -- net=container:name/id   容器和另外一个容器共享network namespace。\n                                          kubernetes中的pod就是多个容器共享一个network namespace。\nhost模式         --net=host                 容器和宿主机共享network namespace\n用户自定义          --net=自定义网络                用户自己使用network相关命令定义网络，创建容器的 时候可以指定为自己定义的网络，就像 elastic\n\n查看一个具体的网络的详细信息\n\n[root@vm-0-6-centos ~]# docker network inspect 4b873066daf7\n[\n    {\n        "name": "bridge",\n        "id": "4b873066daf7eca3fd7a79ce17b46dff17a89368cb7f43d01c88dd9ee08d9407",\n        "created": "2021-06-11t18:42:36.937993641+08:00",\n        "scope": "local",\n        "driver": "bridge",\n        "enableipv6": false,\n        "ipam": {\n            "driver": "default",\n            "options": null,\n            "config": [\n                {\n                //默认 docker0 是管理这个子网范围内的。0~16，\n                //也就是 255*255，去掉0个255，我们有65534可以分配的ip\n                //所以 docker0 网络默认可以支持创建6万多个容器ip不重复\n                    "subnet": "172.18.0.0/16",\n                    "gateway": "172.18.0.1"\n                }\n            ]\n        },\n        "internal": false,\n        "attachable": false,\n        "ingress": false,\n        "configfrom": {\n            "network": ""\n        },\n        "configonly": false,\n        "containers": {\n            "220fac5f16f3cf7f2619131502cb6bb4004f334c3b501a0ceff8804c361cf027": {\n                "name": "tomcat01",\n                "endpointid": "d54c9b71aff1843c3a1609de8eaa85785ebddd8a419ea5fae346fb538568946f",\n                "macaddress": "02:42:ac:12:00:02",\n                "ipv4address": "172.18.0.2/16",\n                "ipv6address": ""\n            },\n            "80ed9c4e1f9428598a91c727ed13b7d0534d86d569855d4fb8739baabe5d6b91": {\n                "name": "tomcat03",\n                "endpointid": "a6dd8dd8ba2b5b341cbed8318a2463a4e28f1059cc848504a409fbf75ae21f4f",\n                "macaddress": "02:42:ac:12:00:04",\n                "ipv4address": "172.18.0.4/16",\n                "ipv6address": ""\n            },\n            "cff25f666b32df808923a51e14f2f2686fc9aff161e07c188c28ce15d0b38401": {\n                "name": "tomcat02",\n                "endpointid": "b5b18a038166b64a0308cc4a506f543b92d35b9fc50f5758f8d5daccc1df87bd",\n                "macaddress": "02:42:ac:12:00:03",\n                "ipv4address": "172.18.0.3/16",\n                "ipv6address": ""\n            }\n        },\n        "options": {\n            "com.docker.network.bridge.default_bridge": "true",\n            "com.docker.network.bridge.enable_icc": "true",\n            "com.docker.network.bridge.enable_ip_masquerade": "true",\n            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",\n            "com.docker.network.bridge.name": "docker0",\n            "com.docker.network.driver.mtu": "1500"\n        },\n        "labels": {}\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 自定义网卡\n\n1、先删除之前创建的 tomcat 镜像以及容器\n\n2、创建容器\n\n但是我们知道默认创建的容器都是 docker0 网卡的\n\n#默认我们不配置网络，也就相当于默认值 --net bridge 使用的docker0\ndocker run -d -p --name tomcat01 --net bridge tomcat\n\n\n1\n2\n\n\ndocker0网络的特点\n\n 1. 它是默认的\n\n 2. 域名访问不通\n\n 3. --link 域名通了，但是删了又不行\n\n3、我们可以让容器创建的时候使用自定义网络\n\n自定义创建的默认default "bridge" 一个网络\n\ndocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n\n\n1\n\n\n[root@vm-0-6-centos ~]# docker network ls\nnetwork id     name      driver    scope\n4b873066daf7   bridge    bridge    local\n64b606f257e7   host      host      local\n7f9fbfea6931   mynet     bridge    local\n34ab4fdb73c0   none      null      local\n\n\n1\n2\n3\n4\n5\n6\n\n\n[root@vm-0-6-centos ~]# docker network inspect mynet\n[\n    {\n        "name": "mynet",\n        "id": "7f9fbfea6931271e917c7a932c47d05f311f2fe6f1e694b95e4ef3fcf060446e",\n        "created": "2021-06-16t15:56:58.841772626+08:00",\n        "scope": "local",\n        "driver": "bridge",\n        "enableipv6": false,\n        "ipam": {\n            "driver": "default",\n            "options": {},\n            "config": [\n                {\n                    "subnet": "192.168.0.0/16",\n                    "gateway": "192.168.0.1"\n                }\n            ]\n        },\n        "internal": false,\n        "attachable": false,\n        "ingress": false,\n        "configfrom": {\n            "network": ""\n        },\n        "configonly": false,\n        "containers": {},\n        "options": {},\n        "labels": {}\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n我们来启动两个容器测试，使用自己的 mynet\n\ndocker run -d -p --name tomcat-net-01 --net mynet tomcat\ndocker run -d -p --name tomcat-net-02 --net mynet tomcat\n\n\n1\n2\n\n\n来测试ping容器名和ip试试\n\n# 都可以ping通\n[root@vm-0-6-centos ~]# docker exec -it tomcat-net-01 ping 192.168.0.3\nping 192.168.0.3 (192.168.0.3) 56(84) bytes of data.\n64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.118 ms\n[root@vm-0-6-centos ~]# docker exec -it tomcat-net-01 ping tomcat-net-02\nping tomcat-net-02 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.059 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n发现，我们自定义的网络docker都已经帮我们维护好了对应的关系\n\n所以我们平时都可以这样使用网络，不使用 --link 效果一样，所有东西实时维护好，直接域名 ping 通。\n\n\n# 网络连通\n\ndocker0和自定义网络肯定不通，我们使用自定义网络的好处就是网络隔离：\n\n大家公司项目部署的业务都非常多，假设我们有一个商城，我们会有订单业务（操作不同数据），会有 订单业务购物车业务（操作不同缓存）。如果在一个网络下，有的程序猿的恶意代码就不能防止了，所 以我们就在部署的时候网络隔离，创建两个桥接网卡，比如订单业务（里面的数据库，redis，mq，全部业务都在 order-net 网络下）其他业务在其他网络。\n\n那关键的问题来了，如何让 tomcat-net-01 访问 tomcat1？\n\n\n\n# 启动默认的容器，在docker0网络下\ndocker run -d -p --name tomcat01 tomcat\ndocker run -d -p --name tomcat02 tomcat\n\n\n1\n2\n3\n\n\n有个命令 connect 用来连接网络\n\n# 我们来测试一下！打通mynet-docker0\n[root@vm-0-6-centos ~]# docker network connect mynet tomcat01\n[root@vm-0-6-centos ~]# docker network inspect mynet\n[\n    {\n        "name": "mynet",\n        "id": "7f9fbfea6931271e917c7a932c47d05f311f2fe6f1e694b95e4ef3fcf060446e",\n        "created": "2021-06-16t15:56:58.841772626+08:00",\n        "scope": "local",\n        "driver": "bridge",\n        "enableipv6": false,\n        "ipam": {\n            "driver": "default",\n            "options": {},\n            "config": [\n                {\n                    "subnet": "192.168.0.0/16",\n                    "gateway": "192.168.0.1"\n                }\n            ]\n        },\n        "internal": false,\n        "attachable": false,\n        "ingress": false,\n        "configfrom": {\n            "network": ""\n        },\n        "configonly": false,\n        "containers": {\n            "52395d45d1fcad0170da201db471ea6ac75c25c9f7d91d10b6260dce2739fd54": {\n                "name": "tomcat-net-01",\n                "endpointid": "3c1aea820c4276b0d0dbe249ebd6f43547baceb7c3e774f8ee4b61b0e4b0b11f",\n                "macaddress": "02:42:c0:a8:00:02",\n                "ipv4address": "192.168.0.2/16",\n                "ipv6address": ""\n            },\n            //发现我们的tomcat01就进来这里了\n            "c159a99201d5b3f0f6be065d562c1a0e6439b316084361937f9eda9a22e997ab": {\n                "name": "tomcat01",\n                "endpointid": "e11948dcd704e50b8008ee41546ff7c9f506b636f41fb6e6697081fd9d398dc5",\n                "macaddress": "02:42:c0:a8:00:04",\n                "ipv4address": "192.168.0.4/16",\n                "ipv6address": ""\n            },\n            "f2106d157b5ea6c5bdb87e04b9dc18be2b2e25a41d61e25851ea0afbf1e9ea39": {\n                "name": "tomcat-net-02",\n                "endpointid": "3cb8b199df4fca69e1a6428ae0536ff3291f9215f8b9d9303a2ec3402bdc704f",\n                "macaddress": "02:42:c0:a8:00:03",\n                "ipv4address": "192.168.0.3/16",\n                "ipv6address": ""\n            }\n        },\n        "options": {},\n        "labels": {}\n    }\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\ntomcat01 可以ping通了\n\n[root@vm-0-6-centos ~]# docker exec -it tomcat01 ping tomcat-net-01\nping tomcat-net-01 (192.168.0.2) 56(84) bytes of data.\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.075 ms\n\n\n1\n2\n3\n\n\ntomcat02 依旧ping不通，大家应该就理解了\n\n[root@vm-0-6-centos ~]#  docker exec -it tomcat02 ping tomcat-net-01\nping: tomcat-net-01: name or service not known\n\n\n1\n2\n\n\n结论：如果要跨网络操作别人，就需要使用 docker network connect [options] network container 连接\n\n\n# 部署 redis 集群\n\n创建网卡\n\ndocker network create redis --subnet 172.38.0.0/16\n\n\n1\n\n\n通过脚本创建六个redis配置\n\nfor port in $(seq 1 6); \\\ndo \\\nmkdir -p /mydata/redis/node-${port}/conf\ntouch /mydata/redis/node-${port}/conf/redis.conf\ncat << eof >/mydata/redis/node-${port}/conf/redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\neof\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n启动6个容器\n\nfor port in $(seq 1 6); \\\ndo \\\n\ndocker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\\n-v /mydata/redis/node-${port}/data:/data \\\n-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \\\n\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n进入一个redis，注意这里是 sh命令\n\ndocker exec -it redis-1 /bin/sh\n\n\n1\n\n\n创建集群\n\nredis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n\n\n1\n\n\n连接集群\n\nredis-cli -c\n\n\n1\n\n\n# 查看集群信息\ncluster info\n# 查看节点\ncluster nodes\n\n\n1\n2\n3\n4\n\n\n此时，六个 redis 已搭建好\n\n测试集群\n\n先 set 一个数据\n\n127.0.0.1:6379> set name zhiyuan\n-> redirected to slot [5798] located at 172.38.0.12:6379\nok\n172.38.0.12:6379> get name\n"zhiyuan"\n\n\n1\n2\n3\n4\n5\n\n\n停止到存值的容器 redis-1\n\n然后再次 get name，发现依旧可以获取值\n\n查看节点，发现高可用完全没问题',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - 数据卷",frontmatter:{title:"Docker - 数据卷",date:"2021-06-05T08:36:05.000Z",permalink:"/pages/d7cc4c/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/12.Docker%20-%20%E6%95%B0%E6%8D%AE%E5%8D%B7.html",relativePath:"05.工具部署/10.Docker/12.Docker - 数据卷.md",key:"v-36ee805b",path:"/pages/d7cc4c/",headers:[{level:2,title:"什么是数据卷",slug:"什么是数据卷",normalizedTitle:"什么是数据卷",charIndex:3},{level:2,title:"使用数据卷",slug:"使用数据卷",normalizedTitle:"使用数据卷",charIndex:13},{level:3,title:"指令 v 方式",slug:"指令-v-方式",normalizedTitle:"指令 v 方式",charIndex:24},{level:3,title:"文件 Docker File 方式",slug:"文件-docker-file-方式",normalizedTitle:"文件 docker file 方式",charIndex:37},{level:2,title:"匿名和具名挂载",slug:"匿名和具名挂载",normalizedTitle:"匿名和具名挂载",charIndex:58},{level:3,title:"匿名挂载",slug:"匿名挂载",normalizedTitle:"匿名挂载",charIndex:71},{level:3,title:"具名挂载",slug:"具名挂载",normalizedTitle:"具名挂载",charIndex:61},{level:2,title:"数据卷容器",slug:"数据卷容器",normalizedTitle:"数据卷容器",charIndex:89}],headersStr:"什么是数据卷 使用数据卷 指令 v 方式 文件 Docker File 方式 匿名和具名挂载 匿名挂载 具名挂载 数据卷容器",content:' * 什么是数据卷\n * 使用数据卷\n   * 指令 v 方式\n   * 文件 Docker File 方式\n * 匿名和具名挂载\n   * 匿名挂载\n   * 具名挂载\n * 数据卷容器\n\n\n# 什么是数据卷\n\n数据卷(Data Volume)\n\ndocker的理念回顾：\n\n将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够 持久化的！\n\n就好比，你安装一个MySQL，结果你把容器删了，就相当于删库跑路了，这TM也太扯了吧！\n\n所以我们希望容器之间有可能可以共享数据，Docker容器产生的数据，如果不通过 docker commit 生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行不通的！\n\n为了能保存数据在Docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除而丢失了！\n\n作用：\n\n卷就是目录或者文件，存在一个或者多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性。\n\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷。\n\n特点：\n\n 1. 数据卷可在容器之间共享或重用数据\n 2. 卷中的更改可以直接生效\n 3. 数据卷中的更改不会包含在镜像的更新中\n 4. 数据卷的生命周期一直持续到没有容器使用它为止\n\n一句话： 就是容器的持久化，以及容器间的继承和数据共享！\n\n\n# 使用数据卷\n\n\n# 指令 v 方式\n\n方式一：容器中直接使用命令来添加\n\n在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。\n\ndocker run -it -v 宿主机绝对路径目录:容器内目录 镜像名\n\n\n1\n\n\n测试：\n\ndocker run -it -v /home/d-test:/home centos /bin/bash\n\n\n1\n\n\n查看数据卷是否挂载成功 docker inspect 容器id\n\n[root@VM-0-6-centos ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES\n05fa819084c9   centos    "/bin/bash"   20 seconds ago   Up 20 seconds             friendly_keller\n[root@VM-0-6-centos ~]#  docker inspect 05fa819084c9\n\n\n1\n2\n3\n4\n\n\n\n\n * 测试容器和宿主机之间数据共享：可以发现，在容器中，创建的会在宿主机中看到！\n\n容器：\n\n[root@05fa819084c9 /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  s\n[root@05fa819084c9 /]# cd home\n[root@05fa819084c9 home]# ls\n[root@05fa819084c9 home]# touch test.java\n\n\n1\n2\n3\n4\n5\n\n\n主机：\n\n[root@VM-0-6-centos ~]# cd /home/d-test\n[root@VM-0-6-centos d-test]# ls\ntest.java\n\n\n1\n2\n3\n\n * 测试容器停止退出后，主机修改数据是否会同步！\n\n 1. 停止容器\n 2. 在宿主机上修改文件，增加些内容\n 3. 启动刚才停止的容器\n 4. 然后查看对应的文件，发现数据依旧同步！\n\n主机：\n\n[root@VM-0-6-centos d-test]# ls\ntest.java\n[root@VM-0-6-centos d-test]# touch new.java\n[root@VM-0-6-centos d-test]# ls\nnew.java  test.java\n\n\n1\n2\n3\n4\n5\n\n\n容器：\n\ndocker ps -a 查看所有容器\n\n[root@VM-0-6-centos home]# docker start 05fa819084c9\n05fa819084c9\n[root@VM-0-6-centos home]# docker attach 05fa819084c9\n[root@05fa819084c9 /]# cd /home\n[root@05fa819084c9 home]# ls\nnew.java  test.java\n\n\n1\n2\n3\n4\n5\n6\n\n\n安装 mysql 测试\n\n1、安装\n\ndocker pull mysql:5.7\n\n\n1\n\n\n2、启动容器 ，-e 为环境变量\n\nmysql 的数据不应该放在容器内，应放主机内！先体验下 -v 挂载卷！\n\n参考官方文档\n\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7\n\n\n1\n\n\n连接 mysql 并创建一个数据库\n\n[root@VM-0-6-centos data]# mysql -h 127.0.0.1 -P 3310 -u root -p\nmysql> create database test;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n| test               |\n+--------------------+\n5 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n\n# 文件 Docker File 方式\n\n方式二：通过Docker File 来添加\n\nDockerFile 是用来构建Docker镜像的构建文件，是由一些列命令和参数构成的脚本。\n\n这里先了解体验一下，后面有详细介绍\n\n1、编写DockerFile文件\n\n我们在宿主机 /home 目录下新建一个 docker-test-volume文件夹\n\nmkdir docker-test-volume\n\n\n1\n\n\n出于可移植和分享的考虑，之前使用的 -v 主机目录:容器目录 这种方式不能够直接在 DockerFile 中实现。\n\n[root@VM-0-6-centos docker-test-volume]# pwd\n/home/docker-test-volume\n[root@VM-0-6-centos docker-test-volume]# vim dockerfile1\n[root@VM-0-6-centos docker-test-volume]# cat dockerfile1\nFROM centos\nVOLUME ["/dataVolumeContainer1","/dataVolumeContainer2"]\nCMD echo "-------end------"\nCMD /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明：在编写DockerFile文件中使用 VOLUME 来给镜像添加一个或多个数据卷\n\n2、build生成镜像\n\nbuild生成镜像，获得一个新镜像 test-centos，注意最后面有个 .\n\ndocker build -f /home/docker-test-volume/dockerfile1 -t test-centos .\n\n\n1\n\n\n然后启动容器：\n\ndocker run -it test-centos /bin/bash\n\n\n1\n\n\n\n\n通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？\n\n3、查看数据目录\n\n我们在数据卷中新建一个文件\n\n[root@93343e21a67b /]# cd dataVolumeContainer1\n[root@93343e21a67b dataVolumeContainer1]# touch container.txt\n\n\n1\n2\n\n\n查看下这个容器的信息\n\ndocker inspect 93343e21a67b\n\n\n1\n\n\n可以看到挂载的路径\n\n\n\n在主机目录里看到之前在容器里创建的文件\n\n[root@VM-0-6-centos ~]# cd /var/lib/docker/volumes/7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788/_data\n[root@VM-0-6-centos _data]# ls\ncontainer.txt\n\n\n1\n2\n3\n\n\n注意：如果访问出现了 cannot open directory: Permission denied\n\n解决办法：在挂载目录后多加一个 --privileged=true参数即可\n\n\n# 匿名和具名挂载\n\n\n# 匿名挂载\n\n-v 容器内路径\n\ndocker run -d -P --name nginx01 -v /etc/nginx nginx\n\n\n1\n\n\n可通过命令 docker volume ls 查看挂载的列表\n\n[root@VM-0-6-centos ~]# docker volume ls\nDRIVER    VOLUME NAME\nlocal     4d0221bc0d8b9e44fb2e878cd3efcacb9b4bd51c8e135d79c549f7a6345f3a24\nlocal     7a1e6924fed1cc5ea6a386d9b2542c0ffc53fada1755bc7d09601274dff6ddd0\nlocal     7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788\nlocal     adaa3053cb2ff95afc7bab51451f4b1167aa1b9056398ed44b0d4cae9580db52\n\n\n1\n2\n3\n4\n5\n6\n\n\n这些没指定名字的都是匿名挂载，我们 -v 只写了容器内路径，并没写容器外路径\n\n挂载目录是： /var/lib/docker/volumes/VOLUME-NAME/_data\n\n匿名挂载的缺点，就是不好维护，不清楚目录挂载的是哪个容器\n\n\n# 具名挂载\n\n-v 卷名:/容器内路径\n\n例如取名为 juming 来挂载\n\n[root@VM-0-6-centos ~]# docker run -d -P --name nginx02 -v juming:/etc/nginx nginx\n112f36599f077eada56197c22dd3b3a3eaba2e5bb38bf2cb19adc783163991e7\n[root@VM-0-6-centos ~]# docker volume ls\nDRIVER    VOLUME NAME\nlocal     4d0221bc0d8b9e44fb2e878cd3efcacb9b4bd51c8e135d79c549f7a6345f3a24\nlocal     7a1e6924fed1cc5ea6a386d9b2542c0ffc53fada1755bc7d09601274dff6ddd0\nlocal     7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788\nlocal     adaa3053cb2ff95afc7bab51451f4b1167aa1b9056398ed44b0d4cae9580db52\nlocal     juming\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n查看挂载的目录：docker volume VOLUME-NAME\n\n[root@VM-0-6-centos ~]# docker volume inspect juming\n[\n    {\n        "CreatedAt": "2021-06-05T16:32:10+08:00",\n        "Driver": "local",\n        "Labels": null,\n        "Mountpoint": "/var/lib/docker/volumes/juming/_data",\n        "Name": "juming",\n        "Options": null,\n        "Scope": "local"\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n挂载操作中，没指定目录名情况下，默认在 /var/lib/docker/volumes/ 目录下\n\n * 改变文件的读写权限\n\n指定容器对我们挂载出来的内容的读写权限\n\ndocker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:ro nginx\ndocker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:rw nginx\n\n\n1\n2\n\n\nro: readonly 只读\n\nrw: readwrite 可读可写\n\n\n# 数据卷容器\n\n之前的是主机和容器之间共享数据，那么如何实现容器和容器之间的共享数据呢？\n\n命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器(Data Volume Container)\n\n测试容器间传递共享\n\n使用之前的镜像：test-centos 为模板，运行容器 docker01（父容器），docker02，docker03\n\n他们都会具有容器卷 /dataVolumeContainer1 和 /dataVolumeContainer2\n\n1、先启动一个父容器docker01，然后在 dataVolumeContainer2 新增文件\n\n[root@VM-0-6-centos _data]# docker run -it --name docker01 test-centos\n[root@cd87cb3eb33b /]# ls -l\ntotal 56\nlrwxrwxrwx   1 root root    7 Nov  3  2020 bin -> usr/bin\ndrwxr-xr-x   2 root root 4096 Jun  5 08:56 dataVolumeContainer1\ndrwxr-xr-x   2 root root 4096 Jun  5 08:56 dataVolumeContainer2\n............\n[root@cd87cb3eb33b /]# cd dataVolumeContainer2\n[root@cd87cb3eb33b dataVolumeContainer2]# touch docker01.txt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n退出且不停止容器运行：ctrl+P+Q\n\n2、创建docker02，docker03 让他们继承docker01\n\n可以看到 docker01 创建的文件存在\n\n[root@VM-0-6-centos _data]# docker run -it --name docker02 --volumes-from docker01 test-centos\n[root@f81238516f65 /]#  cd dataVolumeContainer2\n[root@f81238516f65 dataVolumeContainer2]# ls\ndocker01.txt\n[root@f81238516f65 dataVolumeContainer2]# touch docker02.txt\n\n[root@VM-0-6-centos _data]# docker run -it --name docker03 --volumes-from docker01 test-centos\n[root@c8c41a2a0831 /]# ls\nbin  dataVolumeContainer1  dataVolumeContainer2  dev  etc  home  lib  lib64  lost+found  media\tmnt  opt  proc\troot  run  sbin  srv  sys  tmp\tusr  var\n[root@c8c41a2a0831 /]# cd dataVolumeContainer2\n[root@c8c41a2a0831 dataVolumeContainer2]# ls\ndocker01.txt  docker02.txt\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3、回到docker01发现可以看到 02 和 03 添加的共享文件\n\n[root@VM-0-6-centos ~]#  docker attach docker01\n[root@cd87cb3eb33b dataVolumeContainer2]# ls -l\ntotal 0\n-rw-r--r-- 1 root root 0 Jun  5 08:56 docker01.txt\n-rw-r--r-- 1 root root 0 Jun  5 08:58 docker02.txt\n-rw-r--r-- 1 root root 0 Jun  5 09:00 docker03.txt\n\n\n1\n2\n3\n4\n5\n6\n\n\n删除 docker01 后 ，docker02 修改文件后， docker03 还可以正常共享数据\n\n容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 存储在本机的文件则会一直保留！',normalizedContent:' * 什么是数据卷\n * 使用数据卷\n   * 指令 v 方式\n   * 文件 docker file 方式\n * 匿名和具名挂载\n   * 匿名挂载\n   * 具名挂载\n * 数据卷容器\n\n\n# 什么是数据卷\n\n数据卷(data volume)\n\ndocker的理念回顾：\n\n将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够 持久化的！\n\n就好比，你安装一个mysql，结果你把容器删了，就相当于删库跑路了，这tm也太扯了吧！\n\n所以我们希望容器之间有可能可以共享数据，docker容器产生的数据，如果不通过 docker commit 生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行不通的！\n\n为了能保存数据在docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除而丢失了！\n\n作用：\n\n卷就是目录或者文件，存在一个或者多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 union file system ， 提供一些用于持续存储或共享数据的特性。\n\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 docker 不会在容器删除时删除其挂载的数据卷。\n\n特点：\n\n 1. 数据卷可在容器之间共享或重用数据\n 2. 卷中的更改可以直接生效\n 3. 数据卷中的更改不会包含在镜像的更新中\n 4. 数据卷的生命周期一直持续到没有容器使用它为止\n\n一句话： 就是容器的持久化，以及容器间的继承和数据共享！\n\n\n# 使用数据卷\n\n\n# 指令 v 方式\n\n方式一：容器中直接使用命令来添加\n\n在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。\n\ndocker run -it -v 宿主机绝对路径目录:容器内目录 镜像名\n\n\n1\n\n\n测试：\n\ndocker run -it -v /home/d-test:/home centos /bin/bash\n\n\n1\n\n\n查看数据卷是否挂载成功 docker inspect 容器id\n\n[root@vm-0-6-centos ~]# docker ps\ncontainer id   image     command       created          status          ports     names\n05fa819084c9   centos    "/bin/bash"   20 seconds ago   up 20 seconds             friendly_keller\n[root@vm-0-6-centos ~]#  docker inspect 05fa819084c9\n\n\n1\n2\n3\n4\n\n\n\n\n * 测试容器和宿主机之间数据共享：可以发现，在容器中，创建的会在宿主机中看到！\n\n容器：\n\n[root@05fa819084c9 /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  s\n[root@05fa819084c9 /]# cd home\n[root@05fa819084c9 home]# ls\n[root@05fa819084c9 home]# touch test.java\n\n\n1\n2\n3\n4\n5\n\n\n主机：\n\n[root@vm-0-6-centos ~]# cd /home/d-test\n[root@vm-0-6-centos d-test]# ls\ntest.java\n\n\n1\n2\n3\n\n * 测试容器停止退出后，主机修改数据是否会同步！\n\n 1. 停止容器\n 2. 在宿主机上修改文件，增加些内容\n 3. 启动刚才停止的容器\n 4. 然后查看对应的文件，发现数据依旧同步！\n\n主机：\n\n[root@vm-0-6-centos d-test]# ls\ntest.java\n[root@vm-0-6-centos d-test]# touch new.java\n[root@vm-0-6-centos d-test]# ls\nnew.java  test.java\n\n\n1\n2\n3\n4\n5\n\n\n容器：\n\ndocker ps -a 查看所有容器\n\n[root@vm-0-6-centos home]# docker start 05fa819084c9\n05fa819084c9\n[root@vm-0-6-centos home]# docker attach 05fa819084c9\n[root@05fa819084c9 /]# cd /home\n[root@05fa819084c9 home]# ls\nnew.java  test.java\n\n\n1\n2\n3\n4\n5\n6\n\n\n安装 mysql 测试\n\n1、安装\n\ndocker pull mysql:5.7\n\n\n1\n\n\n2、启动容器 ，-e 为环境变量\n\nmysql 的数据不应该放在容器内，应放主机内！先体验下 -v 挂载卷！\n\n参考官方文档\n\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e mysql_root_password=123456 --name mysql01 mysql:5.7\n\n\n1\n\n\n连接 mysql 并创建一个数据库\n\n[root@vm-0-6-centos data]# mysql -h 127.0.0.1 -p 3310 -u root -p\nmysql> create database test;\nquery ok, 1 row affected (0.00 sec)\n\nmysql> show databases;\n+--------------------+\n| database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n| test               |\n+--------------------+\n5 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n\n# 文件 docker file 方式\n\n方式二：通过docker file 来添加\n\ndockerfile 是用来构建docker镜像的构建文件，是由一些列命令和参数构成的脚本。\n\n这里先了解体验一下，后面有详细介绍\n\n1、编写dockerfile文件\n\n我们在宿主机 /home 目录下新建一个 docker-test-volume文件夹\n\nmkdir docker-test-volume\n\n\n1\n\n\n出于可移植和分享的考虑，之前使用的 -v 主机目录:容器目录 这种方式不能够直接在 dockerfile 中实现。\n\n[root@vm-0-6-centos docker-test-volume]# pwd\n/home/docker-test-volume\n[root@vm-0-6-centos docker-test-volume]# vim dockerfile1\n[root@vm-0-6-centos docker-test-volume]# cat dockerfile1\nfrom centos\nvolume ["/datavolumecontainer1","/datavolumecontainer2"]\ncmd echo "-------end------"\ncmd /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明：在编写dockerfile文件中使用 volume 来给镜像添加一个或多个数据卷\n\n2、build生成镜像\n\nbuild生成镜像，获得一个新镜像 test-centos，注意最后面有个 .\n\ndocker build -f /home/docker-test-volume/dockerfile1 -t test-centos .\n\n\n1\n\n\n然后启动容器：\n\ndocker run -it test-centos /bin/bash\n\n\n1\n\n\n\n\n通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？\n\n3、查看数据目录\n\n我们在数据卷中新建一个文件\n\n[root@93343e21a67b /]# cd datavolumecontainer1\n[root@93343e21a67b datavolumecontainer1]# touch container.txt\n\n\n1\n2\n\n\n查看下这个容器的信息\n\ndocker inspect 93343e21a67b\n\n\n1\n\n\n可以看到挂载的路径\n\n\n\n在主机目录里看到之前在容器里创建的文件\n\n[root@vm-0-6-centos ~]# cd /var/lib/docker/volumes/7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788/_data\n[root@vm-0-6-centos _data]# ls\ncontainer.txt\n\n\n1\n2\n3\n\n\n注意：如果访问出现了 cannot open directory: permission denied\n\n解决办法：在挂载目录后多加一个 --privileged=true参数即可\n\n\n# 匿名和具名挂载\n\n\n# 匿名挂载\n\n-v 容器内路径\n\ndocker run -d -p --name nginx01 -v /etc/nginx nginx\n\n\n1\n\n\n可通过命令 docker volume ls 查看挂载的列表\n\n[root@vm-0-6-centos ~]# docker volume ls\ndriver    volume name\nlocal     4d0221bc0d8b9e44fb2e878cd3efcacb9b4bd51c8e135d79c549f7a6345f3a24\nlocal     7a1e6924fed1cc5ea6a386d9b2542c0ffc53fada1755bc7d09601274dff6ddd0\nlocal     7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788\nlocal     adaa3053cb2ff95afc7bab51451f4b1167aa1b9056398ed44b0d4cae9580db52\n\n\n1\n2\n3\n4\n5\n6\n\n\n这些没指定名字的都是匿名挂载，我们 -v 只写了容器内路径，并没写容器外路径\n\n挂载目录是： /var/lib/docker/volumes/volume-name/_data\n\n匿名挂载的缺点，就是不好维护，不清楚目录挂载的是哪个容器\n\n\n# 具名挂载\n\n-v 卷名:/容器内路径\n\n例如取名为 juming 来挂载\n\n[root@vm-0-6-centos ~]# docker run -d -p --name nginx02 -v juming:/etc/nginx nginx\n112f36599f077eada56197c22dd3b3a3eaba2e5bb38bf2cb19adc783163991e7\n[root@vm-0-6-centos ~]# docker volume ls\ndriver    volume name\nlocal     4d0221bc0d8b9e44fb2e878cd3efcacb9b4bd51c8e135d79c549f7a6345f3a24\nlocal     7a1e6924fed1cc5ea6a386d9b2542c0ffc53fada1755bc7d09601274dff6ddd0\nlocal     7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788\nlocal     adaa3053cb2ff95afc7bab51451f4b1167aa1b9056398ed44b0d4cae9580db52\nlocal     juming\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n查看挂载的目录：docker volume volume-name\n\n[root@vm-0-6-centos ~]# docker volume inspect juming\n[\n    {\n        "createdat": "2021-06-05t16:32:10+08:00",\n        "driver": "local",\n        "labels": null,\n        "mountpoint": "/var/lib/docker/volumes/juming/_data",\n        "name": "juming",\n        "options": null,\n        "scope": "local"\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n挂载操作中，没指定目录名情况下，默认在 /var/lib/docker/volumes/ 目录下\n\n * 改变文件的读写权限\n\n指定容器对我们挂载出来的内容的读写权限\n\ndocker run -d -p --name nginx02 -v nginxconfig:/etc/nginx:ro nginx\ndocker run -d -p --name nginx02 -v nginxconfig:/etc/nginx:rw nginx\n\n\n1\n2\n\n\nro: readonly 只读\n\nrw: readwrite 可读可写\n\n\n# 数据卷容器\n\n之前的是主机和容器之间共享数据，那么如何实现容器和容器之间的共享数据呢？\n\n命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器(data volume container)\n\n测试容器间传递共享\n\n使用之前的镜像：test-centos 为模板，运行容器 docker01（父容器），docker02，docker03\n\n他们都会具有容器卷 /datavolumecontainer1 和 /datavolumecontainer2\n\n1、先启动一个父容器docker01，然后在 datavolumecontainer2 新增文件\n\n[root@vm-0-6-centos _data]# docker run -it --name docker01 test-centos\n[root@cd87cb3eb33b /]# ls -l\ntotal 56\nlrwxrwxrwx   1 root root    7 nov  3  2020 bin -> usr/bin\ndrwxr-xr-x   2 root root 4096 jun  5 08:56 datavolumecontainer1\ndrwxr-xr-x   2 root root 4096 jun  5 08:56 datavolumecontainer2\n............\n[root@cd87cb3eb33b /]# cd datavolumecontainer2\n[root@cd87cb3eb33b datavolumecontainer2]# touch docker01.txt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n退出且不停止容器运行：ctrl+p+q\n\n2、创建docker02，docker03 让他们继承docker01\n\n可以看到 docker01 创建的文件存在\n\n[root@vm-0-6-centos _data]# docker run -it --name docker02 --volumes-from docker01 test-centos\n[root@f81238516f65 /]#  cd datavolumecontainer2\n[root@f81238516f65 datavolumecontainer2]# ls\ndocker01.txt\n[root@f81238516f65 datavolumecontainer2]# touch docker02.txt\n\n[root@vm-0-6-centos _data]# docker run -it --name docker03 --volumes-from docker01 test-centos\n[root@c8c41a2a0831 /]# ls\nbin  datavolumecontainer1  datavolumecontainer2  dev  etc  home  lib  lib64  lost+found  media\tmnt  opt  proc\troot  run  sbin  srv  sys  tmp\tusr  var\n[root@c8c41a2a0831 /]# cd datavolumecontainer2\n[root@c8c41a2a0831 datavolumecontainer2]# ls\ndocker01.txt  docker02.txt\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3、回到docker01发现可以看到 02 和 03 添加的共享文件\n\n[root@vm-0-6-centos ~]#  docker attach docker01\n[root@cd87cb3eb33b datavolumecontainer2]# ls -l\ntotal 0\n-rw-r--r-- 1 root root 0 jun  5 08:56 docker01.txt\n-rw-r--r-- 1 root root 0 jun  5 08:58 docker02.txt\n-rw-r--r-- 1 root root 0 jun  5 09:00 docker03.txt\n\n\n1\n2\n3\n4\n5\n6\n\n\n删除 docker01 后 ，docker02 修改文件后， docker03 还可以正常共享数据\n\n容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 存储在本机的文件则会一直保留！',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - DockerFile",frontmatter:{title:"Docker - DockerFile",date:"2021-06-05T17:05:29.000Z",permalink:"/pages/786a41/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/14.Docker%20-%20DockerFile.html",relativePath:"05.工具部署/10.Docker/14.Docker - DockerFile.md",key:"v-2967a998",path:"/pages/786a41/",headers:[{level:2,title:"什么是 DockerFile",slug:"什么是-dockerfile",normalizedTitle:"什么是 dockerfile",charIndex:3},{level:2,title:"DockerFile 构建过程",slug:"dockerfile-构建过程",normalizedTitle:"dockerfile 构建过程",charIndex:21},{level:2,title:"DockerFile 指令",slug:"dockerfile-指令",normalizedTitle:"dockerfile 指令",charIndex:40},{level:2,title:"CMD 和 ENTRYPOINT 的区别",slug:"cmd-和-entrypoint-的区别",normalizedTitle:"cmd 和 entrypoint 的区别",charIndex:57},{level:2,title:"实战测试",slug:"实战测试",normalizedTitle:"实战测试",charIndex:81},{level:3,title:"CentOS",slug:"centos",normalizedTitle:"centos",charIndex:91},{level:3,title:"Tomcat",slug:"tomcat",normalizedTitle:"tomcat",charIndex:103},{level:3,title:"SpingBoot",slug:"spingboot",normalizedTitle:"spingboot",charIndex:115}],headersStr:"什么是 DockerFile DockerFile 构建过程 DockerFile 指令 CMD 和 ENTRYPOINT 的区别 实战测试 CentOS Tomcat SpingBoot",content:' * 什么是 DockerFile\n * DockerFile 构建过程\n * DockerFile 指令\n * CMD 和 ENTRYPOINT 的区别\n * 实战测试\n   * CentOS\n   * Tomcat\n   * SpingBoot\n\n大家想想，Nginx，tomcat，mysql 这些镜像都是哪里来的？官方能写，我们不能写吗？\n\n我们要研究自己如何做一个镜像，而且我们写的微服务项目以及 springboot 打包上云部署，Docker就是最方便的。\n\n微服务打包成镜像，任何装了Docker的地方，都可以下载使用，极其的方便。\n\n流程：开发应用=>DockerFile=>打包为镜像=>上传到仓库（私有仓库，公有仓库）=> 下载镜像 => 启动 运行。\n\n还可以方便移植！\n\n\n# 什么是 DockerFile\n\ndockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本\n\n构建步骤：\n\n1、编写DockerFile文件\n\n2、docker build 构建镜像\n\n3、docker run\n\n查看之前拉取的 centos ：https://hub.docker.com/_/centos\n\n\n\n查看Dockerfile 文件\n\n\n\n\n# DockerFile 构建过程\n\n基础知识：\n\n1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n\n2、指令按照从上到下，顺序执行\n\n3、# 表示注释\n\n4、每条指令都会创建一个新的镜像层，并对镜像进行提交\n\n流程：\n\n1、docker从基础镜像运行一个容器\n\n2、执行一条指令并对容器做出修改\n\n3、执行类似 docker commit 的操作提交一个新的镜像层\n\n4、Docker再基于刚提交的镜像运行一个新容器\n\n5、执行dockerfile中的下一条指令直到所有指令都执行完成！\n\n说明：\n\n从应用软件的角度来看，DockerFile，docker镜像 与 docker容器 分别代表软件的三个不同阶段。\n\n * DockerFile 是软件的原材料 （代码）\n * Docker 镜像则是软件的交付品 （.apk）\n * Docker 容器则是软件的运行状态 （客户下载安装执行）\n\nDockerFile 面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可！\n\n\n\nDockerFile：需要定义一个DockerFile，DockerFile定义了进程需要的一切东西。DockerFile涉及的内容 包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进 程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权 限控制）等等。\n\nDocker镜像：在DockerFile 定义了一个文件之后，Docker build 时会产生一个Docker镜像，当运行 Docker 镜像时，会真正开始提供服务；\n\nDocker容器：容器是直接提供服务的。\n\n\n# DockerFile 指令\n\n关键字          说明\nFROM         基础镜像，当前新镜像是基于哪个镜像的\nMAINTAINER   镜像维护者的姓名混合邮箱地址\nRUN          容器构建时需要运行的命令\nEXPOSE       当前容器对外保留出的端口\nWORKDIR      指定在创建容器后，终端默认登录的进来工作目录，一个落脚点\nENV          用来在构建镜像过程中设置环境变量\nADD          将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包\nCOPY         类似ADD，拷贝文件和目录到镜像中！\nVOLUME       容器数据卷，用于数据保存和持久化工作\nCMD          指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最后一个生效！\nENTRYPOINT   指定一个容器启动时要运行的命令！和CMD一样\nONBUILD      当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发\n\n\n\n\n\n\n# CMD 和 ENTRYPOINT 的区别\n\n我们之前说过，两个命令都是指定一个容器启动时要运行的命令\n\n * CMD\n   \n   Dockerfile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换！\n\n * ENTRYPOINT\n   \n   docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合！\n\n测试 CMD 命令\n\n1、编写文件\n\n[root@VM-0-6-centos dockerfile-test]# vim dockerfile-cmd-test\n[root@VM-0-6-centos dockerfile-test]# cat dockerfile-cmd-test\nFROM centos \nCMD [ "ls", "-a" ]\n\n\n1\n2\n3\n4\n\n\n2、构建并运行\n\ndocker build -f dockerfile-cmd-test -t cmdtest .\n\ndocker run cmdtest\n\n\n1\n2\n3\n\n\n\n\n3、如果我们希望用 -l 列表展示信息，我们就需要加上 -l参数\n\n[root@VM-0-6-centos dockerfile-test]#  docker run cmdtest -l\ndocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: "-l": executable file not found in $PATH: unknown.\n\n\n1\n2\n\n\n问题：我们可以看到可执行文件找不到的报错，executable file not found。\n\n之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。\n\n因此这里的 -l 替换了原来的 CMD，而不是添加在原来的 ls -a 后面。\n\n而 -l 根本不是命令，所以自然找不到。\n\n那么如果我们希望加入 -l这参数，我们就必须重新完整的输入这个命令：\n\ndocker run cmdtest ls -al\n\n\n1\n\n\n测试 ENTRYPOINT 命令\n\n1、编写文件\n\n[root@VM-0-6-centos dockerfile-test]# vim dockerfile-entrypoint-test\n[root@VM-0-6-centos dockerfile-test]# cat dockerfile-entrypoint-test\nFROM centos\nENTRYPOINT [ "ls", "-a" ]\n\n\n1\n2\n3\n4\n\n\n2、构建并运行\n\ndocker build -f dockerfile-entrypoint-test -t entrypointtest .\n\ndocker run entrypointtest\n\n\n1\n2\n3\n\n\n3、测试 -l 参数，发现可以直接使用，这里就是一种追加\n\n我们可以明显的知道 CMD 和 ENTRYPOINT 的区别了\n\ndocker run entrypointtest -l\n\n\n1\n\n\n\n\n\n# 实战测试\n\n\n# CentOS\n\n官方默认的 CentOS 的情况不支持 vim 和 ifconfig 指令\n\n我们自己构建一个支持这些指令的镜像\n\n1、编写文件\n\n[root@VM-0-6-centos home]# cd dockerfile-test\n[root@VM-0-6-centos dockerfile-test]# ls\nmy-centos\n[root@VM-0-6-centos dockerfile-test]# cat my-centos\nFROM centos\nMAINTAINER zhiyuan<oddfar@163.com>\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nRUN yum -y install vim\nRUN yum -y install net-tools\n\n\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo "----end-----"\nCMD /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、构建\n\n命令最后有一个 . 表示当前目录\n\ndocker build -f my-centos -t mycentos:1.1 .\n\n\n1\n\n\n成功后：\n\n\n\n3、运行\n\ndocker run -it mycentos:1.1\n\n\n1\n\n\n测试后，可以看到，我们自己的新镜像已经支持 vim 和 ifconfig的命令了\n\n * 列出镜像的变更历史：\n   \n   docker history 镜像名\\镜像id\n\n\n# Tomcat\n\n步骤：\n\n * 将 JDK 和 tomcat 安装的压缩包拷贝/home/build 目录下\n   \n   下载地址：\n   \n   链接：https://pan.baidu.com/s/1QZEmvAgyh4-8DbebVz7koQ\n   \n   提取码：spfo\n\n * 新建一个 read.txt 文件\n\n * 新建一个 Dockerfile 文件\n\n[root@VM-0-6-centos home]# cd build\n[root@VM-0-6-centos build]# ls\napache-tomcat-9.0.46.tar.gz  Dockerfile  jdk-8u11-linux-x64.tar.gz  read.txt  tomcat\n\n\n1\n2\n3\n\n\nDockerfile 内容\n\nFROM centos\n\nMAINTAINER zhiyuan<test@qq.com>\n#把宿主机当前上下文的read.txt拷贝到容器/usr/local/路径下\nCOPY read.txt /usr/local/cincontainer.txt\n#把java与tomcat添加到容器中\nADD jdk-8u11-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-9.0.46.tar.gz /usr/local/\n#安装vim编辑器\nRUN yum -y install vim\n#变量\nENV MYPATH /usr/local\n#设置工作访问时候的WORKDIR路径，登录落脚点\nWORKDIR $MYPATH\n#配置java与tomcat环境变量\nENV JAVA_HOME /usr/local/jdk1.8.0_11\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.46\nENV CATALINA_BASE /usr/local/apache-tomcat-9.0.46\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n#容器运行时监听的端口\nEXPOSE 8080\n#启动时运行tomcat\n# ENTRYPOINT ["/usr/local/apache-tomcat-9.0.46/bin/startup.sh" ]\n# CMD ["/usr/local/apache-tomcat-9.0.46/bin/catalina.sh","run"]\nCMD /usr/local/apache-tomcat-9.0.46/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.46/bin/logs/catalina.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n构建镜像：\n\ndocker build -t diytomcat .\n\n\n1\n\n\n在此目录下默认构建 Dockerfile 文件，所以不需要带上文件名\n\n启动：\n\ndocker run -d  -p 9090:8080 --name mydiytomcat -v /home/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/build/tomcat/logs/:/usr/local/apache-tomcat-9.0.46/logs --privileged=true diytomcat\n\n\n1\n\n\n备注：Docker挂载主机目录Docker访问出现cannot open directory Permission denied\n\n解决办法：在挂载目录后多加一个--privileged=true参数即可\n\n写个测试网站扔到test目录：\n\nweb.xml\n\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n  version="4.0"\n  metadata-complete="true">\n\n  <display-name>Test</display-name>\n\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\na.jsp\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n    pageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset="utf-8">\n<title>测试</title>\n</head>\n<body>\n\tHello World!<br/>\n\t<% System.out.println("-------my docker tomcat-------");%>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n查看日志：\n\n[root@VM-0-6-centos tomcat]# cd logs\n[root@VM-0-6-centos logs]# cat catalina.out\n\n\n1\n2\n\n\n\n\n\n# SpingBoot\n\n1、使用 IDEA 构建一个 SpringBoot 项目\n\n2、编写 Controller\n\n@RestController\npublic class HelloController {\n    @GetMapping("/hello")\n    public String hello(){\n\t    return "hello,world";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n打包成 jar 包\n\n3、构建镜像\n\n将打包好的 jar 包拷贝到 Dockerfile 同级目录，编写 Dockerfile文件\n\nFROM java:8\n\n# 服务器只有dockerfile和jar在同级目录\nCOPY *.jar /app.jar\n\nCMD ["--server.port=8080"]\n\n# 指定容器内要暴露的端口\nEXPOSE 8080\n\nENTRYPOINT ["java","-jar","/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n构建运行\n\n# 构建镜像\ndocker build -t idea-ks .\n\n# 运行\ndocker run -d -P --name idea-ks idea-ks\n\n\n1\n2\n3\n4\n5\n\n\n最后测试访问',normalizedContent:' * 什么是 dockerfile\n * dockerfile 构建过程\n * dockerfile 指令\n * cmd 和 entrypoint 的区别\n * 实战测试\n   * centos\n   * tomcat\n   * spingboot\n\n大家想想，nginx，tomcat，mysql 这些镜像都是哪里来的？官方能写，我们不能写吗？\n\n我们要研究自己如何做一个镜像，而且我们写的微服务项目以及 springboot 打包上云部署，docker就是最方便的。\n\n微服务打包成镜像，任何装了docker的地方，都可以下载使用，极其的方便。\n\n流程：开发应用=>dockerfile=>打包为镜像=>上传到仓库（私有仓库，公有仓库）=> 下载镜像 => 启动 运行。\n\n还可以方便移植！\n\n\n# 什么是 dockerfile\n\ndockerfile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本\n\n构建步骤：\n\n1、编写dockerfile文件\n\n2、docker build 构建镜像\n\n3、docker run\n\n查看之前拉取的 centos ：https://hub.docker.com/_/centos\n\n\n\n查看dockerfile 文件\n\n\n\n\n# dockerfile 构建过程\n\n基础知识：\n\n1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n\n2、指令按照从上到下，顺序执行\n\n3、# 表示注释\n\n4、每条指令都会创建一个新的镜像层，并对镜像进行提交\n\n流程：\n\n1、docker从基础镜像运行一个容器\n\n2、执行一条指令并对容器做出修改\n\n3、执行类似 docker commit 的操作提交一个新的镜像层\n\n4、docker再基于刚提交的镜像运行一个新容器\n\n5、执行dockerfile中的下一条指令直到所有指令都执行完成！\n\n说明：\n\n从应用软件的角度来看，dockerfile，docker镜像 与 docker容器 分别代表软件的三个不同阶段。\n\n * dockerfile 是软件的原材料 （代码）\n * docker 镜像则是软件的交付品 （.apk）\n * docker 容器则是软件的运行状态 （客户下载安装执行）\n\ndockerfile 面向开发，docker镜像成为交付标准，docker容器则涉及部署与运维，三者缺一不可！\n\n\n\ndockerfile：需要定义一个dockerfile，dockerfile定义了进程需要的一切东西。dockerfile涉及的内容 包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进 程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权 限控制）等等。\n\ndocker镜像：在dockerfile 定义了一个文件之后，docker build 时会产生一个docker镜像，当运行 docker 镜像时，会真正开始提供服务；\n\ndocker容器：容器是直接提供服务的。\n\n\n# dockerfile 指令\n\n关键字          说明\nfrom         基础镜像，当前新镜像是基于哪个镜像的\nmaintainer   镜像维护者的姓名混合邮箱地址\nrun          容器构建时需要运行的命令\nexpose       当前容器对外保留出的端口\nworkdir      指定在创建容器后，终端默认登录的进来工作目录，一个落脚点\nenv          用来在构建镜像过程中设置环境变量\nadd          将宿主机目录下的文件拷贝进镜像且add命令会自动处理url和解压tar压缩包\ncopy         类似add，拷贝文件和目录到镜像中！\nvolume       容器数据卷，用于数据保存和持久化工作\ncmd          指定一个容器启动时要运行的命令，dockerfile中可以有多个cmd指令，但只有最后一个生效！\nentrypoint   指定一个容器启动时要运行的命令！和cmd一样\nonbuild      当构建一个被继承的dockerfile时运行命令，父镜像在被子镜像继承后，父镜像的 onbuild被触发\n\n\n\n\n\n\n# cmd 和 entrypoint 的区别\n\n我们之前说过，两个命令都是指定一个容器启动时要运行的命令\n\n * cmd\n   \n   dockerfile 中可以有多个cmd 指令，但只有最后一个生效，cmd 会被 docker run 之后的参数替换！\n\n * entrypoint\n   \n   docker run 之后的参数会被当做参数传递给 entrypoint，之后形成新的命令组合！\n\n测试 cmd 命令\n\n1、编写文件\n\n[root@vm-0-6-centos dockerfile-test]# vim dockerfile-cmd-test\n[root@vm-0-6-centos dockerfile-test]# cat dockerfile-cmd-test\nfrom centos \ncmd [ "ls", "-a" ]\n\n\n1\n2\n3\n4\n\n\n2、构建并运行\n\ndocker build -f dockerfile-cmd-test -t cmdtest .\n\ndocker run cmdtest\n\n\n1\n2\n3\n\n\n\n\n3、如果我们希望用 -l 列表展示信息，我们就需要加上 -l参数\n\n[root@vm-0-6-centos dockerfile-test]#  docker run cmdtest -l\ndocker: error response from daemon: oci runtime create failed: container_linux.go:380: starting container process caused: exec: "-l": executable file not found in $path: unknown.\n\n\n1\n2\n\n\n问题：我们可以看到可执行文件找不到的报错，executable file not found。\n\n之前我们说过，跟在镜像名后面的是 command，运行时会替换 cmd 的默认值。\n\n因此这里的 -l 替换了原来的 cmd，而不是添加在原来的 ls -a 后面。\n\n而 -l 根本不是命令，所以自然找不到。\n\n那么如果我们希望加入 -l这参数，我们就必须重新完整的输入这个命令：\n\ndocker run cmdtest ls -al\n\n\n1\n\n\n测试 entrypoint 命令\n\n1、编写文件\n\n[root@vm-0-6-centos dockerfile-test]# vim dockerfile-entrypoint-test\n[root@vm-0-6-centos dockerfile-test]# cat dockerfile-entrypoint-test\nfrom centos\nentrypoint [ "ls", "-a" ]\n\n\n1\n2\n3\n4\n\n\n2、构建并运行\n\ndocker build -f dockerfile-entrypoint-test -t entrypointtest .\n\ndocker run entrypointtest\n\n\n1\n2\n3\n\n\n3、测试 -l 参数，发现可以直接使用，这里就是一种追加\n\n我们可以明显的知道 cmd 和 entrypoint 的区别了\n\ndocker run entrypointtest -l\n\n\n1\n\n\n\n\n\n# 实战测试\n\n\n# centos\n\n官方默认的 centos 的情况不支持 vim 和 ifconfig 指令\n\n我们自己构建一个支持这些指令的镜像\n\n1、编写文件\n\n[root@vm-0-6-centos home]# cd dockerfile-test\n[root@vm-0-6-centos dockerfile-test]# ls\nmy-centos\n[root@vm-0-6-centos dockerfile-test]# cat my-centos\nfrom centos\nmaintainer zhiyuan<oddfar@163.com>\n\nenv mypath /usr/local\nworkdir $mypath\n\nrun yum -y install vim\nrun yum -y install net-tools\n\n\nexpose 80\n\ncmd echo $mypath\ncmd echo "----end-----"\ncmd /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、构建\n\n命令最后有一个 . 表示当前目录\n\ndocker build -f my-centos -t mycentos:1.1 .\n\n\n1\n\n\n成功后：\n\n\n\n3、运行\n\ndocker run -it mycentos:1.1\n\n\n1\n\n\n测试后，可以看到，我们自己的新镜像已经支持 vim 和 ifconfig的命令了\n\n * 列出镜像的变更历史：\n   \n   docker history 镜像名\\镜像id\n\n\n# tomcat\n\n步骤：\n\n * 将 jdk 和 tomcat 安装的压缩包拷贝/home/build 目录下\n   \n   下载地址：\n   \n   链接：https://pan.baidu.com/s/1qzemvagyh4-8dbebvz7koq\n   \n   提取码：spfo\n\n * 新建一个 read.txt 文件\n\n * 新建一个 dockerfile 文件\n\n[root@vm-0-6-centos home]# cd build\n[root@vm-0-6-centos build]# ls\napache-tomcat-9.0.46.tar.gz  dockerfile  jdk-8u11-linux-x64.tar.gz  read.txt  tomcat\n\n\n1\n2\n3\n\n\ndockerfile 内容\n\nfrom centos\n\nmaintainer zhiyuan<test@qq.com>\n#把宿主机当前上下文的read.txt拷贝到容器/usr/local/路径下\ncopy read.txt /usr/local/cincontainer.txt\n#把java与tomcat添加到容器中\nadd jdk-8u11-linux-x64.tar.gz /usr/local/\nadd apache-tomcat-9.0.46.tar.gz /usr/local/\n#安装vim编辑器\nrun yum -y install vim\n#变量\nenv mypath /usr/local\n#设置工作访问时候的workdir路径，登录落脚点\nworkdir $mypath\n#配置java与tomcat环境变量\nenv java_home /usr/local/jdk1.8.0_11\nenv classpath $java_home/lib/dt.jar:$java_home/lib/tools.jar\nenv catalina_home /usr/local/apache-tomcat-9.0.46\nenv catalina_base /usr/local/apache-tomcat-9.0.46\nenv path $path:$java_home/bin:$catalina_home/lib:$catalina_home/bin\n#容器运行时监听的端口\nexpose 8080\n#启动时运行tomcat\n# entrypoint ["/usr/local/apache-tomcat-9.0.46/bin/startup.sh" ]\n# cmd ["/usr/local/apache-tomcat-9.0.46/bin/catalina.sh","run"]\ncmd /usr/local/apache-tomcat-9.0.46/bin/startup.sh && tail -f /usr/local/apache-tomcat-9.0.46/bin/logs/catalina.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n构建镜像：\n\ndocker build -t diytomcat .\n\n\n1\n\n\n在此目录下默认构建 dockerfile 文件，所以不需要带上文件名\n\n启动：\n\ndocker run -d  -p 9090:8080 --name mydiytomcat -v /home/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/build/tomcat/logs/:/usr/local/apache-tomcat-9.0.46/logs --privileged=true diytomcat\n\n\n1\n\n\n备注：docker挂载主机目录docker访问出现cannot open directory permission denied\n\n解决办法：在挂载目录后多加一个--privileged=true参数即可\n\n写个测试网站扔到test目录：\n\nweb.xml\n\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n  xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n  version="4.0"\n  metadata-complete="true">\n\n  <display-name>test</display-name>\n\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\na.jsp\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n    pageencoding="utf-8"%>\n<!doctype html>\n<html>\n<head>\n<meta charset="utf-8">\n<title>测试</title>\n</head>\n<body>\n\thello world!<br/>\n\t<% system.out.println("-------my docker tomcat-------");%>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n查看日志：\n\n[root@vm-0-6-centos tomcat]# cd logs\n[root@vm-0-6-centos logs]# cat catalina.out\n\n\n1\n2\n\n\n\n\n\n# spingboot\n\n1、使用 idea 构建一个 springboot 项目\n\n2、编写 controller\n\n@restcontroller\npublic class hellocontroller {\n    @getmapping("/hello")\n    public string hello(){\n\t    return "hello,world";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n打包成 jar 包\n\n3、构建镜像\n\n将打包好的 jar 包拷贝到 dockerfile 同级目录，编写 dockerfile文件\n\nfrom java:8\n\n# 服务器只有dockerfile和jar在同级目录\ncopy *.jar /app.jar\n\ncmd ["--server.port=8080"]\n\n# 指定容器内要暴露的端口\nexpose 8080\n\nentrypoint ["java","-jar","/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n构建运行\n\n# 构建镜像\ndocker build -t idea-ks .\n\n# 运行\ndocker run -d -p --name idea-ks idea-ks\n\n\n1\n2\n3\n4\n5\n\n\n最后测试访问',charsets:{cjk:!0},lastUpdated:"2023/06/02, 15:06:00",lastUpdatedTimestamp:16857188e5},{title:"Docker - Compose",frontmatter:{title:"Docker - Compose",date:"2021-06-17T17:21:32.000Z",permalink:"/pages/a38e01/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/10.Docker/18.Docker%20-%20Compose.html",relativePath:"05.工具部署/10.Docker/18.Docker - Compose.md",key:"v-360040da",path:"/pages/a38e01/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:9},{level:2,title:"简单上手",slug:"简单上手",normalizedTitle:"简单上手",charIndex:15},{level:2,title:"yaml 规则",slug:"yaml-规则",normalizedTitle:"yaml 规则",charIndex:23},{level:2,title:"java测试发布",slug:"java测试发布",normalizedTitle:"java测试发布",charIndex:34}],headersStr:"简介 安装 简单上手 yaml 规则 java测试发布",content:' * 简介\n * 安装\n * 简单上手\n * yaml 规则\n * java测试发布\n\n\n# 简介\n\n官方介绍\n\nhttps://docs.docker.com/compose/\n\nCompose 是一个用于定义和运行多容器 Docker 应用程序的工具。借助 Compose，您可以使用 YAML 文件来配置应用程序的服务。然后，使用单个命令，从配置中创建并启动所有服务。要了解有关 Compose 的所有功能的更多信息，请参阅功能列表。\n\nCompose 适用于所有环境：生产、登台、开发、测试以及 CI 工作流。您可以在Common Use Cases 中了解有关每个案例的更多信息。\n\n使用 Compose 基本上是一个三步过程：\n\n 1. 使用 定义您的应用程序的环境，Dockerfile以便它可以在任何地方复制。\n 2. 定义组成您的应用程序的服务，docker-compose.yml 以便它们可以在隔离的环境中一起运行。\n 3. 运行 docker compose up 和 Docker compose command 启动并运行你的整个应用程序。您也可以docker-compose up使用 docker-compose 二进制文件运行。\n\n可以用 Docker Compose 来轻松高效的管理容器。定义运行多个容器。\n\n一个docker-compose.yml看起来像这样：\n\nversion: "3.9"  # optional since v1.27.0\nservices:\n  web:\n    build: .\n    ports:\n      - "5000:5000"\n    volumes:\n      - .:/code\n      - logvolume01:/var/log\n    links:\n      - redis\n  redis:\n    image: redis\nvolumes:\n  logvolume01: {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 安装\n\n1、下载\n\n官网：\n\nsudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose\n\n\n1\n\n\n加速下载：https://gitmirror.com/\n\nsudo curl -L "https://hub.gitmirror.com/https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose\n\n\n1\n\n\n2、授权\n\nsudo chmod +x /usr/local/bin/docker-compose\n\n\n1\n\n\n\n# 简单上手\n\n官方文档\n\nhttps://docs.docker.com/compose/gettingstarted/\n\n构建一个在 Docker Compose 上运行的简单 Python Web 应用程序。该应用程序使用 Flask 框架并在 Redis 中维护一个命中计数器。\n\n第1 步：设置\n\n 1. 为项目创建一个目录：\n    \n    mkdir composetest\n    cd composetest\n    \n    \n    1\n    2\n    \n\n 2. 创建app.py\n    \n    import time\n    \n    import redis\n    from flask import Flask\n    \n    app = Flask(__name__)\n    cache = redis.Redis(host=\'redis\', port=6379)\n    \n    def get_hit_count():\n        retries = 5\n        while True:\n            try:\n                return cache.incr(\'hits\')\n            except redis.exceptions.ConnectionError as exc:\n                if retries == 0:\n                    raise exc\n                retries -= 1\n                time.sleep(0.5)\n    \n    @app.route(\'/\')\n    def hello():\n        count = get_hit_count()\n        return \'Hello World! I have been seen {} times.\\n\'.format(count)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    \n\n 3. 在项目目录中创建 requirements.txt\n\nflask\nredis\n\n\n1\n2\n\n\n第 2 步：创建 Dockerfile\n\n项目目录中，创建 Dockerfile\n\n# syntax=docker/dockerfile:1\nFROM python:3.7-alpine\nWORKDIR /code\nENV FLASK_APP=app.py\nENV FLASK_RUN_HOST=0.0.0.0\nRUN apk add --no-cache gcc musl-dev linux-headers\nCOPY requirements.txt requirements.txt\nRUN pip install -r requirements.txt\nEXPOSE 5000\nCOPY . .\nCMD ["flask", "run"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n第 3 步：在 Compose 文件中定义服务\n\n项目目录中创建 docker-compose.yml\n\nversion: "3.9"\nservices:\n  web:\n    build: .\n    ports:\n      - "5000:5000"\n  redis:\n    image: "redis:alpine"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第 4 步：使用 Compose 构建并运行您的应用程序\n\n在项目目录中运行 docker-compose up\n\n[root@VM-0-6-centos composetest]# docker-compose up\n\n\n1\n\n\n如果要后台运行\n\n docker-compose up -d\n\n\n1\n\n\n测试：\n\n[root@VM-0-6-centos ~]# curl localhost:5000\nHello World! I have been seen 1 times.\n[root@VM-0-6-centos ~]# curl localhost:5000\nHello World! I have been seen 2 times.\n[root@VM-0-6-centos ~]# curl localhost:5000\nHello World! I have been seen 3 times.\n\n\n1\n2\n3\n4\n5\n6\n\n * 名字规则\n\n\n\n默认的服务名：文件名_服务名 _ num\n\n * 可以看见多了个网络\n\n[root@VM-0-6-centos ~]# docker network ls\nNETWORK ID     NAME                  DRIVER    SCOPE\n4b873066daf7   bridge                bridge    local\nd87efab51b47   composetest_default   bridge    local\n86da632adad6   elastic               bridge    local\n64b606f257e7   host                  host      local\n34ab4fdb73c0   none                  null      local\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n项目中的内容都在同个网络下。\n\n其他为演示 Compose 量身定制的示例\n\n这些示例专门针对 Docker Compose：\n\n * 快速入门：Compose 和 Django - 展示了如何使用 Docker Compose 来设置和运行一个简单的 Django/PostgreSQL 应用程序。\n * 快速入门：Compose 和 Rails - 展示了如何使用 Docker Compose 来设置和运行 Rails/PostgreSQL 应用程序。\n * 快速入门：Compose 和 WordPress - 展示了如何使用 Docker Compose 在具有 Docker 容器的隔离环境中设置和运行 WordPress。\n\n\n# yaml 规则\n\n官方文档\n\nhttps://docs.docker.com/compose/compose-file/\n\n# 3层！\nversion: \'\' # 版本\nservices: # 服务\n    服务1: web\n    # 服务配置\n    images\n    build\n    network\n    \n    服务2: redis\n    ....\n    服务3: redis\n    ....\n\n# 其他配置 网络/卷、全局规则\nvolumes:\nnetworks:\nconfigs:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java测试发布\n\n以上实例是用 python 写的，我们写一个 java 版本的测试下\n\n\n\n1、编写java代码\n\n创建一个 springboot demo\n\n@RestController\npublic class HelloController {\n\n    @Autowired\n    StringRedisTemplate redisTemplate;\n\n    @GetMapping("/hello")\n    public String hello(){\n        Long views = redisTemplate.opsForValue().increment("views");\n        return "hello world! views:"+ views;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n2、添加配置\n\n * 编写 application.properties 文件\n\nserver.port=8080\nspring.redis.host=redis\n\n\n1\n2\n\n * 编写 Docker 文件\n\nFROM java:8\n\nCOPY *.jar /app.jar\n\nCMD ["--server.port=8080"]\n\nEXPOSE 8080\n\nENTRYPOINT ["java","-jar","/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 编写 docker-compose.yml 文件\n\nversion: "3.9"\nservices:\n  zhiyuanapp:\n    build: .\n    image: zhiyuanapp\n    depends_on:\n      - redis\n    ports:\n      - "8080:8080"\n\n  redis:\n    image: "library/redis:alpine"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n3、上传并构建\n\n把 jar包 、Docker、docker-compose 三个文件上传到一个目录下\n\n并在此目录下构建：\n\n[root@VM-0-6-centos zhiyuanapp]# docker-compose up\n\n\n1\n\n\n4、测试：\n\n[root@VM-0-6-centos ~]# curl localhost:8080/hello\nhello world! views:1\n[root@VM-0-6-centos ~]# curl localhost:8080/hello\nhello world! views:2\n[root@VM-0-6-centos ~]# curl localhost:8080/hello\nhello world! views:3\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:' * 简介\n * 安装\n * 简单上手\n * yaml 规则\n * java测试发布\n\n\n# 简介\n\n官方介绍\n\nhttps://docs.docker.com/compose/\n\ncompose 是一个用于定义和运行多容器 docker 应用程序的工具。借助 compose，您可以使用 yaml 文件来配置应用程序的服务。然后，使用单个命令，从配置中创建并启动所有服务。要了解有关 compose 的所有功能的更多信息，请参阅功能列表。\n\ncompose 适用于所有环境：生产、登台、开发、测试以及 ci 工作流。您可以在common use cases 中了解有关每个案例的更多信息。\n\n使用 compose 基本上是一个三步过程：\n\n 1. 使用 定义您的应用程序的环境，dockerfile以便它可以在任何地方复制。\n 2. 定义组成您的应用程序的服务，docker-compose.yml 以便它们可以在隔离的环境中一起运行。\n 3. 运行 docker compose up 和 docker compose command 启动并运行你的整个应用程序。您也可以docker-compose up使用 docker-compose 二进制文件运行。\n\n可以用 docker compose 来轻松高效的管理容器。定义运行多个容器。\n\n一个docker-compose.yml看起来像这样：\n\nversion: "3.9"  # optional since v1.27.0\nservices:\n  web:\n    build: .\n    ports:\n      - "5000:5000"\n    volumes:\n      - .:/code\n      - logvolume01:/var/log\n    links:\n      - redis\n  redis:\n    image: redis\nvolumes:\n  logvolume01: {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 安装\n\n1、下载\n\n官网：\n\nsudo curl -l "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose\n\n\n1\n\n\n加速下载：https://gitmirror.com/\n\nsudo curl -l "https://hub.gitmirror.com/https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose\n\n\n1\n\n\n2、授权\n\nsudo chmod +x /usr/local/bin/docker-compose\n\n\n1\n\n\n\n# 简单上手\n\n官方文档\n\nhttps://docs.docker.com/compose/gettingstarted/\n\n构建一个在 docker compose 上运行的简单 python web 应用程序。该应用程序使用 flask 框架并在 redis 中维护一个命中计数器。\n\n第1 步：设置\n\n 1. 为项目创建一个目录：\n    \n    mkdir composetest\n    cd composetest\n    \n    \n    1\n    2\n    \n\n 2. 创建app.py\n    \n    import time\n    \n    import redis\n    from flask import flask\n    \n    app = flask(__name__)\n    cache = redis.redis(host=\'redis\', port=6379)\n    \n    def get_hit_count():\n        retries = 5\n        while true:\n            try:\n                return cache.incr(\'hits\')\n            except redis.exceptions.connectionerror as exc:\n                if retries == 0:\n                    raise exc\n                retries -= 1\n                time.sleep(0.5)\n    \n    @app.route(\'/\')\n    def hello():\n        count = get_hit_count()\n        return \'hello world! i have been seen {} times.\\n\'.format(count)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    \n\n 3. 在项目目录中创建 requirements.txt\n\nflask\nredis\n\n\n1\n2\n\n\n第 2 步：创建 dockerfile\n\n项目目录中，创建 dockerfile\n\n# syntax=docker/dockerfile:1\nfrom python:3.7-alpine\nworkdir /code\nenv flask_app=app.py\nenv flask_run_host=0.0.0.0\nrun apk add --no-cache gcc musl-dev linux-headers\ncopy requirements.txt requirements.txt\nrun pip install -r requirements.txt\nexpose 5000\ncopy . .\ncmd ["flask", "run"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n第 3 步：在 compose 文件中定义服务\n\n项目目录中创建 docker-compose.yml\n\nversion: "3.9"\nservices:\n  web:\n    build: .\n    ports:\n      - "5000:5000"\n  redis:\n    image: "redis:alpine"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第 4 步：使用 compose 构建并运行您的应用程序\n\n在项目目录中运行 docker-compose up\n\n[root@vm-0-6-centos composetest]# docker-compose up\n\n\n1\n\n\n如果要后台运行\n\n docker-compose up -d\n\n\n1\n\n\n测试：\n\n[root@vm-0-6-centos ~]# curl localhost:5000\nhello world! i have been seen 1 times.\n[root@vm-0-6-centos ~]# curl localhost:5000\nhello world! i have been seen 2 times.\n[root@vm-0-6-centos ~]# curl localhost:5000\nhello world! i have been seen 3 times.\n\n\n1\n2\n3\n4\n5\n6\n\n * 名字规则\n\n\n\n默认的服务名：文件名_服务名 _ num\n\n * 可以看见多了个网络\n\n[root@vm-0-6-centos ~]# docker network ls\nnetwork id     name                  driver    scope\n4b873066daf7   bridge                bridge    local\nd87efab51b47   composetest_default   bridge    local\n86da632adad6   elastic               bridge    local\n64b606f257e7   host                  host      local\n34ab4fdb73c0   none                  null      local\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n项目中的内容都在同个网络下。\n\n其他为演示 compose 量身定制的示例\n\n这些示例专门针对 docker compose：\n\n * 快速入门：compose 和 django - 展示了如何使用 docker compose 来设置和运行一个简单的 django/postgresql 应用程序。\n * 快速入门：compose 和 rails - 展示了如何使用 docker compose 来设置和运行 rails/postgresql 应用程序。\n * 快速入门：compose 和 wordpress - 展示了如何使用 docker compose 在具有 docker 容器的隔离环境中设置和运行 wordpress。\n\n\n# yaml 规则\n\n官方文档\n\nhttps://docs.docker.com/compose/compose-file/\n\n# 3层！\nversion: \'\' # 版本\nservices: # 服务\n    服务1: web\n    # 服务配置\n    images\n    build\n    network\n    \n    服务2: redis\n    ....\n    服务3: redis\n    ....\n\n# 其他配置 网络/卷、全局规则\nvolumes:\nnetworks:\nconfigs:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# java测试发布\n\n以上实例是用 python 写的，我们写一个 java 版本的测试下\n\n\n\n1、编写java代码\n\n创建一个 springboot demo\n\n@restcontroller\npublic class hellocontroller {\n\n    @autowired\n    stringredistemplate redistemplate;\n\n    @getmapping("/hello")\n    public string hello(){\n        long views = redistemplate.opsforvalue().increment("views");\n        return "hello world! views:"+ views;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n2、添加配置\n\n * 编写 application.properties 文件\n\nserver.port=8080\nspring.redis.host=redis\n\n\n1\n2\n\n * 编写 docker 文件\n\nfrom java:8\n\ncopy *.jar /app.jar\n\ncmd ["--server.port=8080"]\n\nexpose 8080\n\nentrypoint ["java","-jar","/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 编写 docker-compose.yml 文件\n\nversion: "3.9"\nservices:\n  zhiyuanapp:\n    build: .\n    image: zhiyuanapp\n    depends_on:\n      - redis\n    ports:\n      - "8080:8080"\n\n  redis:\n    image: "library/redis:alpine"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n3、上传并构建\n\n把 jar包 、docker、docker-compose 三个文件上传到一个目录下\n\n并在此目录下构建：\n\n[root@vm-0-6-centos zhiyuanapp]# docker-compose up\n\n\n1\n\n\n4、测试：\n\n[root@vm-0-6-centos ~]# curl localhost:8080/hello\nhello world! views:1\n[root@vm-0-6-centos ~]# curl localhost:8080/hello\nhello world! views:2\n[root@vm-0-6-centos ~]# curl localhost:8080/hello\nhello world! views:3\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2023/12/24, 7:12:00",lastUpdatedTimestamp:1703403105e3},{title:"Jenkins - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.工具部署/30.Jenkins",imgUrl:"/img/web.png",description:"Jenkins 目录页"}},title:"Jenkins - 知识体系",permalink:"/jenkins",article:!1,comment:!1,editLink:!1,date:"2021-09-15T15:09:34.000Z"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/30.Jenkins/01.Jenkins%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5.html",relativePath:"05.工具部署/30.Jenkins/01.Jenkins - 目录页.md",key:"v-21390089",path:"/jenkins/",headers:[{level:2,title:"我为什么用Jenkins？",slug:"我为什么用jenkins",normalizedTitle:"我为什么用jenkins？",charIndex:2}],headersStr:"我为什么用Jenkins？",content:"# 我为什么用Jenkins？\n\n和同学写个网站，他负责前端（vue），我负责后端（springboot单体项目）\n\n后端写完，手动打成 jar 包，然后部署到服务器，这些重复手动工作大大的消耗了时间。\n\n于是就用到了 Jenkins ，配置好后，只需要提交代码到 Gitee ，就可以自动构建部署上线，不需要之前的手动重复操作。\n\n> 具体操作教程请看下文：从零开始用Jenkins自动构建部署SpringBoot项目\n\n后续可能完善这个系列的笔记",normalizedContent:"# 我为什么用jenkins？\n\n和同学写个网站，他负责前端（vue），我负责后端（springboot单体项目）\n\n后端写完，手动打成 jar 包，然后部署到服务器，这些重复手动工作大大的消耗了时间。\n\n于是就用到了 jenkins ，配置好后，只需要提交代码到 gitee ，就可以自动构建部署上线，不需要之前的手动重复操作。\n\n> 具体操作教程请看下文：从零开始用jenkins自动构建部署springboot项目\n\n后续可能完善这个系列的笔记",charsets:{cjk:!0},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757171752e3},{title:"Jenkins - 介绍",frontmatter:{title:"Jenkins - 介绍",date:"2021-09-15T14:12:14.000Z",permalink:"/pages/3dedc8/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/30.Jenkins/02.Jenkins%20-%20%E4%BB%8B%E7%BB%8D.html",relativePath:"05.工具部署/30.Jenkins/02.Jenkins - 介绍.md",key:"v-5233b41b",path:"/pages/3dedc8/",headers:[{level:2,title:"Jenkins是什么？",slug:"jenkins是什么",normalizedTitle:"jenkins是什么？",charIndex:2},{level:2,title:"相关概念介绍",slug:"相关概念介绍",normalizedTitle:"相关概念介绍",charIndex:577},{level:3,title:"软件开发生命周期",slug:"软件开发生命周期",normalizedTitle:"软件开发生命周期",charIndex:588},{level:3,title:"软件开发瀑布模型",slug:"软件开发瀑布模型",normalizedTitle:"软件开发瀑布模型",charIndex:1047},{level:3,title:"软件的敏捷开发",slug:"软件的敏捷开发",normalizedTitle:"软件的敏捷开发",charIndex:1397},{level:3,title:"什么是持续集成",slug:"什么是持续集成",normalizedTitle:"什么是持续集成",charIndex:2439},{level:3,title:"持续集成的组成要素",slug:"持续集成的组成要素",normalizedTitle:"持续集成的组成要素",charIndex:3198},{level:3,title:"持续集成的好处",slug:"持续集成的好处",normalizedTitle:"持续集成的好处",charIndex:3377},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3519}],headersStr:"Jenkins是什么？ 相关概念介绍 软件开发生命周期 软件开发瀑布模型 软件的敏捷开发 什么是持续集成 持续集成的组成要素 持续集成的好处 参考资料",content:'# Jenkins是什么？\n\nJenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。\n\n官网： http://jenkins-ci.org/。\n\nJenkins的特征：\n\n * 开源的Java语言开发持续集成工具，支持持续集成，持续部署。\n * 易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可方便web界面配置管理。\n * 消息通知及测试报告：集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生 成JUnit/TestNG测试报告。\n * 分布式构建：支持Jenkins能够让多台计算机一起构建/测试\n * 文件识别：Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。\n * 丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven， docker等。\n\n\n# 相关概念介绍\n\n\n# 软件开发生命周期\n\n\n\n * 需求分析\n   \n   这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。 还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。\n\n * 设计\n   \n   第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目 计划。计划可以使用图表，布局设计或者文者的方式呈现。\n\n * 实现\n   \n   第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进 行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。\n\n * 测试\n   \n   测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等\n\n * 进化\n   \n   最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修 改，bug修复，功能增加等。\n\n\n# 软件开发瀑布模型\n\n瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开发， 但是已经不适合现在的开发了。\n\n\n\n优势：\n\n * 简单易用和理解\n * 当前一阶段完成后，您只需要 去关注后续阶段。\n * 为项目提供了按阶段划分的检 查节点\n\n劣势：\n\n * 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地 增加了工作量。\n * 由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险。\n * 瀑布模型的突出缺点是不适应用户需求的变化。\n\n\n# 软件的敏捷开发\n\n什么是敏捷开发？\n\n敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发 （Incremental Development） 。\n\n> 何为迭代开发？\n\n对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次"大开发"；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次"大开发"变成多次"小开发"，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。\n\n举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。\n\n> 何为增量开发？\n\n软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。\n\n举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼......每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶......\n\n> 敏捷开发如何迭代？\n\n虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。\n\n\n\n> 敏捷开发有什么好处？\n\n * 早期交付\n\n敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的"瀑布开发模式"，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。\n\n * 降低风险\n\n敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？\n\n\n# 什么是持续集成\n\n持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。\n\n通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归功于持续集成。\n\n持续集成的流程\n\n\n\n根据持续集成的设计，代码从提交到生产，整个过程有以下几步。\n\n * 提交\n   \n   流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。\n\n * 测试（第一轮）\n   \n   代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试\n\n * 构建\n   \n   通过第一轮测试，代码就可以合并进主干，就算可以交付了。\n   \n   交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。\n\n * 测试（第二轮）\n   \n   构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。\n\n * 部署\n   \n   过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。\n\n * 回滚\n   \n   一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录。\n\n\n# 持续集成的组成要素\n\n * 一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的， 无需人工干预\n * 一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般 使用SVN或Git\n * 一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。\n\n\n\n\n# 持续集成的好处\n\n1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；\n\n2、对系统健康持续检查，减少发布风险带来的问题；\n\n3、减少重复性工作；\n\n4、持续部署，提供可部署单元包；\n\n5、持续交付可供使用的版本；\n\n6、增强团队信心；\n\n\n# 参考资料\n\n * https://www.jianshu.com/p/5f671aca2b5a\n * https://www.bilibili.com/video/BV1kJ411p7mV',normalizedContent:'# jenkins是什么？\n\njenkins是一个开源的、提供友好操作界面的持续集成(ci)工具，起源于hudson（hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。jenkins用java语言编写，可在tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(scm)、构建工具结合使用。常用的版本控制工具有svn、git，构建工具有maven、ant、gradle。\n\n官网： http://jenkins-ci.org/。\n\njenkins的特征：\n\n * 开源的java语言开发持续集成工具，支持持续集成，持续部署。\n * 易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可方便web界面配置管理。\n * 消息通知及测试报告：集成rss/e-mail通过rss发布构建结果或当构建完成时通过e-mail通知，生 成junit/testng测试报告。\n * 分布式构建：支持jenkins能够让多台计算机一起构建/测试\n * 文件识别：jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。\n * 丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven， docker等。\n\n\n# 相关概念介绍\n\n\n# 软件开发生命周期\n\n\n\n * 需求分析\n   \n   这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。 还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。\n\n * 设计\n   \n   第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目 计划。计划可以使用图表，布局设计或者文者的方式呈现。\n\n * 实现\n   \n   第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进 行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。\n\n * 测试\n   \n   测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等\n\n * 进化\n   \n   最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修 改，bug修复，功能增加等。\n\n\n# 软件开发瀑布模型\n\n瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开发， 但是已经不适合现在的开发了。\n\n\n\n优势：\n\n * 简单易用和理解\n * 当前一阶段完成后，您只需要 去关注后续阶段。\n * 为项目提供了按阶段划分的检 查节点\n\n劣势：\n\n * 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地 增加了工作量。\n * 由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险。\n * 瀑布模型的突出缺点是不适应用户需求的变化。\n\n\n# 软件的敏捷开发\n\n什么是敏捷开发？\n\n敏捷开发（agile development） 的核心是迭代开发（iterative development） 与 增量开发 （incremental development） 。\n\n> 何为迭代开发？\n\n对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次"大开发"；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次"大开发"变成多次"小开发"，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。\n\n举例来说，spacex 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 falcon 9，九年中发射了70次。最后，才开发 falcon 重型火箭。如果 spacex 不采用迭代开发，它可能直到现在还无法上天。\n\n> 何为增量开发？\n\n软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。\n\n举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼......每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶......\n\n> 敏捷开发如何迭代？\n\n虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。\n\n\n\n> 敏捷开发有什么好处？\n\n * 早期交付\n\n敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的"瀑布开发模式"，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。\n\n * 降低风险\n\n敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？\n\n\n# 什么是持续集成\n\n持续集成（ continuous integration ， 简称 ci ）指的是，频繁地（一天多次）将代码集成到主干\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。\n\n通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归功于持续集成。\n\n持续集成的流程\n\n\n\n根据持续集成的设计，代码从提交到生产，整个过程有以下几步。\n\n * 提交\n   \n   流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。\n\n * 测试（第一轮）\n   \n   代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试\n\n * 构建\n   \n   通过第一轮测试，代码就可以合并进主干，就算可以交付了。\n   \n   交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、js脚本、图片）等等。\n\n * 测试（第二轮）\n   \n   构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。\n\n * 部署\n   \n   过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。\n\n * 回滚\n   \n   一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录。\n\n\n# 持续集成的组成要素\n\n * 一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的， 无需人工干预\n * 一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般 使用svn或git\n * 一个持续集成服务器， jenkins 就是一个配置简单和使用方便的持续集成服务器。\n\n\n\n\n# 持续集成的好处\n\n1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；\n\n2、对系统健康持续检查，减少发布风险带来的问题；\n\n3、减少重复性工作；\n\n4、持续部署，提供可部署单元包；\n\n5、持续交付可供使用的版本；\n\n6、增强团队信心；\n\n\n# 参考资料\n\n * https://www.jianshu.com/p/5f671aca2b5a\n * https://www.bilibili.com/video/bv1kj411p7mv',charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"关于 - 我",frontmatter:{title:"关于 - 我",date:"2021-05-16T22:53:19.000Z",permalink:"/pages/038c37/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E%20-%20%E6%88%91/01.%E5%85%B3%E4%BA%8E%20-%20%E6%88%91.html",relativePath:"10.关于/01.关于 - 我/01.关于 - 我.md",key:"v-e25da80e",path:"/pages/038c37/",headers:[{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:3},{level:2,title:"网站初衷",slug:"网站初衷",normalizedTitle:"网站初衷",charIndex:10},{level:2,title:"学习资料",slug:"学习资料",normalizedTitle:"学习资料",charIndex:18}],headersStr:"关于我 网站初衷 学习资料",content:" * 关于我\n * 网站初衷\n * 学习资料\n\n\n# 关于我\n\n2024年毕业，就职于某电商SaaS ERP公司。\n\n\n# 网站初衷\n\n * 构建自己的知识体系\n\n * 监督自己的学习\n\n * 帮助其他初学者\n   \n   笔记内容不深，希望能帮到一些初学者\n\n推荐阅读：如何构建自己的笔记系统？\n\n\n# 学习资料\n\n本人学习 java 也没多长时间，还没硬实力写出完好的自己的知识体系。\n\n大部分 java 笔记借助于狂神和尚硅谷课堂笔记，在文章结尾或开头有视频教程链接地址传送\n\n笔记加了点自己的理解，和其他站点的讲解。\n\n内容难免会有问题，如有任何问题，请各位大佬斧正！\n\n在本项目地址创建 “issues”",normalizedContent:" * 关于我\n * 网站初衷\n * 学习资料\n\n\n# 关于我\n\n2024年毕业，就职于某电商saas erp公司。\n\n\n# 网站初衷\n\n * 构建自己的知识体系\n\n * 监督自己的学习\n\n * 帮助其他初学者\n   \n   笔记内容不深，希望能帮到一些初学者\n\n推荐阅读：如何构建自己的笔记系统？\n\n\n# 学习资料\n\n本人学习 java 也没多长时间，还没硬实力写出完好的自己的知识体系。\n\n大部分 java 笔记借助于狂神和尚硅谷课堂笔记，在文章结尾或开头有视频教程链接地址传送\n\n笔记加了点自己的理解，和其他站点的讲解。\n\n内容难免会有问题，如有任何问题，请各位大佬斧正！\n\n在本项目地址创建 “issues”",charsets:{cjk:!0},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757170909e3},{title:"从零开始用Jenkins自动构建部署SpringBoot项目",frontmatter:{title:"从零开始用Jenkins自动构建部署SpringBoot项目",date:"2021-09-15T14:12:32.000Z",permalink:"/pages/ec9790/"},regularPath:"/05.%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2/30.Jenkins/04.%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%94%A8Jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE.html",relativePath:"05.工具部署/30.Jenkins/04.从零开始用Jenkins自动构建部署SpringBoot项目.md",key:"v-6f12cff7",path:"/pages/ec9790/",headers:[{level:2,title:"前提条件",slug:"前提条件",normalizedTitle:"前提条件",charIndex:37},{level:2,title:"安装Jenkins",slug:"安装jenkins",normalizedTitle:"安装jenkins",charIndex:210},{level:2,title:"插件安装",slug:"插件安装",normalizedTitle:"插件安装",charIndex:1956},{level:2,title:"安装jdk",slug:"安装jdk",normalizedTitle:"安装jdk",charIndex:2040},{level:2,title:"安装maven",slug:"安装maven",normalizedTitle:"安装maven",charIndex:2169},{level:2,title:"配置ssh",slug:"配置ssh",normalizedTitle:"配置ssh",charIndex:2223},{level:2,title:"构建项目",slug:"构建项目",normalizedTitle:"构建项目",charIndex:2294},{level:2,title:"构建后自动部署",slug:"构建后自动部署",normalizedTitle:"构建后自动部署",charIndex:2979},{level:2,title:"Git提交后自动构建",slug:"git提交后自动构建",normalizedTitle:"git提交后自动构建",charIndex:3155}],headersStr:"前提条件 安装Jenkins 插件安装 安装jdk 安装maven 配置ssh 构建项目 构建后自动部署 Git提交后自动构建",content:"# 从零开始用Jenkins自动构建部署SpringBoot项目\n\n\n# 前提条件\n\n * 一台服务器\n   \n   建议配置2h4g以上（1h2g的属实有点低了）\n\n * sspringboot项目手动用maven打包，且jar包可正常运行\n   \n   如果你的是多模块项目（如图），需要配置好打包，否则启动失败\n   \n   \n   \n   就像这样的项目，可浏览文章：SpringBoot多模块打包方式\n\n\n# 安装Jenkins\n\n安装教程可看视频：https://www.bilibili.com/video/BV1wA411c7aS\n\n1、安装\n\ndocker pull jenkins/jenkins:lts\n\n\n1\n\n\n2、创建目录\n\n[root@localhost data]# mkdir jenkins_home\n[root@localhost data]# ls\ndocker  jenkins_home\n\n\n1\n2\n3\n\n\n3、启动\n\ndocker run -di --name=jenkins -p 8080:8080 -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:lts\n\n\n1\n\n\n启动失败：\n\n[root@localhost data]# docker logs  d6b5baf89d6b\ntouch: cannot touch '/var/jenkins_home/copy_reference_file.log': Permission denied\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\ntouch: cannot touch '/var/jenkins_home/copy_reference_file.log': Permission denied\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\n\n\n1\n2\n3\n4\n5\n\n\n权限：\n\nchown -R 1000 /data/jenkins_home\n\n\n1\n\n\n再重新启动，等启动工作完毕后\n\n\n\n查看容器日志：\n\ndocker logs jenkins\n\n\n1\n\n\n\n\n箭头所指就是密码\n\n> 方法二：\n\n[root@localhost data]# cd jenkins_home/secrets/\n[root@localhost secrets]# ll\n总用量 20\ndrwxr-xr-x 2 www www  29 9月  14 18:45 filepath-filters.d\n-rw-r----- 1 www www  33 9月  14 18:45 initialAdminPassword\n-rw-r--r-- 1 www www  32 9月  14 18:45 jenkins.model.Jenkins.crumbSalt\n-rw-r--r-- 1 www www 256 9月  14 18:45 master.key\n-rw-r--r-- 1 www www 272 9月  14 18:45 org.jenkinsci.main.modules.instance_identity.InstanceIdentity.KEY\n-rw-r--r-- 1 www www   5 9月  14 18:45 slave-to-master-security-kill-switch\ndrwxr-xr-x 2 www www  26 9月  14 18:45 whitelisted-callables.d\n[root@localhost secrets]# cat initialAdminPassword\n730edbb8adcd4ae7b58f14ac3ccd001d\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nJenkins修改初始密码:https://www.pianshen.com/article/7582333512/\n\n5、进入页面后，选择推荐的插件\n\n\n\n全部安装成功后：\n\n\n\n有一些会安装失败（我用的服务器，用虚拟机的由于有墙可能访问不到github）\n\n\n\n点击重试后\n\n\n\n大部分都装上了，有几个可能会装不上，到时候可以手动安装，先点确定\n\n然后创建用户\n\n\n\n下一步，URL为，jenkins的IP:端口\n\n\n\n\n# 插件安装\n\n\n\n搜索插件 ssh（红色代表与jenkins版本不匹配）\n\n\n\n安装失败重新安装即可！\n\n第一行表示之前的安装的日志，等图标变成蓝色代表安装成功\n\n\n# 安装jdk\n\n全局工具配置\n\n\n\n点新增JDK，选择版本，登录下oracle账号：2696671285@qq.com Oracle123\n\n账号为up主提供的：https://www.bilibili.com/video/BV1wA411c7aS\n\n\n\n之后安装maven（如果你的项目不是maven则安装别的插件）\n\n\n# 安装maven\n\n点击保存\n\n\n\n\n# 配置ssh\n\n\n\n搜索 ssh\n\n\n\n添加ssh的ip和端口 ， 点击添加\n\n\n\n添加服务器的账号和密码\n\n\n\n检测连接是否成功\n\n\n\n\n# 构建项目\n\n1、新建项目\n\n\n\n2、输入任务名称，选择maven\n\n没有这个项目则下载maven插件（百度即可）\n\nMaven Integration plugin\n\n\n\n3、设置源码管理\n\n\n\n记得添加你的gitee账号密码的凭据\n\n4、设置Maven\n\n\n\n设置\n\nclean package\n\n\n1\n\n\n\n\n然后我们先构建下，等待结束\n\n\n\n但是maven下载依赖速度太慢，我们可以手动关闭构建，把镜像配置为阿里云镜像\n\n5、修改maven配置\n\n配置文件在你的jenkins数据目录下，例如我的就是：\n\n/data/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation\n\n按照原先方法修改配置文件，把maven远程仓库地址改成阿里云的，这步就不用详细说了吧。\n\n6、重新构建\n\n点击 立即构建\n\n这次下载速度就快了，构建好的jar包目录在：\n\n/data/jenkins_home/workspace/jekins-test/service/target\n\njekins-test：是任务名称（我创建任务时，少打了个n）\n\n选中查看控制台输出\n\n\n\n根据输出就能看到jar的生成目录\n\n\n\n然后我们启动看看是否正常\n\ncd /data/jenkins_home/workspace/jekins-test/service/target\nnohup java -jar service-0.0.1-SNAPSHOT.jar > /data/journalism/logs.txt &\n\n\n1\n2\n\n\n\n# 构建后自动部署\n\n8160是我的springboot服务端口\n\nnetstat  -nlp|grep 8160\n\n\n1\n\n\n强制杀死某个端口进程命令，关闭jar包\n\nsudo fuser -k -n tcp 8160\n\n\n1\n\n\n请先把刚才开启的jar包服务关掉\n\n设置构建环境配置，构建后操作（构建前就不用设置，测试过，填了就出现错误）\n\n\n\n\n# Git提交后自动构建\n\n1、配置URL构建触发器\n\n令牌随便输，URL格式就是下面那个英文说明，根据自己的修改\n\n\n\n2、配置Gitee的WebHooks\n\n我这里用的Gitee（学校网进GitHub很不稳定，就选择Gitee了）\n\nGitee项目里设置URL和秘钥\n\n为了安全自己写个服务用来访问触发Jenkins构建的URL，不直接输入之前的URL\n\n例如：我用的php，代码在下方\n\n\n\n3、添加用户token\n\n\n\n生成，保存token信息\n\n\n\n修改url，例如我的，根据自己规则设置\n\nhttp://用户名:token@ip:端口/job/jekins-test/build?token=设置的token\n\n详情访问：通过URL触发Jenkins构建\n\nphp代码如下（修改URL和秘钥）：\n\n<?php\n\n//接收头信息\n function em_getallheaders()\n{\n   foreach ($_SERVER as $name => $value)\n   {\n       if (substr($name, 0, 5) == 'HTTP_')\n       {\n           $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value;\n       }\n   }\n   return $headers;\n}\n\n//发送请求\nfunction getSslPage($url) {\n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($ch, CURLOPT_HEADER, false);\n    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_REFERER, $url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);\n    $result = curl_exec($ch);\n    curl_close($ch);\n    return $result;\n}\n\n$url = \"你的URL\";\n\n$headers = em_getallheaders();\n//是否等于Gitee设置的秘钥\nif($headers['X-Gitee-Token'] == \"你设置的秘钥\"){\n    //调用\n    getSslPage($url);\n    echo \"ok\";\n}else{\n    echo \"no\";\n}\n\nprint_r($headers['X-Gitee-Token']) ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n4、完成测试\n\n更改代码，push到Gitee\n\n\n\nGitee请求成功\n\n\n\njenkins构建成功\n\n",normalizedContent:"# 从零开始用jenkins自动构建部署springboot项目\n\n\n# 前提条件\n\n * 一台服务器\n   \n   建议配置2h4g以上（1h2g的属实有点低了）\n\n * sspringboot项目手动用maven打包，且jar包可正常运行\n   \n   如果你的是多模块项目（如图），需要配置好打包，否则启动失败\n   \n   \n   \n   就像这样的项目，可浏览文章：springboot多模块打包方式\n\n\n# 安装jenkins\n\n安装教程可看视频：https://www.bilibili.com/video/bv1wa411c7as\n\n1、安装\n\ndocker pull jenkins/jenkins:lts\n\n\n1\n\n\n2、创建目录\n\n[root@localhost data]# mkdir jenkins_home\n[root@localhost data]# ls\ndocker  jenkins_home\n\n\n1\n2\n3\n\n\n3、启动\n\ndocker run -di --name=jenkins -p 8080:8080 -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:lts\n\n\n1\n\n\n启动失败：\n\n[root@localhost data]# docker logs  d6b5baf89d6b\ntouch: cannot touch '/var/jenkins_home/copy_reference_file.log': permission denied\ncan not write to /var/jenkins_home/copy_reference_file.log. wrong volume permissions?\ntouch: cannot touch '/var/jenkins_home/copy_reference_file.log': permission denied\ncan not write to /var/jenkins_home/copy_reference_file.log. wrong volume permissions?\n\n\n1\n2\n3\n4\n5\n\n\n权限：\n\nchown -r 1000 /data/jenkins_home\n\n\n1\n\n\n再重新启动，等启动工作完毕后\n\n\n\n查看容器日志：\n\ndocker logs jenkins\n\n\n1\n\n\n\n\n箭头所指就是密码\n\n> 方法二：\n\n[root@localhost data]# cd jenkins_home/secrets/\n[root@localhost secrets]# ll\n总用量 20\ndrwxr-xr-x 2 www www  29 9月  14 18:45 filepath-filters.d\n-rw-r----- 1 www www  33 9月  14 18:45 initialadminpassword\n-rw-r--r-- 1 www www  32 9月  14 18:45 jenkins.model.jenkins.crumbsalt\n-rw-r--r-- 1 www www 256 9月  14 18:45 master.key\n-rw-r--r-- 1 www www 272 9月  14 18:45 org.jenkinsci.main.modules.instance_identity.instanceidentity.key\n-rw-r--r-- 1 www www   5 9月  14 18:45 slave-to-master-security-kill-switch\ndrwxr-xr-x 2 www www  26 9月  14 18:45 whitelisted-callables.d\n[root@localhost secrets]# cat initialadminpassword\n730edbb8adcd4ae7b58f14ac3ccd001d\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\njenkins修改初始密码:https://www.pianshen.com/article/7582333512/\n\n5、进入页面后，选择推荐的插件\n\n\n\n全部安装成功后：\n\n\n\n有一些会安装失败（我用的服务器，用虚拟机的由于有墙可能访问不到github）\n\n\n\n点击重试后\n\n\n\n大部分都装上了，有几个可能会装不上，到时候可以手动安装，先点确定\n\n然后创建用户\n\n\n\n下一步，url为，jenkins的ip:端口\n\n\n\n\n# 插件安装\n\n\n\n搜索插件 ssh（红色代表与jenkins版本不匹配）\n\n\n\n安装失败重新安装即可！\n\n第一行表示之前的安装的日志，等图标变成蓝色代表安装成功\n\n\n# 安装jdk\n\n全局工具配置\n\n\n\n点新增jdk，选择版本，登录下oracle账号：2696671285@qq.com oracle123\n\n账号为up主提供的：https://www.bilibili.com/video/bv1wa411c7as\n\n\n\n之后安装maven（如果你的项目不是maven则安装别的插件）\n\n\n# 安装maven\n\n点击保存\n\n\n\n\n# 配置ssh\n\n\n\n搜索 ssh\n\n\n\n添加ssh的ip和端口 ， 点击添加\n\n\n\n添加服务器的账号和密码\n\n\n\n检测连接是否成功\n\n\n\n\n# 构建项目\n\n1、新建项目\n\n\n\n2、输入任务名称，选择maven\n\n没有这个项目则下载maven插件（百度即可）\n\nmaven integration plugin\n\n\n\n3、设置源码管理\n\n\n\n记得添加你的gitee账号密码的凭据\n\n4、设置maven\n\n\n\n设置\n\nclean package\n\n\n1\n\n\n\n\n然后我们先构建下，等待结束\n\n\n\n但是maven下载依赖速度太慢，我们可以手动关闭构建，把镜像配置为阿里云镜像\n\n5、修改maven配置\n\n配置文件在你的jenkins数据目录下，例如我的就是：\n\n/data/jenkins_home/tools/hudson.tasks.maven_maveninstallation\n\n按照原先方法修改配置文件，把maven远程仓库地址改成阿里云的，这步就不用详细说了吧。\n\n6、重新构建\n\n点击 立即构建\n\n这次下载速度就快了，构建好的jar包目录在：\n\n/data/jenkins_home/workspace/jekins-test/service/target\n\njekins-test：是任务名称（我创建任务时，少打了个n）\n\n选中查看控制台输出\n\n\n\n根据输出就能看到jar的生成目录\n\n\n\n然后我们启动看看是否正常\n\ncd /data/jenkins_home/workspace/jekins-test/service/target\nnohup java -jar service-0.0.1-snapshot.jar > /data/journalism/logs.txt &\n\n\n1\n2\n\n\n\n# 构建后自动部署\n\n8160是我的springboot服务端口\n\nnetstat  -nlp|grep 8160\n\n\n1\n\n\n强制杀死某个端口进程命令，关闭jar包\n\nsudo fuser -k -n tcp 8160\n\n\n1\n\n\n请先把刚才开启的jar包服务关掉\n\n设置构建环境配置，构建后操作（构建前就不用设置，测试过，填了就出现错误）\n\n\n\n\n# git提交后自动构建\n\n1、配置url构建触发器\n\n令牌随便输，url格式就是下面那个英文说明，根据自己的修改\n\n\n\n2、配置gitee的webhooks\n\n我这里用的gitee（学校网进github很不稳定，就选择gitee了）\n\ngitee项目里设置url和秘钥\n\n为了安全自己写个服务用来访问触发jenkins构建的url，不直接输入之前的url\n\n例如：我用的php，代码在下方\n\n\n\n3、添加用户token\n\n\n\n生成，保存token信息\n\n\n\n修改url，例如我的，根据自己规则设置\n\nhttp://用户名:token@ip:端口/job/jekins-test/build?token=设置的token\n\n详情访问：通过url触发jenkins构建\n\nphp代码如下（修改url和秘钥）：\n\n<?php\n\n//接收头信息\n function em_getallheaders()\n{\n   foreach ($_server as $name => $value)\n   {\n       if (substr($name, 0, 5) == 'http_')\n       {\n           $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value;\n       }\n   }\n   return $headers;\n}\n\n//发送请求\nfunction getsslpage($url) {\n    $ch = curl_init();\n    curl_setopt($ch, curlopt_ssl_verifypeer, false);\n    curl_setopt($ch, curlopt_header, false);\n    curl_setopt($ch, curlopt_followlocation, true);\n    curl_setopt($ch, curlopt_url, $url);\n    curl_setopt($ch, curlopt_referer, $url);\n    curl_setopt($ch, curlopt_returntransfer, true);\n    $result = curl_exec($ch);\n    curl_close($ch);\n    return $result;\n}\n\n$url = \"你的url\";\n\n$headers = em_getallheaders();\n//是否等于gitee设置的秘钥\nif($headers['x-gitee-token'] == \"你设置的秘钥\"){\n    //调用\n    getsslpage($url);\n    echo \"ok\";\n}else{\n    echo \"no\";\n}\n\nprint_r($headers['x-gitee-token']) ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n4、完成测试\n\n更改代码，push到gitee\n\n\n\ngitee请求成功\n\n\n\njenkins构建成功\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"文档 - 快速上手",frontmatter:{title:"文档 - 快速上手",date:"2021-05-16T22:47:39.000Z",permalink:"/pages/c6c456/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/02.%E6%96%87%E6%A1%A3%20-%20%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html",relativePath:"10.关于/02.关于 - 本站/02.文档 -  快速上手.md",key:"v-8e9c4c14",path:"/pages/c6c456/",headers:[{level:2,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:3},{level:2,title:"快速开始",slug:"快速开始",normalizedTitle:"快速开始",charIndex:9},{level:2,title:"配置信息修改",slug:"配置信息修改",normalizedTitle:"配置信息修改",charIndex:17},{level:2,title:"详情请看",slug:"详情请看",normalizedTitle:"详情请看",charIndex:27}],headersStr:"准备 快速开始 配置信息修改 详情请看",content:" * 准备\n * 快速开始\n * 配置信息修改\n * 详情请看\n\n使用 vuepress 及主题 vdoing ，自动部署在GitHub Pages\n\n纯新手可看 bilibili 的 vuepress 视频教程：https://www.bilibili.com/video/BV17t41177cr\n\n\n# 准备\n\nVuePress 需要 Node.js >= 8.6\n\n首先需要下载 Node.js\n\n 1. 克隆到本地并进入目录\n    \n    git clone https://github.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n    \n    或 gitee 地址：\n    \n    git clone https://gitee.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n\n 2. 安装本地依赖\n    \n    npm install\n    \n    \n    1\n    \n\n 3. 本地测试\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    默认访问链接：http://localhost:8080\n\n\n# 快速开始\n\n使用 markdown 语法编写 md 文件，所有笔记 md 文件放在 docs/ 目录下\n\n例如添加 test 类，并编写 hello.md 文件\n\n 1. 创建目录\n    \n    格式：序号+标题\n    \n    例如：30.test\n\n 2. 添加笔记\n    \n    例如：01.hello.md\n\n 3. 编写内容\n    \n    ## 标题\n    \n    hello world\n    \n    \n    1\n    2\n    3\n    \n\n 4. 测试运行\n    \n    在项目根目录下\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    会自动生成\n    \n    tittle：标题，默认文件名，即 hello\n    \n    permalink：访问链接\n    \n    date：日期，默认文件创建时间\n\n\n# 配置信息修改\n\n一些常用的\n\n目录 docs\\.vuepress 下\n\n * config.js\n   \n   修改 vuepress 和主题一些配置\n\n * config\\nav.js\n   \n   修改首页导航栏\n\n\n# 详情请看\n\n关于 vuepress 的配置：\n\n * vuepress官方文档\n\n * vdoing主题介绍文档",normalizedContent:" * 准备\n * 快速开始\n * 配置信息修改\n * 详情请看\n\n使用 vuepress 及主题 vdoing ，自动部署在github pages\n\n纯新手可看 bilibili 的 vuepress 视频教程：https://www.bilibili.com/video/bv17t41177cr\n\n\n# 准备\n\nvuepress 需要 node.js >= 8.6\n\n首先需要下载 node.js\n\n 1. 克隆到本地并进入目录\n    \n    git clone https://github.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n    \n    或 gitee 地址：\n    \n    git clone https://gitee.com/oddfar/notes.git && cd notes\n    \n    \n    1\n    \n\n 2. 安装本地依赖\n    \n    npm install\n    \n    \n    1\n    \n\n 3. 本地测试\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    默认访问链接：http://localhost:8080\n\n\n# 快速开始\n\n使用 markdown 语法编写 md 文件，所有笔记 md 文件放在 docs/ 目录下\n\n例如添加 test 类，并编写 hello.md 文件\n\n 1. 创建目录\n    \n    格式：序号+标题\n    \n    例如：30.test\n\n 2. 添加笔记\n    \n    例如：01.hello.md\n\n 3. 编写内容\n    \n    ## 标题\n    \n    hello world\n    \n    \n    1\n    2\n    3\n    \n\n 4. 测试运行\n    \n    在项目根目录下\n    \n    npm run dev\n    \n    \n    1\n    \n    \n    会自动生成\n    \n    tittle：标题，默认文件名，即 hello\n    \n    permalink：访问链接\n    \n    date：日期，默认文件创建时间\n\n\n# 配置信息修改\n\n一些常用的\n\n目录 docs\\.vuepress 下\n\n * config.js\n   \n   修改 vuepress 和主题一些配置\n\n * config\\nav.js\n   \n   修改首页导航栏\n\n\n# 详情请看\n\n关于 vuepress 的配置：\n\n * vuepress官方文档\n\n * vdoing主题介绍文档",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"文档 - md文件写作",frontmatter:{title:"文档 - md文件写作",date:"2021-05-30T00:13:42.000Z",permalink:"/pages/2a3030/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/03.%E6%96%87%E6%A1%A3%20-%20md%E6%96%87%E4%BB%B6%E5%86%99%E4%BD%9C.html",relativePath:"10.关于/02.关于 - 本站/03.文档 - md文件写作.md",key:"v-54f3eee1",path:"/pages/2a3030/",headers:[{level:2,title:"推荐写作软件",slug:"推荐写作软件",normalizedTitle:"推荐写作软件",charIndex:2},{level:2,title:"图片要求",slug:"图片要求",normalizedTitle:"图片要求",charIndex:176},{level:2,title:"文件命名约定",slug:"文件命名约定",normalizedTitle:"文件命名约定",charIndex:302},{level:2,title:"级别说明",slug:"级别说明",normalizedTitle:"级别说明",charIndex:602}],headersStr:"推荐写作软件 图片要求 文件命名约定 级别说明",content:"# 推荐写作软件\n\n推荐写 markdown 软件\n\n 1. Typora\n    \n    下载即用\n\n 2. vs code\n    \n    需要下载 markdown 插件\n    \n    里面终端可设置 git bash 终端，方便调试，适合程序员使用\n    \n    设置教程：新版本VS Code 终端设置为git bash\n\n\n# 图片要求\n\n图片地址必须是可在线访问的链接，不能是本地图片\n\n可以用 GitHub+PicGo+jsDelivr 搭建免费图床\n\n如何免费搭建图床，并在markdown中使用教程：https://oddfar.com/archives/91/\n\n\n# 文件命名约定\n\n * 无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md，我们将会按照序号的顺序来决定其在侧边栏当中的顺序。\n * 同一级别目录别内即使只有一个文件或文件夹也要为其加上序号。\n * 文件或文件夹名称中间不能出现多余的点.，如01.我是.名称.md中间出现.将会导致解析错误。\n\n序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15。\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 README.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子中的其他）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录\n   1. 该级别下只能放.md文件。\n   2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\nvdoing主题介绍文档：https://doc.xugaoyi.com/pages/33d574/",normalizedContent:"# 推荐写作软件\n\n推荐写 markdown 软件\n\n 1. typora\n    \n    下载即用\n\n 2. vs code\n    \n    需要下载 markdown 插件\n    \n    里面终端可设置 git bash 终端，方便调试，适合程序员使用\n    \n    设置教程：新版本vs code 终端设置为git bash\n\n\n# 图片要求\n\n图片地址必须是可在线访问的链接，不能是本地图片\n\n可以用 github+picgo+jsdelivr 搭建免费图床\n\n如何免费搭建图床，并在markdown中使用教程：https://oddfar.com/archives/91/\n\n\n# 文件命名约定\n\n * 无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md，我们将会按照序号的顺序来决定其在侧边栏当中的顺序。\n * 同一级别目录别内即使只有一个文件或文件夹也要为其加上序号。\n * 文件或文件夹名称中间不能出现多余的点.，如01.我是.名称.md中间出现.将会导致解析错误。\n\n序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15。\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 readme.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子中的其他）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录\n   1. 该级别下只能放.md文件。\n   2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\nvdoing主题介绍文档：https://doc.xugaoyi.com/pages/33d574/",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"文档 - 部署",frontmatter:{title:"文档 - 部署",date:"2021-05-16T22:53:51.000Z",permalink:"/pages/39f283/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/05.%E6%96%87%E6%A1%A3%20-%20%E9%83%A8%E7%BD%B2.html",relativePath:"10.关于/02.关于 - 本站/05.文档 - 部署.md",key:"v-0436aabe",path:"/pages/39f283/",headers:[{level:2,title:"手动部署",slug:"手动部署",normalizedTitle:"手动部署",charIndex:3},{level:3,title:"GitHub",slug:"github",normalizedTitle:"github",charIndex:13},{level:3,title:"自己服务器",slug:"自己服务器",normalizedTitle:"自己服务器",charIndex:25},{level:2,title:"GitHub 自动部署",slug:"github-自动部署",normalizedTitle:"github 自动部署",charIndex:34},{level:3,title:"生成 Token",slug:"生成-token",normalizedTitle:"生成 token",charIndex:51},{level:3,title:"配置秘钥",slug:"配置秘钥",normalizedTitle:"配置秘钥",charIndex:65},{level:2,title:"自动部署自己服务器",slug:"自动部署自己服务器",normalizedTitle:"自动部署自己服务器",charIndex:73}],headersStr:"手动部署 GitHub 自己服务器 GitHub 自动部署 生成 Token 配置秘钥 自动部署自己服务器",content:" * 手动部署\n   * GitHub\n   * 自己服务器\n * GitHub 自动部署\n   * 生成 Token\n   * 配置秘钥\n * 自动部署自己服务器\n\n\n# 手动部署\n\n\n# GitHub\n\n创建分支：gh-pages\n\n更改文件deploy.sh内容\n\n仓库地址替换成自己的：\n\n * githubUrl=git@github.com:oddfar/notes.git\n\n * githubUrl=https://oddfar:${GITHUB_TOKEN}@github.com/oddfar/notes.git\n\n * initDist \"module.exports = '/notes/'\"\n\n修好完后，双击运行 deploy.sh\n\n之后配置 GitHub Pages\n\n\n\n\n# 自己服务器\n\n根目录下执行命令\n\nnpm run build\n\n\n1\n\n\n生成文件在 docs\\.vuepress\\dist\\ 目录下\n\n打包到服务器即可\n\n注：本地不可直接访问，需要配合插件，详情看官方文档\n\n\n# GitHub 自动部署\n\n目录 .github\\workflows\\ 下的 ci.yml 文件为配置文件\n\n若不需要同步到 Gitee 镜像，且需要配置对，否则把文件里面的 步骤三和步骤四 删掉\n\n配置文件已经写好了，我们只需要在 github 上配置下秘钥（secrets）\n\n前提已经配置了 GitHub Pages 服务并能正常访问\n\n\n# 生成 Token\n\nSettings -> Developer settings->Personal access tokens\n\n1、Settings\n\n\n\n2、Developer settings\n\n\n\n3、Personal access tokens\n\n\n\n4、Generate new token\n\n\n\n创建成功后，会生成一串token，这串token之后不会再显示，请认真保存\n\n\n# 配置秘钥\n\n仓库Setting -> secrets -> New repository secret\n\n\n\nName必须填 ACCESS_TOKEN\n\nValue填写上一步生成的Token\n\n\n\n至此已全部配置好\n\n每当我们 push 到主分支 master 时候，github pages 会自动部署\n\n\n# 自动部署自己服务器\n\n用到 WebHooks 和 Jenkins，每次提交或其他操作时候，会访问设置的URL\n\nJenkin教程：<Jenkins - 知识体系 | OddFar's Notes>\n\n\n\n跑一遍脚本命令就行\n\nrm -rf notes\ngit clone -b gh-pages https://gitee.com/oddfar/notes.git\n\n\n1\n2\n\n\n因为我的github配置，每次提交会同步到gitee\n\n然后触发webhooks，使jenkins构建同步到自己服务器\n\n最后访问地址：\n\n * https://note.oddfar.com\n\n * https://oddfar.github.io/notes",normalizedContent:" * 手动部署\n   * github\n   * 自己服务器\n * github 自动部署\n   * 生成 token\n   * 配置秘钥\n * 自动部署自己服务器\n\n\n# 手动部署\n\n\n# github\n\n创建分支：gh-pages\n\n更改文件deploy.sh内容\n\n仓库地址替换成自己的：\n\n * githuburl=git@github.com:oddfar/notes.git\n\n * githuburl=https://oddfar:${github_token}@github.com/oddfar/notes.git\n\n * initdist \"module.exports = '/notes/'\"\n\n修好完后，双击运行 deploy.sh\n\n之后配置 github pages\n\n\n\n\n# 自己服务器\n\n根目录下执行命令\n\nnpm run build\n\n\n1\n\n\n生成文件在 docs\\.vuepress\\dist\\ 目录下\n\n打包到服务器即可\n\n注：本地不可直接访问，需要配合插件，详情看官方文档\n\n\n# github 自动部署\n\n目录 .github\\workflows\\ 下的 ci.yml 文件为配置文件\n\n若不需要同步到 gitee 镜像，且需要配置对，否则把文件里面的 步骤三和步骤四 删掉\n\n配置文件已经写好了，我们只需要在 github 上配置下秘钥（secrets）\n\n前提已经配置了 github pages 服务并能正常访问\n\n\n# 生成 token\n\nsettings -> developer settings->personal access tokens\n\n1、settings\n\n\n\n2、developer settings\n\n\n\n3、personal access tokens\n\n\n\n4、generate new token\n\n\n\n创建成功后，会生成一串token，这串token之后不会再显示，请认真保存\n\n\n# 配置秘钥\n\n仓库setting -> secrets -> new repository secret\n\n\n\nname必须填 access_token\n\nvalue填写上一步生成的token\n\n\n\n至此已全部配置好\n\n每当我们 push 到主分支 master 时候，github pages 会自动部署\n\n\n# 自动部署自己服务器\n\n用到 webhooks 和 jenkins，每次提交或其他操作时候，会访问设置的url\n\njenkin教程：<jenkins - 知识体系 | oddfar's notes>\n\n\n\n跑一遍脚本命令就行\n\nrm -rf notes\ngit clone -b gh-pages https://gitee.com/oddfar/notes.git\n\n\n1\n2\n\n\n因为我的github配置，每次提交会同步到gitee\n\n然后触发webhooks，使jenkins构建同步到自己服务器\n\n最后访问地址：\n\n * https://note.oddfar.com\n\n * https://oddfar.github.io/notes",charsets:{cjk:!0},lastUpdated:"2023/03/26, 13:03:00",lastUpdatedTimestamp:167983777e4},{title:"标题 - 锚点比较",frontmatter:{title:"标题 - 锚点比较",date:"2021-05-16T22:54:18.000Z",permalink:"/pages/8bac8d/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/12.%E6%A0%87%E9%A2%98%20-%20%E9%94%9A%E7%82%B9%E6%AF%94%E8%BE%83.html",relativePath:"10.关于/02.关于 - 本站/12.标题 - 锚点比较.md",key:"v-5944f74c",path:"/pages/8bac8d/",headers:[{level:2,title:"一  二级目录2空格",slug:"一-二级目录2空格",normalizedTitle:"一  二级目录2空格",charIndex:null},{level:3,title:"3  相同的三级目录",slug:"_3-相同的三级目录",normalizedTitle:"3  相同的三级目录",charIndex:null},{level:3,title:"3  相同的三级目录",slug:"_3-相同的三级目录-2",normalizedTitle:"3  相同的三级目录",charIndex:null},{level:4,title:"不带符号和空格的四级目录",slug:"不带符号和空格的四级目录",normalizedTitle:"不带符号和空格的四级目录",charIndex:344},{level:2,title:"二 二级目录1空格",slug:"二-二级目录1空格",normalizedTitle:"二 二级目录1空格",charIndex:105},{level:2,title:"二 二级目录（带括号）",slug:"二-二级目录-带括号",normalizedTitle:"二 二级目录（带括号）",charIndex:118},{level:3,title:"3 三级目录",slug:"_3-三级目录",normalizedTitle:"3 三级目录",charIndex:135},{level:4,title:"4 四级目录",slug:"_4-四级目录",normalizedTitle:"4 四级目录",charIndex:404},{level:2,title:"2、带数字和符号的二级目录",slug:"_2、带数字和符号的二级目录",normalizedTitle:"2、带数字和符号的二级目录",charIndex:145},{level:3,title:"3、三级目录",slug:"_3、三级目录",normalizedTitle:"3、三级目录",charIndex:164},{level:4,title:"4、四级目录",slug:"_4、四级目录",normalizedTitle:"4、四级目录",charIndex:447}],headersStr:"一  二级目录2空格 3  相同的三级目录 3  相同的三级目录 不带符号和空格的四级目录 二 二级目录1空格 二 二级目录（带括号） 3 三级目录 4 四级目录 2、带数字和符号的二级目录 3、三级目录 4、四级目录",content:"----------------------------------------\n\nvuepress生成的目录\n\n\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n\n\n\n----------------------------------------\n\n点击两款标题跳转的锚点，自行判断二者的区别\n\n----------------------------------------\n\ndoctoc生成的目录\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n     * 不带符号和空格的四级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n     * 4 四级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n     * 4、四级目录\n\n----------------------------------------\n\n\n# 一 二级目录2空格\n\n\n# 3 相同的三级目录\n\n\n# 3 相同的三级目录\n\n# 不带符号和空格的四级目录\n\n\n# 二 二级目录1空格\n\n\n# 二 二级目录（带括号）\n\n\n# 3 三级目录\n\n# 4 四级目录\n\n\n# 2、带数字和符号的二级目录\n\n\n# 3、三级目录\n\n# 4、四级目录",normalizedContent:"----------------------------------------\n\nvuepress生成的目录\n\n\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n\n\n\n----------------------------------------\n\n点击两款标题跳转的锚点，自行判断二者的区别\n\n----------------------------------------\n\ndoctoc生成的目录\n\n * 一 二级目录2空格\n   * 3 相同的三级目录\n   * 3 相同的三级目录\n     * 不带符号和空格的四级目录\n * 二 二级目录1空格\n * 二 二级目录（带括号）\n   * 3 三级目录\n     * 4 四级目录\n * 2、带数字和符号的二级目录\n   * 3、三级目录\n     * 4、四级目录\n\n----------------------------------------\n\n\n# 一 二级目录2空格\n\n\n# 3 相同的三级目录\n\n\n# 3 相同的三级目录\n\n# 不带符号和空格的四级目录\n\n\n# 二 二级目录1空格\n\n\n# 二 二级目录（带括号）\n\n\n# 3 三级目录\n\n# 4 四级目录\n\n\n# 2、带数字和符号的二级目录\n\n\n# 3、三级目录\n\n# 4、四级目录",charsets:{cjk:!0},lastUpdated:"2021/08/03, 15:08:00",lastUpdatedTimestamp:1628003018e3},{title:"某度翻译",frontmatter:{title:"某度翻译",date:"2023-03-26T21:46:55.000Z",permalink:"/pages/007827/"},regularPath:"/20.%E7%88%AC%E8%99%AB/02.%E6%9F%90%E5%BA%A6%E7%BF%BB%E8%AF%91.html",relativePath:"20.爬虫/02.某度翻译.md",key:"v-7a41b909",path:"/pages/007827/",headers:[{level:2,title:"js分析",slug:"js分析",normalizedTitle:"js分析",charIndex:2},{level:2,title:"python爬虫",slug:"python爬虫",normalizedTitle:"python爬虫",charIndex:8460}],headersStr:"js分析 python爬虫",content:"# js分析\n\n请求网站，查看所需要的数据，找到所对应的url\n\n\n\n请求参数里需要sign和token\n\n这个token试过了不需要动，只需解决sign即可\n\nsign是根据输入的内容生成的\n\n\n\n复制请求的url：https://fanyi.baidu.com/v2transapi\n\n先打个断点\n\n\n\n点击翻译，断住了，可以看到数据里有所需要的sign\n\n\n\n我们需要找到 ajax 请求，看看里面的数据\n\n在 调用堆栈里依次点击，找到需要的数据，发现在第三个堆栈里\n\ndata: w, w就是请求的数据，\n\n\n\n可以控制台输出一下，里面有所需要的sign值\n\n和之前请求翻译“你好”的sign一样，说明值是根据输入内容生成的\n\n\n\n根据w的内容，可以知道sign是由 b(e) 生成的\n\n w = {\n    from: v.fromLang,\n    to: v.toLang,\n    query: e,\n    transtype: i,\n    simple_means_flag: 3,\n    sign: b(e),\n    token: window.common.token,\n    domain: k.getCurDomain()\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n控制台输出一下 b(e)，这个值就是我们想要的\n\n b(e)\n'232427.485594'\n\n\n1\n2\n\n\n鼠标光标放到b上，左键单击进入方法\n\n\n\n可以看到，这个方法就是生成 sign 的\n\n\n\n执行js代码\n\n我用的pycharm，需要安装nodejs环境\n\nfunction sign(t) {\n    var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n    if (null === i) {\n        var a = t.length;\n        a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n    } else {\n        for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, l = s.length, u = []; c < l; c++)\n            \"\" !== s[c] && u.push.apply(u, function (t) {\n                if (Array.isArray(t))\n                    return e(t)\n            }(o = s[c].split(\"\")) || function (t) {\n                if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n                    return Array.from(t)\n            }(o) || function (t, n) {\n                if (t) {\n                    if (\"string\" == typeof t)\n                        return e(t, n);\n                    var r = Object.prototype.toString.call(t).slice(8, -1);\n                    return \"Object\" === r && t.constructor && (r = t.constructor.name),\n                        \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n                }\n            }(o) || function () {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n            }()),\n            c !== l - 1 && u.push(i[c]);\n        var p = u.length;\n        p > 30 && (t = u.slice(0, 10).join(\"\") + u.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + u.slice(-10).join(\"\"))\n    }\n    for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : (r = window[d] || \"\") || \"\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n        var _ = t.charCodeAt(v);\n        _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n            g[y++] = _ >> 18 | 240,\n            g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n            g[y++] = _ >> 6 & 63 | 128),\n            g[y++] = 63 & _ | 128)\n    }\n    for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n        b = n(b += g[x], w);\n    return b = n(b, k),\n    (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n        \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\nconsole.log(sign(\"你好\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n执行结果：\n\n  for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : (r = window[d] || \"\") || \"\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n                                                                                                                            ^\n\nReferenceError: r is not defined\n\n\n1\n2\n3\n4\n\n\n\n\n报错内容是r is not defined，找不到r\n\n定位到报错代码所在行，打个断点\n\n\n\n重新发送请求，点跳转到下一个函数调用，执行\n\n\n\n可以看到r是个字符串，内容为：\"320305.131321201\"\n\n\n\n我们先把 r 写死\n\nvar r = \"320305.131321201\";\n\n\n1\n\n\n重新执行下js，报错找不到n方法\n\n\n\n去找一下 n 方法，打个断定，继续执行脚本\n\n\n\n找到n方法\n\nfunction n(t, e) {\n    for (var n = 0; n < e.length - 2; n += 3) {\n        var r = e.charAt(n + 2);\n        r = \"a\" <= r ? r.charCodeAt(0) - 87 : Number(r),\n        r = \"+\" === e.charAt(n + 1) ? t >>> r : t << r,\n        t = \"+\" === e.charAt(n) ? t + r & 4294967295 : t ^ r\n    }\n    return t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n完整代码js\n\nfunction n(t, e) {\n    for (var n = 0; n < e.length - 2; n += 3) {\n        var r = e.charAt(n + 2);\n        r = \"a\" <= r ? r.charCodeAt(0) - 87 : Number(r),\n        r = \"+\" === e.charAt(n + 1) ? t >>> r : t << r,\n        t = \"+\" === e.charAt(n) ? t + r & 4294967295 : t ^ r\n    }\n    return t\n}\n\nvar r = \"320305.131321201\";\n\nfunction sign(t) {\n    var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n    if (null === i) {\n        var a = t.length;\n        a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n    } else {\n        for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, l = s.length, u = []; c < l; c++)\n            \"\" !== s[c] && u.push.apply(u, function (t) {\n                if (Array.isArray(t))\n                    return e(t)\n            }(o = s[c].split(\"\")) || function (t) {\n                if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n                    return Array.from(t)\n            }(o) || function (t, n) {\n                if (t) {\n                    if (\"string\" == typeof t)\n                        return e(t, n);\n                    var r = Object.prototype.toString.call(t).slice(8, -1);\n                    return \"Object\" === r && t.constructor && (r = t.constructor.name),\n                        \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n                }\n            }(o) || function () {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n            }()),\n            c !== l - 1 && u.push(i[c]);\n        var p = u.length;\n        p > 30 && (t = u.slice(0, 10).join(\"\") + u.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + u.slice(-10).join(\"\"))\n    }\n    for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : \"\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n        var _ = t.charCodeAt(v);\n        _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n            g[y++] = _ >> 18 | 240,\n            g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n            g[y++] = _ >> 6 & 63 | 128),\n            g[y++] = 63 & _ | 128)\n    }\n    for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n        b = n(b += g[x], w);\n    return b = n(b, k),\n    (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n        \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\n\nconsole.log(sign(\"你好\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n执行结果\n\n232427.485594\n\n\n1\n\n\n和之前要的sign值一样\n\n\n# python爬虫\n\n在此网站上：https://curlconverter.com/\n\n把cURL转换成python代码\n\n\n\npyhton代码：\n\nimport json\nimport requests\nimport execjs\n\ndef get_sign(vlues):\n\n    # 读取js文件的内容\n    with open('getSign.js', 'r', encoding='utf-8') as f:\n        js_code = f.read()\n\n    # 通过execjs.compile()进行编译js文件内容\n    compile_result = execjs.compile(js_code)\n    # 调用js文件传参\n    # weixin是js中的function方法名，inp是穿的参\n    result = compile_result.call('sign', vlues)\n    return result\n\ndef spider(value):\n    cookies = {\n        'BAIDUID': 'E7E4E0567FBE9DEDF43C583B9E60119F:FG=1',\n        'REALTIME_TRANS_SWITCH': '1',\n        'FANYI_WORD_SWITCH': '1',\n        'HISTORY_SWITCH': '1',\n        'SOUND_SPD_SWITCH': '1',\n        'SOUND_PREFER_SWITCH': '1',\n        'BIDUPSID': 'E7E4E0567FBE9DEDF43C583B9E60119F',\n        'PSTM': '1662006000',\n        'APPGUIDE_10_0_2': '1',\n        'BDORZ': 'B490B5EBF6F3CD402E515D22BCDA1598',\n        'H_PS_PSSID': '36547_38113_38359_38404_37862_38468_38174_38289_38257_37934_38382_26350_38417_37881',\n        'BDSFRCVID': '2AFOJeC629rz1DRfXd9v5P_3d5XzF9QTH6aomM5W3L3Q6y9KgdxmEG0Pqx8g0KAbMVkPogKKBmOTHn_F_2uxOjjg8UtVJeC6EG0Ptf8g0M5',\n        'H_BDCLCKID_SF': 'tJPJoKDbJKD3jR5m-R5HMtCyqxby2C62aJ0H5lQvWJ5TMC_wKRCaQhDEWM88-jQTXb7b_xnL3DTGShPC-tnVXjLiDPkeQ658fm3M0PnE3l02V-j9e-t2yU_VXJjWQPRMW23GWl7mWnrrsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDGAOJ6cP',\n        'Hm_lvt_64ecd82404c51e03dc91cb9e8c025574': '1678884815,1679816757',\n        'delPer': '0',\n        'PSINO': '1',\n        'BAIDUID_BFESS': 'E7E4E0567FBE9DEDF43C583B9E60119F:FG=1',\n        'BDSFRCVID_BFESS': '2AFOJeC629rz1DRfXd9v5P_3d5XzF9QTH6aomM5W3L3Q6y9KgdxmEG0Pqx8g0KAbMVkPogKKBmOTHn_F_2uxOjjg8UtVJeC6EG0Ptf8g0M5',\n        'H_BDCLCKID_SF_BFESS': 'tJPJoKDbJKD3jR5m-R5HMtCyqxby2C62aJ0H5lQvWJ5TMC_wKRCaQhDEWM88-jQTXb7b_xnL3DTGShPC-tnVXjLiDPkeQ658fm3M0PnE3l02V-j9e-t2yU_VXJjWQPRMW23GWl7mWnrrsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDGAOJ6cP',\n        'Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574': '1679827229',\n        'ab_sr': '1.0.1_ZDc2NWQ5ODZiNDI1NjczMTRjYjRlNWY3YTNhZmY2ODAyZjcxM2MyZmM1ODQ1ZTg4NTIwYmNlOWMwYjk4ZjFhMjQzNTBjMzVjYzg4NTMxODI0NWEyNDBiNDljYWEyOGY1YTlkZWQyMzAwZmU3MGY0N2ZiZjEzMjM5ZDZkOWM3NjA2MzAxMTE0OTkxNTFhNTMwYmI5OTM5OGNkZTFiZjhiNA==',\n    }\n\n    headers = {\n        'Accept': '*/*',\n        'Accept-Language': 'zh-CN,zh;q=0.9',\n        'Acs-Token': '1679831923507_1679831922998_WgGGMV2Y27GwWX9/lcuaMP6Dn3dAzyKShwVfdY3ZvbGZlRi8qcN5M+d4u6tZoV0uV+9HmN2ZaofOexoL6zE8Y6dT7j1AzIF96PjQK5W6ODi5XZ5h2+fNVgP+zZXlhHzr0v2C4Q36HXgFR60nlxaPJG/1Ss+CNd71j94XdKAKMzsaSbJJ4XBxQrmHcUc4uDvtyjFIjn5xCiyhh9fWML6lXakNjAtPDAr0QnoufugFaaQGbzhYaLWRnm7GeV1vHwC9eBW6pDnHmzFmV1dEIJ8PD86wGQwIfJi0l/NJNJaYB5/RLCkajs3XfEAmhDqI+uGPNGy9rimDqL15qldEPYwSNcWsJh8q1A0eMvvxJMfRQ+8=',\n        'Connection': 'keep-alive',\n        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n        # 'Cookie': 'BAIDUID=E7E4E0567FBE9DEDF43C583B9E60119F:FG=1; REALTIME_TRANS_SWITCH=1; FANYI_WORD_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; BIDUPSID=E7E4E0567FBE9DEDF43C583B9E60119F; PSTM=1662006000; APPGUIDE_10_0_2=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; H_PS_PSSID=36547_38113_38359_38404_37862_38468_38174_38289_38257_37934_38382_26350_38417_37881; BDSFRCVID=2AFOJeC629rz1DRfXd9v5P_3d5XzF9QTH6aomM5W3L3Q6y9KgdxmEG0Pqx8g0KAbMVkPogKKBmOTHn_F_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF=tJPJoKDbJKD3jR5m-R5HMtCyqxby2C62aJ0H5lQvWJ5TMC_wKRCaQhDEWM88-jQTXb7b_xnL3DTGShPC-tnVXjLiDPkeQ658fm3M0PnE3l02V-j9e-t2yU_VXJjWQPRMW23GWl7mWnrrsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDGAOJ6cP; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1678884815,1679816757; delPer=0; PSINO=1; BAIDUID_BFESS=E7E4E0567FBE9DEDF43C583B9E60119F:FG=1; BDSFRCVID_BFESS=2AFOJeC629rz1DRfXd9v5P_3d5XzF9QTH6aomM5W3L3Q6y9KgdxmEG0Pqx8g0KAbMVkPogKKBmOTHn_F_2uxOjjg8UtVJeC6EG0Ptf8g0M5; H_BDCLCKID_SF_BFESS=tJPJoKDbJKD3jR5m-R5HMtCyqxby2C62aJ0H5lQvWJ5TMC_wKRCaQhDEWM88-jQTXb7b_xnL3DTGShPC-tnVXjLiDPkeQ658fm3M0PnE3l02V-j9e-t2yU_VXJjWQPRMW23GWl7mWnrrsxA45J7cM4IseboJLfT-0bc4KKJxbnLWeIJEjj6jK4JKDGAOJ6cP; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1679827229; ab_sr=1.0.1_ZDc2NWQ5ODZiNDI1NjczMTRjYjRlNWY3YTNhZmY2ODAyZjcxM2MyZmM1ODQ1ZTg4NTIwYmNlOWMwYjk4ZjFhMjQzNTBjMzVjYzg4NTMxODI0NWEyNDBiNDljYWEyOGY1YTlkZWQyMzAwZmU3MGY0N2ZiZjEzMjM5ZDZkOWM3NjA2MzAxMTE0OTkxNTFhNTMwYmI5OTM5OGNkZTFiZjhiNA==',\n        'Origin': 'https://fanyi.baidu.com',\n        'Referer': 'https://fanyi.baidu.com/',\n        'Sec-Fetch-Dest': 'empty',\n        'Sec-Fetch-Mode': 'cors',\n        'Sec-Fetch-Site': 'same-origin',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36',\n        'X-Requested-With': 'XMLHttpRequest',\n        'sec-ch-ua': '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n        'sec-ch-ua-mobile': '?0',\n        'sec-ch-ua-platform': '\"Windows\"',\n        'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwa19pZCI6MSwiYV9pZCI6IiIsImR0eXBlIjoxLCJpZCI6MSwiZXhwIjoxNjc4NzI0MTQxLCJ0eXBlIjoieXp5IiwiaWF0IjoxNjc4NzE2OTQxfQ.Ztx8Dp3ooCtz9nc5XF6tQ3CFatDTeb4gXwxbG14B780',\n        'uid': '1',\n    }\n\n    params = {\n        'from': 'zh',\n        'to': 'en',\n    }\n\n    data = {\n        'from': 'zh',\n        'to': 'en',\n        'query': value,\n        'transtype': 'translang',\n        'simple_means_flag': '3',\n        'sign': get_sign(value),\n        'token': '34032f562bee3207e4dc0085490c43e3',\n        'domain': 'common',\n    }\n\n    response = requests.post('https://fanyi.baidu.com/v2transapi', params=params, cookies=cookies, headers=headers,\n                             data=data)\n    res = json.loads(response.text)\n    print(res)\n\nif __name__ == '__main__':\n    spider('你好')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\njs：\n\nfunction n(t, e) {\n    for (var n = 0; n < e.length - 2; n += 3) {\n        var r = e.charAt(n + 2);\n        r = \"a\" <= r ? r.charCodeAt(0) - 87 : Number(r),\n        r = \"+\" === e.charAt(n + 1) ? t >>> r : t << r,\n        t = \"+\" === e.charAt(n) ? t + r & 4294967295 : t ^ r\n    }\n    return t\n}\n\nvar r = \"320305.131321201\";\n\nfunction sign(t) {\n    var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n    if (null === i) {\n        var a = t.length;\n        a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n    } else {\n        for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, l = s.length, u = []; c < l; c++)\n            \"\" !== s[c] && u.push.apply(u, function (t) {\n                if (Array.isArray(t))\n                    return e(t)\n            }(o = s[c].split(\"\")) || function (t) {\n                if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n                    return Array.from(t)\n            }(o) || function (t, n) {\n                if (t) {\n                    if (\"string\" == typeof t)\n                        return e(t, n);\n                    var r = Object.prototype.toString.call(t).slice(8, -1);\n                    return \"Object\" === r && t.constructor && (r = t.constructor.name),\n                        \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n                }\n            }(o) || function () {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n            }()),\n            c !== l - 1 && u.push(i[c]);\n        var p = u.length;\n        p > 30 && (t = u.slice(0, 10).join(\"\") + u.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + u.slice(-10).join(\"\"))\n    }\n    for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : \"\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n        var _ = t.charCodeAt(v);\n        _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n            g[y++] = _ >> 18 | 240,\n            g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n            g[y++] = _ >> 6 & 63 | 128),\n            g[y++] = 63 & _ | 128)\n    }\n    for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n        b = n(b += g[x], w);\n    return b = n(b, k),\n    (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n        \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\n\nconsole.log(sign(\"你好\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n运行结果\n\n",normalizedContent:"# js分析\n\n请求网站，查看所需要的数据，找到所对应的url\n\n\n\n请求参数里需要sign和token\n\n这个token试过了不需要动，只需解决sign即可\n\nsign是根据输入的内容生成的\n\n\n\n复制请求的url：https://fanyi.baidu.com/v2transapi\n\n先打个断点\n\n\n\n点击翻译，断住了，可以看到数据里有所需要的sign\n\n\n\n我们需要找到 ajax 请求，看看里面的数据\n\n在 调用堆栈里依次点击，找到需要的数据，发现在第三个堆栈里\n\ndata: w, w就是请求的数据，\n\n\n\n可以控制台输出一下，里面有所需要的sign值\n\n和之前请求翻译“你好”的sign一样，说明值是根据输入内容生成的\n\n\n\n根据w的内容，可以知道sign是由 b(e) 生成的\n\n w = {\n    from: v.fromlang,\n    to: v.tolang,\n    query: e,\n    transtype: i,\n    simple_means_flag: 3,\n    sign: b(e),\n    token: window.common.token,\n    domain: k.getcurdomain()\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n控制台输出一下 b(e)，这个值就是我们想要的\n\n b(e)\n'232427.485594'\n\n\n1\n2\n\n\n鼠标光标放到b上，左键单击进入方法\n\n\n\n可以看到，这个方法就是生成 sign 的\n\n\n\n执行js代码\n\n我用的pycharm，需要安装nodejs环境\n\nfunction sign(t) {\n    var o, i = t.match(/[\\ud800-\\udbff][\\udc00-\\udfff]/g);\n    if (null === i) {\n        var a = t.length;\n        a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n    } else {\n        for (var s = t.split(/[\\ud800-\\udbff][\\udc00-\\udfff]/), c = 0, l = s.length, u = []; c < l; c++)\n            \"\" !== s[c] && u.push.apply(u, function (t) {\n                if (array.isarray(t))\n                    return e(t)\n            }(o = s[c].split(\"\")) || function (t) {\n                if (\"undefined\" != typeof symbol && null != t[symbol.iterator] || null != t[\"@@iterator\"])\n                    return array.from(t)\n            }(o) || function (t, n) {\n                if (t) {\n                    if (\"string\" == typeof t)\n                        return e(t, n);\n                    var r = object.prototype.tostring.call(t).slice(8, -1);\n                    return \"object\" === r && t.constructor && (r = t.constructor.name),\n                        \"map\" === r || \"set\" === r ? array.from(t) : \"arguments\" === r || /^(?:ui|i)nt(?:8|16|32)(?:clamped)?array$/.test(r) ? e(t, n) : void 0\n                }\n            }(o) || function () {\n                throw new typeerror(\"invalid attempt to spread non-iterable instance.\\nin order to be iterable, non-array objects must have a [symbol.iterator]() method.\")\n            }()),\n            c !== l - 1 && u.push(i[c]);\n        var p = u.length;\n        p > 30 && (t = u.slice(0, 10).join(\"\") + u.slice(math.floor(p / 2) - 5, math.floor(p / 2) + 5).join(\"\") + u.slice(-10).join(\"\"))\n    }\n    for (var d = \"\".concat(string.fromcharcode(103)).concat(string.fromcharcode(116)).concat(string.fromcharcode(107)), h = (null !== r ? r : (r = window[d] || \"\") || \"\").split(\".\"), f = number(h[0]) || 0, m = number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n        var _ = t.charcodeat(v);\n        _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charcodeat(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charcodeat(++v)),\n            g[y++] = _ >> 18 | 240,\n            g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n            g[y++] = _ >> 6 & 63 | 128),\n            g[y++] = 63 & _ | 128)\n    }\n    for (var b = f, w = \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(97)) + \"\".concat(string.fromcharcode(94)).concat(string.fromcharcode(43)).concat(string.fromcharcode(54)), k = \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(51)) + \"\".concat(string.fromcharcode(94)).concat(string.fromcharcode(43)).concat(string.fromcharcode(98)) + \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(102)), x = 0; x < g.length; x++)\n        b = n(b += g[x], w);\n    return b = n(b, k),\n    (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n        \"\".concat((b %= 1e6).tostring(), \".\").concat(b ^ f)\n}\nconsole.log(sign(\"你好\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n执行结果：\n\n  for (var d = \"\".concat(string.fromcharcode(103)).concat(string.fromcharcode(116)).concat(string.fromcharcode(107)), h = (null !== r ? r : (r = window[d] || \"\") || \"\").split(\".\"), f = number(h[0]) || 0, m = number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n                                                                                                                            ^\n\nreferenceerror: r is not defined\n\n\n1\n2\n3\n4\n\n\n\n\n报错内容是r is not defined，找不到r\n\n定位到报错代码所在行，打个断点\n\n\n\n重新发送请求，点跳转到下一个函数调用，执行\n\n\n\n可以看到r是个字符串，内容为：\"320305.131321201\"\n\n\n\n我们先把 r 写死\n\nvar r = \"320305.131321201\";\n\n\n1\n\n\n重新执行下js，报错找不到n方法\n\n\n\n去找一下 n 方法，打个断定，继续执行脚本\n\n\n\n找到n方法\n\nfunction n(t, e) {\n    for (var n = 0; n < e.length - 2; n += 3) {\n        var r = e.charat(n + 2);\n        r = \"a\" <= r ? r.charcodeat(0) - 87 : number(r),\n        r = \"+\" === e.charat(n + 1) ? t >>> r : t << r,\n        t = \"+\" === e.charat(n) ? t + r & 4294967295 : t ^ r\n    }\n    return t\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n完整代码js\n\nfunction n(t, e) {\n    for (var n = 0; n < e.length - 2; n += 3) {\n        var r = e.charat(n + 2);\n        r = \"a\" <= r ? r.charcodeat(0) - 87 : number(r),\n        r = \"+\" === e.charat(n + 1) ? t >>> r : t << r,\n        t = \"+\" === e.charat(n) ? t + r & 4294967295 : t ^ r\n    }\n    return t\n}\n\nvar r = \"320305.131321201\";\n\nfunction sign(t) {\n    var o, i = t.match(/[\\ud800-\\udbff][\\udc00-\\udfff]/g);\n    if (null === i) {\n        var a = t.length;\n        a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n    } else {\n        for (var s = t.split(/[\\ud800-\\udbff][\\udc00-\\udfff]/), c = 0, l = s.length, u = []; c < l; c++)\n            \"\" !== s[c] && u.push.apply(u, function (t) {\n                if (array.isarray(t))\n                    return e(t)\n            }(o = s[c].split(\"\")) || function (t) {\n                if (\"undefined\" != typeof symbol && null != t[symbol.iterator] || null != t[\"@@iterator\"])\n                    return array.from(t)\n            }(o) || function (t, n) {\n                if (t) {\n                    if (\"string\" == typeof t)\n                        return e(t, n);\n                    var r = object.prototype.tostring.call(t).slice(8, -1);\n                    return \"object\" === r && t.constructor && (r = t.constructor.name),\n                        \"map\" === r || \"set\" === r ? array.from(t) : \"arguments\" === r || /^(?:ui|i)nt(?:8|16|32)(?:clamped)?array$/.test(r) ? e(t, n) : void 0\n                }\n            }(o) || function () {\n                throw new typeerror(\"invalid attempt to spread non-iterable instance.\\nin order to be iterable, non-array objects must have a [symbol.iterator]() method.\")\n            }()),\n            c !== l - 1 && u.push(i[c]);\n        var p = u.length;\n        p > 30 && (t = u.slice(0, 10).join(\"\") + u.slice(math.floor(p / 2) - 5, math.floor(p / 2) + 5).join(\"\") + u.slice(-10).join(\"\"))\n    }\n    for (var d = \"\".concat(string.fromcharcode(103)).concat(string.fromcharcode(116)).concat(string.fromcharcode(107)), h = (null !== r ? r : \"\").split(\".\"), f = number(h[0]) || 0, m = number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n        var _ = t.charcodeat(v);\n        _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charcodeat(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charcodeat(++v)),\n            g[y++] = _ >> 18 | 240,\n            g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n            g[y++] = _ >> 6 & 63 | 128),\n            g[y++] = 63 & _ | 128)\n    }\n    for (var b = f, w = \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(97)) + \"\".concat(string.fromcharcode(94)).concat(string.fromcharcode(43)).concat(string.fromcharcode(54)), k = \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(51)) + \"\".concat(string.fromcharcode(94)).concat(string.fromcharcode(43)).concat(string.fromcharcode(98)) + \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(102)), x = 0; x < g.length; x++)\n        b = n(b += g[x], w);\n    return b = n(b, k),\n    (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n        \"\".concat((b %= 1e6).tostring(), \".\").concat(b ^ f)\n}\n\nconsole.log(sign(\"你好\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n执行结果\n\n232427.485594\n\n\n1\n\n\n和之前要的sign值一样\n\n\n# python爬虫\n\n在此网站上：https://curlconverter.com/\n\n把curl转换成python代码\n\n\n\npyhton代码：\n\nimport json\nimport requests\nimport execjs\n\ndef get_sign(vlues):\n\n    # 读取js文件的内容\n    with open('getsign.js', 'r', encoding='utf-8') as f:\n        js_code = f.read()\n\n    # 通过execjs.compile()进行编译js文件内容\n    compile_result = execjs.compile(js_code)\n    # 调用js文件传参\n    # weixin是js中的function方法名，inp是穿的参\n    result = compile_result.call('sign', vlues)\n    return result\n\ndef spider(value):\n    cookies = {\n        'baiduid': 'e7e4e0567fbe9dedf43c583b9e60119f:fg=1',\n        'realtime_trans_switch': '1',\n        'fanyi_word_switch': '1',\n        'history_switch': '1',\n        'sound_spd_switch': '1',\n        'sound_prefer_switch': '1',\n        'bidupsid': 'e7e4e0567fbe9dedf43c583b9e60119f',\n        'pstm': '1662006000',\n        'appguide_10_0_2': '1',\n        'bdorz': 'b490b5ebf6f3cd402e515d22bcda1598',\n        'h_ps_pssid': '36547_38113_38359_38404_37862_38468_38174_38289_38257_37934_38382_26350_38417_37881',\n        'bdsfrcvid': '2afojec629rz1drfxd9v5p_3d5xzf9qth6aomm5w3l3q6y9kgdxmeg0pqx8g0kabmvkpogkkbmothn_f_2uxojjg8utvjec6eg0ptf8g0m5',\n        'h_bdclckid_sf': 'tjpjokdbjkd3jr5m-r5hmtcyqxby2c62aj0h5lqvwj5tmc_wkrcaqhdewm88-jqtxb7b_xnl3dtgshpc-tnvxjlidpkeq658fm3m0pne3l02v-j9e-t2yu_vxjjwqprmw23gwl7mwnrrsxa45j7cm4isebojlft-0bc4kkjxbnlweijejj6jk4jkdgaoj6cp',\n        'hm_lvt_64ecd82404c51e03dc91cb9e8c025574': '1678884815,1679816757',\n        'delper': '0',\n        'psino': '1',\n        'baiduid_bfess': 'e7e4e0567fbe9dedf43c583b9e60119f:fg=1',\n        'bdsfrcvid_bfess': '2afojec629rz1drfxd9v5p_3d5xzf9qth6aomm5w3l3q6y9kgdxmeg0pqx8g0kabmvkpogkkbmothn_f_2uxojjg8utvjec6eg0ptf8g0m5',\n        'h_bdclckid_sf_bfess': 'tjpjokdbjkd3jr5m-r5hmtcyqxby2c62aj0h5lqvwj5tmc_wkrcaqhdewm88-jqtxb7b_xnl3dtgshpc-tnvxjlidpkeq658fm3m0pne3l02v-j9e-t2yu_vxjjwqprmw23gwl7mwnrrsxa45j7cm4isebojlft-0bc4kkjxbnlweijejj6jk4jkdgaoj6cp',\n        'hm_lpvt_64ecd82404c51e03dc91cb9e8c025574': '1679827229',\n        'ab_sr': '1.0.1_zdc2nwq5odzindi1njczmtrjyjrlnwy3ytnhzmy2odayzjcxm2myzmm1odq1ztg4ntiwymnlowmwyjk4zjfhmjqzntbjmzvjyzg4ntmxodi0nweyndbindljyweyogy1ytlkzwqymzawzmu3mgy0n2zizjezmjm5zdzkowm3nja2mzaxmte0otkxntfhntmwymi5otm5ognkztfizjhina==',\n    }\n\n    headers = {\n        'accept': '*/*',\n        'accept-language': 'zh-cn,zh;q=0.9',\n        'acs-token': '1679831923507_1679831922998_wgggmv2y27gwwx9/lcuamp6dn3dazykshwvfdy3zvbgzlri8qcn5m+d4u6tzov0uv+9hmn2zaofoexol6ze8y6dt7j1azif96pjqk5w6odi5xz5h2+fnvgp+zzxlhhzr0v2c4q36hxgfr60nlxapjg/1ss+cnd71j94xdkakmzsasbjj4xbxqrmhcuc4udvtyjfijn5xciyhh9fwml6lxaknjatpdar0qnoufugfaaqgbzhyalwrnm7gev1vhwc9ebw6pdnhmzfmv1deij8pd86wgqwifji0l/njnjayb5/rlckajs3xfeamhdqi+ugpngy9rimdql15qldepywsncwsjh8q1a0emvvxjmfrq+8=',\n        'connection': 'keep-alive',\n        'content-type': 'application/x-www-form-urlencoded; charset=utf-8',\n        # 'cookie': 'baiduid=e7e4e0567fbe9dedf43c583b9e60119f:fg=1; realtime_trans_switch=1; fanyi_word_switch=1; history_switch=1; sound_spd_switch=1; sound_prefer_switch=1; bidupsid=e7e4e0567fbe9dedf43c583b9e60119f; pstm=1662006000; appguide_10_0_2=1; bdorz=b490b5ebf6f3cd402e515d22bcda1598; h_ps_pssid=36547_38113_38359_38404_37862_38468_38174_38289_38257_37934_38382_26350_38417_37881; bdsfrcvid=2afojec629rz1drfxd9v5p_3d5xzf9qth6aomm5w3l3q6y9kgdxmeg0pqx8g0kabmvkpogkkbmothn_f_2uxojjg8utvjec6eg0ptf8g0m5; h_bdclckid_sf=tjpjokdbjkd3jr5m-r5hmtcyqxby2c62aj0h5lqvwj5tmc_wkrcaqhdewm88-jqtxb7b_xnl3dtgshpc-tnvxjlidpkeq658fm3m0pne3l02v-j9e-t2yu_vxjjwqprmw23gwl7mwnrrsxa45j7cm4isebojlft-0bc4kkjxbnlweijejj6jk4jkdgaoj6cp; hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1678884815,1679816757; delper=0; psino=1; baiduid_bfess=e7e4e0567fbe9dedf43c583b9e60119f:fg=1; bdsfrcvid_bfess=2afojec629rz1drfxd9v5p_3d5xzf9qth6aomm5w3l3q6y9kgdxmeg0pqx8g0kabmvkpogkkbmothn_f_2uxojjg8utvjec6eg0ptf8g0m5; h_bdclckid_sf_bfess=tjpjokdbjkd3jr5m-r5hmtcyqxby2c62aj0h5lqvwj5tmc_wkrcaqhdewm88-jqtxb7b_xnl3dtgshpc-tnvxjlidpkeq658fm3m0pne3l02v-j9e-t2yu_vxjjwqprmw23gwl7mwnrrsxa45j7cm4isebojlft-0bc4kkjxbnlweijejj6jk4jkdgaoj6cp; hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1679827229; ab_sr=1.0.1_zdc2nwq5odzindi1njczmtrjyjrlnwy3ytnhzmy2odayzjcxm2myzmm1odq1ztg4ntiwymnlowmwyjk4zjfhmjqzntbjmzvjyzg4ntmxodi0nweyndbindljyweyogy1ytlkzwqymzawzmu3mgy0n2zizjezmjm5zdzkowm3nja2mzaxmte0otkxntfhntmwymi5otm5ognkztfizjhina==',\n        'origin': 'https://fanyi.baidu.com',\n        'referer': 'https://fanyi.baidu.com/',\n        'sec-fetch-dest': 'empty',\n        'sec-fetch-mode': 'cors',\n        'sec-fetch-site': 'same-origin',\n        'user-agent': 'mozilla/5.0 (windows nt 10.0; win64; x64) applewebkit/537.36 (khtml, like gecko) chrome/111.0.0.0 safari/537.36',\n        'x-requested-with': 'xmlhttprequest',\n        'sec-ch-ua': '\"google chrome\";v=\"111\", \"not(a:brand\";v=\"8\", \"chromium\";v=\"111\"',\n        'sec-ch-ua-mobile': '?0',\n        'sec-ch-ua-platform': '\"windows\"',\n        'token': 'eyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjwa19pzci6mswiyv9pzci6iiisimr0exblijoxlcjpzci6mswizxhwijoxnjc4nzi0mtqxlcj0exblijoiexp5iiwiawf0ijoxnjc4nze2otqxfq.ztx8dp3ooctz9nc5xf6tq3cfatdteb4gxwxbg14b780',\n        'uid': '1',\n    }\n\n    params = {\n        'from': 'zh',\n        'to': 'en',\n    }\n\n    data = {\n        'from': 'zh',\n        'to': 'en',\n        'query': value,\n        'transtype': 'translang',\n        'simple_means_flag': '3',\n        'sign': get_sign(value),\n        'token': '34032f562bee3207e4dc0085490c43e3',\n        'domain': 'common',\n    }\n\n    response = requests.post('https://fanyi.baidu.com/v2transapi', params=params, cookies=cookies, headers=headers,\n                             data=data)\n    res = json.loads(response.text)\n    print(res)\n\nif __name__ == '__main__':\n    spider('你好')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\njs：\n\nfunction n(t, e) {\n    for (var n = 0; n < e.length - 2; n += 3) {\n        var r = e.charat(n + 2);\n        r = \"a\" <= r ? r.charcodeat(0) - 87 : number(r),\n        r = \"+\" === e.charat(n + 1) ? t >>> r : t << r,\n        t = \"+\" === e.charat(n) ? t + r & 4294967295 : t ^ r\n    }\n    return t\n}\n\nvar r = \"320305.131321201\";\n\nfunction sign(t) {\n    var o, i = t.match(/[\\ud800-\\udbff][\\udc00-\\udfff]/g);\n    if (null === i) {\n        var a = t.length;\n        a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n    } else {\n        for (var s = t.split(/[\\ud800-\\udbff][\\udc00-\\udfff]/), c = 0, l = s.length, u = []; c < l; c++)\n            \"\" !== s[c] && u.push.apply(u, function (t) {\n                if (array.isarray(t))\n                    return e(t)\n            }(o = s[c].split(\"\")) || function (t) {\n                if (\"undefined\" != typeof symbol && null != t[symbol.iterator] || null != t[\"@@iterator\"])\n                    return array.from(t)\n            }(o) || function (t, n) {\n                if (t) {\n                    if (\"string\" == typeof t)\n                        return e(t, n);\n                    var r = object.prototype.tostring.call(t).slice(8, -1);\n                    return \"object\" === r && t.constructor && (r = t.constructor.name),\n                        \"map\" === r || \"set\" === r ? array.from(t) : \"arguments\" === r || /^(?:ui|i)nt(?:8|16|32)(?:clamped)?array$/.test(r) ? e(t, n) : void 0\n                }\n            }(o) || function () {\n                throw new typeerror(\"invalid attempt to spread non-iterable instance.\\nin order to be iterable, non-array objects must have a [symbol.iterator]() method.\")\n            }()),\n            c !== l - 1 && u.push(i[c]);\n        var p = u.length;\n        p > 30 && (t = u.slice(0, 10).join(\"\") + u.slice(math.floor(p / 2) - 5, math.floor(p / 2) + 5).join(\"\") + u.slice(-10).join(\"\"))\n    }\n    for (var d = \"\".concat(string.fromcharcode(103)).concat(string.fromcharcode(116)).concat(string.fromcharcode(107)), h = (null !== r ? r : \"\").split(\".\"), f = number(h[0]) || 0, m = number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n        var _ = t.charcodeat(v);\n        _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charcodeat(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charcodeat(++v)),\n            g[y++] = _ >> 18 | 240,\n            g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n            g[y++] = _ >> 6 & 63 | 128),\n            g[y++] = 63 & _ | 128)\n    }\n    for (var b = f, w = \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(97)) + \"\".concat(string.fromcharcode(94)).concat(string.fromcharcode(43)).concat(string.fromcharcode(54)), k = \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(51)) + \"\".concat(string.fromcharcode(94)).concat(string.fromcharcode(43)).concat(string.fromcharcode(98)) + \"\".concat(string.fromcharcode(43)).concat(string.fromcharcode(45)).concat(string.fromcharcode(102)), x = 0; x < g.length; x++)\n        b = n(b += g[x], w);\n    return b = n(b, k),\n    (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n        \"\".concat((b %= 1e6).tostring(), \".\").concat(b ^ f)\n}\n\nconsole.log(sign(\"你好\"))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n运行结果\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/27, 13:03:00",lastUpdatedTimestamp:1679922049e3},{title:"文档密码破解",frontmatter:{title:"文档密码破解",date:"2024-01-30T16:19:06.000Z",permalink:"/pages/7de988/"},regularPath:"/20.%E7%88%AC%E8%99%AB/04.%E6%96%87%E6%A1%A3%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3.html",relativePath:"20.爬虫/04.文档密码破解.md",key:"v-23d64f0e",path:"/pages/7de988/",headers:[{level:2,title:"某文档一",slug:"某文档一",normalizedTitle:"某文档一",charIndex:2},{level:2,title:"某文档二",slug:"某文档二",normalizedTitle:"某文档二",charIndex:619}],headersStr:"某文档一 某文档二",content:'# 某文档一\n\n浏览某技术文档时，发现此文档需要验证码，而验证码需加入知识星球才能看到\n\n\n\n于是先看看能不能破解咯，打开 F12 ，先随便输入个验证码，看看是不是动态验证的\n\n\n\nXHR 请求里有请求进行验证\n\n\n\n根据此链接去打个断点看看\n\n\n\n重新输入验证码发起请求，接着分析代码\n\n\n\n这里很容易就知道，当 s 不等于 i 时代表验证码错误\n\n我们只需要让 s==i 就可以\n\n if (st.log("md5Input", s),\n\t!= i)\n\t\tthrow new Error("验证码错误！")\n\n\n1\n2\n3\n\n\n打个断点，看看他俩值是多少\n\n\n\n右上角继续执行\n\n\n\ni 就是 XHR 请求返回数据中的字段 description 的值\n\ns 就是 y7.MD5(o).toString() ，o 就是输入的验证码\n\n\n\n我们只要把 s 的内容改成 "e74eb4201f9376041508fc2219a125e2" 就行了\n\n作用域里直接替换就行了\n\n\n\n接着继续执行，提示文档解锁成功\n\n\n\n> 固定返回内容\n\n验证码可能会定期更换，我们也可以更改接口的返回内容，这样就不用担心更换\n\n使用一款拓展程序：Requestly: Open Source HTTPs Debugging Proxy\n\n\n\n添加一个 Modify API Response（修改API响应）的规则\n\n直接返回我们自己想要的\n\n\n\n\n# 某文档二\n\n浏览另一平台的文档，也是需要验证码\n\n\n\n随机输入一个验证码后，没有网络请求，可以断定验证码在本地\n\n\n\n停用缓存，重新刷新网页，搜索关键字：解锁验证码有误\n\n\n\n去分析下代码\n\n\n\n根据这块代码意思就是\n\n输入框 id="unlockCode" 的值和 e 比较，存在也就是 >= 0 就设置 Cookies 否则就是验证码错误\n\n所以 e 就是密码\n\n\n\n这个输入框也正好是 验证码 的输入框\n\n\n\n鼠标放过去就知道了密码\n\n',normalizedContent:'# 某文档一\n\n浏览某技术文档时，发现此文档需要验证码，而验证码需加入知识星球才能看到\n\n\n\n于是先看看能不能破解咯，打开 f12 ，先随便输入个验证码，看看是不是动态验证的\n\n\n\nxhr 请求里有请求进行验证\n\n\n\n根据此链接去打个断点看看\n\n\n\n重新输入验证码发起请求，接着分析代码\n\n\n\n这里很容易就知道，当 s 不等于 i 时代表验证码错误\n\n我们只需要让 s==i 就可以\n\n if (st.log("md5input", s),\n\t!= i)\n\t\tthrow new error("验证码错误！")\n\n\n1\n2\n3\n\n\n打个断点，看看他俩值是多少\n\n\n\n右上角继续执行\n\n\n\ni 就是 xhr 请求返回数据中的字段 description 的值\n\ns 就是 y7.md5(o).tostring() ，o 就是输入的验证码\n\n\n\n我们只要把 s 的内容改成 "e74eb4201f9376041508fc2219a125e2" 就行了\n\n作用域里直接替换就行了\n\n\n\n接着继续执行，提示文档解锁成功\n\n\n\n> 固定返回内容\n\n验证码可能会定期更换，我们也可以更改接口的返回内容，这样就不用担心更换\n\n使用一款拓展程序：requestly: open source https debugging proxy\n\n\n\n添加一个 modify api response（修改api响应）的规则\n\n直接返回我们自己想要的\n\n\n\n\n# 某文档二\n\n浏览另一平台的文档，也是需要验证码\n\n\n\n随机输入一个验证码后，没有网络请求，可以断定验证码在本地\n\n\n\n停用缓存，重新刷新网页，搜索关键字：解锁验证码有误\n\n\n\n去分析下代码\n\n\n\n根据这块代码意思就是\n\n输入框 id="unlockcode" 的值和 e 比较，存在也就是 >= 0 就设置 cookies 否则就是验证码错误\n\n所以 e 就是密码\n\n\n\n这个输入框也正好是 验证码 的输入框\n\n\n\n鼠标放过去就知道了密码\n\n',charsets:{cjk:!0},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757170909e3},{title:"标题 - 目录生成",frontmatter:{title:"标题 - 目录生成",date:"2021-05-16T23:36:45.000Z",permalink:"/pages/2bde62/"},regularPath:"/10.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/11.%E6%A0%87%E9%A2%98%20-%20%E7%9B%AE%E5%BD%95%E7%94%9F%E6%88%90.html",relativePath:"10.关于/02.关于 - 本站/11.标题 - 目录生成.md",key:"v-bbc08472",path:"/pages/2bde62/",headers:[{level:2,title:"标题目录生成",slug:"标题目录生成",normalizedTitle:"标题目录生成",charIndex:3},{level:3,title:"typora",slug:"typora",normalizedTitle:"typora",charIndex:15},{level:3,title:"vuepress",slug:"vuepress",normalizedTitle:"vuepress",charIndex:27},{level:4,title:"markdown.extractHeaders",slug:"markdown-extractheaders",normalizedTitle:"markdown.extractheaders",charIndex:254},{level:3,title:"DoCToc",slug:"doctoc",normalizedTitle:"doctoc",charIndex:41},{level:2,title:"标题建议",slug:"标题建议",normalizedTitle:"标题建议",charIndex:51}],headersStr:"标题目录生成 typora vuepress markdown.extractHeaders DoCToc 标题建议",content:" * 标题目录生成\n   * typora\n   * vuepress\n   * DoCToc\n * 标题建议\n\n\n\n\n# 标题目录生成\n\n推荐使用DocToc，使用自带的vuepress即可\n\n\n# typora\n\n输入\n\n[TOC]\n\n\n1\n\n\n生成所有标题\n\n但不能在 github vuepress 中正常显示，可在 csdn 中使用\n\n\n# vuepress\n\n输入\n\n[[TOC]]\n\n\n1\n\n\n只生成二级、三级标题，新版本可以使目录栏支持h2~h6标题\n\n只在 vuepress 中显示\n\n# markdown.extractHeaders\n\n * 类型: Array\n * 默认值: ['h2', 'h3']\n\nMarkdown 文件的 headers (标题 & 小标题) 会在准备阶段被提取出来，并存储在 this.$page.headers 中。默认情况下，VuePress 会提取 h2 和 h3 标题。你可以通过这个选项来修改提取出的标题级别。\n\nmodule.exports = {\n  markdown: {\n    extractHeaders: [ 'h2', 'h3', 'h4', 'h5', 'h6' ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n注：此配置来自 VuePress官方文档\n\n\n# DoCToc\n\nDocToc：为本地git仓库内的markdown文件生成目录。链接与github或其他站点生成的锚点兼容。\n\n全局安装\n\nnpm install -g doctoc\n\n\n1\n\n\n使用方法：\n\n官方文档：https://www.npmjs.com/package/doctoc\n\nDocToc 默认在顶头生成目录，但在 vuepress 中顶头写的是配置\n\n所以需要自定义目录位置\n\n\x3c!-- START doctoc --\x3e\n\x3c!-- END doctoc --\x3e\n\n\n1\n2\n\n\n例如：\n\n// my_new_post.md\nHere we are, introducing the post. It's going to be great!\nBut first: a TOC for easy reference.\n\n\x3c!-- START doctoc --\x3e\n\x3c!-- END doctoc --\x3e\n\n# Section One\n\nHere we'll discuss...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n生成目录\n\n生成一个文件 README.md\n\ndoctoc README.md --github\n\n\n1\n\n\n更新目录\n\n更新一个文件 README.md\n\ndoctoc README.md --github -u\n\n\n1\n\n\n目录下所有文件一键生成\n\n在项目根目录中\n\ndoctoc . --github -u\n\n\n1\n\n\n此命令只会在有标记记录的md文件 生成/更新 目录\n\n若你想每个文件都生成，需要自己在每个文件中加上标记\n\n\n# 标题建议\n\n为了链接适配 github 及 vuepress 标题锚点兼容\n\n建议\n\n * 不要使用小写数字+空格，可用大写数字+空格\n\n * 不要使用符号\n   \n   可以用空格，且只能一个空格\n\n * 三级标题及更小标题不可添加符号及空格\n\n正确：\n\n## 一 java简介\n## 二 Java的特性和优势\n## Java三大版本\n\n\n1\n2\n3\n\n\n错误\n\n//使用二个空格\n## 一  java简介\n//使用符号\n## 2、java简介\n\n//三级及以下标题不可加符号和空格\n### 三 Java三大版本\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n两者生成的锚点链接差异：访问下文\n\n总结：不用符号",normalizedContent:" * 标题目录生成\n   * typora\n   * vuepress\n   * doctoc\n * 标题建议\n\n\n\n\n# 标题目录生成\n\n推荐使用doctoc，使用自带的vuepress即可\n\n\n# typora\n\n输入\n\n[toc]\n\n\n1\n\n\n生成所有标题\n\n但不能在 github vuepress 中正常显示，可在 csdn 中使用\n\n\n# vuepress\n\n输入\n\n[[toc]]\n\n\n1\n\n\n只生成二级、三级标题，新版本可以使目录栏支持h2~h6标题\n\n只在 vuepress 中显示\n\n# markdown.extractheaders\n\n * 类型: array\n * 默认值: ['h2', 'h3']\n\nmarkdown 文件的 headers (标题 & 小标题) 会在准备阶段被提取出来，并存储在 this.$page.headers 中。默认情况下，vuepress 会提取 h2 和 h3 标题。你可以通过这个选项来修改提取出的标题级别。\n\nmodule.exports = {\n  markdown: {\n    extractheaders: [ 'h2', 'h3', 'h4', 'h5', 'h6' ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n注：此配置来自 vuepress官方文档\n\n\n# doctoc\n\ndoctoc：为本地git仓库内的markdown文件生成目录。链接与github或其他站点生成的锚点兼容。\n\n全局安装\n\nnpm install -g doctoc\n\n\n1\n\n\n使用方法：\n\n官方文档：https://www.npmjs.com/package/doctoc\n\ndoctoc 默认在顶头生成目录，但在 vuepress 中顶头写的是配置\n\n所以需要自定义目录位置\n\n\x3c!-- start doctoc --\x3e\n\x3c!-- end doctoc --\x3e\n\n\n1\n2\n\n\n例如：\n\n// my_new_post.md\nhere we are, introducing the post. it's going to be great!\nbut first: a toc for easy reference.\n\n\x3c!-- start doctoc --\x3e\n\x3c!-- end doctoc --\x3e\n\n# section one\n\nhere we'll discuss...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n生成目录\n\n生成一个文件 readme.md\n\ndoctoc readme.md --github\n\n\n1\n\n\n更新目录\n\n更新一个文件 readme.md\n\ndoctoc readme.md --github -u\n\n\n1\n\n\n目录下所有文件一键生成\n\n在项目根目录中\n\ndoctoc . --github -u\n\n\n1\n\n\n此命令只会在有标记记录的md文件 生成/更新 目录\n\n若你想每个文件都生成，需要自己在每个文件中加上标记\n\n\n# 标题建议\n\n为了链接适配 github 及 vuepress 标题锚点兼容\n\n建议\n\n * 不要使用小写数字+空格，可用大写数字+空格\n\n * 不要使用符号\n   \n   可以用空格，且只能一个空格\n\n * 三级标题及更小标题不可添加符号及空格\n\n正确：\n\n## 一 java简介\n## 二 java的特性和优势\n## java三大版本\n\n\n1\n2\n3\n\n\n错误\n\n//使用二个空格\n## 一  java简介\n//使用符号\n## 2、java简介\n\n//三级及以下标题不可加符号和空格\n### 三 java三大版本\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n两者生成的锚点链接差异：访问下文\n\n总结：不用符号",charsets:{cjk:!0},lastUpdated:"2022/06/12, 3:06:00",lastUpdatedTimestamp:165500324e4},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-536574fe",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2021/05/26, 10:05:00",lastUpdatedTimestamp:1622024154e3},{title:"AI 解读项目",frontmatter:{title:"AI 解读项目",date:"2025-08-25T20:46:37.000Z",permalink:"/pages/86599a/"},regularPath:"/30.AI/01.AI%20%E8%A7%A3%E8%AF%BB%E9%A1%B9%E7%9B%AE.html",relativePath:"30.AI/01.AI 解读项目.md",key:"v-fc806cac",path:"/pages/86599a/",headers:[{level:2,title:"🚀 一分钟速通 DeepWiki",slug:"🚀-一分钟速通-deepwiki",normalizedTitle:"🚀 一分钟速通 deepwiki",charIndex:45}],headersStr:"🚀 一分钟速通 DeepWiki",content:"----------------------------------------\n\n\n# 🚀 一分钟速通 DeepWiki\n\n别硬啃代码了，DeepWiki 才是当代打工人的续命神器。先放结论：\n\n * 10 分钟 生成一份带架构图、时序图、类图的超详细 Wiki\n * 直接对话 代码库，哪里不会问哪里\n * 完全免费（私有库也支持，后面讲姿势）\n\n但帮助挺有限的，不过还是可以提高阅读效率\n\n场景      原做法                               DEEPWIKI 做法\n读开源项目   git clone → 翻 README → 猜目录 → 放弃   https://deepwiki.com/owner/repo 一把梭\n看私有项目   搭 VPN + 拉代码 + 本地 IDE 全局搜索         本地 Docker 一键部署，代码不落地\n写技术文档   手画架构图 + 写 Markdown → 永远落后代码       AI 自动生成，每次 commit 都能重新生成\n\n> 🔧 玩法\n\n玩法        命令 / 地址                                        效果\n直接跳转      https://deepwiki.com/owner/repo                已索引项目秒开\n浏览器小书签    把 GitHub 地址栏 github 改成 deepwiki                一键切换\n源码&部署指南   https://github.com/AsyncFuncAI/deepwiki-open   担心代码泄露，可自己部署使用\n\n----------------------------------------",normalizedContent:"----------------------------------------\n\n\n# 🚀 一分钟速通 deepwiki\n\n别硬啃代码了，deepwiki 才是当代打工人的续命神器。先放结论：\n\n * 10 分钟 生成一份带架构图、时序图、类图的超详细 wiki\n * 直接对话 代码库，哪里不会问哪里\n * 完全免费（私有库也支持，后面讲姿势）\n\n但帮助挺有限的，不过还是可以提高阅读效率\n\n场景      原做法                               deepwiki 做法\n读开源项目   git clone → 翻 readme → 猜目录 → 放弃   https://deepwiki.com/owner/repo 一把梭\n看私有项目   搭 vpn + 拉代码 + 本地 ide 全局搜索         本地 docker 一键部署，代码不落地\n写技术文档   手画架构图 + 写 markdown → 永远落后代码       ai 自动生成，每次 commit 都能重新生成\n\n> 🔧 玩法\n\n玩法        命令 / 地址                                        效果\n直接跳转      https://deepwiki.com/owner/repo                已索引项目秒开\n浏览器小书签    把 github 地址栏 github 改成 deepwiki                一键切换\n源码&部署指南   https://github.com/asyncfuncai/deepwiki-open   担心代码泄露，可自己部署使用\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757171752e3},{title:"Claude Code教程",frontmatter:{title:"Claude Code教程",date:"2025-09-06T22:43:27.000Z",permalink:"/pages/ec7818/"},regularPath:"/30.AI/05.Claude%20Code%E6%95%99%E7%A8%8B.html",relativePath:"30.AI/05.Claude Code教程.md",key:"v-3a8672e0",path:"/pages/ec7818/",headers:[{level:2,title:"安装指南",slug:"安装指南",normalizedTitle:"安装指南",charIndex:92},{level:2,title:"基础命令",slug:"基础命令",normalizedTitle:"基础命令",charIndex:238},{level:3,title:"项目初始化",slug:"项目初始化",normalizedTitle:"项目初始化",charIndex:247},{level:3,title:"集成开发环境模式",slug:"集成开发环境模式",normalizedTitle:"集成开发环境模式",charIndex:401},{level:2,title:"思考增强功能",slug:"思考增强功能",normalizedTitle:"思考增强功能",charIndex:515},{level:3,title:"Think 命令",slug:"think-命令",normalizedTitle:"think 命令",charIndex:526},{level:3,title:"思考级别关键词",slug:"思考级别关键词",normalizedTitle:"思考级别关键词",charIndex:640},{level:2,title:"运行模式",slug:"运行模式",normalizedTitle:"运行模式",charIndex:887},{level:3,title:"非交互模式",slug:"非交互模式",normalizedTitle:"非交互模式",charIndex:896},{level:2,title:"MCP 连接器管理",slug:"mcp-连接器管理",normalizedTitle:"mcp 连接器管理",charIndex:1001},{level:3,title:"添加 MCP 连接器",slug:"添加-mcp-连接器",normalizedTitle:"添加 mcp 连接器",charIndex:1066},{level:3,title:"移除 MCP 连接器",slug:"移除-mcp-连接器",normalizedTitle:"移除 mcp 连接器",charIndex:1287},{level:2,title:"权限管理",slug:"权限管理",normalizedTitle:"权限管理",charIndex:1378},{level:3,title:"查看权限",slug:"查看权限",normalizedTitle:"查看权限",charIndex:1387},{level:3,title:"跳过权限检查（谨慎使用）",slug:"跳过权限检查-谨慎使用",normalizedTitle:"跳过权限检查（谨慎使用）",charIndex:1421},{level:2,title:"自定义功能",slug:"自定义功能",normalizedTitle:"自定义功能",charIndex:1514},{level:3,title:"自定义命令",slug:"自定义命令",normalizedTitle:"自定义命令",charIndex:1524},{level:3,title:"Hooks（钩子函数）",slug:"hooks-钩子函数",normalizedTitle:"hooks（钩子函数）",charIndex:1749},{level:2,title:"高级功能",slug:"高级功能",normalizedTitle:"高级功能",charIndex:1957},{level:3,title:"Sub Agent",slug:"sub-agent",normalizedTitle:"sub agent",charIndex:1966},{level:3,title:"历史对话管理",slug:"历史对话管理",normalizedTitle:"历史对话管理",charIndex:2021},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:2108},{level:3,title:"1. 项目管理",slug:"_1-项目管理",normalizedTitle:"1. 项目管理",charIndex:2117},{level:3,title:"2. 思考功能使用",slug:"_2-思考功能使用",normalizedTitle:"2. 思考功能使用",charIndex:2193},{level:3,title:"3. 权限安全",slug:"_3-权限安全",normalizedTitle:"3. 权限安全",charIndex:2280},{level:3,title:"4. 自定义优化",slug:"_4-自定义优化",normalizedTitle:"4. 自定义优化",charIndex:2368},{level:3,title:"5. 工作流程",slug:"_5-工作流程",normalizedTitle:"5. 工作流程",charIndex:2436},{level:2,title:"故障排除",slug:"故障排除",normalizedTitle:"故障排除",charIndex:2634},{level:3,title:"常见问题及解决方案",slug:"常见问题及解决方案",normalizedTitle:"常见问题及解决方案",charIndex:2643},{level:3,title:"获取帮助",slug:"获取帮助",normalizedTitle:"获取帮助",charIndex:3054},{level:2,title:"高效使用技巧",slug:"高效使用技巧",normalizedTitle:"高效使用技巧",charIndex:3191}],headersStr:"安装指南 基础命令 项目初始化 集成开发环境模式 思考增强功能 Think 命令 思考级别关键词 运行模式 非交互模式 MCP 连接器管理 添加 MCP 连接器 移除 MCP 连接器 权限管理 查看权限 跳过权限检查（谨慎使用） 自定义功能 自定义命令 Hooks（钩子函数） 高级功能 Sub Agent 历史对话管理 最佳实践 1. 项目管理 2. 思考功能使用 3. 权限安全 4. 自定义优化 5. 工作流程 故障排除 常见问题及解决方案 获取帮助 高效使用技巧",content:'# Claude Code 命令教程\n\nClaude Code 是一个强大的命令行工具，让开发者能够直接从终端与 Claude AI 进行交互，实现高效的代码开发和问题解决。\n\n\n# 安装指南\n\n官方文档： https://docs.anthropic.com/zh-CN/docs/claude-code/overview\n\n智谱AI接入： https://docs.bigmodel.cn/cn/guide/develop/claude\n\n也可接入通义前问等模型\n\n\n# 基础命令\n\n\n# 项目初始化\n\nclaude /init\n\n\n1\n\n\n作用： 在当前目录初始化一个新的 Claude Code 项目，创建必要的配置文件和目录结构。\n\n示例：\n\ncd my-project\nclaude /init\n\n\n1\n2\n\n\n这将在项目根目录创建 .claude 配置目录，为后续开发做好准备。\n\n\n# 集成开发环境模式\n\nclaude /ide\n\n\n1\n\n\n作用： 启动交互式开发环境，提供更丰富的开发体验和持续对话能力。\n\n示例：\n\nclaude /ide\n# 进入交互模式，可以进行持续的代码讨论和修改\n\n\n1\n2\n\n\n\n# 思考增强功能\n\n\n# Think 命令\n\nclaude think\n\n\n1\n\n\n作用： 为 Claude 提供额外的思考时间，帮助处理复杂问题。有两种触发方式：\n\n * manual - 手动调用\n * auto - 上下文窗口满时自动触发\n\n\n# 思考级别关键词\n\n在提示中添加以下关键词，按复杂度递增排列：\n\n关键词            TOKEN 消耗   适用场景\nthink          最低         简单问题思考\nthink hard     中等         中等复杂度问题\nthink harder   较高         复杂逻辑问题\nultrathink     最高         极其复杂的问题\n\n示例：\n\nclaude "ultrathink 设计一个分布式缓存系统的架构"\n\n\n1\n\n\n\n# 运行模式\n\n\n# 非交互模式\n\nclaude -p "你的问题"\n\n\n1\n\n\n作用： 直接提问并获取答案，不进入交互式对话模式。\n\n示例：\n\nclaude -p "解释 JavaScript 的事件循环机制"\n\n\n1\n\n\n\n# MCP 连接器管理\n\nMCP (Model Context Protocol) 允许 Claude 连接外部工具和服务。\n\n\n# 添加 MCP 连接器\n\n# 添加用户级别的连接器\nclaude mcp add context7 --scope user -- npx -y @upstash/context7-mcp --api-key your-api-key\n\n# 添加 HTTP 传输连接器\nclaude mcp add --transport http chrome-mcp http://127.0.0.1:12306/mcp\n\n\n1\n2\n3\n4\n5\n\n\n\n# 移除 MCP 连接器\n\nclaude mcp remove context7\n\n\n1\n\n\n示例场景：\n\n * 连接数据库服务\n * 集成浏览器控制\n * 接入第三方 API\n\n\n# 权限管理\n\n\n# 查看权限\n\nclaude permissions\n\n\n1\n\n\n\n# 跳过权限检查（谨慎使用）\n\nclaude --dangerously-skip-permissions\n\n\n1\n\n\n注意： 此选项会跳过所有安全检查，仅在完全信任的环境中使用。\n\n\n# 自定义功能\n\n\n# 自定义命令\n\n在项目的 .claude/commands 目录下创建自定义命令脚本。\n\n示例：\n\n# 创建自定义命令\nmkdir -p .claude/commands\necho \'#!/bin/bash\\necho "执行项目构建..."\' > .claude/commands/build\nchmod +x .claude/commands/build\n\n# 使用自定义命令\nclaude /build\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Hooks（钩子函数）\n\n在 .claude/hooks 目录下设置在特定事件后执行的脚本。\n\n示例：\n\n# 创建后处理钩子\nmkdir -p .claude/hooks\necho \'#!/bin/bash\\necho "命令执行完成，运行测试..."\' > .claude/hooks/post-command\nchmod +x .claude/hooks/post-command\n\n\n1\n2\n3\n4\n\n\n\n# 高级功能\n\n\n# Sub Agent\n\nClaude Code 支持创建子代理来处理特定任务，实现任务分工和并行处理。\n\n\n# 历史对话管理\n\n# 查看对话历史\nclaude history\n\n# 搜索历史记录\nclaude history search "关键词"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 最佳实践\n\n\n# 1. 项目管理\n\n * 每个新项目都先运行 claude /init\n * 合理组织 .claude 目录结构\n * 使用版本控制管理配置文件\n\n\n# 2. 思考功能使用\n\n * 简单问题使用 think\n * 架构设计类问题使用 think harder 或 ultrathink\n * 根据问题复杂度选择合适级别\n\n\n# 3. 权限安全\n\n * 避免不必要使用 --dangerously-skip-permissions\n * 定期检查和更新权限设置\n * 在生产环境中特别注意权限管理\n\n\n# 4. 自定义优化\n\n * 将常用操作封装为自定义命令\n * 使用 hooks 实现自动化工作流\n * 合理配置 MCP 连接器\n\n\n# 5. 工作流程\n\n# 标准工作流程示例\nclaude /init                    # 初始化项目\nclaude /ide                     # 启动开发环境\nclaude "think hard 分析这个bug"  # 深度思考问题\nclaude mcp add database-tool     # 添加必要工具\n\n\n1\n2\n3\n4\n5\n\n\n\n# 故障排除\n\n\n# 常见问题及解决方案\n\n权限被拒绝\n\n# 检查文件权限\nls -la .claude/\n# 或使用权限选项\nclaude --help permissions\n\n\n1\n2\n3\n4\n\n\nMCP 连接失败\n\n# 检查服务状态\ncurl -f http://127.0.0.1:12306/mcp\n# 重新添加连接器\nclaude mcp remove problematic-connector\nclaude mcp add problematic-connector --transport http http://127.0.0.1:12306/mcp\n\n\n1\n2\n3\n4\n5\n\n\n自定义命令无法执行\n\n# 检查脚本权限\nchmod +x .claude/commands/your-command\n# 检查脚本语法\nbash -n .claude/commands/your-command\n\n\n1\n2\n3\n4\n\n\n\n# 获取帮助\n\n# 查看全局帮助\nclaude --help\n\n# 查看特定命令帮助\nclaude mcp --help\nclaude permissions --help\n\n# 查看版本信息\nclaude --version\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 高效使用技巧\n\n 1. 组合使用命令：将多个命令组合使用以实现复杂工作流\n 2. 利用历史记录：通过历史功能快速回顾和重用之前的解决方案\n 3. 定制开发环境：根据项目需求配置专属的 MCP 连接器和自定义命令\n 4. 合理使用思考功能：在复杂问题上投入更多思考 token，在简单问题上保持效率\n\n通过掌握这些命令和最佳实践，你可以充分发挥 Claude Code 的强大功能，显著提升开发效率和代码质量。',normalizedContent:'# claude code 命令教程\n\nclaude code 是一个强大的命令行工具，让开发者能够直接从终端与 claude ai 进行交互，实现高效的代码开发和问题解决。\n\n\n# 安装指南\n\n官方文档： https://docs.anthropic.com/zh-cn/docs/claude-code/overview\n\n智谱ai接入： https://docs.bigmodel.cn/cn/guide/develop/claude\n\n也可接入通义前问等模型\n\n\n# 基础命令\n\n\n# 项目初始化\n\nclaude /init\n\n\n1\n\n\n作用： 在当前目录初始化一个新的 claude code 项目，创建必要的配置文件和目录结构。\n\n示例：\n\ncd my-project\nclaude /init\n\n\n1\n2\n\n\n这将在项目根目录创建 .claude 配置目录，为后续开发做好准备。\n\n\n# 集成开发环境模式\n\nclaude /ide\n\n\n1\n\n\n作用： 启动交互式开发环境，提供更丰富的开发体验和持续对话能力。\n\n示例：\n\nclaude /ide\n# 进入交互模式，可以进行持续的代码讨论和修改\n\n\n1\n2\n\n\n\n# 思考增强功能\n\n\n# think 命令\n\nclaude think\n\n\n1\n\n\n作用： 为 claude 提供额外的思考时间，帮助处理复杂问题。有两种触发方式：\n\n * manual - 手动调用\n * auto - 上下文窗口满时自动触发\n\n\n# 思考级别关键词\n\n在提示中添加以下关键词，按复杂度递增排列：\n\n关键词            token 消耗   适用场景\nthink          最低         简单问题思考\nthink hard     中等         中等复杂度问题\nthink harder   较高         复杂逻辑问题\nultrathink     最高         极其复杂的问题\n\n示例：\n\nclaude "ultrathink 设计一个分布式缓存系统的架构"\n\n\n1\n\n\n\n# 运行模式\n\n\n# 非交互模式\n\nclaude -p "你的问题"\n\n\n1\n\n\n作用： 直接提问并获取答案，不进入交互式对话模式。\n\n示例：\n\nclaude -p "解释 javascript 的事件循环机制"\n\n\n1\n\n\n\n# mcp 连接器管理\n\nmcp (model context protocol) 允许 claude 连接外部工具和服务。\n\n\n# 添加 mcp 连接器\n\n# 添加用户级别的连接器\nclaude mcp add context7 --scope user -- npx -y @upstash/context7-mcp --api-key your-api-key\n\n# 添加 http 传输连接器\nclaude mcp add --transport http chrome-mcp http://127.0.0.1:12306/mcp\n\n\n1\n2\n3\n4\n5\n\n\n\n# 移除 mcp 连接器\n\nclaude mcp remove context7\n\n\n1\n\n\n示例场景：\n\n * 连接数据库服务\n * 集成浏览器控制\n * 接入第三方 api\n\n\n# 权限管理\n\n\n# 查看权限\n\nclaude permissions\n\n\n1\n\n\n\n# 跳过权限检查（谨慎使用）\n\nclaude --dangerously-skip-permissions\n\n\n1\n\n\n注意： 此选项会跳过所有安全检查，仅在完全信任的环境中使用。\n\n\n# 自定义功能\n\n\n# 自定义命令\n\n在项目的 .claude/commands 目录下创建自定义命令脚本。\n\n示例：\n\n# 创建自定义命令\nmkdir -p .claude/commands\necho \'#!/bin/bash\\necho "执行项目构建..."\' > .claude/commands/build\nchmod +x .claude/commands/build\n\n# 使用自定义命令\nclaude /build\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# hooks（钩子函数）\n\n在 .claude/hooks 目录下设置在特定事件后执行的脚本。\n\n示例：\n\n# 创建后处理钩子\nmkdir -p .claude/hooks\necho \'#!/bin/bash\\necho "命令执行完成，运行测试..."\' > .claude/hooks/post-command\nchmod +x .claude/hooks/post-command\n\n\n1\n2\n3\n4\n\n\n\n# 高级功能\n\n\n# sub agent\n\nclaude code 支持创建子代理来处理特定任务，实现任务分工和并行处理。\n\n\n# 历史对话管理\n\n# 查看对话历史\nclaude history\n\n# 搜索历史记录\nclaude history search "关键词"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 最佳实践\n\n\n# 1. 项目管理\n\n * 每个新项目都先运行 claude /init\n * 合理组织 .claude 目录结构\n * 使用版本控制管理配置文件\n\n\n# 2. 思考功能使用\n\n * 简单问题使用 think\n * 架构设计类问题使用 think harder 或 ultrathink\n * 根据问题复杂度选择合适级别\n\n\n# 3. 权限安全\n\n * 避免不必要使用 --dangerously-skip-permissions\n * 定期检查和更新权限设置\n * 在生产环境中特别注意权限管理\n\n\n# 4. 自定义优化\n\n * 将常用操作封装为自定义命令\n * 使用 hooks 实现自动化工作流\n * 合理配置 mcp 连接器\n\n\n# 5. 工作流程\n\n# 标准工作流程示例\nclaude /init                    # 初始化项目\nclaude /ide                     # 启动开发环境\nclaude "think hard 分析这个bug"  # 深度思考问题\nclaude mcp add database-tool     # 添加必要工具\n\n\n1\n2\n3\n4\n5\n\n\n\n# 故障排除\n\n\n# 常见问题及解决方案\n\n权限被拒绝\n\n# 检查文件权限\nls -la .claude/\n# 或使用权限选项\nclaude --help permissions\n\n\n1\n2\n3\n4\n\n\nmcp 连接失败\n\n# 检查服务状态\ncurl -f http://127.0.0.1:12306/mcp\n# 重新添加连接器\nclaude mcp remove problematic-connector\nclaude mcp add problematic-connector --transport http http://127.0.0.1:12306/mcp\n\n\n1\n2\n3\n4\n5\n\n\n自定义命令无法执行\n\n# 检查脚本权限\nchmod +x .claude/commands/your-command\n# 检查脚本语法\nbash -n .claude/commands/your-command\n\n\n1\n2\n3\n4\n\n\n\n# 获取帮助\n\n# 查看全局帮助\nclaude --help\n\n# 查看特定命令帮助\nclaude mcp --help\nclaude permissions --help\n\n# 查看版本信息\nclaude --version\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 高效使用技巧\n\n 1. 组合使用命令：将多个命令组合使用以实现复杂工作流\n 2. 利用历史记录：通过历史功能快速回顾和重用之前的解决方案\n 3. 定制开发环境：根据项目需求配置专属的 mcp 连接器和自定义命令\n 4. 合理使用思考功能：在复杂问题上投入更多思考 token，在简单问题上保持效率\n\n通过掌握这些命令和最佳实践，你可以充分发挥 claude code 的强大功能，显著提升开发效率和代码质量。',charsets:{cjk:!0},lastUpdated:"2025/09/06, 15:09:00",lastUpdatedTimestamp:1757171752e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/web.png",heroText:"OddFar's Notes",tagline:"我们在黑暗中并肩前行，走在各自的朝圣路上!",actionText:"立刻进入 →",actionLink:"/java/",bannerBg:"none",postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-bf924ecc",path:"/",headersStr:null,content:"黎明之前总有一段时间特别黑。",normalizedContent:"黎明之前总有一段时间特别黑。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 14:02:00",lastUpdatedTimestamp:1676644803e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"Java",link:"/java/",items:[{text:"Java-Se",items:[{text:"Java基础",link:"/java/se/initial-java/"},{text:"Java面向对象",link:"/java/se/object/"},{text:"Java常用类",link:"/java/se/commonly-used-class/"},{text:"Java集合框架",link:"/java/se/collection/synopsis/"}]},{text:"Java-Se进阶",items:[{text:"JUC多线程",link:"/java/se/thread/1/"}]},{text:"Java-ee",items:[{text:"JavaWeb",link:"/javaweb/"}]}]},{text:"数据库",items:[{text:"SQL 数据库",items:[{text:"MySQL",link:"/mysql/"}]},{text:"NoSQL 数据库",items:[{text:"Redis",link:"/redis/"},{text:"ElasticSearch",link:"/es/"},{text:"MongoDB",link:"/mongodb/"}]}]},{text:"框架",items:[{text:"数据库",items:[{text:"MyBatis",link:"/mybatis/study-note/"},{text:"MyBatis-Plus",link:"/mybatis-plus/study-note/"}]},{text:"Spring",items:[{text:"Spring",link:"/spring/"}]},{text:"中间件",items:[{text:"RabbitMQ",link:"/rabbitmq/"}]}]},{text:"工具|部署",items:[{text:"Git",link:"/git/"},{text:"Docker",link:"/docker/"},{text:"Jenkins",link:"/jenkins/"}]},{text:"AI",link:"/ai/"},{text:"爬虫",link:"/spider/"},{text:"项目",items:[{text:"Campus",link:"https://oddfar.github.io/campus-doc/"},{text:"校园信息墙",link:"https://oddfar.github.io/campus-doc/campus-example/"}]},{text:"关于",link:"/about/"},{text:"归档",link:"/archives/"}],sidebarDepth:2,logo:"/img/logo.png",repo:"oddfar/notes",searchMaxSuggestions:10,lastUpdated:"最后更新",docsDir:"docs",editLinks:!0,editLinkText:"在 GitHub 上编辑此页",pageStyle:"line",category:!1,tag:!1,sidebar:{"/00.目录页/":[["01.java.md","java","/java"],["10.关于.md","关于","/about"],["20.爬虫.md","爬虫","/spider"],["30.AI.md","AI专栏","/ai"]],catalogue:{java:"/java","关于":"/about","爬虫":"/spider",AI:"/ai",javaweb:"/javaweb",MySQL:"/mysql","Redis知识体系":"/redis",ElasticSearch:"/es","Mongo - 目录页":"/mongodb","RabbitMQ知识体系 ":"/rabbitmq",Git:"/git",Docker:"/docker","Jenkins - 目录页":"/jenkins"},"/01.Java/":[{title:"java-基础",collapsable:!0,children:[["02.java-基础/01.初识java.md","初识java","/java/se/initial-java/"],{title:"基础语法",collapsable:!0,children:[["02.java-基础/02.基础语法/01.注释.md","注释","/java/se/basic-grammar/annotation"],["02.java-基础/02.基础语法/02.标识符.md","标识符","/java/se/basic-grammar/identifier/"],["02.java-基础/02.基础语法/03.数据类型.md","数据类型","/java/se/basic-grammar/data-type/"],["02.java-基础/02.基础语法/04.类型转换.md","类型转换","/java/se/basic-grammar/type-conversion/"],["02.java-基础/02.基础语法/05.变量和常量.md","变量和常量","/java/se/basic-grammar/variate-constant/"],["02.java-基础/02.基础语法/06.运算符.md","运算符","/java/se/basic-grammar/operator/"],["02.java-基础/02.基础语法/07.包机制.md","包机制","/java/se/basic-grammar/packet/"],["02.java-基础/02.基础语法/08.JavaDoc.md","JavaDoc","/java/se/basic-grammar/javadoc/"]]},{title:"流程控制",collapsable:!0,children:[["02.java-基础/03.流程控制/01.用户交互Scanner.md","Scanner","/java/se/process-control/scanner/"],["02.java-基础/03.流程控制/02.顺序结构.md","顺序结构","/java/se/process-control/sequential-structure/"],["02.java-基础/03.流程控制/03.选择结构.md","选择结构","/java/se/process-control/case-structure/"],["02.java-基础/03.流程控制/04.循环结构.md","循环结构","/java/se/process-control/loop-structure"],["02.java-基础/03.流程控制/05.break和continue.md","break和continue","/java/se/process-control/break-continue"]]},["02.java-基础/04.方法.md","方法","/java/se/method/"],["02.java-基础/05.数组.md","数组","/java/se/array/"],["02.java-基础/07.异常机制.md","异常机制","/java/se/exception/"]]},{title:"java-面向对象",collapsable:!0,children:[["03.java-面向对象/06.面向对象.md","面向对象","/java/se/object/"]]},{title:"Java-常用类",collapsable:!0,children:[["04.Java-常用类/08.常用类.md","常用类","/java/se/commonly-used-class/"]]},{title:"Java-集合框架",collapsable:!0,children:[["05.Java-集合框架/01.集合概序.md","集合概序","/java/se/collection/synopsis"],["05.Java-集合框架/02.ArrayList.md","ArrayList","/java/se/collection/ArrayList"],["05.Java-集合框架/03.LinkedList.md","LinkedList","/java/se/collection/LinkedList"],["05.Java-集合框架/04.Vevtor和Stack.md","Vevtor和Stack","/java/se/collection/Vevtor-Stack/"],["05.Java-集合框架/05.List总结.md","List总结","/java/se/collection/List-summary/"],["05.Java-集合框架/06.HashMap.md","HashMap","/java/se/collection/HashMap/"],["05.Java-集合框架/07.Set.md","set","/java/se/collection/set/"],["05.Java-集合框架/08.HashSet.md","HashSet","/java/se/collection/HashSet/"],["05.Java-集合框架/09.TreeSet.md","TreeSet","/java/se/collection/TreeSet/"],["05.Java-集合框架/10.迭代器.md","迭代器","/java/se/collection/iterator/"],["05.Java-集合框架/11.泛型.md","泛型","/java/se/collection/generic-paradigm/"],["05.Java-集合框架/12.Collections工具类.md","Collections工具类","/java/se/collection/collections/"]]},{title:"Java-多线程",collapsable:!0,children:[["07.Java-多线程/02.JUC学习笔记.md","JUC学习笔记（上）","/java/se/thread/1"],["07.Java-多线程/05.JUC学习笔记.md","JUC学习笔记（下）","/java/se/thread/2"]]},{title:"JavaWeb",collapsable:!0,children:[["20.JavaWeb/00.javaweb.md","JavaWeb- 知识体系","/javaweb"],["20.JavaWeb/01.基本概念.md","JavaWeb - 基本概念","/pages/5916e7/"],["20.JavaWeb/02.Tomcat.md","JavaWeb - Tomcat","/pages/1ccdff/"],["20.JavaWeb/03.Http.md","JavaWeb - Http","/pages/7187be/"],["20.JavaWeb/04.Maven.md","JavaWeb - Maven","/pages/cb259f/"],["20.JavaWeb/05.servlet.md","JavaWeb - Servlet","/pages/e986b8/"],["20.JavaWeb/06.cookie和session.md","JavaWeb - Cookie和Session","/pages/d20044/"],["20.JavaWeb/20.总览.md","JavaWeb - 其它总览","/pages/e8021e/"]]}],"/03.数据库/":[{title:"MySQL",collapsable:!0,children:[["05.MySQL/02.MySQL.md","MySQL - 知识体系","/mysql"],["05.MySQL/04.MySQL - 逻辑架构.md","MySQL - 逻辑架构简介","/mysql/logic/"],["05.MySQL/06.MySQL - 索引.md","MySQL - 索引介绍","/mysql/index/"],["05.MySQL/10.MySQL - 优化SQL检测步骤.md","MySQL - 优化SQL检测步骤","/mysql/optimize-sql-check/"],["05.MySQL/12.MySQL - 索引的使用.md","MySQL - 索引的使用","/mysql/index-use/"],["05.MySQL/14.MySQL - SQL优化.md","MySQL - SQL语句优化","/mysql/sql-optimize/"],["05.MySQL/16.MySQL - 缓存查询.md","MySQL - 缓存查询","/mysql/cache-query/"],["05.MySQL/18.MySQL - 内存管理.md","MySQL - 内存管理","/mysql/memory-management/"],["05.MySQL/20.MySQL - 并发参数.md","MySQL - 并发参数","/mysql/concurrent-parameter/"],["05.MySQL/22.MySQL - 锁问题.md","MySQL - 锁问题","/mysql/lock-question/"],["05.MySQL/24.MySQL - 常用sql技巧.md","MySQL - 常用sql技巧","/mysql/common-use-sql-skill/"],["05.MySQL/26.MySQL - 常用工具.md","MySQL - 常用工具","/mysql/common-tools/"],["05.MySQL/28.MySQL - 日志.md","MySQL - 日志","/mysql/log/"],["05.MySQL/30.MySQL - 主从复制.md","MySQL - 主从复制","/mysql/copy/"]]},{title:"Redis",collapsable:!0,children:[["10.Redis/00.Redis知识体系.md","Redis - 知识体系","/redis"],["10.Redis/01.Redis - 入门.md","Redis - 概念和基础","/pages/28aa50/"],["10.Redis/02.五大数据类型.md","Redis - 五大数据类型","/pages/6ea36e/"],["10.Redis/03.三种特殊数据类型.md","Redis - 三种特殊数据类型","/pages/5898ab/"],["10.Redis/04.Redis事务.md","Redis - 事务","/pages/41f31b/"],["10.Redis/05.Redis - Java.md","Redis - Java","/pages/216cfe/"],["10.Redis/10.Redis学习笔记-总览.md","Redis - 学习笔记-总览","/pages/feab74/"]]},{title:"ElasticSearch",collapsable:!0,children:[["15.ElasticSearch/01.ElasticSearch.md","ElasticSearch - 知识体系","/es"],["15.ElasticSearch/02.ES - 基础概念.md","ES - ElasticSearch基础概念","/es/introduce"],["15.ElasticSearch/04.ES - 安装.md","ES - 安装ElasticSearch","/es/install"],["15.ElasticSearch/06.ES - 索引和文档的基本操作.md","ES - 索引和文档的基本操作","/es/index-doc/"],["15.ElasticSearch/08.ES - 高级查询操作.md","ES - 高级查询操作","/es/query/"],["15.ElasticSearch/10.ES - 索引管理.md","ES - 索引管理","/pages/8b85ee/"],["15.ElasticSearch/12.ES - 分词.md","ES - 分词","/pages/87178e/"]]},{title:"MongoDB",collapsable:!0,children:[["20.MongoDB/00.Mongo - 目录页.md","MongoDB - 知识体系","/mongodb"],["20.MongoDB/05.Mongo - 基础概念.md","Mongo - 基础概念","/pages/34c4ae/"],["20.MongoDB/10.Mongo - 安装和CRUD.md","Mongo - 安装和CRUD","/pages/f04bc7/"]]}],"/04.框架/":[{title:"mybatis",collapsable:!0,children:[["01.mybatis/01.学习笔记.md","mybatis学习笔记","/mybatis/study-note"]]},{title:"mybatis-plus",collapsable:!0,children:[["02.mybatis-plus/01.学习笔记.md","mybatis-plus学习笔记","/mybatis-plus/study-note"]]},{title:"Spring",collapsable:!0,children:[["03.Spring/01.spring - 目录页.md","spring","/spring/"]]},{title:"RabbitMQ",collapsable:!0,children:[["20.RabbitMQ/01.RabbitMQ知识体系 .md","RabbitMQ - 知识体系","/rabbitmq"],["20.RabbitMQ/02.中间件介绍.md","中间件介绍","/pages/e38dcb/"],["20.RabbitMQ/04.消息队列介绍.md","消息队列介绍","/pages/2c91a1/"],["20.RabbitMQ/06.RabbitMQ - 安装.md","RabbitMQ - 安装","/pages/f015b1/"],["20.RabbitMQ/08.RabbitMQ - 简单案例.md","RabbitMQ - 简单案例","/pages/95ce73/"],["20.RabbitMQ/10.RabbitMQ - 发布确认.md","RabbitMQ - 发布确认","/pages/ef9b33/"],["20.RabbitMQ/12.RabbitMQ - 交换机.md","RabbitMQ - 交换机","/pages/c9c254/"],["20.RabbitMQ/14.RabbitMQ - 死信队列.md","RabbitMQ - 死信队列","/pages/1477b8/"],["20.RabbitMQ/16.RabbitMQ - 延迟队列.md","RabbitMQ - 延迟队列","/pages/0a0086/"],["20.RabbitMQ/18.RabbitMQ - 发布确认高级.md","RabbitMQ - 发布确认高级","/pages/c94906/"],["20.RabbitMQ/20.RabbitMQ - 幂等性、优先级、惰性.md","RabbitMQ - 幂等性、优先级、惰性","/pages/ee71b9/"]]}],"/05.工具部署/":[{title:"Git",collapsable:!0,children:[["01.Git/00.Git.md","Git - 知识体系","/git"],["01.Git/01.Git简单提交.md","Git - 简单提交","/pages/7d2d32/"],["01.Git/02.SSH免密登录.md","Git - SSH免密登录","/pages/5747a6/"],["01.Git/04.Git - Commit常用表情.md","Git - Commit常用表情","/pages/fe0004/"],["01.Git/05.Git删除提交记录.md","Git - 删除提交记录","/pages/81663b/"],["01.Git/06.DS_Store.md","Git - DS_Store","/pages/0fc313/"],["01.Git/11.GitHub提速.md","GitHub - 提速","/pages/90bb76/"]]},{title:"Docker",collapsable:!0,children:[["10.Docker/01.Docker.md","Docker - 知识体系","/docker"],["10.Docker/02.Docker - 概述.md","Docker - 概述","/pages/09f2eb/"],["10.Docker/04.Docker - 安装.md","Docker - 安装","/pages/fc0548/"],["10.Docker/06.Docker - 常用命令.md","Docker - 常用命令","/pages/a25911/"],["10.Docker/08.Docker - 可视化.md","Docker - 可视化","/pages/4e8ad2/"],["10.Docker/10.Docker - 镜像和仓库.md","Docker - 镜像和仓库","/pages/982fe2/"],["10.Docker/12.Docker - 数据卷.md","Docker - 数据卷","/pages/d7cc4c/"],["10.Docker/14.Docker - DockerFile.md","Docker - DockerFile","/pages/786a41/"],["10.Docker/16.Docker - 网络.md","Docker - 网络","/pages/3b9d4b/"],["10.Docker/18.Docker - Compose.md","Docker - Compose","/pages/a38e01/"]]},{title:"Jenkins",collapsable:!0,children:[["30.Jenkins/01.Jenkins - 目录页.md","Jenkins - 知识体系","/jenkins"],["30.Jenkins/02.Jenkins - 介绍.md","Jenkins - 介绍","/pages/3dedc8/"],["30.Jenkins/04.从零开始用Jenkins自动构建部署SpringBoot项目.md","从零开始用Jenkins自动构建部署SpringBoot项目","/pages/ec9790/"]]}],"/10.关于/":[{title:"关于 - 我",collapsable:!0,children:[["01.关于 - 我/01.关于 - 我.md","关于 - 我","/pages/038c37/"]]},{title:"关于 - 本站",collapsable:!0,children:[["02.关于 - 本站/02.文档 -  快速上手.md","文档 - 快速上手","/pages/c6c456/"],["02.关于 - 本站/03.文档 - md文件写作.md","文档 - md文件写作","/pages/2a3030/"],["02.关于 - 本站/05.文档 - 部署.md","文档 - 部署","/pages/39f283/"],["02.关于 - 本站/11.标题 - 目录生成.md","标题 - 目录生成","/pages/2bde62/"],["02.关于 - 本站/12.标题 - 锚点比较.md","标题 - 锚点比较","/pages/8bac8d/"]]}],"/20.爬虫/":[["02.某度翻译.md","某度翻译","/pages/007827/"],["04.文档密码破解.md","文档密码破解","/pages/7de988/"]],"/30.AI/":[["01.AI 解读项目.md","AI 解读项目","/pages/86599a/"],["05.Claude Code教程.md","Claude Code教程","/pages/ec7818/"]]},updateBar:{showToArticle:!1},author:{name:"zhiyuan",href:"https://oddfar.com/"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:oddfar@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/oddfar"}]},footer:{createYear:2021,copyrightInfo:'oddfar | <a href="https://beian.miit.gov.cn/" target="_blank">冀ICP备20001094号</a>'}}};var wl=t(123),_l=t(124),Sl=t(21);var jl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(Sl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(Sl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Sl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,i=n.length;a<i;a++){const{frontmatter:{categories:i,tags:r}}=n[a];"array"===Object(Sl.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(Sl.n)(r)&&r.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(wl.default),Gt.component(_l.default);function El(n){return n.toString().padStart(2,"0")}t(276);Gt.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,397))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,123))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,124)));t(277);var Tl=[({Vue:n,options:e,router:t,siteData:a})=>{},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${El(n.getUTCMonth()+1)}-${El(n.getUTCDate())} ${El(n.getUTCHours())}:${El(n.getUTCMinutes())}:${El(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(jl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function a(n){var t=e.createElement("div");t.className="heart",i.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var i=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),a(n))}}(),function n(){for(var t=0;t<i.length;t++)i[t].alpha<=0?(e.body.removeChild(i[t].el),i.splice(t,1)):(i[t].y--,i[t].scale+=.004,i[t].alpha-=.013,i[t].el.style.cssText="left:"+i[t].x+"px;top:"+i[t].y+"px;opacity:"+i[t].alpha+";transform:scale("+i[t].scale+","+i[t].scale+") rotate(45deg);background:"+i[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)}],Cl=[];class ql extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(ql.prototype,{getPageAsyncComponent:so,getLayoutAsyncComponent:oo,getAsyncComponent:lo,getVueComponent:co});var Il={install(n){const e=new ql;n.$vuepress=e,n.prototype.$vuepress=e}};function Al(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ml={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return po("pageKey",e),Gt.component(e)||Gt.component(e,so(e)),Gt.component(e)?n(e):n("")}},zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ll={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Dl=(t(278),t(279),Object(yl.a)(Ll,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Rl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use(Hs),Gt.use(Il),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),r={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),r),{computed:r}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xl)),Gt.component("Content",Ml),Gt.component("ContentSlotsDistributor",zl),Gt.component("OutboundLink",Dl),Gt.component("ClientOnly",Rl),Gt.component("Layout",oo("Layout")),Gt.component("NotFound",oo("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:"030b8e9"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xl.routerBase||xl.base,t=new Hs({base:e,mode:"history",fallback:!1,routes:kl,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Al(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Al(n,t)?a(t):a()}else a();else{const t=e.path+"/",i=e.path+".html";Al(n,i)?a(i):Al(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Tl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:a,router:t,siteData:xl,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Cl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);