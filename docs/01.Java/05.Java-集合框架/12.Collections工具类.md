---
title: Collections工具类
date: 2021-04-16 16:19:25
permalink: /java/se/collection/collections/
categories:
  - java
  - java-se
  - 集合框架
---

## Collections工具类

【前言】

Java提供了一个操作Set、List和Map等集合的工具类：Collections，该工具类提供了大量方法对集合进 行排序、查询和修改等操作，还提供了将集合对象置为不可变、对集合对象实现同步控制等方法。

这个类不需要创建对象，内部提供的都是静态方法。

### 1、Collectios概述

![image-20210331222908814](https://testingcf.jsdelivr.net/gh/oddfar/static/img/JavaSE-集合.assets/image-20210331222908814.png)

此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。它包含在 collection 上操作的多态算法，即“包装器”，包装器返回由指定 collection 支持的新 collection，以及少数其他内容。如果为 此类的方法所提供的 collection 或类对象为 null，则这些方法都将抛出 NullPointerException 。



### 2、排序操作

```java
static void reverse(List<?> list)//反转列表中元素的顺序。

static void shuffle(List<?> list) //对List集合元素进行随机排序。

static void sort(List<T> list) //根据元素的自然顺序 对指定列表按升序进行排序

static <T> void sort(List<T> list, Comparator<? super T> c) //根据指定比较器产生的顺序对指定列表进行排序。
    
static void swap(List<?> list, int i, int j)   //在指定List的指定位置i,j处交换元素。

static void rotate(List<?> list, int distance)
 //当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度。
```

【演示】

```java
public static void main(String[] args) {
    ArrayList list = new ArrayList();
    list.add(3);
    list.add(-2);
    list.add(9);
    list.add(5);
    list.add(-1);
    list.add(6);

    //输出：[3, -2, 9, 5, -1, 6]
    System.out.println(list);
    //集合元素的次序反转
    Collections.reverse(list);
    //输出：[6, -1, 5, 9, -2, 3]
    System.out.println(list);
    //排序：按照升序排序
    Collections.sort(list);
    //[-2, -1, 3, 5, 6, 9]
    System.out.println(list);
    //根据下标进行交换
    Collections.swap(list, 2, 5);
    //输出：[-2, -1, 9, 5, 6, 3]
    System.out.println(list);
    
    /*//随机排序
    Collections.shuffle(list);
    //每次输出的次序不固定
    System.out.println(list);*/
    
    //后两个整体移动到前边
    Collections.rotate(list, 2);
    //输出：[6, 9, -2, -1, 3, 5]
    System.out.println(list);
}
```

【演示】

创建学生集合，加入数据，并**自定义排序**，先根据年龄，再根据首字母

pojo类

```java
public class Student {
    public String name;
    public int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

test代码

```java
public static void main(String[] args) {
    ArrayList<Student> array = new ArrayList<>();
    Student s1 = new Student("lingqingxia",20);
    Student s2 = new Student("wangxizhi",30);
    Student s3 = new Student("libai",25);
    Student s4 = new Student("dufu",25);
	//Student s5 = new Student("dufu",25);

    array.add(s1);
    array.add(s2);
    array.add(s3);
    array.add(s4);
	//array.add(s5);
    Collections.sort(array, new Comparator<Student>() {
        @Override
        public int compare(Student o1, Student o2) {
            int i = o1.age-o2.age;
            int n = i==0?o1.name.compareTo(o2.name):i;
            return n;
        }
    });

    for (Student s:array){
        System.out.println(s.name+","+s.age);
    }
}
```

### 3、查找、替换操作

【方法】

```java
//使用二分搜索法搜索指定列表，以获得指定对象在List集合中的索引。
//注意：此前必须保证List集合中的元素已经处于有序状态。
static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)

//根据元素的自然顺序，返回给定collection 的最大元素。
static Object max(Collection coll)

   	//根据指定比较器产生的顺序，返回给定 collection 的最大元素。
    static Object max(Collection coll,Comparator comp)

    //根据元素的自然顺序，返回给定collection 的最小元素。
    static Object min(Collection coll)
    
    //根据指定比较器产生的顺序，返回给定 collection 的最小元素。
    static Object min(Collection coll,Comparator comp)
    
    使用指定元素替换指定列表中的所有元素。
    static <T> void fill(List<? super T> list, T obj)
    
    //返回指定 collection 中等于指定对象的出现次数。
    static int frequency(Collection<?> c, Object o)
    
    //返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1。
    static int indexOfSubList(List<?> source, List<?> target) 
    
    //返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回-1。
    static int lastIndexOfSubList(List<?> source, List<?> target)
    
    //使用一个新值替换List对象的所有旧值oldVal
    static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)

```

【演示：实例使用查找、替换操作】

```java
public static void main(String[] args) {
    ArrayList list = new ArrayList();
    list.add(3);
    list.add(-2);
    list.add(9);
    list.add(5);
    list.add(-1);
    list.add(6);
    //[3, -2, 9, 5, -1, 6]
    System.out.println(list);
    //输出最大元素9
    System.out.println(Collections.max(list));
    //输出最小元素：-2
    System.out.println(Collections.min(list));
    //将list中的-2用1来代替
    System.out.println(Collections.replaceAll(list, -2, 1));
    //[3, 1, 9, 5, -1, 6]
    System.out.println(list);
    list.add(9);
    //判断9在集合中出现的次数，返回2
    System.out.println(Collections.frequency(list, 9));
    //对集合进行排序
    Collections.sort(list);
    //[-1, 1, 3, 5, 6, 9, 9]
    System.out.println(list);
    //只有排序后的List集合才可用二分法查询，输出2
    System.out.println(Collections.binarySearch(list, 3));
}
```

### 4、同步控制

Collectons提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从 而解决多线程并发访问集合时的线程安全问题。

正如前面介绍的HashSet，TreeSet，arrayList,LinkedList,HashMap,TreeMap都是线程不安全的。 Collections提供了多个静态方法可以把他们包装成线程同步的集合。

【方法】

```java
//返回指定 collection 支持的同步（线程安全的）collection。
static <T> Collection<T> synchronizedCollection(Collection<T> c)
    
//返回指定列表支持的同步（线程安全的）列表。
static <T> List<T> synchronizedList(List<T> list)

//返回由指定映射支持的同步（线程安全的）映射。
static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)

//返回指定 set 支持的同步（线程安全的）set
static <T> Set<T> synchronizedSet(Set<T> s)
```

【实例】

```java
public static void main(String[] args) {
    //下面程序创建了四个同步的集合对象
    Collection c = Collections.synchronizedCollection(new ArrayList());
    List list = Collections.synchronizedList(new ArrayList());
    Set s = Collections.synchronizedSet(new HashSet());
    Map m = Collections.synchronizedMap(new HashMap());

}
```

### 5、Collesction设置不可变集合

【方法】

```java
//返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。
emptyXxx()

//返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。
singletonXxx()
    
//返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。
unmodifiableXxx():
```

上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。

【实例】

```java
public static void main(String[] args) {
    //创建一个空的、不可改变的List对象
    List<String> unmodifiableList = Collections.emptyList();
    //unmodifiableList.add("java");
    //添加出现异常：java.lang.UnsupportedOperationException
    System.out.println(unmodifiableList);// []
    //创建一个只有一个元素，且不可改变的Set对象
    Set unmodifiableSet = Collections.singleton("Struts2权威指南");
    //[Struts2权威指南]
    System.out.println(unmodifiableSet);
    //创建一个普通Map对象
    Map scores = new HashMap();
    scores.put("语文", 80);
    scores.put("Java", 82);
    //返回普通Map对象对应的不可变版本
    Map unmodifiableMap = Collections.unmodifiableMap(scores);
    //下面任意一行代码都将引发UnsupportedOperationException异常
    unmodifiableList.add("测试元素");
    unmodifiableSet.add("测试元素");
    unmodifiableMap.put("语文", 90);
    
}
```

### 总结和测试

实体类：Pojo

```java
import java.util.*;


public class CollectionsTest {
    public static void main(String[] args) {
        //创建一个空的、不可改变的List对象
        List<String> unmodifiableList = Collections.emptyList();
        //unmodifiableList.add("java");
        //添加出现异常：java.lang.UnsupportedOperationException
        System.out.println(unmodifiableList);// []
        //创建一个只有一个元素，且不可改变的Set对象
        Set unmodifiableSet = Collections.singleton("Struts2权威指南");
        //[Struts2权威指南]
        System.out.println(unmodifiableSet);
        //创建一个普通Map对象
        Map scores = new HashMap();
        scores.put("语文", 80);
        scores.put("Java", 82);
        //返回普通Map对象对应的不可变版本
        Map unmodifiableMap = Collections.unmodifiableMap(scores);
        //下面任意一行代码都将引发UnsupportedOperationException异常
        unmodifiableList.add("测试元素");
        unmodifiableSet.add("测试元素");
        unmodifiableMap.put("语文", 90);

    }

}
```

测试类代码如下

```java
import java.util.ArrayList;
import java.util.List;

public class Test01 {
    public static void main(String[] args) throws Exception {
        //一个对象对应了一行记录！
        Employee e1 = new Employee(0301, "狂神", 3000, "项目部", "2017-10");
        Employee e2 = new Employee(0302, "小明", 3500, "教学部", "2016-10");
        Employee e3 = new Employee(0303, "小红", 3550, "教学部", "2016-10");
        List<Employee> list = new ArrayList<Employee>();
        list.add(e1);
        list.add(e2);
        list.add(e3);
        printEmpName(list);
    }

    public static void printEmpName(List<Employee> list) {
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i).getName() + "-" + list.get(i).getHireDate());
        }
    }
}
```

### 斗地主案例

简易版本

```java
public static void main(String[] args) {
    ArrayList<String> array = new ArrayList<>();

    String[] colors = {"方片", "梅花", "黑桃", "红桃"};
    String[] numbers = {"1","2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"};

    for (String c : colors) {
        for (String n : numbers) {
            array.add(c + n);
        }
    }
    array.add("小王");
    array.add("大王");
    Collections.shuffle(array);//洗牌

    //发牌
    ArrayList<String> wj1 = new ArrayList<>();//玩家1
    ArrayList<String> wj2 = new ArrayList<>();
    ArrayList<String> wj3 = new ArrayList<>();
    ArrayList<String> dp = new ArrayList<>();//底牌


    for (int i = 0; i < array.size(); i++) {
        String s = array.get(i);
        if (i >= array.size() - 3) {
            dp.add(s);
        }else{
            int i1 = i % 3;
            switch (i1){
                case 0:
                    wj1.add(s);
                    break;
                case 1:
                    wj2.add(s);
                    break;
                case 2:
                    wj3.add(s);
                    break;
            }
        }
    }
    //看牌
    System.out.println("底牌："+dp);
    System.out.println("玩家1的牌"+wj1);
    System.out.println("玩家2的牌"+wj2);
    System.out.println("玩家3的牌"+wj3);

}
```


>底牌：[梅花1, 黑桃2, 红桃Q]
>
>玩家1的牌[黑桃10, 大王, 方片7, 梅花5, 方片9, 方片3, 黑桃4, 红桃8, 梅花4, 红桃9, 红桃2, 红桃4, 小王, 方片K, 红桃6, 黑桃6, 红桃K]
>
>玩家2的牌[红桃1, 红桃7, 黑桃7, 方片J, 红桃J, 梅花3, 梅花7, 梅花8, 梅花9, 梅花2, 梅花J, 红桃10, 方片10, 黑桃5, 方片1, 黑桃K, 黑桃Q]
>
>玩家3的牌[方片5, 方片4, 黑桃9, 方片8, 黑桃3, 方片Q, 方片6, 红桃5, 梅花6, 黑桃8, 黑桃1, 梅花Q, 红桃3, 梅花10, 方片2, 梅花K, 黑桃J]

可以看到，能实现洗牌，发牌，看牌

但是牌的顺序不是从小到大的，我们来改进一下

![image-20210331233413189](https://testingcf.jsdelivr.net/gh/oddfar/static/img/JavaSE-集合.assets/image-20210331233413189.png)

1. 用HashMap键值对从0到53序号，存储牌
2. 用ArrayList存牌的序号
3. 用TreeSet存玩家的牌的序号，TreeSet可以自动排序
4. 通过TreeSet的序号，从HashMap中查取牌

```java
public class Poker {
    public static void main(String[] args) {
        //编号，牌
        HashMap<Integer,String> hm = new HashMap<>();
        //储存编号
        ArrayList<Integer> array = new ArrayList<>();

        String[] colors = {"方片", "梅花", "黑桃", "红桃"};
        String[] numbers = { "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K","A","2"};
        int index=0;
        for (String c:colors){
            for (String n:numbers){
                hm.put(index,c+n);
                array.add(index);
                index++;
            }
        }
        hm.put(index,"小王");
        array.add(index);
        index++;
        hm.put(index,"大王");
        array.add(index);

        Collections.shuffle(array);//洗牌
        //发牌
        TreeSet<Integer> wj1 = new TreeSet<>();//玩家1
        TreeSet<Integer> wj2 = new TreeSet<>();
        TreeSet<Integer> wj3 = new TreeSet<>();
        TreeSet<Integer> dp  = new TreeSet<>();//底牌

        for (int i = 0; i < array.size(); i++) {
            Integer s = array.get(i);
            if (i >= array.size() - 3) {
                dp.add(s);
            }else{
                int i1 = i % 3;
                switch (i1){
                    case 0:
                        wj1.add(s);
                        break;
                    case 1:
                        wj2.add(s);
                        break;
                    case 2:
                        wj3.add(s);
                        break;
                }
            }
        }
        lookpoke("玩家1",wj1 ,hm);
        lookpoke("玩家2",wj2 ,hm);
        lookpoke("玩家3",wj3 ,hm);
        lookpoke("底牌",dp ,hm);

    }
    public  static void lookpoke(String name,TreeSet<Integer> ts,HashMap<Integer,String> hm){
        System.out.print(name+"的牌：   ");
        for (Integer t:ts){
            System.out.print(hm.get(t)+" ");
        }
        System.out.println();

    }
}
```