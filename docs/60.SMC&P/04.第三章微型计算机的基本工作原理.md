---
title: 第三章 指令系统与汇编语言程序设计
date: 2021-06-16 08:00:00
permalink: /SMC&P/note/3
author: 
    name: eric
    href: https://wfmiss.cn
---
# 第三章 指令系统与汇编语言程序设计

```txt
三、指令系统与汇编语言程序设计
（一）知识范围
指令系统的概念、指令格式；
对操作数的寻址方式；
常用指令（传送指令、算术运算指令、逻辑运算和移位指令、串操作指令、程序控制指令与处理器控制指令）；
汇编语言程序的基本结构；
常用伪指令（数据定义、符号定义、段定义、设定段寄存器）；
DOS功能调用（输入/输出字符、输入/输出字符串、结束程序）；
三种结构（顺序结构、分支结构和循环结构）程序设计；
常用程序设计举例。
（二）考核要求
1.	理解指令系统的概念及指令格式。
2.	掌握常用的寻址方式并能熟练地使用它们。
3.	掌握常用指令的格式、功能和使用方法，分析各种指令执行后的结果。
4.	掌握指令对状态标志的影响。
5.	掌握常用伪指令的格式和功能。
6.	掌握汇编语言源程序的构成，熟练掌握汇编语言程序上机调试运行过程。
7.	理解程序的三种基本结构，能够使用汇编语言解决常见的问题。
8.
```

## 1. 指令系统及指令格式

特点：

- 指令系统的兼容性
- 指令系统的灵活性
- 寻址方式的多样性
- 可对多种类型的数据进行处理
- 可构成多处理机系统

**指令：**控制计算完成特定操作的命令

**指令系统：**指令系统是计算机能够执行全部命令的集合，它其取决于计算机的硬件设计。指令系统因机而异，没有通用性。

指令中应包含的信息：执行的运算、运算结果的去向、运算数据的来源

**指令格式：**

```txt
操作码		 [操作数]	,	[操作数]
----- 	   --------     --------
   |			|			|
执行何种操作	目的操作数  ， 源操作数【参加操作的数据】

源操作数：指令加工前的数据
目的操作数：指令加工之后形成的数据

零操作数指令：操作码
单操作数指令：操作码	操作数
双操作数指令：操作码	目的操作数，源操作数

操作数形式：
立即数、寄存器、存储器
```

**********

### 1.1操作数形式

**立即数操作数：**

- 表示参加操作的数据本身，可以是8位或16位；
- 立即数无法作为目标操作数；
- 立即数可以是无符号或带符号数，其数值应在可取值范围内。

**寄存器操作数：**

- 表示参加运算的数存放在指令给出的寄存器中，可以是16位或8位。

**存储器操作数：**

- 表示当前参加运算的数存放在存储器的某一个或两个单元中。

**指令的字长与指令的执行速度：**

- 指令字长由操作码的长度、操作数地址长度、操作数个数决定
- 8088/8086 CPU采用变字长指令格式
- 指令的字长影响指令执行的速度
- 对不同的操作数，指令执行的时间不同：

```txt
存储器 → 立即数 → 寄存器
----------------------
慢		→		  快
```

***********************

### 1.2 8086的操作码

指令由操作码（Opcode）和操作数（地址码）组成。8086 的指令长度是可变的，一条指令般由 1~6字节组成（加上前级字节，最长可为7宇节)。指令的操作码采用二进制代码表示本指会所执行的操作，通常用指令的第一个字节表示。有时由于用8位不够，因此在指令的第二个字节中还可能占了位。除此以外的其他字节 （或位）用来表示操作数。
在多数操作码中，使用某些位来指示有关信息，常用的符号及含义如下：
◎W（字位）：表示本指令是对字（W=1）还是对字节（W=0）操作。

◎D（方向位）：表示参加操作的寄存器是作为目的操作数寄存器（D=1）还是作为源操作数寄存器（D=0）。

◎S（符号扩展位）：用于某些立即寻址的机器指令中。如果立即数为8位，但要求扩展成16位，则S=1；否则，S=0（所扩展的高8位要根据8位立即数的最高位来定）。

**********

### 1.3 8086指令中寄存器的编码

1. 指令的二进制一般形式

8086指令的二进制一般形式如下：`操作码 d/v/s w`

2. 编码模式

编码方式主要有以下三种：段寄存器编码、通用寄存器编码、内存寻址编码。

- 段寄存器编码

| 编码 | 段寄存器编码 |
| ---- | ------------ |
| 00   | ES           |
| 01   | CS           |
| 10   | SS           |
| 11   | DS           |

- 通用寄存器编码

| 编码 | 16位寄存器名 | 8位寄存器名 |
| ---- | ------------ | ----------- |
| 000  | AX           | AL          |
| 001  | CX           | CL          |
| 010  | DX           | DL          |
| 011  | BX           | XL          |
| 100  | SP           | AH          |
| 101  | BP           | CH          |
| 110  | SI           | DH          |
| 111  | DI           | BH          |

- 内存寻址编码

| r/m编码 | 基址寄存器 | 变址寄存器 |
| ------- | ---------- | ---------- |
| 000     | BX     +   | SI         |
| 001     | BX     +   | DI         |
| 010     | BP     +   | SI         |
| 011     | BP      +  | DI         |
| 100     |            | SI         |
| 101     |            | SI         |
| 110     | BP         |            |
| 111     | BX         |            |

8086指令中通常使用一个或两个操作数，在少数指令中隐含的第三个操作数。

### 1.4指令的寻址方式

指令的寻址方式就是寻找指令操作数所在地址的方式，以确定数据的来源和去处。

1. **立即寻址（立即数寻址）：**

指令操作数部分直接给出指令的操作数，它与指令操作码相接，顺序存放在代码中。立即数有8位和16位之分。

注意：

- 立即寻址方式只能用于源操作数，主要用于给寄存器赋值。
- 立即寻址方式不执行总线周期，执行速度快。

************

2. **寄存器寻址：**

- 操作数放在寄存器内，由指令直接给出某个寄存器的名字，以寄存器的内容作为操作数。
- 寄存器可以是16位的AX、BX、CX、DX、SI、DI、SP、BP寄存器，也可以是8位的AH、AL、BX、XL、CH、CL、DH、DL寄存器。

注意：

- 寄存器寻址方式的指令操作在CPU内部执行，不需要执行总线周期，执行速度快。
- 寄存器寻址方式既适用于指令的源操作数，也适用于目的操作数，并且可同时使用于源操作数和目的操作数。

*********

3. **直接寻址：**

操作数在存储器中，指令中直接给出操作数所在存储单元的有效地址EA，即段内偏移地址，表示操作数所在存储单元距离段首址的字节数。有效地址是一个无符号的16位二进制数。（直接给出偏移地址）

注意：

- 直接寻址方式的操作数所在存储单元的短地址一般在数据段寄存器DS中。（默认DS段）
- 如果操作数在其他段，则需要在指令中用段超越前缀指出相应的段寄存器名。

***********

4. **寄存器间接寻址：**

- 操作数在存储器中，指令中寄存器的内容作为操作数所在单元的有效地址EA（偏移地址）。寄存器仅限于BX、BP、SI、DI。

```txt
	|[SI]
	|[DI]
EA- |[BX]
	|[BP]
```

- 当使用BX、SI、DI时，操作数所在存储单元的段地址存在数据段寄存器DS中。
- 当使用BP时，操作数所在存储单元的段地址存在堆栈段寄存器SS中。

注意：

- 只有SI、DI、BX、BP可作为间接寻址器。
- 若操作指令所在存储单元不在数据段DS中，需要在指令中用段超越前缀表明其所在段的段名。

*********

5. **基址寻址：**

- 操作数在存储器内，指令中寄存器（BX或BP）的内容与指令指定的位移量之和作为操作数所在存储单元的有效地址EA（偏移地址）。

```txt
	|[BX]|
EA= |	 |->[8位或16位位移量]
	|[BP]|
```

- 当使用BX时，段地址为DS的内容；
- 当使用BP时，段地址为SS的内容。

**********

6. **变址寻址：**

- 操作数在存储器内，指令将变址寄存器SI、DI内容与指令指定的偏移位移量之和作为操作数所在存储单元的有效地址EA（偏移地址）。段地址规定为DS的内容。

```txt 
	|[SI]|
EA= |	 |->[8位或16位位移量]
	|[DI]|
```

*****

7. **基址加变址寄存器：**

- 操作数在内部寄存器内。指令将基址寄存器BX、BP与变址寄存器SI、DI的内容之和再加上之前的偏移量（8位或16位），得到操作数所在存储单元的有效地址EA。

```txt
	|[SI]|	 |[SI]|
EA= |	 | + |	  | + ->[8位或16位位移量]
	|[DI]|	 |[DI]|
```

- 当使用BX时，段地址寄存器为DS。
- 当使用BP时，段地址寄存器为SS。

```txt
MOV 寄存器,[BX/BP+SI/DI+n]
 // n为16进制地址,
```

******

8. **字符串寻址：**

- 用于字符串操作指令。规定变址寄存器SI中的内容是源数据串的段内偏移地址，而变址寄存器DI中的内容是目标数据串的段内偏移地址。
- 源数据串的地址规定是数据段DS，目标数据串的段地址规定是附加段ES。指令执行后SI和DI的内容自动增量（或减量），增（或减）值为1或2。

****

9. **I/O端口寻址：**（独立编址）

- 寻址输入输出设备的端口地址，可分为直接端口寻址和间接端口寻址。
- 直接端口寻址：由指令直接给出I/O设备的端口地址。它规定端口地址为8位，能寻址256个端口
- 间接端口寻址：由DX给出I/O设备的端口地址。由于DX是16位，因此间接端口地址能寻址多达64K个端口。

例如：

```txt
IN AL,20H;	将地址为20H的外设内容读入AL中。
OUT DX,AL;	AL中内容输出给以DX的内容为地址的外设。
```

*********

10. **隐含寻址：**

指令隐含了的一个或两个操作数的地址，即操作数在默认的地址中。

例如：

```txt
AAA;	对AL中的内容进行十进制加法调整，并把调整后的结果放入AH和AL中。这条指令的隐含操作数是AH和AL。
```



## 2.8086的指令系统

指令系统包括九大类、133种基本指令，通过寻址方式的变化与数据形式（字节、字型）的组合，可构成上千条指令。指令系统按功能分为：数据传送类、算数运算类、逻辑运算与移位类、串操作类、控制转移类、处理机控制、输入输出、中断等。

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210609231517.png)

******

### 2.1传送类指令

#### 2.1.1数据传送指令

数据传送类指令实现CPU内部寄存器之间、CPU与内存储器之间、CPU与I/O端口之间的数据传送。

**通用数据传送指令**

包括MOV、进栈（PUSH）、出栈指令（POP）、交换指令和换码指令。

- 一般数据传送指令MOV（8位/16位）

```txt
格式：MOV	OP目的操作数,OP源操作数
功能：OP源操作数 ——> OP目的操作数
要求：OP目 可以是寄存器（除CS外）、存储器 OP源可以是寄存器、存储器和立即数。
```

<img src="https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210609170714.png" style="zoom: 33%;" />

该指令有如下9种形式：

```txt
MOV REG,REG			;通用寄存器间传送
MOV REG,IMM			;立即数送通用寄存器
MOV MEM,IMM			;立即数送存储器
MOV MEM,REG			;通用寄存器送存储器
MOV REG,MEM			;存储器送通用寄存器
MOV SEGREG,REG		;通用寄存器送段寄存器（CS除外）
MOV REG,SEGREG		;段寄存器送通用寄存器（含CS）
MOV SEGREG,MEM		;存储器送通用寄存器（CS除外）
MOV MEM,SEGREG		;段寄存器送存储器（含CS）
```

注意：

- MOV指令的两个操作数（源、目的）均可采用不同的寻址方式。
- 源操作数和目的操作数的类型必须一致。
- 源和目的不能都是存储器操作数。
- 不允许把立即数做目的操作数，也不允许向段寄存器（CS、DS、SS、ES）送立即数。

- 不允许在段寄存器之间、存储单元之间传送数据。
- CS、IP寄存器不能用作目的操作数。
- 一般传指令不影响标志位。

******

**堆栈操作指令**

堆栈：是按 “后进先出” 原则工作的一段存储区域。

堆栈寄存器SS —— 段地址

堆栈指针SP —— 始终单前栈顶所在的存储单元地址，即最新入栈数据所在存储单元的地址。

**压栈操作(进栈指令)：`PUSH OP(源操作数)`**

功能：把OP(源操作数)字节数据压入栈中，结果SP-2 ——> SP

原则：高字节压在高地址，低字节压在低地址

执行过程：

```txt
SP <-- SP - 1;		[SP] <-- OPH
SP <-- SP - 1;		[SP] <-- OPL
```

堆栈操作总是对16位的数据进行，指令中目的操作数隐含为堆栈。进栈操作把数据传输到以SS为段基址、SP为偏移地址的栈中。其操作过程如下：

- SP减一，指示堆栈中可以存放数据的位置，存放源操作数的高8位。
- SP再减一，存源操作数的迪8位，完成进栈操作。

**出栈操作(出栈指令)：`POP OP(目操作数)`**

功能：从栈中弹出数据 ——> OP(目操作数)，结果SP+2——>SP

执行过程：

```txt
OPL <-- [SP];		SP <—— SP+1
OPH <-- [SP];		SP <—— SP+1
```

例如：

```txt
已知：AX=1122H,BX=3344H,SP=1010H
执行指令：PUSH AX
		PUSH BX
		POP AX
		POP BX
执行后AX，BX，SP的结果？
解：AX=3344H
   BX=1122H
   SP=1010H
```

注意：

- 堆栈操作总是按字进行的。
- 压入指令，SP-2，数据在栈顶。弹出指令正好相反。
- 操作数可以是存储器、寄存器或段寄存器操作数 （CS不能用于POP），不能是立即数。

**********

#### 2.1.2目标地址传送指令

此类指令的功能是将操作数所在存储器的地址送入目标寄存器。

注意：

- OP源必须是存储器操作数，OP目必须是16为的通用寄存器。
- 地址传输指令不影响状态标志位。

*********

**取有效地址指令**

格式：`LEA 16位寄存器(OP目的操作数),源操作数偏移地址(OP源操作数)`

功能：存储器地址送到一个寄存器。

例如：

```txt
LEA SI,[2040H]
指令执行后，SI中的内容为2040H。又如：
MOV SI,[2040H]
指令执行后，SI中有偏移地址为2040H单元中的内容，而不是2040H这个值。
```

***********

**将地址指针装到DS和另一个寄存器的指令**

格式：`LDS 16位寄存器(OP目的操作数),源操作数偏移地址(OP源操作数)`

功能：把OP源指定的4个字节内容取出，低地址的两个字节—>OP目，高地址的两个字节—>DS。

例如：

```txt
LDS DI,[2130H]
2130H和2131H的单元中的内容送到DI；
2132H和2133H的单元中的内容送到DS；
```

************

**将地址指针装到ES和另一个寄存器的指令**

格式：`LES 16位寄存器(OP目的操作数),源操作数偏移地址(OP源操作数)`

功能：本指令与LDS指令的操作数基本相同，所不同的是将OP源4个字节中的高地址的两个字节—>ES。

例如：

```txt
LES DI,[2130H]
2130H和2131H的单元中的内容送到DI；
2132H和2133H的单元中的内容送到ES；
```

************

#### 2.1.3标志寄存器传送指令

**读取标志指令**

格式：`LAHF ; AH <— 标志寄存器低八位`

特点：此指令操作结果不影响标志寄存器。

********

**设置标志指令**

格式：`SAHF ; 标志寄存器低8位 <— AH`

特点：此之指令直接为标志寄存器的低8位赋值。

*******

**对标志寄存器的堆栈操作指令**

格式：`PUSHF ; 将标志寄存器的值压栈。`

​			`POPF ; 从栈顶弹出一个字送标志寄存器。`

特点：

- PUSHF不影响标志寄存器，而POPF直接为标志寄存器赋值。
- 通常两条指令成对出现，用来保护和恢复标志寄存器的内容。

**************

#### 2.1.4累加器专用传输指令

**数据交换指令**

格式：`XCHG OP1(目的操作数),OP1(源操作数)`

功能：实现OP1和OP2的内容的相互交换。

操作数：通用寄存器或存储器，但不能均为内存单元。

注意：段寄存器和IP不能作为交换指令的操作数。

***********

**换码指令（查表指令、翻译指令）**

换码指令是一条完成字节翻译功能的指令。它可以使累加器中的一个值变化为内存表格中的某一个值，一般用来实现编码制的转换。

格式：XLAT

功能：

```txt
[BX+AL] —> AL
	|----> EA
```

说明：将BX和AL内容相加作为有效地址EA，在一个表格中找出此单元中的内容—>AL。

BX——表格的首地址

AL——相对于表格首地址的位移量（要装换的代码）

注意：

- 使用前，先建立被转换代码（字节型）的数据表。
- 换码指令只能使用寄存器BX、AL，不影响标志位。

*************

**输入指令**

格式：`IN AL,n`

​			`IN AX,n`

​			`IN AL,DX`

​			`IN AX,DX`

说明：以上四种指令格式分别是8位/16位端口地址组合形式；指令中n表示为8位端口地址（00H~FFH），此时地址线高8位默认为0；当端口地址为16位时，指令中采用寄存器间接寻址，应先将16位端口地址传输到DX中，然后DX中的地址在IN指令中间接寻址。

*********

**输出指令**

**输入指令**

格式：`OUT n,AL`

​			`OUT n,AX`

​			`IN DX,AL`

​			`IN DX,AX`

OUT指令除源操作数和目的操作数与IN指令相反外，其他相同。

可见，无论是输入指令还是输出指令，其中地址部分的寻址方式要么是直接寻址，要么是寄存器寻址。

### 2.2算数运算类指令

8086的算数运算类指令能够对二进制或十进制（BCD码）数进行加、减、乘、除运算，操作数的数据形式可以是8位或16位的无符号数或带符号数。

#### 2.2.1加法指令

**不带进位的加法指令：**

格式：`ADD OP目,OP源 `

功能：OP目<— OP源+OP目，根据结果设置标志位（FR）。

注意：两操作数的类型相同，类型明确，不能同为存储器操作数。

**进位的加法指令**

格式：`ADC OP目,OP源`

功能：OP目<—OP源+OP目+CF，置标志位

说明：只要用于多字节运算，多字节运算时低位字节产生进位应加到高位。 

**加1指令**

格式：INC OP

功能：OP <— OP+1

说明：常用于修改偏移地址和计数次数。操作数可以是8/16位通用寄存器操作数，不能为立即数。

注意：

- INC指令不影响CF位，影响标志位AF、OF、PF、SF和ZF。
- 操作数视为无符号数。

总结：以上三条指令运算结果将影响状态标志位，但INC不影响标志CF。

#### 2.2.2减法指令

**不带借位的减法指令**

格式：`SUB OP目,OP源`

功能：OP目<— OP目-OP源，并根据结果设置标志

说明：

- 指令的目的操作数不能是立即寻址；
- 减法操作中产生的借位进入CF标志；
- 无符号操作数相减，若CF=1，则结果为补码；
- 带符号操作数相减要考虑溢出。

**带借位的减法指令**

格式：`SBB OP目,OP源`

功能：OP目<—OP目-OP源-DF，并根据结果设置标志。

说明：

- 主要用于多字节或多精度数据相减的运算。
- 指令中有3个操作数，其中CF是本指令执行前的状态；
- 本指令在需要完成多字节数（如4字节的32位数或更多字节）相减时时使用；
- 指令的目的操作数不能是立即寻址（立即数）；
- 无符号操作数相减，若CF=1，则结果为补码；
- 带符号操作数相减要考虑溢出。

**减1指令**

格式：`DEC OP目`

功能：OP目<—OP目-1，根据结果置标志位，不影响CF。

说明：

- 操作数不能是立即寻址；
- 该指令不影响CF标志；
- 操作数为内存寻址时，需使用伪指令。

**取补指令**

格式：`NEG OP`

功能：0-OP—>OP,将操作数取补后回送原操作数OP可以是8/16位通用寄存器和存储寄存器操作数，不能为立即数。

说明：

- 对80H或8000H取补时，操作数没有变化，但OF=1。
- 对CF影响较特殊，只要操作数不是0，总是使CF=1。   

- 操作数不能是立即寻址。

**比较指令**

格式：`CMP OP目,OP源`

功能：OP目-OP源，不回送结果，只根据结果置标志位。

说明：

- 执行指令执行“目的操作数-源操作数”，与SUB指令不同的是，不产生运算结果，仅影响标志位；
- 指令的目的操作数不能是立即寻址；
- 目的操作数和源操作数不能同时为存储器操作数。

用途：用于比较两个数的大小，可作为条件转移指令转移的条件。

#### 2.2.3乘法指令

**无符号数乘法**

格式：`MUL OP`

功能：`AX<—AL*OP`，8位数乘法

​			`(DX、AX)<— AX*OP`，16位数乘法

说明：

- `8位*8位=>16位，16位*16位=>32位`
- 乘数和被乘数都不能为立即寻址；
- 乘数或被乘数必须放在AL或AX中，在指令中隐含；
- 16位运算结果在AX中，32位运算结果在DX（高16位）和AX（低16位）中。

**带符号数乘法**

格式：`IMUL OP`

功能：操作同上，但是操作数为带符号数

说明：

- `8位*8位=>16位，16位*16位=>32位`
- 乘数和被乘数都不能为立即寻址；

- 乘数或被乘数必须放在AL或AX中，在指令中隐含；
- 16位运算结果在AX中，32位运算结果在DX（高16位）和AX（低16位）中。
- 有符号数在计算机中是其补码，且符号位也参加运算，此时用MUL指令就得不到正确结果，IMUL指令则会将符号部分和数值部分分别进行处理。

**注意：**

(1）进行字节运算时，OP目必须是AL，乘积在AX中；进行字运算时，0P目必须是AX，乘积在DX、AX中。源操作数不允许使用立即数寻址方式。
(2）运算结果只影响CF、OF，其他的无定义。
(3）对于MUL，若字节型数据相乘之积AH=0或字数据相乘之积DX=0，则CF=OF=0，否则CF=OF=1；
		对于IMUL指令，若字节数据相乘之积AH或字数据相乘之积DX的内容是低一半的符号扩展，则CF=OF=0, 否则CF=OF=1。

例题：

```txt
已知AL=0FEH
视为无符号数254，视为带符号数，值为-2
BH=0AH
视为无符号数为10，视为带符号数，数值为+10。
执行指令MUL BH后 AX=09ECH，CF=OF=1
执行指令IMUL BH后AX=FFECH，CF=OF=0
```

#### 2.2.4除法指令

**指令要求被除数是除数的双倍字长，即当除数是8/16位时，要求被除数是16/32位的二进制数。**

**无符号数除数**

格式：`DIV OP`

功能：

- 字节除法：AX/OP—>AL=商，AH=余数
- 字出除法：（DX、AX）/OP—>AX=商，DX=余数

说明：

- 指令中使用16位除8位，32位除16位的格式，被除数不够16位或32位，则需要扩展；
- 被除数、除数都不能为立即寻址，除数必须是寄存器数或存储器寻址；
- 被除数必须放在AX或DX:AX中，在指令中则隐含；
- 16位运算的商放在AL中，在余数放在AH中；
- 32位运算的商放在AX中，余数放在DX中。

**带符号除数**

格式：`IDIV OP`

功能：操作同DIV，但是操作数作为符号数。

说明：

- 同DIV

注意：

- 当除数是字节时，被除数必须放在AX中，

  当除数是子时，被除数必须放在DX，AX中。

- 商超出规定的范围时，将产生0号中断。

- IDIV运算结果余数的符号与被除数相同。

- 带符号数除法运算中，当被除数位数不够时，则需将被除数扩展到所需的位数。（8086/8088设有带符号数扩展指令）

**符号扩张指令格式**

格式：`CBW`

功能；将AL中的数的符号位扩展AH

规则：

- 若最高位=1，则执行后AH=FFH
- 若最高位=0，则执行后AH=00H

说明：

- 在符号除法指令中，被除数要扩展成16位时使用该指令

**字节扩展指令（16位—>32位）**

格式：`CWD`

功能：将AX中的数的符号位扩展到DX

规则：

- 若最高位=1，则执行后DX=FFFFH
- 若最高位=0，则执行后DX=0000H

说明：

- 在符号除法指令中，被除数要扩展成32位时使用该指令

这两条指令不影响标志位。

### 2.3十进制运算调整指令

#### 2.3.1加法调整指令

**对非组合BCD数加法操作进行校正AAA**

格式：`AAA`

功能：对AL寄存器的内容进行十进制数调整。

说明：

- 要求参加操作的数必须是非组合BCD数；
- 该指令用在非压缩BCD数加法操作后，操作数隐含在AL中；
- 由于该调整指令使用AH寄存器，故应先将AH内容清零。

AAA指令调整方法：

1. 如果AL寄存器指令的低4位在0~9之间，AF为0，则跳过第2步执行第3步；

2. 如果AL寄存器的低4位在0AH~0FH之间或AF为1，则AL寄存器的内容加06H，同时AH寄存器内容加1，且将AF置1；
3. AL寄存器的高4位清零；
4. AF位的值送CF。

**对组合BCD数加法操作的结果进行校正DAA**

格式：`DAA`

功能：对AL中的由两个组合BCD码相加进行调整，将结果（组合BCD码）存于AL中。

说明：

- 要求参加操作的数必须是BCD数；
- 该指令用在组合BCD数加法操作后，操作数隐含在AL中。

DAA指令调整方法：

- 调整方法与AAA类似，只是此指令要分别考虑AL的高4位和低4位。
- 若AL低四位大于9或AF=1，则AL+6—>AL，置AF=1；
- 若AL高四位大于9或CF=1，则AL+60H—>AL，置CF=1

注意：以上两条指令使用时必须紧跟在ADD或ADC之后。

#### 2.3.2减法调整指令

**非组合BCD码的减法调整指令**

格式：`AAS`
功能：对AL中由两个非组合BCD码相减的差进行调整，将结果（非组合BCD码）存于AL中。
调整过程：调整方法与AAA类似，不同的是当AL的低4位表示的数大于9或AF=1时，将AL-6--AL, AH-1
一AH，并将AF和CF置1，清除AL的高四位。

说明：

- 参加操作的数必须是非组合BCD数；
- 该指令用在非组合BCD数操作之后，操作数隐含在AL中；
- 由于该调整指令使用到AH寄存器，故先将AH内容清零。

AAS指令调整方法：

1. 如果AL寄存器指令的低4位在0~9之间，AF为0，则跳过第2步执行第3步；

2. 如果AL寄存器的低4位在0AH~0FH之间或AF为1，则AL寄存器的内容减06H，同时AH寄存器内容减1，且将AF置1；
3. AL寄存器的高4位清零；
4. AF位的值送CF。

**组合BCD码的减法调整指令**
格式：`DAS`
功能：对AL中由两个组合BCD码相减所得的结果进行调整，并将结果（组合BCD码）存于AL中。
调整过程：调整方法与DAA类似，不同的是当AL的低4位大于9或者 AF=1，则AL-6 一>AL，并置AF=1；而当 AL的高4位大于9或者 CF=1时，则AL-60H—>AL，并置CF=1。

说明：

- 参加操作的数必须是组合BCD数；
- 该指令用在组合BCD数减法操作之后，操作数隐含在AL中。

注意：使用AAS、DAS指令必须紧跟在减法指令之后。

#### 2.3.3乘法调整指令

**非组合BCD码的乘法调整指令**

格式：`AAM`

功能：对AX中的由两个非组合BCD码相乘所得的结果进行调整，并将调整后的结果存于AX中。

调整过程：AH<—AL/0AH（商），AL<—AL%0AH（余数）

说明：

- 参加操作的数必须是非组合BCD数，该指令在MUL指令之后；
- AAM指令调整方法：因为两个非组合BCD数相乘的结果为0~81，不会到十进制数的百位，因此调整方法就是将AL寄存器的内容除以0AH，商放在AH寄存器（与除法指令不同）中，表示转换的十位整数；余数放在AL寄存器（与除法指令不同）中，表示转换的个位数。

注意：本指令必须紧跟在MUL指令之后使用。


#### 2.3.4除法调整指令

**非组合BCD码的除法调整指令**
格式：`AAD`

功能：把AX中的两个非组合BCD码进行调整，然后可用DIV指令实现两个非组合BCD码的除法运算

调整过程：`AL<—10*AH+AL, AH<—0`
注意：本指令必须在DIV运算前使用。

说明：

- 该操作数要满足16位除8位的除法操作做要求，即非组合BCD数需放在AX寄存器中，
- 该指令用在DIV指令之前，先调整，后做除法操作。

AAD指令调整方法：将AX中的非组合BCD数转换成二进制数，因为除数也是非组合BCD数，必须在0~9之间，实质是完成二进制数除法。

#### 2.3.5总结

- DAA或DAS必须用在ADD (ADC)或SUB (SBB)之后，结果对OF无影响，对其他状态标志位均有影响。

- AAA或AAS必须用在ADD (ADC)或SUB (SBB)之后，结果影响AF和CF，对其他标志位均无意义。

- AAM必须用在MUL之后，结果影响SF、ZF和PF，对AF、CF和OF无影响。

- AAD必须用在DIV之前，结果影响SF、ZF和PF，对AF、CF和OF无影响。

### 2.4位操作指令

位操作指令的共同特点如下：

```txt
- 可以按二进制位进行操作。
- 逻辑运算指令按逻辑门电路的运算规则。
- 逻辑位移指令有左移和右移，移出的位都进入CF标志。
- 因移空位的补充方式不同，有多种指令形式。
- 逻辑移位指令中，移动超过1次，则用CL寄存器作为计数器。
- 执行逻辑操作指令，CF均被清零。
```

OP源：8/16位通用寄存器、存储器操作数或立即数

OP目：通用寄存器和存储器操作数。

除 “非” 运算外其余指令都会使OF=CF=0

#### 2.4.1逻辑运算指令

**逻辑与运算指令**

格式：`AND OP目,OP源`

功能：将8/16位寄存器或存储器内容和源操作数 进行“与”运算。

说明：

- 目的操作数不能为立即寻址；
- 可由源操作数控制，对8/16位数的某些位进行屏蔽或保留。

************

**逻辑或运算指令**

格式：`OR OP目,OP源`

功能：对两个操作数进行或运算，结果回送到OP目。

说明：

- 目的操作数不能为立即寻址；
- 可用于组合某个字，或将某些位进行置1或保留。

例：

```txt
将AL中的非组合BCD码转换为ASCII码。
OR AL,30H
非组合BCD码：00H~09H（0~9）
ASSCII码：  30H~39H（‘0’~‘9’）
0000 1001
0011 0000
----------
0011 1001 39H
```

**************

**逻辑异或运算指令**

格式：`XOR OP目,OP源`

功能：对于两个操作数进行异或运算，结果回送到OP目。

说明：用于对某个二进制数按位取反或对某寄存器清0。

- 相同为零，不同为1

- 和1异或，相当于取反
- 和0异或，相当于不变

例：

```txt
寄存器清0（有4条指令可达到AX清0目的）：
XOP AL,AL	;AL清0
MOV AX,0	;移位指令不影响CF
SUB AX,AX
AND AX,0
```

****************

**逻辑求反指令**

格式：`NOT OP目`

功能：对操作数逐位取反后回送到原处。

说明： 

- 该指令只是执行求反操作，而不是求反码指令，对符号位也求反；
- 不影响标志位。
- 对8/16位一次性全部取反。

*******

**测试指令**

格式：`TEST OP目,OP源`

功能：将OP目与OP源进行 “与” 运算，不回送结果，只根据结果置标志位。

说明：

- 主要用来检测目的操作数的某些位是1或0，根据测试结果，决定转向。
- 目的操作数不能为立即寻址；
- TEST指令和AND指令的运行规则相同，但TEST指令不产生运算结果，仅影响状态标志；
- 常用于对某位是“1”或“0”的检测。

****

**总结**

- AND、OR、XOR、TEST均影响标志，CF=0，OF=0，而PF，SF，ZF由结果而定，AF无意义。 此指令可用来清CF，常用与拆字，拼字。
- NOT不影响标志。

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures//Principle_and_application_of_microcomputer/20210617125826.png)

*****************

#### 2.4.2逻辑移位指令

位移操作：

- 非循环移位
  - 逻辑移位
  - 算数移位

- 循环移位
  - 不带进位位的移位
  - 带进位位的移位

规定：移动一位时由指令中的计数值直接给出；位移两位及以上，则位移次数由CL指定，即必须将移位位数N事先装入CL中。

*****

##### -非循环位移指令

![](https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210617130329.png)

- 算数左移与逻辑左移相同，可用于无符号数乘2操作；
- 逻辑右移可用于无符号数除2操作；
- 算数右移可以用于有符号数除2操作。
- 算数逻辑位移指令是双操作数指令，操作数可以是立即数之外的任何寻址方式；当计数值大于1时，必须使用CL作计数器。

*****

**逻辑左移指令**

格式：`SHL 目的操作数,1`

​			`SHL 目的操作数,CL`

功能：将8/16位寄存器或存储器内容左移，移空的位补0.

说明：

- 使用逻辑左移指令移动1位时，源操作数为1；左移位数超过1位时，用CL寄存器控制移动次数；
- 逻辑左移指令移动1位，则原数据乘2（在无进位的情况下）。

****

**算数左移指令**

格式：`SAL 目的操作数,1`

​			`SAL 目的操作数,CL`

功能：将8/16位寄存器或存储器内容左移，移空的位补0。

说明：

- 使用算数左移指令移动1位时，源操作数为1；
- 使用算数左移指令超过1位时，用CL寄存器控制移动次数；算数左移指令移动1位，则原数据乘2（在无进位视的情况下）
- 算数左移指令和逻辑左移指令功能相同。

*********

**逻辑右移指令**

格式：`SHR 目的操作数,1`

​			`SHR 目的操作数,CL`

功能：将8/16位寄存器或存储器内容右移，移空的位补0。

说明：

- 使用逻辑右移指令移动1位时，源操作数为1；
- 使用逻辑右移指令移动超过1位时，用CL寄存器控制移动次数；逻辑右移指令移动1位，则原数据除2（与除法指令有差别）。

************

**算数逻辑右移指令**

格式：`SAR 目的操作数,1`

​			`SAR 目的操作数，CL`

功能：将8/16位寄存器或存储器内容右移，移空的位由目的操作数的最高位补充。

说明：

- 使用算数右移指令1位时，源操作数为1；
- 使用算数右移指令超过1位时，用CL寄存器控制移动次数；算数右移指令实质上补充的是符号位。

*****

##### -不带进位循环移位指令

**循环左移指令**

格式：`ROL 目的操作数,1`

​			`ROL 目的操作数,CL`

功能：将8/16位寄存器或存储器内容左移，移空的位由移出位补充。

说明：

- 使用不带进位循环左移指令移动1位时，源操作数为1；
- 使用不带进位循环左移指令移动超过1位时，用CL寄存器控制移动次数。

**循环右移指令**

格式：`ROR 目的操作数,1`

​			`ROR 目的操作数,CL`

功能：将8/16位寄存器或存储器内容右移，移空的位由移出位补充。

说明：

- 使用不带进位循环右移指令移动1位时，源操作数为1；
- 使用不带进位循环右移指令移动超过1位时，用CL寄存器控制移动次数。

***************

##### -带进位循环位移指令

**循环左移移指令**

格式：`RCL 目的操作数,1`

​			`RCL 目的操作数,CL`

功能：将8/16位寄存器或存储器内容左移，移空的位由CF位补充。

说明：

- 使用带进位循环左移指令移动1位时，源操作数为1；
- 使用带进位循环左移指令移动超过1位时，用CL寄存器控制移动次数。
- 该指令执行前，若CF没有置“1”或清“0”，则第一次移位时，移空位CF中的随机数补充。

**循环右移移指令**

格式：`RCR 目的操作数,1`

​			`RCR 目的操作数,CL`

功能：将8/16位寄存器或存储器内容右移，移空的位由CF位补充。

说明：

- 使用带进位循环右移指令移动1位时，源操作数为1；
- 使用带进位循环右移指令移动超过1位时，用CL寄存器控制移动次数。
- 该指令执行前，若CF没有置”1“或清”0“，则第一次移位时，移空位由CF中的随机数补充。

********

### 2.5串操作指令

串操作指令实现一对字符或数据的操作，分为基本串操作指令和重复前缀指令。基本串操作指令每执行一次只能处理一个数据，与重复前缀指令结合可以处理一串数据。

申处理指令是针对存储器操作，其共同点如下：

- 源串一般存放在数据段（DS），偏移地址由SI指定，目标串在附加段（ES），偏移地址由DI指定。

- 指令有特珠的寻址方式，规定源操作数的逻辑地址由`DS:SI`给出，目的操作数的逻辑地址由`ES:DI` 给出。

- 由于存储单元有字型数据和字节型数据，指令的助记符则有B或 W之分。
- 每执行一次串操作后自动修改指针SI、DI。若方向标志DF=0，则每次操作后SI和DI自动加1（或加2）；若DF=1，则每次操作后SI和DI自动减1（或减2）。

- 使用这类指令，存储单元的地址指针是自动移动的，由 DF 标志控制指针的移动方向，DF=0，地址往增加方向移动；DF=1，地址往减小方向移动。
- 串长（字或字节个数）存放在CX中。
- 串的长度由 CX 给定。

- 这类指令前一般可以使用指令前缀。

- 这类指令后不带操作数，操作数在此指令前给定。

串处理指令中需要注意的问题：

* 在执行指令前必须DS、ES、SI、DI、DF、CX置好需要的值，它们是串操作指令的隐含操作数。

- 当串指令在同段之间执行传送或比较等操作时，应将DS 和ES 取同样的值。
- 当使开指令前缀进行重复操作时，CX 的值是指数据个数，不是存储单元的字节数。
- 当使用 DF=1， 即地址指针为减小方向移动时，源操作数和目的操作数的初始地址要正确设定。

***************

#### 2.5.1串传送指令

**串传送指令**

格式：`MOVSB`——字节传送

​			`MOVSW`——字传送

功能：

- 目的操作数 <一 源操作数。
- 把位于数据段由SI指定的内存单元的字节/字数据传送到附加段由DI指定的内存单元，指令不影响状态标志位。

说明：

- 源操作数地址由 DS:SI指定，目的操作数由 ES:DI指定;
- 指令执行时，由DF标志控制SI和 DI是增大还是减小；
- 由指令中的B和W控制 SI 和DI 是加1/加2，还是减1/减2；
-  指令执行一次，CX 奇存器的内容不改变。
- 串传送指令常与无条件重复前缀连用。

过程：

```txt
[DI]<--[SI] 若DF=0 SI<--SI+1/2,DI<--DI+1/2
[DI]<--[SI] 若DF=1 SI<--SI-1/2,DI<--DI-1/2
```

***********

#### 2.5.2串比较指令

格式：`CMPSB`——字节比较

​			`CMPSW`——字比较

功能：

- 目的操作数 一 源操作数。
- 把位于数据段由SI指定的字节/字数据与附加段由DI指定的字节数进行比较，结果不保存，但应响状态标志位，并由DF状态决定SI、DI的修改方向。

说明：

- 执行指令完成内存中两串数据对应元素的减法操作，但不产生运算结果，仅影响状态标志；
- 其余与串传送指令相同；
- 该指令多与其他指令或指令前缀配合。
- 串比较指令常与条件重复前缀连用，指令的执行不改变操作数，仅影响标志位。

过程：

```txt
[SI]-[DI] SI<--SI(+/-)1/2,DI<--DI(+/-)1/2
```

********

#### 2.5.3串搜索指令

格式：`SCASB`——字节搜索

​			`SCASW`——字搜索

功能：把AL/AX中的内容与附加段由DI指定的一个字节/字数据进行比较，结果不保存，但影响状态标志位，并由DF状态决定DI的修改方向。

说明：

- 执行该指令前，将需检索的数据存入AL或AX寄存器中；
- 指令完成内存数据串中每个元素的搜索操作，即AL/AX减串元素；
- 该指令多与其他指令或指令前缀配合；
- 其余与串传输指令相同。

过程：

```txt
字节——AL-[DI],DI<--DI(+/-)1
  字——AX-[DI],DI<--DI(+/-)2
```

#### 2.5.4串装入指令（取字符串）

格式：`LODSB`

​			`LODSW`

功能：

- AL/AX <— 源操作数

- 把位于数据段由SI指定内存单元的内容取到AL或AX中，并修改SI的内容，指向下一字节/字单元。

说明：

- 该指令每执行一次，将存储单元中的内容写入累加器；
- 该指令多与其他指令配合，但不能有指令前缀；
- 在软件循环中与其他指令配合，可完成复杂字符串的处理；
- LODS指令的执行不影响标志位。

************

#### 2.5.5串存储指令（存字符串）

格式：`STOSB`

​			`STOSW`

功能：

- 目的操作数<— AL/AX
- 把寄存器AL或AX中的内容存到附加段由DI指定的内存单元，并修改DI的内容，指向下一字节/字的存放单元。

说明：

- 该指令每执行一次，将累加器的内容写入存储单元中；
- 该指令可以有指令前缀
- 该指令的执行不影响标志位。

**********

#### 2.5.6重复前缀指令

基本串操作指令每执行一次只能处理一个数据，与重复前缀指令结合可以处理一串数据。

**无条件重复**

REP：

- REP为重复前缀，每执行一次，CX内容减1，直到CX内容为0，才退出串处理过程，一般与MOVS指令和STOS指令配合使用。

- 若CX !=0，则CX<— CX-1 继续重复操作，知道CX=0为止。

**********

**条件重复**

- （相等/为0）重复 
  - REPE/REPZ
    - 若CX !=0且ZF=1，则CX<— CX-1 继续重复操作，知道CX=0或ZF=0为止。

- （不相等/不为0）重复
  - REPNZ/REPNE
    - 若CX !=0且ZF=0，则CX<— CX-1 继续重复操作，知道CX=0或ZF=1为止。

**********

**注意**

- 重复前缀指令不能单独使用，其后必须紧跟基本串操作指令，控制基本串操作指令重复执行。其执行过程相当于一个循环控制程序的运行。在每次重复之后，地址指针SI和DI都被修改，但指针IP仍保持指向带有前缀的串操作指令的地址。
- 重复执行次数由数据串长度决定，数据串长度应预置在寄存器CX中。
- 执行重复前缀指令不影响标志位。

***********

### 2.6程序控制转移指令

#### 2.6.1寻址方式

控制转移指令在段内、段间转移时、使用直接（相对）寻址或间接寻址方式。

**直接寻址方式**

- 段内寻址方式：目标程序和源程序在同一程序段内，只给出源地址和目标地址的差值，此差值是偏移量，它是一个以IP为基准的8/16位的带符号补码数。

- 段间直接寻址方式：直接给出转移目标地址的段地址和段内位移量，用前者取代CS当前的值，用后者取代IP中当前的值，使程序从一个代码段转移到另一个代码段。

********

**间接寻址方式**

- 段内间接寻址方式：指令转移的有效地址存在一个寄存器或存储器单元中，用它取代单前IP的值，实现程序转移。
- 段间间接寻址方式：指令给出一个存储器地址，从该地址开始的4个字节单元中存放转移目标地址的段内偏移量和段地址，这两个地址在指令执行时用于取代当前的IP和CS的内容，使程序从一个代码段转移到另一个代码段。

#### 2.6.2转移指令

通过修改指令的偏移地址或段地址及偏移地址实现程序的转移

##### -无条件转移指令

无条件转移到目标地址，执行新的指令。

**段内直接转移指令**

一个段内的直接无条件转移是在指令中给出一个相对位移量。该位移量是相对于IP奇存器来计算的，即有效转移地址是在IP当前的内容上加上一个8位或16位的位移量，所以也称为相对寻址。其位移量是带符号的数，这就使转移可在向前或向后的方向进行。

格式：`JMP NEAR PTR 目标地址`

补码：-32768～+32767

功能：当位移量为16位带符号数时，允许在（+/-）32KB 的范国内寻找目标地址，称为**段内直接近转移**。

格式：`JMP NEAR SHORT 目标地址`

补码：-128～+127

功能：当位移量为8位带符号数时，允许在（+/-）127字节 的范国内寻找目标地址，称为**段内直接短转移**。

******

**段内间接转移指令**

格式：`JMP OP(寄存器)`

​			`JMP WORD PTR [BX]`

功能：在JMP 指令中，间接给出转移目标地址，即由一个 16位奇存器或由存储单元寻址目标地址。

******

**段间直接转移指令**

格式：`JMP FAR PTR 目标地址`

功能：段间转移意味着寄存器 CS 和IP的值都要改变，指令中直接采用汇编中的符号地址作为直接目标地址。

*******

**段间间接转移指令**

格式：`JMP WORD PTR [BX][SI]`

功能：段间转移意味着寄存器 CS 和IP 的值都要改变，所以间接给出目标地址，只能由存储单元寻址。也就是说，目标地址存放在连续的4个存储单元中，低字节两个单元的内容代替IP，高字节两个单元的内容代替CS。

*********

**注意：**

* 当目标地址高于源地址时称为正向转移，偏移量是正数；
* 当目标地址低于原地址时称为反向转移，偏移量是负数。

##### -有条件转移指令

在具备一定条件的情况下转移到目标地址。

#### 2.6.3调用和返回指令

**调用指令CALL**

为了程确保程序正确返回，CALL指令的类型必须与RET指令的类型相匹配。

CALL指令有两种的得到目标地址的方法：直接寻址和间接寻址。直接寻址意味着目标地址在CALL指令的操作码部分直接给出。间接寻址意味着目标地址在指定的寄存器或内存单元中，以间接方式给出。

一个过程用于段内调用，则在过程定义中属性应为NEAR。而另一个过程用于段间调用，则在过程定义中属性应为FAR。

**段内直接调用**

`CALL NEAR 目标地址`

**段内间接调用**

例如：

```txt
CALL WORD PRT [SI]

```

**段间直接调用**



**段间间接调用**

